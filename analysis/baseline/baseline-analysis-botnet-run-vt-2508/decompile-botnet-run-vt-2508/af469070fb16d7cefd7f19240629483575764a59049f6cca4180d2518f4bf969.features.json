{
  "program": {
    "name": "af469070fb16d7cefd7f19240629483575764a59049f6cca4180d2518f4bf969.exe",
    "format": "Portable Executable (PE)",
    "language": "x86/little/32/default",
    "compiler": "Visual Studio",
    "image_base": "00400000",
    "size": 20947078,
    "sha256": "af469070fb16d7cefd7f19240629483575764a59049f6cca4180d2518f4bf969"
  },
  "functions": [
    {
      "name": "FUN_00401000",
      "entry": "00401000",
      "size": 35,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00401030",
      "entry": "00401030",
      "size": 229,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401120",
      "entry": "00401120",
      "size": 253,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401220",
      "entry": "00401220",
      "size": 28,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401240",
      "entry": "00401240",
      "size": 256,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401340",
      "entry": "00401340",
      "size": 174,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004013f0",
      "entry": "004013f0",
      "size": 223,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004014d0",
      "entry": "004014d0",
      "size": 120,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401550",
      "entry": "00401550",
      "size": 41,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401580",
      "entry": "00401580",
      "size": 346,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004016e0",
      "entry": "004016e0",
      "size": 183,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004017a0",
      "entry": "004017a0",
      "size": 69,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004017f0",
      "entry": "004017f0",
      "size": 74,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401840",
      "entry": "00401840",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00401850",
      "entry": "00401850",
      "size": 34,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401880",
      "entry": "00401880",
      "size": 18,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004018a0",
      "entry": "004018a0",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004018c0",
      "entry": "004018c0",
      "size": 45,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004018f0",
      "entry": "004018f0",
      "size": 48,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401920",
      "entry": "00401920",
      "size": 157,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004019c0",
      "entry": "004019c0",
      "size": 653,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401c50",
      "entry": "00401c50",
      "size": 384,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401dd0",
      "entry": "00401dd0",
      "size": 85,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401e30",
      "entry": "00401e30",
      "size": 71,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401e80",
      "entry": "00401e80",
      "size": 122,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401f00",
      "entry": "00401f00",
      "size": 97,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00401f70",
      "entry": "00401f70",
      "size": 205,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "thunk_FUN_004031a0",
      "entry": "00402040",
      "size": 5,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00402050",
      "entry": "00402050",
      "size": 57,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00402090",
      "entry": "00402090",
      "size": 63,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004020d0",
      "entry": "004020d0",
      "size": 514,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "guard_check_icall",
      "entry": "004022e0",
      "size": 1,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004022f0",
      "entry": "004022f0",
      "size": 218,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004023d0",
      "entry": "004023d0",
      "size": 897,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00402760",
      "entry": "00402760",
      "size": 53,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004027a0",
      "entry": "004027a0",
      "size": 93,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00402800",
      "entry": "00402800",
      "size": 196,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004028d0",
      "entry": "004028d0",
      "size": 91,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00402930",
      "entry": "00402930",
      "size": 104,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004029a0",
      "entry": "004029a0",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004029c0",
      "entry": "004029c0",
      "size": 121,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00402a40",
      "entry": "00402a40",
      "size": 256,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00402b40",
      "entry": "00402b40",
      "size": 1492,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403120",
      "entry": "00403120",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00403130",
      "entry": "00403130",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00403140",
      "entry": "00403140",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00403150",
      "entry": "00403150",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00403160",
      "entry": "00403160",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00403170",
      "entry": "00403170",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004031a0",
      "entry": "004031a0",
      "size": 33,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004031d0",
      "entry": "004031d0",
      "size": 501,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004033d0",
      "entry": "004033d0",
      "size": 327,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403520",
      "entry": "00403520",
      "size": 338,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403680",
      "entry": "00403680",
      "size": 521,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004038d0",
      "entry": "004038d0",
      "size": 163,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403980",
      "entry": "00403980",
      "size": 693,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403c40",
      "entry": "00403c40",
      "size": 292,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403d70",
      "entry": "00403d70",
      "size": 102,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403de0",
      "entry": "00403de0",
      "size": 481,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00403fd0",
      "entry": "00403fd0",
      "size": 167,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404080",
      "entry": "00404080",
      "size": 482,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404270",
      "entry": "00404270",
      "size": 684,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404520",
      "entry": "00404520",
      "size": 63,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404560",
      "entry": "00404560",
      "size": 45,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404590",
      "entry": "00404590",
      "size": 421,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404740",
      "entry": "00404740",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404770",
      "entry": "00404770",
      "size": 333,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004048c0",
      "entry": "004048c0",
      "size": 46,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004048f0",
      "entry": "004048f0",
      "size": 352,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404a50",
      "entry": "00404a50",
      "size": 181,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404b10",
      "entry": "00404b10",
      "size": 19,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404b30",
      "entry": "00404b30",
      "size": 285,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404c50",
      "entry": "00404c50",
      "size": 251,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404d50",
      "entry": "00404d50",
      "size": 150,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404df0",
      "entry": "00404df0",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404e10",
      "entry": "00404e10",
      "size": 203,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404ee0",
      "entry": "00404ee0",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404f00",
      "entry": "00404f00",
      "size": 134,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00404f90",
      "entry": "00404f90",
      "size": 140,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00405020",
      "entry": "00405020",
      "size": 246,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00405120",
      "entry": "00405120",
      "size": 124,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004051a0",
      "entry": "004051a0",
      "size": 116,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00405220",
      "entry": "00405220",
      "size": 5885,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004069b0",
      "entry": "004069b0",
      "size": 100,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00406a20",
      "entry": "00406a20",
      "size": 187,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00406ae0",
      "entry": "00406ae0",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00406b00",
      "entry": "00406b00",
      "size": 86,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00406b60",
      "entry": "00406b60",
      "size": 175,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00406c10",
      "entry": "00406c10",
      "size": 212,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00406cf0",
      "entry": "00406cf0",
      "size": 236,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "thunk_FUN_00406df0",
      "entry": "00406de0",
      "size": 5,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00406df0",
      "entry": "00406df0",
      "size": 624,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00407060",
      "entry": "00407060",
      "size": 681,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00407320",
      "entry": "00407320",
      "size": 19,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00407340",
      "entry": "00407340",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00407350",
      "entry": "00407350",
      "size": 1188,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00407800",
      "entry": "00407800",
      "size": 1047,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "ConvertStringSecurityDescriptorToSecurityDescriptorW",
      "entry": "00407c18",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "unknown"
    },
    {
      "name": "Ordinal_14",
      "entry": "00407c1e",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "unknown"
    },
    {
      "name": "__security_check_cookie",
      "entry": "00407c24",
      "size": 17,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "__alloca_probe",
      "entry": "00407c40",
      "size": 45,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__scrt_common_main_seh",
      "entry": "00407d2b",
      "size": 306,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "entry",
      "entry": "00407e9a",
      "size": 10,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__alldiv",
      "entry": "00407eb0",
      "size": 170,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___raise_securityfailure",
      "entry": "00407f5a",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___report_gsfailure",
      "entry": "00407f82",
      "size": 251,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___report_rangecheckfailure",
      "entry": "0040807d",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___report_securityfailure",
      "entry": "00408089",
      "size": 208,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "find_pe_section",
      "entry": "00408159",
      "size": 68,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___scrt_acquire_startup_lock",
      "entry": "0040819d",
      "size": 53,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___scrt_initialize_crt",
      "entry": "004081d2",
      "size": 57,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___scrt_initialize_onexit_tables",
      "entry": "0040820b",
      "size": 151,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___scrt_is_nonwritable_in_current_image",
      "entry": "004082a2",
      "size": 116,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___scrt_release_startup_lock",
      "entry": "0040832c",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___scrt_uninitialize_crt",
      "entry": "00408349",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__onexit",
      "entry": "00408371",
      "size": 59,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_atexit",
      "entry": "004083ac",
      "size": 21,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___security_init_cookie",
      "entry": "004083c1",
      "size": 156,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00408460",
      "entry": "00408460",
      "size": 3,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00408463",
      "entry": "00408463",
      "size": 4,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00408467",
      "entry": "00408467",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040846d",
      "entry": "0040846d",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00408479",
      "entry": "00408479",
      "size": 33,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040849a",
      "entry": "0040849a",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_004084a0",
      "entry": "004084a0",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_004084bd",
      "entry": "004084bd",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_004084c9",
      "entry": "004084c9",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_004084cf",
      "entry": "004084cf",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___scrt_fastfail",
      "entry": "004084d5",
      "size": 283,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___scrt_unhandled_exception_filter@4",
      "entry": "004085fc",
      "size": 65,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040863d",
      "entry": "0040863d",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00408645",
      "entry": "00408645",
      "size": 43,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00408670",
      "entry": "00408670",
      "size": 43,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "guard_check_icall",
      "entry": "0040869b",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__SEH_prolog4",
      "entry": "004086b0",
      "size": 70,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__SEH_epilog4",
      "entry": "004086f6",
      "size": 21,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___isa_available_init",
      "entry": "0040870b",
      "size": 410,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___scrt_is_ucrt_dll_in_use",
      "entry": "004088a5",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_memset",
      "entry": "004088c0",
      "size": 346,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00408a20",
      "entry": "00408a20",
      "size": 299,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00408b50",
      "entry": "00408b50",
      "size": 311,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00408c90",
      "entry": "00408c90",
      "size": 1330,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_ValidateLocalCookies",
      "entry": "00409210",
      "size": 50,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__except_handler4",
      "entry": "00409250",
      "size": 358,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___vcrt_initialize",
      "entry": "004093b6",
      "size": 41,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___vcrt_uninitialize",
      "entry": "004093df",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__local_unwind4",
      "entry": "00409400",
      "size": 144,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_EH4_CallFilterFunc",
      "entry": "004094fe",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "_EH4_TransferToHandler",
      "entry": "00409515",
      "size": 25,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "_EH4_GlobalUnwind2",
      "entry": "0040952e",
      "size": 25,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "_EH4_LocalUnwind",
      "entry": "00409547",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "FUN_0040955e",
      "entry": "0040955e",
      "size": 28,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___vcrt_initialize_ptd",
      "entry": "0040957a",
      "size": 51,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___vcrt_uninitialize_ptd",
      "entry": "004095ad",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___vcrt_initialize_locks",
      "entry": "004095c8",
      "size": 60,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___vcrt_uninitialize_locks",
      "entry": "00409604",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__crt_fast_encode_pointer<void*>",
      "entry": "00409633",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "try_get_function",
      "entry": "00409650",
      "size": 160,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "try_get_module",
      "entry": "004096f0",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___vcrt_FlsAlloc",
      "entry": "00409771",
      "size": 58,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___vcrt_FlsFree",
      "entry": "004097ab",
      "size": 58,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___vcrt_FlsSetValue",
      "entry": "004097e5",
      "size": 61,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___vcrt_InitializeCriticalSectionEx",
      "entry": "00409822",
      "size": 70,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___vcrt_initialize_winapi_thunks",
      "entry": "00409868",
      "size": 58,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___vcrt_uninitialize_winapi_thunks",
      "entry": "004098a2",
      "size": 50,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___vcrt_initialize_pure_virtual_call_handler",
      "entry": "004098d4",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__global_unwind2",
      "entry": "00409900",
      "size": 32,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__local_unwind2",
      "entry": "00409965",
      "size": 132,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__NLG_Notify",
      "entry": "00409a15",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00409a34",
      "entry": "00409a34",
      "size": 3,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00409a50",
      "entry": "00409a50",
      "size": 3,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00409a53",
      "entry": "00409a53",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00409a59",
      "entry": "00409a59",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_strncmp",
      "entry": "00409a60",
      "size": 115,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00409ad8",
      "entry": "00409ad8",
      "size": 295,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00409bff",
      "entry": "00409bff",
      "size": 439,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:_free",
      "entry": "00409db6",
      "size": 5,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00409dbb",
      "entry": "00409dbb",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__fclose_nolock",
      "entry": "00409dc6",
      "size": 118,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_fclose",
      "entry": "00409e3c",
      "size": 115,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00409eb2",
      "entry": "00409eb2",
      "size": 10,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_feof",
      "entry": "00409ebc",
      "size": 43,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_ferror",
      "entry": "00409ee7",
      "size": 43,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__fread_nolock_s",
      "entry": "00409f12",
      "size": 460,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_fread",
      "entry": "0040a0de",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_fread_s",
      "entry": "0040a0fb",
      "size": 133,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040a186",
      "entry": "0040a186",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "LongLongSub",
      "entry": "0040a18e",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_fseek",
      "entry": "0040a20f",
      "size": 122,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040a28c",
      "entry": "0040a28c",
      "size": 10,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_fseek_binary_mode_read_only_fast_track_nolock",
      "entry": "0040a296",
      "size": 217,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_fseek_nolock",
      "entry": "0040a36f",
      "size": 217,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_fseek",
      "entry": "0040a448",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_ftell<long>",
      "entry": "0040a463",
      "size": 96,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040a4c6",
      "entry": "0040a4c6",
      "size": 10,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_ftell_nolock<long>",
      "entry": "0040a4d0",
      "size": 43,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_ftell_nolock<__int64>",
      "entry": "0040a4fb",
      "size": 405,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_ftell_read_mode_nolock",
      "entry": "0040a690",
      "size": 388,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_ftell_translated_utf8_nolock",
      "entry": "0040a814",
      "size": 411,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040a9af",
      "entry": "0040a9af",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040a9ba",
      "entry": "0040a9ba",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "operator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>",
      "entry": "0040a9c5",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FUN_0040aa0a",
      "entry": "0040aa0a",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>",
      "entry": "0040aa16",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()",
      "entry": "0040aa3e",
      "size": 70,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "__fwrite_nolock",
      "entry": "0040aa84",
      "size": 377,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_fwrite",
      "entry": "0040abfd",
      "size": 88,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_iob_func",
      "entry": "0040ad1d",
      "size": 16,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__lock_file",
      "entry": "0040ad79",
      "size": 20,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__unlock_file",
      "entry": "0040ad8d",
      "size": 20,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__get_sys_err_msg",
      "entry": "0040ada1",
      "size": 36,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_perror",
      "entry": "0040adc5",
      "size": 147,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040ae58",
      "entry": "0040ae58",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "operator()<>",
      "entry": "0040ae61",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040aea6",
      "entry": "0040aea6",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lock_stream_and_call<>",
      "entry": "0040aeb2",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_vsprintf<class___crt_stdio_output::standard_base,char>",
      "entry": "0040aeda",
      "size": 380,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_vsprintf<class___crt_stdio_output::standard_base,wchar_t>",
      "entry": "0040b056",
      "size": 389,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "count<char>",
      "entry": "0040b1db",
      "size": 24,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "ensure_buffer_is_big_enough<char>",
      "entry": "0040b1f3",
      "size": 134,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "is_wide_character_specifier<char>",
      "entry": "0040b279",
      "size": 64,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "is_wide_character_specifier<wchar_t>",
      "entry": "0040b2b9",
      "size": 79,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "scratch_data<char>",
      "entry": "0040b308",
      "size": 30,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "type_case_integer_parse_into_buffer<>",
      "entry": "0040b326",
      "size": 117,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "type_case_integer_parse_into_buffer<>",
      "entry": "0040b39b",
      "size": 136,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "write_multiple_characters<class___crt_stdio_output::stream_output_adapter<char>,char>",
      "entry": "0040b423",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>",
      "entry": "0040b44f",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>",
      "entry": "0040b47b",
      "size": 49,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_data<char>",
      "entry": "0040b4ac",
      "size": 71,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "common_data<wchar_t>",
      "entry": "0040b4f3",
      "size": 76,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "output_adapter_data<>",
      "entry": "0040b53f",
      "size": 60,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "output_adapter_data<>",
      "entry": "0040b57b",
      "size": 60,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "output_processor<>",
      "entry": "0040b5b7",
      "size": 53,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "output_processor<>",
      "entry": "0040b5ec",
      "size": 53,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "_LocaleUpdate",
      "entry": "0040b621",
      "size": 131,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "~formatting_buffer",
      "entry": "0040b6a4",
      "size": 26,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "operator=",
      "entry": "0040b6be",
      "size": 36,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "operator()",
      "entry": "0040b6e2",
      "size": 189,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "crop_zeroes",
      "entry": "0040b79f",
      "size": 87,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "find_next_state",
      "entry": "0040b7f6",
      "size": 50,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "find_next_state",
      "entry": "0040b828",
      "size": 52,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "force_decimal_point",
      "entry": "0040b85c",
      "size": 92,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "parse_int_from_format_string",
      "entry": "0040b8b8",
      "size": 92,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "parse_int_from_format_string",
      "entry": "0040b914",
      "size": 94,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "process",
      "entry": "0040b972",
      "size": 249,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "process",
      "entry": "0040ba8e",
      "size": 249,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "process",
      "entry": "0040bbaa",
      "size": 254,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "state_case_flag",
      "entry": "0040bcca",
      "size": 61,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_flag",
      "entry": "0040bd07",
      "size": 61,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal",
      "entry": "0040bd44",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal",
      "entry": "0040bd63",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal",
      "entry": "0040bd82",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal_common",
      "entry": "0040bda1",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal_common",
      "entry": "0040bdcb",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal_common",
      "entry": "0040bdf5",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal_tchar",
      "entry": "0040be10",
      "size": 97,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_normal_tchar",
      "entry": "0040be71",
      "size": 97,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_precision",
      "entry": "0040bed2",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_precision",
      "entry": "0040befa",
      "size": 41,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_size",
      "entry": "0040bf23",
      "size": 361,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_size",
      "entry": "0040c08c",
      "size": 361,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_size",
      "entry": "0040c1f5",
      "size": 380,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_type",
      "entry": "0040c371",
      "size": 559,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "state_case_type",
      "entry": "0040c5a0",
      "size": 559,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "state_case_type",
      "entry": "0040c7cf",
      "size": 605,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "state_case_width",
      "entry": "0040ca2c",
      "size": 43,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "state_case_width",
      "entry": "0040ca57",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "to_integer_size",
      "entry": "0040ca83",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "type_case_Z",
      "entry": "0040cadf",
      "size": 99,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_Z",
      "entry": "0040cb42",
      "size": 99,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_a",
      "entry": "0040cba5",
      "size": 346,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_a",
      "entry": "0040ccff",
      "size": 370,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_c_tchar",
      "entry": "0040ce71",
      "size": 144,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_c_tchar",
      "entry": "0040cf01",
      "size": 152,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_integer",
      "entry": "0040cf99",
      "size": 330,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "type_case_n",
      "entry": "0040d0e3",
      "size": 116,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_o",
      "entry": "0040d157",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_p",
      "entry": "0040d176",
      "size": 24,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_s",
      "entry": "0040d18e",
      "size": 115,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_s",
      "entry": "0040d201",
      "size": 116,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "type_case_s_compute_narrow_string_length",
      "entry": "0040d275",
      "size": 64,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "validate",
      "entry": "0040d2b5",
      "size": 33,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "validate",
      "entry": "0040d2d6",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "validate_stream_is_ansi_if_required",
      "entry": "0040d2f1",
      "size": 130,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_character",
      "entry": "0040d373",
      "size": 61,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "write_character",
      "entry": "0040d3b0",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "write_character",
      "entry": "0040d3f2",
      "size": 69,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "write_stored_string_tchar",
      "entry": "0040d437",
      "size": 167,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "write_stored_string_tchar",
      "entry": "0040d4de",
      "size": 167,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "write_stored_string_tchar",
      "entry": "0040d585",
      "size": 139,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "write_string",
      "entry": "0040d610",
      "size": 138,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "write_string",
      "entry": "0040d69a",
      "size": 147,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "write_string",
      "entry": "0040d72d",
      "size": 154,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FID_conflict:___stdio_common_vfprintf",
      "entry": "0040d7c7",
      "size": 119,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___stdio_common_vsprintf",
      "entry": "0040d83e",
      "size": 36,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___stdio_common_vswprintf",
      "entry": "0040d862",
      "size": 36,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "GetCurrentProcessId",
      "entry": "0040d886",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_strncpy",
      "entry": "0040d890",
      "size": 292,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_strtok",
      "entry": "0040d9b4",
      "size": 30,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_stat<struct__stat64i32>",
      "entry": "0040d9d2",
      "size": 263,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_stat_handle_file_not_opened<struct__stat64i32>",
      "entry": "0040dad9",
      "size": 140,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_stat_handle_file_opened<struct__stat64i32>",
      "entry": "0040db65",
      "size": 440,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "convert_large_integer_time_to_time_t<__int64>",
      "entry": "0040dd1d",
      "size": 170,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "loctotime<unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,int>",
      "entry": "0040ddc7",
      "size": 62,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "call_wfullpath",
      "entry": "0040de05",
      "size": 96,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "compute_size",
      "entry": "0040de65",
      "size": 50,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "convert_to_stat_mode",
      "entry": "0040de97",
      "size": 102,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "get_drive_number_from_path",
      "entry": "0040defd",
      "size": 109,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "has_executable_extension",
      "entry": "0040df6a",
      "size": 111,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "is_root_or_empty",
      "entry": "0040dfd9",
      "size": 87,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "is_root_unc_name",
      "entry": "0040e030",
      "size": 196,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "is_slash",
      "entry": "0040e0f4",
      "size": 28,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "is_usable_drive_or_unc_root",
      "entry": "0040e110",
      "size": 173,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:__stat64i32",
      "entry": "0040e1bd",
      "size": 96,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040e21d",
      "entry": "0040e21d",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040e228",
      "entry": "0040e228",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_setbuf",
      "entry": "0040e233",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_strncat",
      "entry": "0040e260",
      "size": 309,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_fullpath_dynamic_buffer<char>",
      "entry": "0040e395",
      "size": 118,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_fullpath_dynamic_buffer<wchar_t>",
      "entry": "0040e40b",
      "size": 118,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_fullpath_user_buffer<char>",
      "entry": "0040e481",
      "size": 95,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_fullpath_user_buffer<wchar_t>",
      "entry": "0040e4e0",
      "size": 95,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__fullpath",
      "entry": "0040e53f",
      "size": 87,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wfullpath",
      "entry": "0040e596",
      "size": 86,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_fsopen<wchar_t>",
      "entry": "0040e5ec",
      "size": 167,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040e696",
      "entry": "0040e696",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__wfopen",
      "entry": "0040e6ad",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__strdup",
      "entry": "0040e6c4",
      "size": 85,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_mbstowcs_l_helper",
      "entry": "0040e71a",
      "size": 377,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_mbstowcs",
      "entry": "0040e893",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__get_fmode",
      "entry": "0040e8bd",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__set_fmode",
      "entry": "0040e8e9",
      "size": 61,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__setmode",
      "entry": "0040e926",
      "size": 256,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040ea13",
      "entry": "0040ea13",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__setmode_nolock",
      "entry": "0040ea34",
      "size": 209,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_stdio_flush_nolock",
      "entry": "0040eb05",
      "size": 102,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__fflush_nolock",
      "entry": "0040eb6b",
      "size": 71,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040ebb2",
      "entry": "0040ebb2",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_flush_all",
      "entry": "0040ebbb",
      "size": 188,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040ec60",
      "entry": "0040ec60",
      "size": 10,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040ec8a",
      "entry": "0040ec8a",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_fflush",
      "entry": "0040ec93",
      "size": 75,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040ece4",
      "entry": "0040ece4",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__fileno",
      "entry": "0040ecec",
      "size": 38,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_putenv<>",
      "entry": "0040ed12",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040ed57",
      "entry": "0040ed57",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_putenv_nolock<wchar_t>",
      "entry": "0040ed60",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "create_environment_string<wchar_t>",
      "entry": "0040ede1",
      "size": 298,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "set_variable_in_other_environment<wchar_t>",
      "entry": "0040ef0b",
      "size": 202,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:__wputenv_s",
      "entry": "0040efd5",
      "size": 60,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f011",
      "entry": "0040f011",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_find_first_wide<struct__wfinddata64i32_t>",
      "entry": "0040f039",
      "size": 296,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_find_next_wide<struct__wfinddata64i32_t>",
      "entry": "0040f162",
      "size": 284,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "convert_file_time_to_time_t<__int64>",
      "entry": "0040f27f",
      "size": 128,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f2ff",
      "entry": "0040f2ff",
      "size": 38,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f325",
      "entry": "0040f325",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f330",
      "entry": "0040f330",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_lowio_create_handle_array",
      "entry": "0040f33b",
      "size": 122,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_lowio_destroy_handle_array",
      "entry": "0040f3b5",
      "size": 53,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_lowio_ensure_fh_exists",
      "entry": "0040f3ea",
      "size": 140,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f479",
      "entry": "0040f479",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_lowio_lock_fh",
      "entry": "0040f482",
      "size": 35,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_lowio_set_os_handle",
      "entry": "0040f4a5",
      "size": 148,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_lowio_unlock_fh",
      "entry": "0040f539",
      "size": 35,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__alloc_osfhnd",
      "entry": "0040f55c",
      "size": 262,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f665",
      "entry": "0040f665",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__free_osfhnd",
      "entry": "0040f66e",
      "size": 145,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__get_osfhandle",
      "entry": "0040f6ff",
      "size": 106,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()<>",
      "entry": "0040f769",
      "size": 75,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040f7b7",
      "entry": "0040f7b7",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>",
      "entry": "0040f7c3",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__crt_fast_encode_pointer<>",
      "entry": "0040f7eb",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f893",
      "entry": "0040f893",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "get_global_action_nolock",
      "entry": "0040f8b8",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "siglookup",
      "entry": "0040f8fa",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "signal_failed",
      "entry": "0040f922",
      "size": 49,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_get_sigabrt_handler",
      "entry": "0040f953",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_initialize_signal_handlers",
      "entry": "0040f96a",
      "size": 59,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040f9a5",
      "entry": "0040f9a5",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_raise",
      "entry": "0040f9ae",
      "size": 490,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040fb6e",
      "entry": "0040fb6e",
      "size": 15,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "_signal",
      "entry": "0040fbb6",
      "size": 416,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040fd50",
      "entry": "0040fd50",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0040fd68",
      "entry": "0040fd68",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_tempnam<wchar_t>",
      "entry": "0040fd90",
      "size": 299,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "compute_name<wchar_t>",
      "entry": "0040febc",
      "size": 195,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0040ff82",
      "entry": "0040ff82",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "get_directory<wchar_t>",
      "entry": "0040ff8b",
      "size": 209,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "strip_quotes<wchar_t>",
      "entry": "0041005d",
      "size": 138,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__crt_stdio_path_requires_backslash",
      "entry": "004100e7",
      "size": 58,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wtempnam",
      "entry": "00410121",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_clearerr_s",
      "entry": "0041013c",
      "size": 5,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_clearerr_s",
      "entry": "00410141",
      "size": 160,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004101e4",
      "entry": "004101e4",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__seh_filter_exe",
      "entry": "004101ec",
      "size": 371,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041035f",
      "entry": "0041035f",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00410365",
      "entry": "00410365",
      "size": 15,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_has_user_matherr",
      "entry": "00410374",
      "size": 25,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041038d",
      "entry": "0041038d",
      "size": 20,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_invoke_user_matherr",
      "entry": "004103a1",
      "size": 73,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___setusermatherr",
      "entry": "004103ea",
      "size": 21,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_configure_argv<wchar_t>",
      "entry": "004103ff",
      "size": 287,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "parse_command_line<wchar_t>",
      "entry": "0041051e",
      "size": 390,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_allocate_buffer_for_argv",
      "entry": "004106a4",
      "size": 85,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004106f9",
      "entry": "004106f9",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_get_or_create_environment_nolock<char>",
      "entry": "00410704",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_get_or_create_environment_nolock<wchar_t>",
      "entry": "00410733",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_initialize_environment_nolock<char>",
      "entry": "00410762",
      "size": 89,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_initialize_environment_nolock<wchar_t>",
      "entry": "004107bb",
      "size": 84,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "create_environment<char>",
      "entry": "0041080f",
      "size": 208,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "create_environment<wchar_t>",
      "entry": "004108e0",
      "size": 249,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "free_environment<wchar_t>",
      "entry": "004109da",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "initialize_environment_by_cloning_nolock<char>",
      "entry": "00410a09",
      "size": 127,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "initialize_environment_by_cloning_nolock<wchar_t>",
      "entry": "00410a88",
      "size": 121,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "uninitialize<>",
      "entry": "00410b01",
      "size": 64,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "uninitialize_environment_internal<>",
      "entry": "00410b41",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "uninitialize_environment_internal<>",
      "entry": "00410b5c",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_get_or_create_environment_nolock<char>",
      "entry": "00410b77",
      "size": 5,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_get_or_create_environment_nolock<wchar_t>",
      "entry": "00410b7c",
      "size": 5,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00410b81",
      "entry": "00410b81",
      "size": 55,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FID_conflict:__get_initial_narrow_environment",
      "entry": "00410bb8",
      "size": 20,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_initialize_environment_nolock<wchar_t>",
      "entry": "00410bcc",
      "size": 5,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__initterm",
      "entry": "00410bd1",
      "size": 92,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__initterm_e",
      "entry": "00410c2d",
      "size": 69,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "atexit_exception_filter",
      "entry": "00410c72",
      "size": 19,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_exit",
      "entry": "00410c85",
      "size": 261,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00410d8f",
      "entry": "00410d8f",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "exit_or_terminate_process",
      "entry": "00410d9e",
      "size": 64,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___scrt_is_managed_app",
      "entry": "00410ddf",
      "size": 68,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "try_cor_exit_process",
      "entry": "00410e23",
      "size": 106,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00410e8d",
      "entry": "00410e8d",
      "size": 15,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__cexit",
      "entry": "00410eab",
      "size": 15,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__exit",
      "entry": "00410eba",
      "size": 22,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__register_thread_local_exe_atexit_callback",
      "entry": "00410ed0",
      "size": 56,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_exit",
      "entry": "00410f08",
      "size": 22,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_set_locale_changed",
      "entry": "00410f1e",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00410f72",
      "entry": "00410f72",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__configthreadlocale",
      "entry": "00410f7b",
      "size": 98,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00410fdd",
      "entry": "00410fdd",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__set_new_mode",
      "entry": "00410fe3",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00411012",
      "entry": "00411012",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "operator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>",
      "entry": "00411018",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FUN_0041105d",
      "entry": "0041105d",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "operator()<class_<lambda_995298e7d72eb4c2aab26c0585b3abe5>,class_<lambda_275893d493268fdec8709772e3fcec0e>&,class_<lambda_293819299cbf9a7022e18b56a874bb5c>_>",
      "entry": "00411069",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FUN_004110ae",
      "entry": "004110ae",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>",
      "entry": "004110ba",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>",
      "entry": "004110e2",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()",
      "entry": "0041110a",
      "size": 288,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "operator()",
      "entry": "0041122a",
      "size": 321,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "__crt_atexit",
      "entry": "0041136b",
      "size": 22,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__execute_onexit_table",
      "entry": "00411381",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__initialize_onexit_table",
      "entry": "0041139e",
      "size": 61,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__register_onexit_function",
      "entry": "004113db",
      "size": 36,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "initialize",
      "entry": "004114f0",
      "size": 49,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "___acrt_initialize",
      "entry": "00411521",
      "size": 18,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_uninitialize",
      "entry": "00411533",
      "size": 18,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__controlfp_s",
      "entry": "00411545",
      "size": 95,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "terminate",
      "entry": "004115a4",
      "size": 52,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:_free",
      "entry": "004115e0",
      "size": 58,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__malloc_base",
      "entry": "0041161a",
      "size": 78,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_strcpy_s",
      "entry": "00411668",
      "size": 90,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_abort",
      "entry": "004116c2",
      "size": 67,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__calloc_base",
      "entry": "00411705",
      "size": 93,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "is_overflow_condition<unsigned_long>",
      "entry": "00411762",
      "size": 51,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "make_c_string_character_source<>",
      "entry": "00411795",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>",
      "entry": "004117b0",
      "size": 552,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>",
      "entry": "004119d8",
      "size": 1765,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "unget",
      "entry": "004120bd",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "unget",
      "entry": "004120e5",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "__chvalidchk_l",
      "entry": "00412111",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__ischartype_l",
      "entry": "0041213b",
      "size": 51,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_atol",
      "entry": "0041216e",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_call_reportfault",
      "entry": "00412198",
      "size": 315,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004122d3",
      "entry": "004122d3",
      "size": 20,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__invalid_parameter",
      "entry": "004122e7",
      "size": 122,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00412362",
      "entry": "00412362",
      "size": 16,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__invoke_watson",
      "entry": "00412372",
      "size": 51,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:___acrt_errno_from_os_error",
      "entry": "004123a5",
      "size": 67,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_errno_map_os_error",
      "entry": "004123e8",
      "size": 35,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___doserrno",
      "entry": "0041240b",
      "size": 19,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__errno",
      "entry": "0041241e",
      "size": 19,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>",
      "entry": "00412431",
      "size": 115,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FUN_004124a7",
      "entry": "004124a7",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>",
      "entry": "004124b3",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__close",
      "entry": "004124db",
      "size": 127,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__close_nolock",
      "entry": "0041255a",
      "size": 156,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_stdio_allocate_stream",
      "entry": "004125f6",
      "size": 83,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041264c",
      "entry": "0041264c",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_stdio_free_stream",
      "entry": "00412655",
      "size": 59,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "find_or_allocate_unused_stream_nolock",
      "entry": "00412690",
      "size": 195,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_stdio_free_buffer_nolock",
      "entry": "00412753",
      "size": 62,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "translate_text_mode_nolock<char>",
      "entry": "00412791",
      "size": 343,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "translate_text_mode_nolock<wchar_t>",
      "entry": "004128e8",
      "size": 448,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "translate_ansi_or_utf8_nolock",
      "entry": "00412aa8",
      "size": 336,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "translate_utf16_from_console_nolock",
      "entry": "00412bf8",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__read",
      "entry": "00412c79",
      "size": 261,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00412d63",
      "entry": "00412d63",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__read_nolock",
      "entry": "00412d8c",
      "size": 949,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_refill_and_read_nolock<char>",
      "entry": "00413141",
      "size": 385,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004132c2",
      "entry": "004132c2",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_lseek<__int64>",
      "entry": "004132cd",
      "size": 244,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004133a5",
      "entry": "004133a5",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_lseek_nolock<__int64>",
      "entry": "004133d2",
      "size": 126,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__lseeki64",
      "entry": "00413450",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__lseeki64_nolock",
      "entry": "0041346b",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "initialize_inherited_file_handles_nolock",
      "entry": "00413486",
      "size": 182,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041353c",
      "entry": "0041353c",
      "size": 182,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041363f",
      "entry": "0041363f",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "write_double_translated_ansi_nolock",
      "entry": "00413674",
      "size": 435,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_double_translated_unicode_nolock",
      "entry": "00413827",
      "size": 109,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_requires_double_translation_nolock",
      "entry": "00413894",
      "size": 118,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_text_ansi_nolock",
      "entry": "0041390a",
      "size": 223,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_text_utf16le_nolock",
      "entry": "004139e9",
      "size": 238,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_text_utf8_nolock",
      "entry": "00413ad7",
      "size": 301,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__write",
      "entry": "00413c04",
      "size": 221,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00413cc6",
      "entry": "00413cc6",
      "size": 8,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__write_nolock",
      "entry": "00413cef",
      "size": 524,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_flush_and_write_nolock<char>",
      "entry": "00413efb",
      "size": 273,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "write_buffer_nolock<char>",
      "entry": "0041400c",
      "size": 204,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004140d8",
      "entry": "004140d8",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_stdio_begin_temporary_buffering_nolock",
      "entry": "004140e3",
      "size": 181,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_stdio_end_temporary_buffering_nolock",
      "entry": "00414198",
      "size": 57,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "try_get_CompareStringEx",
      "entry": "004141d1",
      "size": 26,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "try_get_function",
      "entry": "004141eb",
      "size": 156,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "try_get_module",
      "entry": "00414287",
      "size": 123,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_AreFileApisANSI@0",
      "entry": "00414302",
      "size": 78,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_CompareStringEx@36",
      "entry": "00414350",
      "size": 116,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_FlsAlloc@4",
      "entry": "004143c4",
      "size": 86,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_FlsFree@4",
      "entry": "0041441a",
      "size": 86,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_FlsGetValue@4",
      "entry": "00414470",
      "size": 86,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_FlsSetValue@8",
      "entry": "004144c6",
      "size": 89,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_GetFileInformationByHandleEx@16",
      "entry": "0041451f",
      "size": 99,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_InitializeCriticalSectionEx@12",
      "entry": "00414582",
      "size": 98,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_LCMapStringEx@36",
      "entry": "004145e4",
      "size": 136,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_LocaleNameToLCID@8",
      "entry": "0041466c",
      "size": 92,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_is_packaged_app",
      "entry": "004146ee",
      "size": 135,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "___acrt_uninitialize_winapi_thunks",
      "entry": "00414775",
      "size": 54,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004147ab",
      "entry": "004147ab",
      "size": 151,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00414842",
      "entry": "00414842",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041484b",
      "entry": "0041484b",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00414851",
      "entry": "00414851",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__isdigit_l",
      "entry": "00414857",
      "size": 56,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_isdigit",
      "entry": "0041488f",
      "size": 45,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>",
      "entry": "004148bc",
      "size": 330,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "internal_isupper_l",
      "entry": "00414a06",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__tolower_l",
      "entry": "00414a23",
      "size": 26,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_tolower",
      "entry": "00414a3d",
      "size": 48,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_strtol",
      "entry": "00414a6d",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_wcstol",
      "entry": "00414a99",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__mbtowc_l",
      "entry": "00414ac5",
      "size": 250,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_mbtowc",
      "entry": "00414bbf",
      "size": 26,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wctomb_s_l",
      "entry": "00414bd9",
      "size": 289,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_wctomb_s",
      "entry": "00414cfa",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()<>",
      "entry": "00414d17",
      "size": 68,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00414d5b",
      "entry": "00414d5b",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "operator()<>",
      "entry": "00414d67",
      "size": 85,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00414dbc",
      "entry": "00414dbc",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "operator()<>",
      "entry": "00414dc8",
      "size": 63,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00414e07",
      "entry": "00414e07",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "operator()<>",
      "entry": "00414e13",
      "size": 60,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00414e4f",
      "entry": "00414e4f",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>",
      "entry": "00414e5b",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>",
      "entry": "00414e83",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>",
      "entry": "00414eab",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>",
      "entry": "00414ed3",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "construct_ptd",
      "entry": "00414efb",
      "size": 121,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "destroy_fls",
      "entry": "00414f74",
      "size": 33,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "destroy_ptd",
      "entry": "00414f95",
      "size": 169,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "replace_current_thread_locale_nolock",
      "entry": "0041503e",
      "size": 75,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_getptd",
      "entry": "00415089",
      "size": 131,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_getptd_noexit",
      "entry": "0041510d",
      "size": 133,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_004151be",
      "entry": "004151be",
      "size": 26,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_update_locale_info",
      "entry": "004151d8",
      "size": 45,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_update_multibyte_info",
      "entry": "00415205",
      "size": 45,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_fp_classify",
      "entry": "00415232",
      "size": 108,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_fp_is_negative",
      "entry": "0041529e",
      "size": 30,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fp_format_a",
      "entry": "004152bc",
      "size": 771,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fp_format_e",
      "entry": "004155bf",
      "size": 155,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fp_format_e_internal",
      "entry": "0041565a",
      "size": 330,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fp_format_f",
      "entry": "004157a5",
      "size": 141,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fp_format_f_internal",
      "entry": "00415832",
      "size": 215,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fp_format_g",
      "entry": "00415909",
      "size": 200,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fp_format_nan_or_infinity",
      "entry": "004159d1",
      "size": 247,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "shift_bytes",
      "entry": "00415ac9",
      "size": 52,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_fp_format",
      "entry": "00415afd",
      "size": 330,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__fputc_nolock",
      "entry": "00415c47",
      "size": 41,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__get_printf_count_output",
      "entry": "00415c70",
      "size": 21,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_strtok_s_novalidation",
      "entry": "00415c85",
      "size": 223,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "get_drive_number_from_path",
      "entry": "00415d64",
      "size": 45,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__getdrive",
      "entry": "00415d91",
      "size": 175,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_wcspbrk",
      "entry": "00415e40",
      "size": 69,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wcsicmp",
      "entry": "00415e85",
      "size": 149,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wcsicmp_l",
      "entry": "00415f1a",
      "size": 224,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_copy_path_to_wide_string",
      "entry": "00415ffa",
      "size": 199,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__crt_time_elapsed_leap_years<int>",
      "entry": "004160c1",
      "size": 58,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__crt_time_is_leap_year<int>",
      "entry": "004160fb",
      "size": 65,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_loctotime_t<__int64>",
      "entry": "0041613c",
      "size": 481,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__crt_time_is_day_valid",
      "entry": "0041631e",
      "size": 71,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00416365",
      "entry": "00416365",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>",
      "entry": "00416370",
      "size": 66,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FUN_004163b5",
      "entry": "004163b5",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>",
      "entry": "004163c1",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()",
      "entry": "004163e9",
      "size": 154,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "set_buffer",
      "entry": "00416483",
      "size": 51,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_setvbuf",
      "entry": "004164b6",
      "size": 118,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getdcwd<char>",
      "entry": "0041652c",
      "size": 193,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getdcwd<wchar_t>",
      "entry": "004165ed",
      "size": 237,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getdcwd_dynamic_buffer<char>",
      "entry": "004166da",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getdcwd_dynamic_buffer<wchar_t>",
      "entry": "0041675b",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getdcwd_user_buffer<char>",
      "entry": "004167dc",
      "size": 90,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getdcwd_user_buffer<wchar_t>",
      "entry": "00416836",
      "size": 90,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "is_valid_drive",
      "entry": "00416890",
      "size": 126,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__getcwd",
      "entry": "0041690e",
      "size": 28,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wgetcwd",
      "entry": "0041692a",
      "size": 28,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_stdio_parse_mode<wchar_t>",
      "entry": "00416946",
      "size": 580,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_openfile<wchar_t>",
      "entry": "00416b8a",
      "size": 133,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_stdio_parse_mode_D",
      "entry": "00416c0f",
      "size": 27,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_stdio_parse_mode_T",
      "entry": "00416c2a",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:__acrt_stdio_parse_mode_b",
      "entry": "00416c49",
      "size": 32,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_stdio_parse_mode_c",
      "entry": "00416c69",
      "size": 34,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_stdio_parse_mode_n",
      "entry": "00416c8b",
      "size": 34,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_stdio_parse_mode_plus",
      "entry": "00416cad",
      "size": 53,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:__acrt_stdio_parse_mode_b",
      "entry": "00416ce2",
      "size": 32,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00416d02",
      "entry": "00416d02",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__isleadbyte_l",
      "entry": "00416d0d",
      "size": 57,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_lock",
      "entry": "00416d87",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00416d9e",
      "entry": "00416d9e",
      "size": 49,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_unlock",
      "entry": "00416dcf",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>",
      "entry": "00416de6",
      "size": 137,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FUN_00416e72",
      "entry": "00416e72",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>",
      "entry": "00416e7e",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__commit",
      "entry": "00416ea6",
      "size": 111,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_wcscpy_s",
      "entry": "00416f15",
      "size": 100,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_set_variable_in_environment_nolock<char>",
      "entry": "00416f79",
      "size": 570,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_set_variable_in_environment_nolock<wchar_t>",
      "entry": "004171b4",
      "size": 572,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "copy_environment<char>",
      "entry": "004173f1",
      "size": 176,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "copy_environment<wchar_t>",
      "entry": "004174a2",
      "size": 189,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "find_in_environment_nolock<char>",
      "entry": "00417560",
      "size": 84,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "find_in_environment_nolock<wchar_t>",
      "entry": "004175b4",
      "size": 87,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041760b",
      "entry": "0041760b",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00417616",
      "entry": "00417616",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_xtox<unsigned_long,wchar_t>",
      "entry": "00417621",
      "size": 142,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_xtox_s<unsigned_long,wchar_t>",
      "entry": "004176af",
      "size": 95,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__ultow_s",
      "entry": "0041770e",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_dupenv_s<wchar_t>",
      "entry": "0041772b",
      "size": 79,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041777d",
      "entry": "0041777d",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_dupenv_s_nolock<wchar_t>",
      "entry": "00417786",
      "size": 173,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getenv_nolock<char>",
      "entry": "00417834",
      "size": 112,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getenv_nolock<wchar_t>",
      "entry": "004178a4",
      "size": 138,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_getenv_s<char>",
      "entry": "0041792e",
      "size": 73,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041797a",
      "entry": "0041797a",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_getenv_s_nolock<char>",
      "entry": "00417983",
      "size": 167,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:__dupenv_s",
      "entry": "00417a2b",
      "size": 30,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00417a49",
      "entry": "00417a49",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_wcscat_s",
      "entry": "00417a54",
      "size": 117,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__waccess_s",
      "entry": "00417ac9",
      "size": 192,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00417c02",
      "entry": "00417c02",
      "size": 10,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_00417c21",
      "entry": "00417c21",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "common_tcsncpy_s<wchar_t>",
      "entry": "00417c2a",
      "size": 205,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00417cf7",
      "entry": "00417cf7",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00417d02",
      "entry": "00417d02",
      "size": 24,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_expand_argv_wildcards<wchar_t>",
      "entry": "00417d1a",
      "size": 460,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "copy_and_add_argument_to_buffer<wchar_t>",
      "entry": "00417ee7",
      "size": 157,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "expand_argument_wildcards<wchar_t>",
      "entry": "00417f85",
      "size": 438,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "~argument_list<wchar_t>",
      "entry": "0041813b",
      "size": 37,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "append",
      "entry": "00418160",
      "size": 53,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "expand_if_necessary",
      "entry": "00418195",
      "size": 135,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "FUN_0041821c",
      "entry": "0041821c",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()<class_<lambda_978dc153c237d78434369da87b74ff60>,class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>&,class_<lambda_4a8533e2866a575feecb8298ce776b0d>_>",
      "entry": "00418227",
      "size": 55,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "FUN_0041825e",
      "entry": "0041825e",
      "size": 12,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>_>",
      "entry": "0041826a",
      "size": 40,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "operator()",
      "entry": "00418292",
      "size": 196,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "CPtoLocaleName",
      "entry": "00418356",
      "size": 62,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "getSystemCP",
      "entry": "00418394",
      "size": 115,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "setSBCS",
      "entry": "00418407",
      "size": 101,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "setSBUpLow",
      "entry": "0041846c",
      "size": 404,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "setmbcp_internal",
      "entry": "00418600",
      "size": 257,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_initialize_multibyte",
      "entry": "00418701",
      "size": 30,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___acrt_update_thread_multibyte_data",
      "entry": "0041871f",
      "size": 150,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_004187b0",
      "entry": "004187b0",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__setmbcp_nolock",
      "entry": "004187c1",
      "size": 497,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_memcpy_s",
      "entry": "004189b2",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "find_end_of_double_null_terminated_sequence",
      "entry": "00418a33",
      "size": 55,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___dcrt_get_narrow_environment_from_os",
      "entry": "00418a6a",
      "size": 131,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___dcrt_get_wide_environment_from_os",
      "entry": "00418aed",
      "size": 80,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___pctype_func",
      "entry": "00418b3d",
      "size": 38,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "____lc_codepage_func",
      "entry": "00418b63",
      "size": 39,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_locale_free_monetary",
      "entry": "00418b8a",
      "size": 254,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_locale_free_numeric",
      "entry": "00418c88",
      "size": 105,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "free_crt_array_internal",
      "entry": "00418cf1",
      "size": 60,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_locale_free_time",
      "entry": "00418d2d",
      "size": 228,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_wcsncmp",
      "entry": "00418e11",
      "size": 58,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_GetStringTypeA",
      "entry": "00418e4b",
      "size": 285,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__freea_crt",
      "entry": "00418f68",
      "size": 32,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_add_locale_ref",
      "entry": "00418f88",
      "size": 125,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_free_locale",
      "entry": "00419005",
      "size": 330,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_locale_add_lc_time_reference",
      "entry": "0041914f",
      "size": 41,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_locale_free_lc_time_if_unreferenced",
      "entry": "00419178",
      "size": 48,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_locale_release_lc_time_reference",
      "entry": "004191a8",
      "size": 41,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_release_locale_ref",
      "entry": "004191d1",
      "size": 129,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_update_thread_locale_data",
      "entry": "00419252",
      "size": 107,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_004192b8",
      "entry": "004192b8",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__updatetlocinfoEx_nolock",
      "entry": "004192c9",
      "size": 80,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00419319",
      "entry": "00419319",
      "size": 120,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_execute_initializers",
      "entry": "004193ac",
      "size": 131,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_execute_uninitializers",
      "entry": "0041942f",
      "size": 77,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041947c",
      "entry": "0041947c",
      "size": 20,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__callnewh",
      "entry": "00419490",
      "size": 68,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__query_new_handler",
      "entry": "004194d4",
      "size": 70,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041951d",
      "entry": "0041951d",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___hw_cw_sse2",
      "entry": "00419526",
      "size": 171,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__clearfp",
      "entry": "004195d1",
      "size": 222,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__control87",
      "entry": "004196af",
      "size": 770,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__hw_cw",
      "entry": "004199b1",
      "size": 153,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_iswctype",
      "entry": "00419a4a",
      "size": 95,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__isctype_l",
      "entry": "00419aa9",
      "size": 210,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__isatty",
      "entry": "00419b7b",
      "size": 86,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_stdio_allocate_buffer_nolock",
      "entry": "00419bd1",
      "size": 93,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__putwch_nolock",
      "entry": "00419c2e",
      "size": 69,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "GetTableIndexFromLocaleName",
      "entry": "00419c73",
      "size": 188,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_DownlevelLocaleNameToLCID",
      "entry": "00419d2f",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__acrt_LCMapStringA_stat",
      "entry": "00419d5b",
      "size": 541,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_LCMapStringA",
      "entry": "00419f78",
      "size": 75,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_fp_strflt_to_string",
      "entry": "00419fc3",
      "size": 188,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "scoped_fp_state_reset",
      "entry": "0041a07f",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__thiscall"
    },
    {
      "name": "divide",
      "entry": "0041a0b0",
      "size": 1192,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_fltout",
      "entry": "0041a55e",
      "size": 5019,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__towlower_l",
      "entry": "0041b8fa",
      "size": 201,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041b9fa",
      "entry": "0041b9fa",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041ba00",
      "entry": "0041ba00",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041ba06",
      "entry": "0041ba06",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041ba0c",
      "entry": "0041ba0c",
      "size": 6,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__get_daylight",
      "entry": "0041ba12",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__get_dstbias",
      "entry": "0041ba3e",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__get_timezone",
      "entry": "0041ba6a",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_isindst_nolock",
      "entry": "0041ba96",
      "size": 486,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "cvtdate",
      "entry": "0041bc7d",
      "size": 335,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "tzset_from_environment_nolock",
      "entry": "0041bdcd",
      "size": 468,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "tzset_from_system_nolock",
      "entry": "0041bfa2",
      "size": 346,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "tzset_nolock",
      "entry": "0041c0fd",
      "size": 224,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___tzset",
      "entry": "0041c1dd",
      "size": 72,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041c225",
      "entry": "0041c225",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__isindst",
      "entry": "0041c22e",
      "size": 62,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041c26f",
      "entry": "0041c26f",
      "size": 9,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__wcsnicmp",
      "entry": "0041c278",
      "size": 184,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wcsnicmp_l",
      "entry": "0041c330",
      "size": 257,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__strnicmp",
      "entry": "0041c431",
      "size": 108,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__strnicmp_l",
      "entry": "0041c49d",
      "size": 183,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_sopen_dispatch<wchar_t>",
      "entry": "0041c554",
      "size": 154,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041c5f4",
      "entry": "0041c5f4",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "configure_text_mode",
      "entry": "0041c620",
      "size": 588,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "create_file",
      "entry": "0041c86d",
      "size": 37,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "decode_open_create_flags",
      "entry": "0041c892",
      "size": 112,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "decode_options",
      "entry": "0041c902",
      "size": 379,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "truncate_ctrl_z_if_present",
      "entry": "0041ca7e",
      "size": 176,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wsopen_nolock",
      "entry": "0041cb2e",
      "size": 809,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FID_conflict:__sopen_s",
      "entry": "0041ce57",
      "size": 32,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wcsnicoll",
      "entry": "0041ce77",
      "size": 208,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__wcsnicoll_l",
      "entry": "0041cf47",
      "size": 301,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__strnicoll",
      "entry": "0041d074",
      "size": 41,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__strnicoll_l",
      "entry": "0041d09d",
      "size": 202,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041d167",
      "entry": "0041d167",
      "size": 62,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "shortsort",
      "entry": "0041d1b0",
      "size": 147,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "swap",
      "entry": "0041d250",
      "size": 57,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_qsort",
      "entry": "0041d290",
      "size": 916,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "common_tcsncpy_s<char>",
      "entry": "0041d62a",
      "size": 177,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041d6db",
      "entry": "0041d6db",
      "size": 11,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "_strpbrk",
      "entry": "0041d6f0",
      "size": 64,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041d73f",
      "entry": "0041d73f",
      "size": 51,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__realloc_base",
      "entry": "0041d772",
      "size": 105,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___set_fpsr_sse2",
      "entry": "0041d7db",
      "size": 72,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__clrfp",
      "entry": "0041d851",
      "size": 19,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__ctrlfp",
      "entry": "0041d864",
      "size": 44,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041d890",
      "entry": "0041d890",
      "size": 91,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__statfp",
      "entry": "0041d8eb",
      "size": 18,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___dcrt_lowio_initialize_console_output",
      "entry": "0041d8fd",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "___strncnt",
      "entry": "0041d933",
      "size": 28,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fegetenv",
      "entry": "0041d94f",
      "size": 29,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "fesetenv",
      "entry": "0041d96c",
      "size": 73,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "feholdexcept",
      "entry": "0041d9b5",
      "size": 79,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041da50",
      "entry": "0041da50",
      "size": 79,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041daa8",
      "entry": "0041daa8",
      "size": 197,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041db60",
      "entry": "0041db60",
      "size": 470,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_LCMapStringW",
      "entry": "0041dc7d",
      "size": 62,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___ascii_strnicmp",
      "entry": "0041dcc0",
      "size": 97,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__chsize_nolock",
      "entry": "0041dd21",
      "size": 401,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_CompareStringW",
      "entry": "0041deb2",
      "size": 104,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "InternalCompareStringA",
      "entry": "0041df1a",
      "size": 680,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___acrt_CompareStringA",
      "entry": "0041e1c2",
      "size": 72,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___get_abstract_control_sse2",
      "entry": "0041e20a",
      "size": 125,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___get_abstract_control_x87",
      "entry": "0041e287",
      "size": 115,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___get_machine_control",
      "entry": "0041e2fa",
      "size": 113,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___get_machine_control_sse2",
      "entry": "0041e36b",
      "size": 128,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___get_machine_status_sse2",
      "entry": "0041e3eb",
      "size": 97,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "___get_machine_status_x87",
      "entry": "0041e44c",
      "size": 97,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__getfpcontrolword",
      "entry": "0041e4ad",
      "size": 67,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__getfpstatusword",
      "entry": "0041e4f0",
      "size": 168,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__setfpcontrolword",
      "entry": "0041e598",
      "size": 128,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__setfpstatusword",
      "entry": "0041e618",
      "size": 128,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041e6b0",
      "entry": "0041e6b0",
      "size": 24,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041e6ce",
      "entry": "0041e6ce",
      "size": 614,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041ed6c",
      "entry": "0041ed6c",
      "size": 25,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "FUN_0041edc8",
      "entry": "0041edc8",
      "size": 22,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__math_exit",
      "entry": "0041edeb",
      "size": 42,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "FUN_0041eed0",
      "entry": "0041eed0",
      "size": 23,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "__startOneArgErrorHandling",
      "entry": "0041eee7",
      "size": 60,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "___libm_error_support",
      "entry": "0041ef23",
      "size": 536,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041f1f4",
      "entry": "0041f1f4",
      "size": 106,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041f25e",
      "entry": "0041f25e",
      "size": 299,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__87except",
      "entry": "0041f389",
      "size": 267,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041f494",
      "entry": "0041f494",
      "size": 22,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__errcode",
      "entry": "0041f4aa",
      "size": 52,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__except1",
      "entry": "0041f4de",
      "size": 206,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__handle_exc",
      "entry": "0041f5ac",
      "size": 480,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__raise_exc",
      "entry": "0041f78c",
      "size": 35,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__raise_exc_ex",
      "entry": "0041f7af",
      "size": 753,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__set_errno_from_matherr",
      "entry": "0041faa0",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__umatherr",
      "entry": "0041facf",
      "size": 162,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041fb71",
      "entry": "0041fb71",
      "size": 212,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__set_exp",
      "entry": "0041fc45",
      "size": 47,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__sptype",
      "entry": "0041fc74",
      "size": 94,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__fpclass",
      "entry": "0041fcd2",
      "size": 164,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "IsProcessorFeaturePresent",
      "entry": "0041fd76",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "__stdcall"
    },
    {
      "name": "RtlUnwind",
      "entry": "0041fd7c",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__FindPESection",
      "entry": "0041fd90",
      "size": 67,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__IsNonwritableInCurrentImage",
      "entry": "0041fde0",
      "size": 164,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__ValidateImageBase",
      "entry": "0041fea0",
      "size": 49,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "__aulldvrm",
      "entry": "0041fee0",
      "size": 149,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__SEH_prolog4_GS",
      "entry": "0041ff80",
      "size": 73,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_0041ffc9",
      "entry": "0041ffc9",
      "size": 17,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__allmul",
      "entry": "0041ffe0",
      "size": 52,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__alldvrm",
      "entry": "00420020",
      "size": 223,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__aullshr",
      "entry": "00420100",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "__alloca_probe_16",
      "entry": "00420120",
      "size": 22,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__alloca_probe_8",
      "entry": "00420136",
      "size": 22,
      "is_thunk": false,
      "calling_convention": "__stdcall"
    },
    {
      "name": "__allshl",
      "entry": "00420150",
      "size": 31,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "FUN_00420170",
      "entry": "00420170",
      "size": 145,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "FUN_00420225",
      "entry": "00420225",
      "size": 161,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_004202c6",
      "entry": "004202c6",
      "size": 174,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    },
    {
      "name": "FUN_00420380",
      "entry": "00420380",
      "size": 1330,
      "is_thunk": false,
      "calling_convention": "__cdecl"
    }
  ],
  "imports": [
    "CloseHandle",
    "CompareStringW",
    "ConvertStringSecurityDescriptorToSecurityDescriptorW",
    "CreateDirectoryW",
    "CreateFileW",
    "CreateProcessW",
    "DecodePointer",
    "DeleteCriticalSection",
    "DeleteFileW",
    "EnterCriticalSection",
    "ExitProcess",
    "ExpandEnvironmentStringsW",
    "FileTimeToSystemTime",
    "FindClose",
    "FindFirstFileExW",
    "FindNextFileW",
    "FlushFileBuffers",
    "FormatMessageW",
    "FreeEnvironmentStringsW",
    "FreeLibrary",
    "GetACP",
    "GetCPInfo",
    "GetCommandLineA",
    "GetCommandLineW",
    "GetConsoleCP",
    "GetConsoleMode",
    "GetCurrentDirectoryW",
    "GetCurrentProcess",
    "GetCurrentProcessId",
    "GetCurrentThreadId",
    "GetDriveTypeW",
    "GetEnvironmentStringsW",
    "GetEnvironmentVariableW",
    "GetExitCodeProcess",
    "GetFileAttributesExW",
    "GetFileType",
    "GetFullPathNameA",
    "GetFullPathNameW",
    "GetLastError",
    "GetModuleFileNameW",
    "GetModuleHandleExW",
    "GetModuleHandleW",
    "GetOEMCP",
    "GetProcAddress",
    "GetProcessHeap",
    "GetShortPathNameW",
    "GetStartupInfoW",
    "GetStdHandle",
    "GetStringTypeW",
    "GetSystemTimeAsFileTime",
    "GetTempPathW",
    "GetTimeZoneInformation",
    "HeapAlloc",
    "HeapFree",
    "HeapReAlloc",
    "HeapSize",
    "InitializeCriticalSectionAndSpinCount",
    "InitializeSListHead",
    "IsDebuggerPresent",
    "IsProcessorFeaturePresent",
    "IsValidCodePage",
    "LCMapStringW",
    "LeaveCriticalSection",
    "LoadLibraryA",
    "LoadLibraryExW",
    "MultiByteToWideChar",
    "Ordinal_14",
    "PeekNamedPipe",
    "QueryPerformanceCounter",
    "RaiseException",
    "ReadConsoleW",
    "ReadFile",
    "RemoveDirectoryW",
    "RtlUnwind",
    "SetConsoleCtrlHandler",
    "SetDllDirectoryW",
    "SetEndOfFile",
    "SetEnvironmentVariableA",
    "SetEnvironmentVariableW",
    "SetErrorMode",
    "SetFilePointerEx",
    "SetLastError",
    "SetStdHandle",
    "SetUnhandledExceptionFilter",
    "Sleep",
    "SystemTimeToTzSpecificLocalTime",
    "TerminateProcess",
    "TlsAlloc",
    "TlsFree",
    "TlsGetValue",
    "TlsSetValue",
    "UnhandledExceptionFilter",
    "WaitForSingleObject",
    "WideCharToMultiByte",
    "WriteConsoleW",
    "WriteFile"
  ],
  "strings": [
    "!This program cannot be run in DOS mode.\r\r\n$",
    "Rich",
    ".text",
    "`.rdata",
    "@.data",
    ".gfids",
    "@.rsrc",
    "@.reloc",
    "t$ Ph4",
    "t$ PhP",
    "D$ j",
    "D$8j",
    "FhPhx",
    "u1VUS",
    "_^][",
    "_^][",
    "_^][",
    "D$`S",
    "\\$pVW",
    "L$`3",
    "~FPf",
    "_^[3",
    "_^][",
    "_^][",
    "~hWh",
    "FhPh`",
    "D$ P",
    "Pu%hH",
    "_^[3",
    "tDh0",
    "Vhx@",
    "u.h`",
    "^_][",
    "FhUP",
    "t Uh",
    "^_][",
    "^_][",
    "^_][",
    "D$0V",
    "D$DPj",
    "t$Hh",
    "D$ PV",
    "D$PSVW",
    "<bta<xt]<ZtY<duc",
    "_^[3",
    "<bt!<xt",
    "u'hL",
    "u'hl",
    "VW;]",
    "_^][3",
    "_^[3",
    "u,hd",
    "D$$P",
    "][_^3",
    "<1\\u",
    "1j\\V",
    "u+hx",
    "D$8P",
    "D$@P",
    "D$ P",
    "D$4P",
    "<1\\u",
    "1j\\V",
    "_^][",
    "_^][",
    "_^][",
    "|6hd",
    "u\nhp",
    "u\nh$",
    "u\nhh",
    "h< B",
    "u\nhP B",
    "u\nh(!B",
    "hT!B",
    "u\nh`!B",
    "hP\"B",
    "u\nhh\"B",
    "h$#B",
    "u\nh8#B",
    "hh#B",
    "u\nh|#B",
    "h$$B",
    "u\nh4$B",
    "h`$B",
    "u\nhp$B",
    "h4%B",
    "u\nhL%B",
    "h|%B",
    "3h<&B",
    "hP&B",
    " |*h|&B",
    "SVWh",
    "ShD+B",
    "hP+B",
    "h|+B",
    "]_^3",
    "khUj",
    "Vh0,B",
    "h@,B",
    "uVhH,B",
    "UVh8,B",
    "t\rhp,B",
    "^]_3",
    "gfff",
    "tCh 'B",
    "D$LP",
    "D$PP",
    "D$DPh0'B",
    "D$LP",
    "PhT'B",
    "Php'B",
    "_^][3",
    "VWh((B",
    "hD(B",
    "hd(B",
    "GhPt/h8*C",
    "h8*C",
    "hPzC",
    "hPzC",
    "Vt?h0",
    "h,)B",
    ":hHZC",
    "hH)B",
    "Vh,)B",
    "hHZC",
    "hp)B",
    "h@:C",
    "h@:C",
    "h@*B",
    "u\rhd*B",
    "h@:C",
    "ukSj",
    "_^[3",
    "tTWh$-B",
    "Wh8-B",
    "h\\-B",
    "D$<h",
    "D$Pj",
    "_^][3",
    "D$<P",
    "|$@O",
    "|$@+",
    "D$DP",
    "_[]^",
    "D$DP",
    "D$@Ph",
    "D$@h",
    "SVWh",
    "_^[3",
    "SVWj",
    "D$$Pj",
    "D$ P",
    "t?h .B",
    "hP.B",
    "hp.B",
    "D$(U",
    "D$4f",
    "T$4f",
    "_^][3",
    " SUV",
    "t$0WVh",
    "hD1B",
    "h01B",
    "h /B",
    "h,/B",
    "h</B",
    "_^][",
    "_^][",
    "hP/B",
    "_^][",
    "t$ j",
    "hD1B",
    "h01B",
    "_^][",
    "jjjj",
    "t$(j",
    "hH0B",
    "_^][",
    "L$43",
    "h01B",
    "hD1B",
    "h01B",
    "uCVVj",
    "h01B",
    "hD1B",
    "h01B",
    "uEVVVVj",
    "t$$Vh",
    "hH0B",
    "t$$j",
    "hH0B",
    "t$ j",
    "hD1B",
    "h01B",
    "_^][",
    "jjjj",
    "h$0B",
    "hH0B",
    "t$ j",
    "h\\0B",
    "hH0B",
    "l$4V",
    "D$$j",
    "wI;O(wDj",
    "D$4v",
    "WD;P s",
    "L$4t",
    "s@u';i",
    "WD;P(s",
    "L$4t",
    " s)f",
    "D$ +",
    "Gl;G`sV",
    "Gl;G`r",
    "PRQj",
    "GtPj",
    "Gd9Gl",
    "D$4;",
    "D$4;",
    "L$4;",
    "M;t$4r",
    "L$4;",
    "L$4;",
    "|$$+",
    "GtPj",
    "GdRQ",
    "OPH#",
    "J#T$",
    "T$4#\\$",
    "O#|$",
    "OTH#",
    "J#T$",
    "T$4#\\$",
    "O#|$",
    "D$(+",
    ";O0v ",
    "D$ +",
    "|$ +",
    "|$$9OD",
    "D$(+D$",
    "D$(t4",
    "D$$+D$,",
    "D$(tG",
    ";W t=",
    "w@^][",
    "D$8+A",
    "D$8t<",
    "DD$H",
    "D$,^][_",
    "t@90u<",
    "F  s@",
    "F$@s@",
    "F Wh",
    "t}9;uy",
    "|o=S?",
    "~\n^]_",
    "9s(t",
    "^]_[",
    "+~4U",
    "][_^",
    "N,9N4u",
    "F0][_3",
    "DD\\;",
    "^_][3",
    "\\$ ;",
    "\\$ ;",
    "DD|f",
    "DD|A;",
    "D$,@]B",
    "u\t=T",
    "D$,+",
    "D$0f",
    "D$4u",
    "t$P#",
    "t$X;t$H",
    "D$T+",
    "8SUVW",
    "+L$P",
    "L$(#",
    "L$(H#",
    "L$,#",
    "T$P+",
    "L$,H#",
    "T$P+",
    "+D$@",
    "|$$;",
    ";L$Dv",
    "D$4+",
    "|$0;",
    "|$0+",
    "|$ ;",
    ";T$8",
    "L$LH#",
    "D$8+",
    "x<_^",
    "h@][",
    "WVS3",
    "j Y+",
    "8csm",
    "Y__^[",
    "ineI",
    "5ntel",
    "5Genu",
    "t#=`",
    "^_[3",
    "oF f",
    "oF f",
    "oF f",
    "oV f",
    "o^0f",
    "of@f",
    "onPf",
    "ov`f",
    "o~pf",
    "FGIu",
    "FGIu",
    "8_^]",
    "xf~U",
    "8csm",
    "t.ht",
    "URPQQh",
    "L$,3",
    "UVWS",
    "[_^]",
    "SVWj",
    "_^[]",
    "j Y+",
    "_^[]",
    "Wu\rVVS",
    "^_[]",
    "j Y+",
    "j Y+",
    "SVWUj",
    "]_^[",
    ";t$,v-",
    "UQPXY]Y[",
    "j X+",
    "j X+",
    "t\rf9:t",
    "f9:t",
    "t\rf9:t",
    "f9:t",
    "f9:t",
    "t39E",
    "_^[]",
    "uC9u",
    "SVWj",
    "A<Au",
    "VWSP",
    "_^[]",
    "AG;}",
    "RVSW",
    "u@;U",
    "t9 S",
    ";T9 ",
    ";D9$",
    "~8@_",
    "F4^[]",
    "QQSV",
    "~8@_",
    "F4^[",
    "~!Sf",
    "_[^]",
    "\t<et",
    "Wj\nQ",
    "Wj\nQ",
    "<Pt8",
    "<Pt8",
    "y1*t\n",
    "y2*t\n",
    "A1<Fu",
    "<Nu&",
    "u<dt",
    "<Xu]",
    "8lu\r@",
    "A1<Fu",
    "<Nu&",
    "u<dt",
    "<Xu]",
    "8lu\r@",
    "Tt1jhZ;",
    "OjlZ;",
    "^$+^8+",
    "^$+^8+",
    "jAZjX",
    ">t6;",
    "t\tj-Xf",
    "jXXf;",
    "jA_f;",
    "t0jXXf",
    "jAXf;",
    "~$+~8+",
    "y1*t\n",
    "y2*t\n",
    "F1<at\r<At\t",
    "F1<gt",
    "v(PQ",
    "F1<gt",
    "N @@",
    "QQVW",
    "jgYjG",
    "F2f;",
    "v(PQ",
    "F2jgYf;",
    "jGYf;",
    "N @@",
    "jsXf",
    "F8SP",
    "9F(~",
    "W49u",
    "BBF;u",
    "u&9E",
    "C;^8u",
    "u&9E",
    "C;^8u",
    "QQSV",
    "G;~8u",
    "QQVW",
    "SVWj03",
    "\"h4gB",
    "u j0",
    "iSVW",
    "WWWSHSh",
    "V,_^[",
    "j\nY3",
    "SPSSSW",
    "WjA[",
    "jZ_f;",
    "jaZf;",
    "zw43",
    ":u$f9Q",
    "_^[]",
    "h gB",
    "jAZf;",
    "Zv\rjaZf;",
    "zw\nf",
    "f99t7",
    "f99t/",
    "f99t",
    "h,gB",
    "t(9M",
    "PPPPP",
    "~0WPQ",
    "j=XSf",
    "SVW3",
    "PPPPj",
    "PPPPj",
    "PPWVj",
    "1RR+",
    "=WPj",
    "SSSQSP",
    "SSSSS",
    "PPPPP",
    "QQSWj0j@",
    "Y_[^]",
    "xi;5",
    "xg;5",
    "_^[]",
    "x';\r",
    "j Y+",
    "t\rj Y+",
    "j Y+",
    ">PgB",
    "hPgB",
    "t\"k5",
    "YY9u",
    "h<gB",
    "YY_^",
    "PPPPP",
    "wMj\n",
    "SSSSS",
    "QSVW3",
    "hHgB",
    "tESV",
    "SSSSS",
    "99t\t",
    "wOtD",
    "f9;u",
    "PWWS",
    "A98u",
    "j\"Xf9",
    "t\tf;E",
    "j\"Xu",
    "@f91t",
    "j\"^f91j\\^u8",
    "u 8]",
    "j\"^f9q",
    "j\\^u",
    "t*8]",
    "QQSVW",
    "PPPPP",
    "t/j=[f;",
    "Cf93u",
    "PPPPP",
    "Y_^]",
    "QSSSSj",
    "KSSj",
    "t1SVj",
    "j Y+",
    "t#Vh",
    "j Y+",
    "j Y+",
    "j Y;E",
    "j Y+",
    "j _;",
    "j Y+",
    "j Y+",
    ",0<\tw",
    "u=j\n_",
    "j0Xj",
    "j:Xf;",
    "u0jAXf;",
    "jZXf;",
    "j0Xf;",
    "j:Xf;",
    "u0jAXf;",
    "jZXf;",
    "t1;E",
    "j\nQQ",
    "PPPPP",
    "j\rX]",
    "x7;5",
    "\rFC@",
    "D8(Ht",
    "j\rZf9U",
    "s3j\nZf9",
    "j\rZf",
    "D8(HXt:f",
    "gj\rXf",
    ";f9E",
    "j\nXf9E",
    "t\tj\rXf",
    "D8(Ht5F",
    "D9,+",
    "2D9-$",
    "0D9-",
    "\ru ;",
    "j\n_f99",
    "<\nto",
    "<\nt)",
    "SVW3",
    "Ht$;}",
    "\nu,j\rXj",
    "j\r[S",
    "C<\nu",
    "j\rZf",
    "\nu\tj\rZf",
    "SShU\r",
    "(@t\t",
    "@( t",
    "@_^]",
    "_[^]",
    "_^[]",
    "Wu\rVVS",
    "^[_]",
    "Vh0oB",
    "h(oB",
    "Vh8oB",
    "h0oB",
    "h8oB",
    "VhPoB",
    "hHoB",
    "hPoB",
    "~';_",
    "GWVj\t",
    "QVWSj",
    "FLY;",
    "uIhd",
    "uQhd",
    "htOA",
    "_^[]",
    "0SVW",
    "u$SW",
    "8] j0",
    "j0Yf",
    "v6j0",
    "Wj0XPV",
    "jdSQ",
    "j\nSQ",
    "Fj0X",
    "80t/",
    "-jd_;",
    "j\n_;",
    "PPPPP",
    "Wj0V",
    "_^[t\n",
    "QWPV",
    " _^[",
    "PPPPP",
    "QQVW",
    "u,t6",
    "$[_^",
    "SVWf9",
    "_^[]",
    "SVWjA_jZ+",
    "r\rf;",
    "uBjAYjZ+",
    "r\rf;",
    "t:f;",
    "^[t\n",
    "Y_[^",
    "SSSSS",
    "F@j:f",
    "j.Xf",
    "\rj.Xf",
    "@j:f",
    "j\\Xf",
    "f9>t",
    "pt\\+",
    "f9>t",
    "h\\xB",
    "f9>t",
    ">=ur",
    "f9>t",
    "hdxB",
    "hpxB",
    "f9>t",
    "x7;5",
    "|VWj=S",
    "SSSSS",
    "}VWj=S",
    "SSSSS",
    "PPPPP",
    "PPPPP",
    "j-ZCf",
    "_^[]",
    "PPPPP",
    "<2=u",
    "QQVW",
    "<r=u",
    "v!j\"X_^[",
    "PPPPP",
    "f92t",
    "u\r9M",
    "taj*Xf",
    "j?Xf",
    "PPPPP",
    "PPPPP",
    "VWj\\^j:",
    "j\\Zf;",
    "j:Zf;",
    "WWWPWS",
    "PWWS",
    "t-f9",
    "u\tf9",
    "j.Xu",
    "_^[]",
    "IH;A",
    "SSVWh ",
    "9wLt",
    "X_^]",
    "f9:t!V",
    "f9:u",
    "QSVW",
    "YWWW",
    "SVWW",
    "WSVPP",
    "_^[]",
    "t\rf;1u",
    "9E WW",
    "t4SWV",
    "tl=@",
    "Y_^[",
    "YY^]",
    "j@%@",
    "x$;\r",
    "SVW3",
    "r\rf;",
    "9E(j",
    "PPPPPWS",
    "QQQP",
    "PP9E u:PPVWP",
    "?5|\r",
    "u\n_3",
    "wIPS3",
    "j Y+",
    "j X+",
    "jrY;",
    "j Y+",
    "j X+",
    "jrY;",
    "j X+",
    "j X+",
    "jrY;",
    "stW;",
    "stW;",
    "YYj\nZ;",
    "_^[t\r",
    "PPPPP",
    "SSPQSS",
    "Xj\n_3",
    "RPQj",
    "PPPj",
    "PPSW",
    "@_^[",
    "SSSSS",
    "uySW",
    "u kE$<",
    "uDiE",
    "jjjjj",
    "_WVj@",
    ">:uBFV",
    "PPPPP",
    "PSj?",
    "PSj?",
    "t\r9]",
    "SSSSS",
    "SVjA[jZ^+",
    "r\rf;",
    "jAZjZ^",
    "r\rf;",
    "t@f;",
    "uG9E",
    "SSSSS",
    "uz9}",
    "PPPPP",
    "PPPV",
    "DSVW",
    "mSjA[jZ^+",
    "r\rf;",
    "8jZZf;",
    "r\rf;",
    "r\rf;",
    "(SWS",
    "VPRQ",
    "PRPQh",
    "SVWj",
    "u\r9M",
    "PPPPPPPP",
    "<$tL",
    "|%=2",
    "QQQP",
    "~\"VW",
    " SVW3",
    " SVW3",
    "QQSV",
    "_^[]",
    "Y_^[",
    "Y_^[",
    "v\tN+D$",
    "WVU3",
    "v\tN+D$",
    "<$Xf",
    "oF f",
    "oF f",
    "oF f",
    "oV f",
    "o^0f",
    "of@f",
    "onPf",
    "ov`f",
    "o~pf",
    "FGIu",
    "FGIu",
    "Cannot read Table of Contents.\n",
    "Error allocating decompression buffer\n",
    "1.2.11",
    "Error %d from inflate: %s\n",
    "Error %d from inflateInit: %s\n",
    "Cannot open archive file\n",
    "Could not allocate read buffer\n",
    "Could not read from file\n",
    "Error decompressing %s\n",
    "%s could not be extracted!\n",
    "fopen",
    "Failed to write all bytes for %s\n",
    "fwrite",
    "LOADER: Could not find a valid magic value (was %x %x).\n",
    "LOADER: %s contains a digital signature\n",
    "LOADER: archivename is %s\n",
    "LOADER: Cannot open archive: %s\n",
    "Loader: Cannot find cookie",
    "Could not allocate buffer for TOC.",
    "malloc",
    "Could not read from file.",
    "fread",
    "Error on file\n.",
    "LOADER: Freeing archive status for %s\n",
    "[%d] ",
    "%s: %s",
    "LOADER: Splitting item into path and filename\n",
    "LOADER: Coping file %s to %s\n",
    "LOADER: Getting file from archive.\n",
    "LOADER: Archive found: %s\n",
    "LOADER: Checking next archive in the list...\n",
    "Error allocating memory for status\n",
    "Archive path exceeds PATH_MAX\n",
    "Error opening archive %s\n",
    "LOADER: Extracting dependencies from archive\n",
    "LOADER: Extracting dependencies\n",
    "LOADER: Checking if file exists\n",
    "%s%s%s%s%s",
    "LOADER: File %s found, assuming is onedir\n",
    "Error copying %s\n",
    "%s%s%s%s%s%s%s",
    "LOADER: File %s not found, assuming is onefile.\n",
    "%s%s%s.pkg",
    "%s%s%s.exe",
    "%s%s%s",
    "Archive not found: %s\n",
    "Error extracting %s\n",
    "LOADER: Extracting binaries\n",
    "__main__",
    "Could not get __main__ module.",
    "Could not get __main__ module's dict.",
    "Name exceeds PATH_MAX\n",
    "LOADER: Running %s\n",
    "__file__",
    "Failed to unmarshal code object for %s\n",
    "Failed to execute script %s\n",
    "pyi-windows-manifest-filename",
    "LOADER: OK.\n",
    "PyInstaller Bootloader 3.x\n",
    "Cannot allocate memory for ARCHIVE_STATUS\n",
    "calloc",
    "_MEIPASS2",
    "NULL",
    "LOADER: _MEIPASS2 is %s\n",
    "Cannot open self %s or archive %s\n",
    "LOADER: No need to extract files to run; setting extractionpath to homepath\n",
    "LOADER: SetDllDirectory(%s)\n",
    "LOADER: Already in the child - running user's code.\n",
    "LOADER: temppath exceeds PATH_MAX\n",
    "LOADER: temppath is %s\n",
    "LOADER: Error extracting binaries\n",
    "LOADER: Executing self as child\n",
    "LOADER: set _MEIPASS2 to %s\n",
    "LOADER: Back to parent (RC: %d)\n",
    "LOADER: Doing cleanup\n",
    "Failed to get executable path.",
    "GetModuleFileNameW",
    "Failed to convert executable path to UTF-8.",
    "LOADER: executable is %s\n",
    "LOADER: homepath is %s\n",
    "Py_DontWriteBytecodeFlag",
    "Failed to get address for Py_DontWriteBytecodeFlag\n",
    "GetProcAddress",
    "Py_FileSystemDefaultEncoding",
    "Failed to get address for Py_FileSystemDefaultEncoding\n",
    "Py_FrozenFlag",
    "Failed to get address for Py_FrozenFlag\n",
    "Py_IgnoreEnvironmentFlag",
    "Failed to get address for Py_IgnoreEnvironmentFlag\n",
    "Py_NoSiteFlag",
    "Failed to get address for Py_NoSiteFlag\n",
    "Py_NoUserSiteDirectory",
    "Failed to get address for Py_NoUserSiteDirectory\n",
    "Py_OptimizeFlag",
    "Failed to get address for Py_OptimizeFlag\n",
    "Py_VerboseFlag",
    "Failed to get address for Py_VerboseFlag\n",
    "Py_BuildValue",
    "Failed to get address for Py_BuildValue\n",
    "Py_DecRef",
    "Failed to get address for Py_DecRef\n",
    "Py_Finalize",
    "Failed to get address for Py_Finalize\n",
    "Py_IncRef",
    "Failed to get address for Py_IncRef\n",
    "Py_Initialize",
    "Failed to get address for Py_Initialize\n",
    "Py_SetPath",
    "Failed to get address for Py_SetPath\n",
    "Py_GetPath",
    "Failed to get address for Py_GetPath\n",
    "Py_SetProgramName",
    "Failed to get address for Py_SetProgramName\n",
    "Py_SetPythonHome",
    "Failed to get address for Py_SetPythonHome\n",
    "PyDict_GetItemString",
    "Failed to get address for PyDict_GetItemString\n",
    "PyErr_Clear",
    "Failed to get address for PyErr_Clear\n",
    "PyErr_Occurred",
    "Failed to get address for PyErr_Occurred\n",
    "PyErr_Print",
    "Failed to get address for PyErr_Print\n",
    "PyImport_AddModule",
    "Failed to get address for PyImport_AddModule\n",
    "PyImport_ExecCodeModule",
    "Failed to get address for PyImport_ExecCodeModule\n",
    "PyImport_ImportModule",
    "Failed to get address for PyImport_ImportModule\n",
    "PyList_Append",
    "Failed to get address for PyList_Append\n",
    "PyList_New",
    "Failed to get address for PyList_New\n",
    "PyLong_AsLong",
    "Failed to get address for PyLong_AsLong\n",
    "PyModule_GetDict",
    "Failed to get address for PyModule_GetDict\n",
    "PyObject_CallFunction",
    "Failed to get address for PyObject_CallFunction\n",
    "PyObject_SetAttrString",
    "Failed to get address for PyObject_SetAttrString\n",
    "PyRun_SimpleString",
    "Failed to get address for PyRun_SimpleString\n",
    "PyString_FromString",
    "Failed to get address for PyString_FromString\n",
    "PyString_FromFormat",
    "Failed to get address for PyString_FromFormat\n",
    "PySys_AddWarnOption",
    "Failed to get address for PySys_AddWarnOption\n",
    "PySys_SetArgvEx",
    "Failed to get address for PySys_SetArgvEx\n",
    "PySys_GetObject",
    "Failed to get address for PySys_GetObject\n",
    "PySys_SetObject",
    "Failed to get address for PySys_SetObject\n",
    "PySys_SetPath",
    "Failed to get address for PySys_SetPath\n",
    "PyEval_EvalCode",
    "Failed to get address for PyEval_EvalCode\n",
    "PyMarshal_ReadObjectFromString",
    "Failed to get address for PyMarshal_ReadObjectFromString\n",
    "PyUnicode_FromString",
    "Failed to get address for PyUnicode_FromString\n",
    "Py_DecodeLocale",
    "Failed to get address for Py_DecodeLocale\n",
    "_Py_char2wchar",
    "Failed to get address for _Py_char2wchar\n",
    "PyUnicode_FromFormat",
    "Failed to get address for PyUnicode_FromFormat\n",
    "PyUnicode_Decode",
    "Failed to get address for PyUnicode_Decode\n",
    "PyUnicode_DecodeFSDefault",
    "Failed to get address for PyUnicode_DecodeFSDefault\n",
    "LOADER: Loaded functions from Python library.\n",
    "DLL name length exceeds buffer\n",
    "ucrtbase.dll",
    "LOADER: ucrtbase.dll is exists: %s\n",
    "LOADER: Python library: %s\n",
    "Error loading Python DLL '%s'.\n",
    "LoadLibrary",
    "pyi-",
    "LOADER: Bootloader option: %s\n",
    "LOADER: Runtime option: %s\n",
    "Failed to convert Wflag %s using mbstowcs (invalid multibyte string)\n",
    "LOADER: Setting sys.argv\n",
    "Failed to convert argv to mbcs\n",
    "Failed to convert argv to wchar_t\n",
    "Failed to convert progname to wchar_t\n",
    "LOADER: Manipulating environment (sys.path, sys.prefix)\n",
    "Failed to convert pyhome to ANSI (invalid multibyte string)\n",
    "LOADER: sys.prefix is %s\n",
    "Failed to convert pyhome to wchar_t\n",
    "base_library.zip",
    "Failed to convert pypath to wchar_t\n",
    "LOADER: Pre-init sys.path is %s\n",
    "LOADER: Setting runtime options\n",
    "LOADER: Initializing python\n",
    "LOADER: Overriding Python's sys.path\n",
    "LOADER: Post-init sys.path is %s\n",
    "Failed to convert pypath to ANSI (invalid multibyte string)\n",
    "Error detected starting Python VM.",
    "LOADER: setting sys._MEIPASS\n",
    "Failed to encode _MEIPASS as ANSI.\n",
    "strict",
    "utf-8",
    "Failed to get _MEIPASS as PyObject.\n",
    "_MEIPASS",
    "LOADER: importing modules from CArchive\n",
    "marshal",
    "loads",
    "LOADER: extracted %s\n",
    "LOADER: callfunction returned...\n",
    "LOADER: callfunction returned NULL",
    "mod is NULL - %s",
    "Failed to convert %s to ShortFileName\n",
    "%s?%d",
    "%U?%d",
    "path",
    "Installing PYZ: Could not get sys.path\n",
    "Failed to append to sys.path\n",
    "LOADER: Installing PYZ archive with Python modules.\n",
    "LOADER: PYZ archive: %s\n",
    "LOADER: Cleaning up Python interpreter.\n",
    "P_MEI%d",
    "pyi-runtime-tmpdir",
    "LOADER: Found runtime-tmpdir %s\n",
    "INTERNAL ERROR: cannot create temporary directory!\n",
    "WARNING: file already exists but should not: %s\n",
    "LOADER: Setting up to run child\n",
    "LOADER: Creating child process\n",
    "LOADER: Waiting for child process to finish...\n",
    "Error creating child process!\n",
    "CreateProcessW",
    "No error messages generated.\n",
    "FormatMessageW",
    "PyInstaller: FormatMessageW failed.",
    "PyInstaller: pyi_win32_utils_to_utf8 failed.",
    "LOADER: manifestpath: %s\n",
    "kernel32",
    "CreateActCtxW",
    "ActivateActCtx",
    "LOADER: Cannot find CreateActCtx/ActivateActCtx exports in kernel32.dll\n",
    "LOADER: Activation context created\n",
    "LOADER: Activation context activated\n",
    "LOADER: Error activating the context: ActivateActCtx: \n%s\n",
    "Failed to get ANSI buffer size.\n",
    "WideCharToMultiByte",
    "Failed to encode filename as ANSI.\n",
    "Failed to get short path name for filename. GetShortPathNameW: \n%s\n",
    "Failed to get UTF-8 buffer size.\n",
    "Failed to encode wchar_t as UTF-8.\n",
    "Failed to get wchar_t buffer size.\n",
    "MultiByteToWideChar",
    "Failed to decode wchar_t from UTF-8\n",
    "D:(A;;FA;;;S-1-3-4)",
    "incorrect header check",
    "unknown compression method",
    "invalid window size",
    "unknown header flags set",
    "header crc mismatch",
    "invalid block type",
    "invalid stored block lengths",
    "too many length or distance symbols",
    "invalid code lengths set",
    "invalid bit length repeat",
    "invalid code -- missing end-of-block",
    "invalid literal/lengths set",
    "invalid distances set",
    "invalid literal/length code",
    "invalid distance code",
    "invalid distance too far back",
    "incorrect data check",
    "incorrect length check",
    " n;^",
    "Qkkbal",
    "3_L\n",
    ">jm\r",
    "i]Wb",
    "9a&g",
    "MGiI",
    "wn>Jj",
    "#.zf",
    "+o*7",
    "Z* ,\t",
    "H$6t",
    "52F*",
    "\t#jT$",
    "\n=G\\",
    "^6o}",
    "[-&LMb#{'",
    ")q\n>(",
    "w+OQvr",
    "\r}!b",
    "R1h58",
    "SKyu",
    ")\\ZEo^m/",
    "ru&o",
    "i8P/",
    "?(3w",
    "wXR\r",
    "H*0\"ZOW",
    "{kHw",
    ")T`D",
    "!AxU",
    "l!;b\tF",
    ":1X:",
    "y9*O",
    "kM`~",
    "Vc0a",
    "dQy/",
    "lDa>",
    "7~8A",
    "C-Yn",
    "gqr<",
    "$/o|",
    "f-=v",
    "\rmj>zjZ",
    "l6qnk",
    "IiGM>nw",
    "1A26b",
    "i91k",
    "ewh/?y",
    "*5KS",
    "6~_'",
    "F*.f",
    "1wsHp",
    "M8MF",
    "Pe6^",
    "#bML\"",
    "`F(>\nq-q",
    "vQO+t",
    "[h1R",
    "XsBI",
    "hPU3",
    "^oEZ_",
    "2%k_",
    "w3Xc",
    "[\n;g",
    "/P8i",
    "OZw3(?",
    "Z\"0*",
    "fP~V",
    "^GP~",
    "b;!l",
    "V_:X1:",
    "NJ2\"v",
    "O*9y]",
    "fu`z",
    "/yQA",
    "&]|v",
    "need dictionary",
    "stream end",
    "file error",
    "stream error",
    "data error",
    "insufficient memory",
    "buffer error",
    "incompatible version",
    " inflate 1.2.11 Copyright 1995-2017 Mark Adler ",
    "#+3;CScs",
    "!1Aa",
    "Badvapi32",
    "api-ms-win-core-fibers-l1-1-1",
    "api-ms-win-core-synch-l1-2-0",
    "kernel32",
    "FlsAlloc",
    "FlsFree",
    "FlsGetValue",
    "FlsSetValue",
    "InitializeCriticalSectionEx",
    "__based(",
    "__cdecl",
    "__pascal",
    "__stdcall",
    "__thiscall",
    "__fastcall",
    "__vectorcall",
    "__clrcall",
    "__eabi",
    "__ptr64",
    "__restrict",
    "__unaligned",
    "restrict(",
    " new",
    " delete",
    "operator",
    "`vftable'",
    "`vbtable'",
    "`vcall'",
    "`typeof'",
    "`local static guard'",
    "`string'",
    "`vbase destructor'",
    "`vector deleting destructor'",
    "`default constructor closure'",
    "`scalar deleting destructor'",
    "`vector constructor iterator'",
    "`vector destructor iterator'",
    "`vector vbase constructor iterator'",
    "`virtual displacement map'",
    "`eh vector constructor iterator'",
    "`eh vector destructor iterator'",
    "`eh vector vbase constructor iterator'",
    "`copy constructor closure'",
    "`udt returning'",
    "`RTTI",
    "`local vftable'",
    "`local vftable constructor closure'",
    " new[]",
    " delete[]",
    "`omni callsig'",
    "`placement delete closure'",
    "`placement delete[] closure'",
    "`managed vector constructor iterator'",
    "`managed vector destructor iterator'",
    "`eh vector copy constructor iterator'",
    "`eh vector vbase copy constructor iterator'",
    "`dynamic initializer for '",
    "`dynamic atexit destructor for '",
    "`vector copy constructor iterator'",
    "`vector vbase copy constructor iterator'",
    "`managed vector copy constructor iterator'",
    "`local static thread guard'",
    "operator \"\" ",
    " Type Descriptor'",
    " Base Class Descriptor at (",
    " Base Class Array'",
    " Class Hierarchy Descriptor'",
    " Complete Object Locator'",
    "( 8PX",
    "700WP",
    "`h````",
    "xpxxxx",
    "(null)",
    "(null)",
    ".exe",
    ".cmd",
    ".bat",
    ".com",
    "mscoree.dll",
    "CorExitProcess",
    "R\rS\rW",
    "l\rm p",
    "Bapi-ms-win-appmodel-runtime-l1-1-1",
    "api-ms-win-core-datetime-l1-1-1",
    "api-ms-win-core-file-l2-1-1",
    "api-ms-win-core-localization-l1-2-1",
    "api-ms-win-core-localization-obsolete-l1-2-0",
    "api-ms-win-core-processthreads-l1-1-2",
    "api-ms-win-core-string-l1-1-0",
    "api-ms-win-core-sysinfo-l1-2-1",
    "api-ms-win-core-winrt-l1-1-0",
    "api-ms-win-core-xstate-l2-1-0",
    "api-ms-win-rtcore-ntuser-window-l1-1-0",
    "api-ms-win-security-systemfunctions-l1-1-0",
    "ext-ms-win-kernel32-package-current-l1-1-0",
    "ext-ms-win-ntuser-dialogbox-l1-1-0",
    "ext-ms-win-ntuser-windowstation-l1-1-0",
    "user32",
    "AreFileApisANSI",
    "CompareStringEx",
    "GetCurrentPackageId",
    "GetFileInformationByHandleEx",
    "LCMapStringEx",
    "LocaleNameToLCID",
    "No error",
    "Operation not permitted",
    "No such file or directory",
    "No such process",
    "Interrupted function call",
    "Input/output error",
    "No such device or address",
    "Arg list too long",
    "Exec format error",
    "Bad file descriptor",
    "No child processes",
    "Resource temporarily unavailable",
    "Not enough space",
    "Permission denied",
    "Bad address",
    "Unknown error",
    "Resource device",
    "File exists",
    "Improper link",
    "No such device",
    "Not a directory",
    "Is a directory",
    "Invalid argument",
    "Too many open files in system",
    "Too many open files",
    "Inappropriate I/O control operation",
    "File too large",
    "No space left on device",
    "Invalid seek",
    "Read-only file system",
    "Too many links",
    "Broken pipe",
    "Domain error",
    "Result too large",
    "Resource deadlock avoided",
    "Filename too long",
    "No locks available",
    "Function not implemented",
    "Directory not empty",
    "Illegal byte sequence",
    "NAN(SNAN)",
    "nan(snan)",
    "NAN(IND)",
    "nan(ind)",
    "e+000",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "January",
    "February",
    "March",
    "April",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
    "MM/dd/yy",
    "dddd, MMMM dd, yyyy",
    "HH:mm:ss",
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "January",
    "February",
    "March",
    "April",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
    "MM/dd/yy",
    "dddd, MMMM dd, yyyy",
    "HH:mm:ss",
    "en-US",
    "Bccs",
    "UTF-8",
    "UTF-16LEUNICODE",
    "Bja-JP",
    "zh-CN",
    "ko-KR",
    "zh-TW",
    "         (((((                  H",
    "      (                          ",
    "         (((((                  H",
    " !\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
    " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~",
    "zh-CHS",
    "ar-SA",
    "bg-BG",
    "ca-ES",
    "cs-CZ",
    "da-DK",
    "de-DE",
    "el-GR",
    "fi-FI",
    "fr-FR",
    "he-IL",
    "hu-HU",
    "is-IS",
    "it-IT",
    "nl-NL",
    "nb-NO",
    "pl-PL",
    "pt-BR",
    "ro-RO",
    "ru-RU",
    "hr-HR",
    "sk-SK",
    "sq-AL",
    "sv-SE",
    "th-TH",
    "tr-TR",
    "ur-PK",
    "id-ID",
    "uk-UA",
    "be-BY",
    "sl-SI",
    "et-EE",
    "lv-LV",
    "lt-LT",
    "fa-IR",
    "vi-VN",
    "hy-AM",
    "az-AZ-Latn",
    "eu-ES",
    "mk-MK",
    "tn-ZA",
    "xh-ZA",
    "zu-ZA",
    "af-ZA",
    "ka-GE",
    "fo-FO",
    "hi-IN",
    "mt-MT",
    "se-NO",
    "ms-MY",
    "kk-KZ",
    "ky-KG",
    "sw-KE",
    "uz-UZ-Latn",
    "tt-RU",
    "bn-IN",
    "pa-IN",
    "gu-IN",
    "ta-IN",
    "te-IN",
    "kn-IN",
    "ml-IN",
    "mr-IN",
    "sa-IN",
    "mn-MN",
    "cy-GB",
    "gl-ES",
    "kok-IN",
    "syr-SY",
    "div-MV",
    "quz-BO",
    "ns-ZA",
    "mi-NZ",
    "ar-IQ",
    "de-CH",
    "en-GB",
    "es-MX",
    "fr-BE",
    "it-CH",
    "nl-BE",
    "nn-NO",
    "pt-PT",
    "sr-SP-Latn",
    "sv-FI",
    "az-AZ-Cyrl",
    "se-SE",
    "ms-BN",
    "uz-UZ-Cyrl",
    "quz-EC",
    "ar-EG",
    "zh-HK",
    "de-AT",
    "en-AU",
    "es-ES",
    "fr-CA",
    "sr-SP-Cyrl",
    "se-FI",
    "quz-PE",
    "ar-LY",
    "zh-SG",
    "de-LU",
    "en-CA",
    "es-GT",
    "fr-CH",
    "hr-BA",
    "smj-NO",
    "ar-DZ",
    "zh-MO",
    "de-LI",
    "en-NZ",
    "es-CR",
    "fr-LU",
    "bs-BA-Latn",
    "smj-SE",
    "ar-MA",
    "en-IE",
    "es-PA",
    "fr-MC",
    "sr-BA-Latn",
    "sma-NO",
    "ar-TN",
    "en-ZA",
    "es-DO",
    "sr-BA-Cyrl",
    "sma-SE",
    "ar-OM",
    "en-JM",
    "es-VE",
    "sms-FI",
    "ar-YE",
    "en-CB",
    "es-CO",
    "smn-FI",
    "ar-SY",
    "en-BZ",
    "es-PE",
    "ar-JO",
    "en-TT",
    "es-AR",
    "ar-LB",
    "en-ZW",
    "es-EC",
    "ar-KW",
    "en-PH",
    "es-CL",
    "ar-AE",
    "es-UY",
    "ar-BH",
    "es-PY",
    "ar-QA",
    "es-BO",
    "es-SV",
    "es-HN",
    "es-NI",
    "es-PR",
    "zh-CHT",
    "af-za",
    "ar-ae",
    "ar-bh",
    "ar-dz",
    "ar-eg",
    "ar-iq",
    "ar-jo",
    "ar-kw",
    "ar-lb",
    "ar-ly",
    "ar-ma",
    "ar-om",
    "ar-qa",
    "ar-sa",
    "ar-sy",
    "ar-tn",
    "ar-ye",
    "az-az-cyrl",
    "az-az-latn",
    "be-by",
    "bg-bg",
    "bn-in",
    "bs-ba-latn",
    "ca-es",
    "cs-cz",
    "cy-gb",
    "da-dk",
    "de-at",
    "de-ch",
    "de-de",
    "de-li",
    "de-lu",
    "div-mv",
    "el-gr",
    "en-au",
    "en-bz",
    "en-ca",
    "en-cb",
    "en-gb",
    "en-ie",
    "en-jm",
    "en-nz",
    "en-ph",
    "en-tt",
    "en-us",
    "en-za",
    "en-zw",
    "es-ar",
    "es-bo",
    "es-cl",
    "es-co",
    "es-cr",
    "es-do",
    "es-ec",
    "es-es",
    "es-gt",
    "es-hn",
    "es-mx",
    "es-ni",
    "es-pa",
    "es-pe",
    "es-pr",
    "es-py",
    "es-sv",
    "es-uy",
    "es-ve",
    "et-ee",
    "eu-es",
    "fa-ir",
    "fi-fi",
    "fo-fo",
    "fr-be",
    "fr-ca",
    "fr-ch",
    "fr-fr",
    "fr-lu",
    "fr-mc",
    "gl-es",
    "gu-in",
    "he-il",
    "hi-in",
    "hr-ba",
    "hr-hr",
    "hu-hu",
    "hy-am",
    "id-id",
    "is-is",
    "it-ch",
    "it-it",
    "ja-jp",
    "ka-ge",
    "kk-kz",
    "kn-in",
    "kok-in",
    "ko-kr",
    "ky-kg",
    "lt-lt",
    "lv-lv",
    "mi-nz",
    "mk-mk",
    "ml-in",
    "mn-mn",
    "mr-in",
    "ms-bn",
    "ms-my",
    "mt-mt",
    "nb-no",
    "nl-be",
    "nl-nl",
    "nn-no",
    "ns-za",
    "pa-in",
    "pl-pl",
    "pt-br",
    "pt-pt",
    "quz-bo",
    "quz-ec",
    "quz-pe",
    "ro-ro",
    "ru-ru",
    "sa-in",
    "se-fi",
    "se-no",
    "se-se",
    "sk-sk",
    "sl-si",
    "sma-no",
    "sma-se",
    "smj-no",
    "smj-se",
    "smn-fi",
    "sms-fi",
    "sq-al",
    "sr-ba-cyrl",
    "sr-ba-latn",
    "sr-sp-cyrl",
    "sr-sp-latn",
    "sv-fi",
    "sv-se",
    "sw-ke",
    "syr-sy",
    "ta-in",
    "te-in",
    "th-th",
    "tn-za",
    "tr-tr",
    "tt-ru",
    "uk-ua",
    "ur-pk",
    "uz-uz-cyrl",
    "uz-uz-latn",
    "vi-vn",
    "xh-za",
    "zh-chs",
    "zh-cht",
    "zh-cn",
    "zh-hk",
    "zh-mo",
    "zh-sg",
    "zh-tw",
    "zu-za",
    "d8L2",
    "[aOni*{",
    "@2&@",
    "\"RP(",
    "eLK(w",
    "m\nXo",
    "FEMh",
    "h0'D",
    "owM&",
    "~ $s%r",
    "@b;zO]",
    "$qE}",
    ";*xh",
    "[\"93",
    "iu+-,",
    "\\lo}",
    "obwQ4",
    "&Sgw",
    "R\tE]",
    "?nz(",
    "=87M",
    "v2!L.2",
    "\tcQr",
    "X/4B",
    "k=yI",
    "^<V7w",
    "W&|.",
    "1#INF",
    "1#QNAN",
    "1#SNAN",
    "1#IND",
    "CONOUT$",
    "log10",
    "lzZ?",
    "log10",
    "asin",
    "acos",
    "sqrt",
    "\tk8=",
    "?5Wg4p",
    "Nv$^",
    "w(@\t",
    "BC .=",
    "(lX ",
    "#{ =",
    "`~R=",
    "}s\"=",
    "\tE[\n",
    "%S#[k",
    "\"B <1=",
    "\\-!y",
    "#.X'=",
    "i9+=",
    "?tanh",
    "atan",
    "atan2",
    "ceil",
    "floor",
    "fabs",
    "modf",
    "ldexp",
    "_cabs",
    "_hypot",
    "fmod",
    "frexp",
    "_logb",
    "_nextafter",
    "sinh",
    "cosh",
    ".text$mn",
    ".idata$5",
    ".00cfg",
    ".CRT$XCA",
    ".CRT$XCAA",
    ".CRT$XCZ",
    ".CRT$XIA",
    ".CRT$XIAA",
    ".CRT$XIAC",
    ".CRT$XIC",
    ".CRT$XIZ",
    ".CRT$XPA",
    ".CRT$XPX",
    ".CRT$XPXA",
    ".CRT$XPZ",
    ".CRT$XTA",
    ".CRT$XTZ",
    ".rdata",
    ".rdata$sxdata",
    ".rdata$zzzdbg",
    ".rtc$IAA",
    ".rtc$IZZ",
    ".rtc$TAA",
    ".rtc$TZZ",
    ".xdata$x",
    ".idata$2",
    ".idata$3",
    ".idata$4",
    ".idata$6",
    ".data",
    ".bss",
    ".gfids$x",
    ".gfids$y",
    ".rsrc$01",
    ".rsrc$02",
    "GetLastError",
    "SetDllDirectoryW",
    "GetModuleFileNameW",
    "GetProcAddress",
    "SetErrorMode",
    "GetCommandLineW",
    "GetEnvironmentVariableW",
    "SetEnvironmentVariableW",
    "ExpandEnvironmentStringsW",
    "GetTempPathW",
    "WaitForSingleObject",
    "Sleep",
    "GetExitCodeProcess",
    "CreateProcessW",
    "GetStartupInfoW",
    "LoadLibraryExW",
    "CreateDirectoryW",
    "GetShortPathNameW",
    "FormatMessageW",
    "LoadLibraryA",
    "MultiByteToWideChar",
    "WideCharToMultiByte",
    "KERNEL32.dll",
    "ConvertStringSecurityDescriptorToSecurityDescriptorW",
    "ADVAPI32.dll",
    "WS2_32.dll",
    "UnhandledExceptionFilter",
    "SetUnhandledExceptionFilter",
    "GetCurrentProcess",
    "TerminateProcess",
    "IsProcessorFeaturePresent",
    "QueryPerformanceCounter",
    "GetCurrentProcessId",
    "GetCurrentThreadId",
    "GetSystemTimeAsFileTime",
    "InitializeSListHead",
    "IsDebuggerPresent",
    "GetModuleHandleW",
    "RtlUnwind",
    "SetLastError",
    "EnterCriticalSection",
    "LeaveCriticalSection",
    "DeleteCriticalSection",
    "InitializeCriticalSectionAndSpinCount",
    "TlsAlloc",
    "TlsGetValue",
    "TlsSetValue",
    "TlsFree",
    "FreeLibrary",
    "GetCommandLineA",
    "ReadFile",
    "CreateFileW",
    "GetDriveTypeW",
    "GetFileType",
    "CloseHandle",
    "PeekNamedPipe",
    "SystemTimeToTzSpecificLocalTime",
    "FileTimeToSystemTime",
    "GetFullPathNameW",
    "GetFullPathNameA",
    "RemoveDirectoryW",
    "FindClose",
    "FindFirstFileExW",
    "FindNextFileW",
    "SetStdHandle",
    "SetConsoleCtrlHandler",
    "DeleteFileW",
    "GetStdHandle",
    "WriteFile",
    "ExitProcess",
    "GetModuleHandleExW",
    "GetACP",
    "HeapFree",
    "HeapAlloc",
    "GetConsoleMode",
    "ReadConsoleW",
    "SetFilePointerEx",
    "GetConsoleCP",
    "CompareStringW",
    "LCMapStringW",
    "GetCurrentDirectoryW",
    "FlushFileBuffers",
    "SetEnvironmentVariableA",
    "GetFileAttributesExW",
    "IsValidCodePage",
    "GetOEMCP",
    "GetCPInfo",
    "GetEnvironmentStringsW",
    "FreeEnvironmentStringsW",
    "GetStringTypeW",
    "GetProcessHeap",
    "WriteConsoleW",
    "GetTimeZoneInformation",
    "HeapSize",
    "HeapReAlloc",
    "SetEndOfFile",
    "DecodePointer",
    "RaiseException",
    "                          ",
    "abcdefghijklmnopqrstuvwxyz",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "                          ",
    "abcdefghijklmnopqrstuvwxyz",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "Es4\nY",
    "P)TS)235",
    "QOONNNNOQR",
    "TVV]^^^7",
    "RQQR",
    "TVV]^^^bI",
    "VV]^^^bb",
    "V]]^bbbh",
    "]^^^bbbh",
    "f^^^bbhhh",
    "Y^bbbbhhh",
    "Uabbbhhkg",
    "Ubbbhhkke",
    "]bbhhhskd",
    "bbhhkkllG",
    "bhhkksluI",
    "hhkklkuuI",
    "hkkkluu",
    "hklluuuu",
    "ikk4*.3cz",
    "&*06e",
    "&*06e",
    "#*16i",
    "H-Z_",
    ">BB@",
    ":7669",
    "=>ABCF",
    "<ABCGL",
    ">BCGHK",
    "BCGHPd",
    "CGHPUe",
    "GHPQUk",
    "HPQUW{",
    "PQWWX|",
    "zQWW_afk{",
    "TU$\"IVqttwyyyvihm",
    " %Ms",
    "!JRt",
    "/ P6pL",
    ",/KPip",
    "/-P?pR",
    "('7ffe",
    "5puvwxwu:>s",
    "6opuvwxy1.0=",
    "cnopuvww,00r",
    "\"dmnopuvp.00",
    " &)49ghkj00/",
    "AGLC\n",
    "FS^_YB",
    "JWbb`I",
    "JW\\bbM",
    "JW[bb_HP",
    "tJX\\bbb",
    "qJW\\Z]XQ",
    "<JWbaD",
    "NU`^E",
    "PNG\r\n",
    "\rIHDR",
    "bIDATx",
    "BHH!",
    "bB5`",
    "3[ggg",
    "OV|>\t~",
    "_Brr",
    "Djr<RR",
    "2ZZe45",
    "NBfF",
    "3gjPF",
    "JNTa",
    "S8YR\rb=",
    "Yq$O",
    "nd[7E",
    "RPDk",
    "JUaUl=",
    "A2%$ ",
    "kh\r5",
    "wUJiU",
    "LX{s",
    "Y+kZ",
    "8\\9.",
    ";QSb",
    "=zwM",
    "Qix2",
    "}YP)",
    "*vt1;",
    "UU\n`d3",
    "hpF*yI",
    "}YSZ",
    "\\QL7",
    "h8=Vn",
    "=YU`",
    "nbJn",
    "n|6zvI",
    "K\r% P",
    "PG`4",
    "m]y*",
    "e(vK",
    "=7/>^",
    "MKrZrS",
    "V[_`",
    "_R^Xh",
    "%!=o",
    ";;2}",
    "\"Zol",
    "JXpE",
    "C+?;",
    "#?eL:",
    "aQTQ",
    "-9(|",
    "\tGJc",
    "p)J -",
    "(e|0",
    ",5\n0$",
    "T\tj>",
    "SSCY",
    "Sfl}Yc",
    "ddf`",
    ";*mbM)(",
    "=\\/`",
    "%tm\t",
    ";*mv-)(",
    "_rP~#",
    "hkm%",
    "p\tK|f7",
    "u'&`x",
    "!,8TL",
    "34oO$",
    "|@6k",
    "$8E[t",
    "NL $",
    "^cUtA",
    "ae .",
    "c;\"]b",
    "Hj-@",
    "^=B\\A",
    "hinA}M",
    "gU&K7",
    "G;]N",
    "(~CC",
    "HRPV\r",
    "-yE]8",
    "m&E?",
    "lojl!S3",
    "kB}-",
    ",[\rM",
    "S3pt",
    "u$w.",
    "MGFN*2",
    "n$&{",
    "_Ff:&O",
    "]WK9",
    "Q4R~M",
    "Y(k(+",
    "JK\tkiQ",
    "G;MN&@",
    "&VX~]",
    "r#a\n'OT",
    "e;uP~",
    "{1  ",
    ",\tAB",
    "o@S}3",
    "Q$>d",
    "CEy=6",
    "=v8z",
    "rmm#V,;",
    "%Y4C==",
    "(Fjf\n",
    "1?y\r",
    "{O!!G",
    "\"')(",
    "efe`",
    "0u8)9",
    "E3=n",
    ">xc-",
    "]\"B@",
    "V&Pr",
    "fLDJJ",
    "YYJ5",
    "B`z81\r7",
    "uW%J",
    "}KO<",
    "Y-&T",
    "O^\"&W",
    "\t|qA",
    "9' c\nH",
    "W&a@",
    "%sW*}",
    "kbXe",
    "V6|=",
    "WNA|\\",
    "{M\ru",
    "@TZaxa",
    "ooa!",
    "A-@{",
    "-B]U%",
    "\"A-@8",
    "fpP1",
    "XT;p|",
    "  +5",
    "-+p  ",
    "QcG //",
    "m474",
    "\\0qs",
    "bR;;",
    "Jy{_",
    " \"s_Nf@G",
    "_YVj",
    "$J6m",
    "<...",
    "ljhn",
    "ubw_",
    "DbCY",
    "4ph{",
    "5:p(",
    "`0>0y",
    "pfeG",
    "a5\r.]",
    "&:NX",
    " {x`/",
    "l#H0",
    "G}xp7",
    ")y}-",
    "V9lKMK",
    "2h4 uTP",
    "vJff&",
    "m_&kGU",
    "ZG~/",
    "HMKV6)",
    "B?@'",
    "*[GJbV7L",
    "\t`fW1",
    "tu<6",
    "gU|)",
    "5k.h:'",
    "DJ.j",
    "d,$vrrr",
    "d-pt",
    "' 9V",
    "Q)/-",
    "iFAQ\tQ",
    "Q|AU",
    "m$\nWX8a,RRT",
    "x{D_",
    "L$hlh",
    "[)E\n",
    "r$J9",
    " I9=1",
    "RP00",
    "80`K~",
    ".dy,",
    "_th/",
    "`f.b",
    "Ledi",
    "GyHu",
    "{<!)",
    ">9BG",
    "}#N%",
    "rk+^}e'",
    "TWVa",
    "0(($",
    "9=4g",
    "K)<Uf",
    "~wsCC]",
    "##K\r",
    "ollTz",
    "@c}}3",
    ".TW7",
    "7)((P",
    "X&=8",
    "@ AM",
    "hq\n2",
    "(\n/q",
    "%?=[",
    "Z0cl6",
    "\\nll",
    "'`0:",
    "PS@2",
    "{EA{",
    "\\I.2",
    "$se\r",
    "xMa}VF",
    "@0QUf",
    ")ziM",
    "318?",
    "vIS7M",
    "JAA$t",
    "ShjjE)",
    "teJL3mlu",
    "rx%'/",
    "'P|J",
    ":!%S",
    "omWX",
    "aUZf:",
    "37c@@ni",
    "1@JPm",
    "@fzP",
    "xEg_",
    "\".1E",
    "i!\rw*",
    "s@fk",
    "4RPL",
    "68Qll",
    "#XdN",
    "Gs%~",
    "sxIp/",
    "N@vf",
    "H@jj<",
    "\\S[XU",
    "g+ee^",
    "wM' ",
    "mhllE}C",
    "u-hin",
    "3_\\<",
    "\r0~\n",
    "3?kw",
    "l6\"{",
    "IjlV",
    "fsCe)v",
    "E$7E",
    "=e!JT",
    "%8Ur",
    "L@T>5V",
    "WZz$W",
    "[^gk",
    "wWbJ",
    "9`j5",
    " <H4",
    "6jkk",
    "UvV}",
    "eUiYen",
    "t;Q~",
    "NMMU&}",
    "/'''+",
    "pp7)",
    "IUl]",
    "Q,o^",
    "7\th4o",
    "T\"ZBW",
    ",-oi ",
    "Mlpbc",
    "9e=u*",
    "cXbSS3",
    "*-kg",
    "mL@e",
    "l)Ni8",
    "m'1GZA",
    "|TWd",
    "RKmj",
    "Dee%",
    "pIZV",
    "GII\t",
    "yLfA@",
    "}']}",
    "P_!|A",
    "fKk}Y_",
    "d1!X",
    "=+9v",
    "(ngU",
    "vni]wR<[",
    "^RU\t",
    "xMK8",
    "_G\\O",
    "Dre[[",
    "{wM8",
    "BHBHB",
    "dDUWe",
    "3_f)",
    "{<?U",
    "\n(4>",
    ".#L ",
    "k!zj",
    "` HVBz",
    "@_?f",
    "0?~jM\t",
    "i3%?",
    ")uv_C",
    "\t\\Rx",
    "k>9oJW",
    "(4i_\n>",
    "O%af",
    "\\rIh",
    "'0[\n:Q,",
    "BM@!",
    "!NL@",
    "\"Bwa",
    "|HN]",
    "ko'?SH+",
    "W^C.",
    "^*3o",
    "!\\D[u(&",
    "g2^}y",
    "u3L\r",
    ":~9rQL:",
    "Bq 8",
    "w*_L",
    "/rQXh",
    "w ~b",
    "JWWP",
    "Yvg!",
    "]UXw$",
    "Mz+v",
    "l'x\nF=y",
    "ieY& 2",
    "l~_L",
    "Y=QA",
    "\tPgG3",
    "@9a\\",
    "\nJY\r",
    "j4`)",
    "&  @",
    "@[7\n_",
    "&!ra",
    "vhhh",
    "B$yX",
    "9<lG",
    "s*_L",
    "Ug!8",
    "V73[~Y",
    "%N q|+$",
    "J$R5",
    "U{GM",
    "A-\"5H",
    "Rhll",
    "/c/A8",
    ".hbZ",
    "odUm",
    "Z^^N=/",
    "yI\r!",
    "G``H",
    "&9@[A",
    "hy.q",
    "Y\tTS",
    "\rW]u",
    "<;_$?",
    "pmnh",
    "39U]",
    "N]\n7uta4",
    "W\\aA",
    "1&`IZ",
    "b4`|",
    "2hnn",
    "z&S_",
    "keh<",
    "(twwC,",
    "\"%'s",
    "n!'5E",
    ".Y' ",
    "yr~3UU\tM",
    "w/$/",
    "W]n8",
    "SJ4Z;",
    "R0G|",
    "%K R",
    "3BHl",
    "b/\"rNR",
    "z|X??\r/t",
    "]/@2",
    "HE:91",
    "S}aI",
    "\rg y",
    "9?]VW",
    " 9pLu",
    "@OO/$",
    "ozP&",
    ";H~o",
    "\nr~5YU\t",
    "yW-=G*?N`",
    "DB>F]",
    "{$^$",
    ",r*6",
    "jhd(",
    "qA=n",
    "p@&`",
    "k7\r4/",
    "cH=6<>",
    "1xMXZ",
    "n\rf/#/]",
    "n``@%b",
    "$Z$f",
    "3#\t4",
    "$l$ZCR",
    "_$j|",
    "\rbGiM",
    "T!<W",
    "\"L`3,\\",
    ">C${",
    "D(z1",
    "z~54",
    "e^K*",
    "GPWW",
    ")Y'l",
    "#rj3",
    "D*^^",
    ":iCN>",
    " ;@~",
    "\\6C*S",
    "6u6L",
    "N3r=",
    "iLBO",
    "y\tX'?",
    "+\r\n!&",
    "!N]G",
    " OPN0a",
    "JX0A`",
    "O{?%",
    "IEND",
    "|voib\\TNF@82)#",
    "e\n\n\nJ",
    "r@\r}e2",
    "m^tk",
    "q>\ts",
    "n=\nl",
    "3.*'#",
    ">2)!",
    "tB\nb",
    "wC\tT",
    "///|",
    "f-ae2",
    "[\"Hh5",
    "X#N.",
    "a,h/",
    "T ,\"",
    "2N2b2",
    "6Q6V6",
    "9*:9:F:Y:w:",
    ";7;\\;n;{;",
    ">O?t?",
    "141D1",
    "202D2",
    "2!3L3n3",
    "4'4,4",
    "4&5w5",
    "8.878<8y8",
    ":&:H;M;U;^;c;v;~;",
    "<\"<+<0<C<K<T<Y<l<t<}<",
    "=!=&=9=A=J=O=l=t=}=",
    ">)>1>:>D>L>U>_>g>p>z>",
    "?$?-?7???H?W?_?h?r?z?",
    "0%0/070@0S0[0d0s0{0",
    "1\"121B1R1b1",
    "1\n2#2H2O2W2e2}2",
    "373A3O3\\3j3x3",
    "4>4U4[4x4~4",
    "4+5?5`5",
    "6)6M6",
    "7%7?7F7K7Z7",
    "8#9N9a9",
    ":-:2:<:H:Y:m:w:}:",
    ";';,;=;P;U;`;e;k;s;",
    "<%<K<q<",
    ">1>y>",
    ">!?Q?",
    "1N1z1*2;2",
    "2\r3-3",
    "7[7{7",
    "9&9O9T9c9i9o9v9~9",
    ":#:::[:u:",
    "<T=a=x=",
    "=%>0>5>g>p>u>",
    "?%?*?b?k?p?",
    "051@1E1x1",
    "3a4x4",
    ":!;/;};",
    ";N=y=",
    "e0|0",
    "0&1c315",
    "7 9$9(9,9094989<9@9D9H9L9P9T9X9\\9`9d9h9l9p9t9x9|9",
    "9^:r:",
    "1+151N1U1a1k1",
    "242;2G2S2s2~2",
    "2\t3W385@5S5[5",
    "< <&<",
    "<.=\\=m=r=w=",
    "=a?j?u?|?",
    "0#0-070G0W0g0p0",
    "1 1*141G1L1",
    "1,2?2R2^2n2",
    "2A3N3u3}3",
    "4K4S4n4t4",
    "5?6H6M6s6x6",
    "797D7",
    "7$838:8p8y8",
    "9\":V;",
    "4!485i5{5",
    "6\"676J6^6j6",
    "7*767D7f7v7{7",
    "8'8,818a8i8n8~8",
    "9q9}9",
    ":9:>:D:I:T:Z:",
    "7$8~8",
    "9V<p<",
    "='===J=X=f=q=",
    ">8>d>",
    "b0?6H6P6",
    "8?8Q8",
    "9n:r:v:z:~:",
    "1B2^2\r3*3P3@4",
    "8@:y:",
    "<&=M=a=",
    "=g=p=",
    "=\"?N?w?",
    "0%0E0",
    "3-4<4J4g4o4",
    "5\r5O5V5_5",
    "6A6M6",
    "6'7;7l7",
    "8\r8+8?8E8N8T8",
    ";(;U;",
    ";)<1<C<H<v<",
    "=r=|=,>",
    "'0<0D1",
    "1(3>3`3n3u3}3",
    "324<4B4H4",
    "7.747>7]7d7",
    ":-:W:",
    "; ;M;h;",
    ";\r<4<N<",
    "=0=5=A=F=W=",
    "=+>=>E>O>X>i>{>",
    "?!?,?6?<?P?\\?",
    "444G4z4",
    "4\"5'54595",
    "5\n6H6N6",
    "6B7H7",
    "3;3F3",
    "4(444g4",
    "7B8V8s8",
    ":#:}:",
    ":!;0;n;",
    ";d<|<",
    "?a?v?",
    "0>0H0",
    "0@2H2",
    "3#3M3\r4",
    "5O6_6}6",
    "<:<W<y<",
    "=c>m>",
    "1)1/1",
    "2=2M2d2l2",
    "363W3",
    "4!4,41464Q4[4w4",
    "5\n5&51565;5_5k5",
    "636W6s6~6",
    "7A7O7^7",
    "8\"8L8R8",
    "8C:[;",
    "[0b0",
    "1R1c1}1",
    ": :0:?:F:^:e:",
    ":r<}<",
    "W0d0",
    "143;3s3Y4",
    "6k7u7",
    "8$8b8~8",
    ":\n;);H;",
    ";K=d=",
    ">1>B>",
    "-080E0V0d0l0%1",
    "2\"2i2w2",
    "5.719",
    ":.;8;",
    "W0~0",
    "0!1*2",
    "3,313F3y3",
    "3@4x4",
    "7\"797i7~7",
    "878J8",
    "<0<B<T<f<x<",
    ">#?5?",
    "2U2k2",
    "464X4",
    ";5<D<c<",
    "<$=Q=c=",
    "==>7?",
    "2M2T2Y5",
    ":\r:4:`:",
    ";%;1;9;K;V;^;f;n;w;",
    "<^<i<",
    "=&=K=P=V=a=k=",
    ">o>z>",
    "0$0.080I0P0~0",
    "1!1*1?1",
    "274W5",
    ":9<D<W<a<",
    "=d=|=",
    "> >F>~>",
    "z0p1",
    "2N3{3",
    "3-4r4",
    "5A5f7l7",
    ";8;C;P;b;",
    ";G<\\<e<n<",
    "7\t7'7/7",
    "708Z8b8",
    "9!:X:u:",
    "=&={=|>",
    ">,?7?B?H?Q?",
    "0-0X0p0",
    "2W3v3",
    "466Q6g6}6",
    ":x=~=",
    ">/>5>",
    "(<,<0<4<8<<<@<D<H<L<",
    "> ?$?(?,?0?4?8?<?@?D?H?L?P?T?X?\\?`?d?h?l?p?t?x?|?",
    "0 0$0(0,0004080<0@0D0H0L0P0T0X0\\0`0d0h0l0p0t0x0|0",
    "8 8(8,8084888<8@8D8L8P8T8X8\\8`8d8h8t8|8",
    ": :$:(:,:0:4:8:<:@:D:h?l?p?t?x?|?",
    "7 7$7(7,7074787<7@7D7H7L7P7T7X7\\7`7d7h7l7p7t7x7|7",
    "8 8$8(8,8084888<8@8D8H8L8P8T8X8",
    "1$1,141<1D1L1T1\\1d1l1t1|1",
    "2$2,242<2D2L2T2\\2d2l2t2|2",
    "3$3,343<3D3L3T3\\3d3l3t3|3",
    "4$4,444<4D4L4T4\\4d4l4t4|4",
    "5$5,545<5D5L5T5\\5d5l5t5|5",
    "6$6,646<6D6L6T6\\6d6l6t6|6",
    "7$7,747<7D7L7T7\\7d7l7t7|7",
    "2 2(20282@2H2P2X2`2h2p2x2",
    "3 3(30383@3H3P3X3`3h3p3x3",
    "4 4(40484@4H4P4X4`4h4p4x4",
    "5 5(50585@5H5P5X5`5h5p5x5",
    "6 6(60686@6H6P6X6`6h6p6x6",
    "7 7(70787@7H7P7X7`7h7p7x7",
    "8 8(80888@8H8P8X8`8h8p8x8",
    "z=~=",
    "7$7,747<7D7L7T7\\7d7l7t7|7",
    "<0<P<p<",
    "=8=X=x=",
    ">8>X>`>d>",
    "? ?@?`?",
    "0 0@0`0",
    "1(1H1h1",
    "H2x2",
    "30848@8D8H8L8P8T8X8\\8`8d8p8t8x8|8"
  ],
  "sections": [
    {
      "name": "Headers",
      "start": "00400000",
      "end": "004003ff",
      "size": 1024,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 2.8783,
      "strings_count": 8,
      "functions_count": 0,
      "bytes_total": 1024,
      "bytes_sampled": 1024,
      "bytes_truncated": false
    },
    {
      "name": ".text",
      "start": "00401000",
      "end": "004209ff",
      "size": 129536,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": true,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 6.6643,
      "strings_count": 688,
      "functions_count": 840,
      "bytes_total": 129536,
      "bytes_sampled": 129536,
      "bytes_truncated": false
    },
    {
      "name": ".rdata",
      "start": "00421000",
      "end": "0042cbff",
      "size": 48128,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 6.117,
      "strings_count": 1069,
      "functions_count": 0,
      "bytes_total": 48128,
      "bytes_sampled": 48128,
      "bytes_truncated": false
    },
    {
      "name": ".data",
      "start": "0042d000",
      "end": "0043b67f",
      "size": 59008,
      "initialized": true,
      "read": true,
      "write": true,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 0.1269,
      "strings_count": 6,
      "functions_count": 0,
      "bytes_total": 59008,
      "bytes_sampled": 59008,
      "bytes_truncated": false
    },
    {
      "name": ".gfids",
      "start": "0043c000",
      "end": "0043c1ff",
      "size": 512,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 1.8517,
      "strings_count": 0,
      "functions_count": 0,
      "bytes_total": 512,
      "bytes_sampled": 512,
      "bytes_truncated": false
    },
    {
      "name": ".rsrc",
      "start": "0043d000",
      "end": "0044bbff",
      "size": 60416,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 7.2971,
      "strings_count": 471,
      "functions_count": 0,
      "bytes_total": 60416,
      "bytes_sampled": 60416,
      "bytes_truncated": false
    },
    {
      "name": ".reloc",
      "start": "0044c000",
      "end": "0044d9ff",
      "size": 6656,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 6.5033,
      "strings_count": 211,
      "functions_count": 0,
      "bytes_total": 6656,
      "bytes_sampled": 6656,
      "bytes_truncated": false
    },
    {
      "name": "tdb",
      "start": "ffdff000",
      "end": "ffdfffff",
      "size": 4096,
      "initialized": true,
      "read": true,
      "write": true,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": null,
      "comment": null,
      "entropy": 0.0098,
      "strings_count": 0,
      "functions_count": 0,
      "bytes_total": 4096,
      "bytes_sampled": 4096,
      "bytes_truncated": false
    }
  ],
  "libraries": [
    "KERNEL32.DLL",
    "ADVAPI32.DLL",
    "WS2_32.DLL"
  ],
  "exports": [
    "??$?RV<lambda_11b4f7b0d3157825a5656a18eba1ae27>@@AAV<lambda_b51c0495177f500e782686251704ae76>@@V<lambda_cf89b47920b5017557bfe891e78aca36>@@@?$__crt_seh_guarded_call@I@@QAEI$$QAV<lambda_11b4f7b0d3157825a5656a18eba1ae27>@@AAV<lambda_b51c0495177f500e782686251704ae76>@@$$QAV<lambda_cf89b47920b5017557bfe891e78aca36>@@@Z",
    "??$?RV<lambda_123407a5e2ac06da108355a851863b7a>@@AAV<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>@@V<lambda_ae55bdf541ad94d75914d381c370e64d>@@@?$__crt_seh_guarded_call@H@@QAEH$$QAV<lambda_123407a5e2ac06da108355a851863b7a>@@AAV<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>@@$$QAV<lambda_ae55bdf541ad94d75914d381c370e64d>@@@Z",
    "??$?RV<lambda_61cee617f5178ae960314fd4d05640a0>@@AAV<lambda_6978c1fb23f02e42e1d9e99668cc68aa>@@V<lambda_9cd88cf8ad10232537feb2133f08c833>@@@?$__crt_seh_guarded_call@H@@QAEH$$QAV<lambda_61cee617f5178ae960314fd4d05640a0>@@AAV<lambda_6978c1fb23f02e42e1d9e99668cc68aa>@@$$QAV<lambda_9cd88cf8ad10232537feb2133f08c833>@@@Z",
    "??$?RV<lambda_800076c951b434888f4765a74a194fcc>@@AAV<lambda_4e60a939b0d047cfe11ddc22648dfba9>@@V<lambda_6dbb1268764f43b569ce7b67e331d33a>@@@?$__crt_seh_guarded_call@H@@QAEH$$QAV<lambda_800076c951b434888f4765a74a194fcc>@@AAV<lambda_4e60a939b0d047cfe11ddc22648dfba9>@@$$QAV<lambda_6dbb1268764f43b569ce7b67e331d33a>@@@Z",
    "??$?RV<lambda_978dc153c237d78434369da87b74ff60>@@AAV<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>@@V<lambda_4a8533e2866a575feecb8298ce776b0d>@@@?$__crt_seh_guarded_call@X@@QAEX$$QAV<lambda_978dc153c237d78434369da87b74ff60>@@AAV<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>@@$$QAV<lambda_4a8533e2866a575feecb8298ce776b0d>@@@Z",
    "??$?RV<lambda_995298e7d72eb4c2aab26c0585b3abe5>@@AAV<lambda_275893d493268fdec8709772e3fcec0e>@@V<lambda_293819299cbf9a7022e18b56a874bb5c>@@@?$__crt_seh_guarded_call@H@@QAEH$$QAV<lambda_995298e7d72eb4c2aab26c0585b3abe5>@@AAV<lambda_275893d493268fdec8709772e3fcec0e>@@$$QAV<lambda_293819299cbf9a7022e18b56a874bb5c>@@@Z",
    "??$?RV<lambda_d92cfe8357b99225085016881b624cb0>@@AAV<lambda_b721fa326cdb32351d23dfa67958c160>@@V<lambda_42d75b0848218ec137fa420c8ba9fdf9>@@@?$__crt_seh_guarded_call@H@@QAEH$$QAV<lambda_d92cfe8357b99225085016881b624cb0>@@AAV<lambda_b721fa326cdb32351d23dfa67958c160>@@$$QAV<lambda_42d75b0848218ec137fa420c8ba9fdf9>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_275893d493268fdec8709772e3fcec0e>@@@@YAHW4__acrt_lock_id@@$$QAV<lambda_275893d493268fdec8709772e3fcec0e>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_4e60a939b0d047cfe11ddc22648dfba9>@@@@YAHW4__acrt_lock_id@@$$QAV<lambda_4e60a939b0d047cfe11ddc22648dfba9>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_6250bd4b2a391816dd638c3bf72b0bcb>@@@@YAXW4__acrt_lock_id@@$$QAV<lambda_6250bd4b2a391816dd638c3bf72b0bcb>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>@@@@YAXW4__acrt_lock_id@@$$QAV<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_b2ea41f6bbb362cd97d94c6828d90b61>@@@@YAXW4__acrt_lock_id@@$$QAV<lambda_b2ea41f6bbb362cd97d94c6828d90b61>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_be2b3da3f62db62e9dad5dc70221a656>@@@@YAXW4__acrt_lock_id@@$$QAV<lambda_be2b3da3f62db62e9dad5dc70221a656>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_e69574bed617af4e071282c136b37893>@@@@YAXW4__acrt_lock_id@@$$QAV<lambda_e69574bed617af4e071282c136b37893>@@@Z",
    "??$__acrt_lock_and_call@V<lambda_ec61778202f4f5fc7e7711acc23c3bca>@@@@YAP6AXH@ZW4__acrt_lock_id@@$$QAV<lambda_ec61778202f4f5fc7e7711acc23c3bca>@@@Z",
    "??$__acrt_lock_stream_and_call@V<lambda_b51c0495177f500e782686251704ae76>@@@@YAIQAU_iobuf@@$$QAV<lambda_b51c0495177f500e782686251704ae76>@@@Z",
    "??$__acrt_lock_stream_and_call@V<lambda_b721fa326cdb32351d23dfa67958c160>@@@@YAHQAU_iobuf@@$$QAV<lambda_b721fa326cdb32351d23dfa67958c160>@@@Z",
    "??$__acrt_lowio_lock_fh_and_call@V<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>@@@@YAHH$$QAV<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>@@@Z",
    "??$__acrt_lowio_lock_fh_and_call@V<lambda_6978c1fb23f02e42e1d9e99668cc68aa>@@@@YAHH$$QAV<lambda_6978c1fb23f02e42e1d9e99668cc68aa>@@@Z",
    "??$__acrt_stdio_parse_mode@_W@@YA?AU__acrt_stdio_stream_mode@@QB_W@Z",
    "??$__crt_fast_encode_pointer@PAX@@YAPAXQAX@Z",
    "??$__crt_time_elapsed_leap_years@H@@YAHH@Z",
    "??$__crt_time_is_leap_year@H@@YA_NH@Z",
    "??$common_configure_argv@_W@@YAHW4_crt_argv_mode@@@Z",
    "??$common_dupenv_s@_W@@YAHQAPA_WQAIQB_WHQBDH@Z",
    "??$common_dupenv_s_nolock@_W@@YAHQAPA_WQAIQB_WHQBDH@Z",
    "??$common_expand_argv_wildcards@_W@@YAHQAPA_WQAPAPA_W@Z",
    "??$common_find_first_wide@U_wfinddata64i32_t@@@@YAHQB_WQAU_wfinddata64i32_t@@@Z",
    "??$common_find_next_wide@U_wfinddata64i32_t@@@@YAHHQAU_wfinddata64i32_t@@@Z",
    "??$common_flush_and_write_nolock@D@@YAHHV__crt_stdio_stream@@@Z",
    "??$common_fsopen@_W@@YAPAU_iobuf@@QB_W0H@Z",
    "??$common_ftell@J@@YAJV__crt_stdio_stream@@@Z",
    "??$common_ftell_nolock@J@@YAJV__crt_stdio_stream@@@Z",
    "??$common_ftell_nolock@_J@@YA_JV__crt_stdio_stream@@@Z",
    "??$common_fullpath_dynamic_buffer@D@@YAPADQBDIH0H@Z",
    "??$common_fullpath_dynamic_buffer@_W@@YAPA_WQB_WIHQBDH@Z",
    "??$common_fullpath_user_buffer@D@@YAPADQADQBDI@Z",
    "??$common_fullpath_user_buffer@_W@@YAPA_WQA_WQB_WI@Z",
    "??$common_get_or_create_environment_nolock@D@@YAPAPADXZ",
    "??$common_get_or_create_environment_nolock@_W@@YAPAPA_WXZ",
    "??$common_getdcwd@D@@YAPADHQADHHQBDH@Z",
    "??$common_getdcwd@_W@@YAPA_WHQA_WHHQBDH@Z",
    "??$common_getdcwd_dynamic_buffer@D@@YAPADQADIHQBDH@Z",
    "??$common_getdcwd_dynamic_buffer@_W@@YAPA_WQA_WIHQBDH@Z",
    "??$common_getdcwd_user_buffer@D@@YAPADQAD0I@Z",
    "??$common_getdcwd_user_buffer@_W@@YAPA_WQA_W0I@Z",
    "??$common_getenv_nolock@D@@YAPADQBD@Z",
    "??$common_getenv_nolock@_W@@YAPA_WQB_W@Z",
    "??$common_getenv_s@D@@YAHQAIQADIQBD@Z",
    "??$common_getenv_s_nolock@D@@YAHQAIQADIQBD@Z",
    "??$common_initialize_environment_nolock@D@@YAHXZ",
    "??$common_initialize_environment_nolock@_W@@YAHXZ",
    "??$common_loctotime_t@_J@@YA_JHHHHHHH@Z",
    "??$common_lseek@_J@@YA_JH_JH@Z",
    "??$common_lseek_nolock@_J@@YA_JH_JH@Z",
    "??$common_openfile@_W@@YAPAU_iobuf@@QB_W0HV__crt_stdio_stream@@@Z",
    "??$common_putenv_nolock@_W@@YAHQB_W0@Z",
    "??$common_refill_and_read_nolock@D@@YAHV__crt_stdio_stream@@@Z",
    "??$common_set_variable_in_environment_nolock@D@@YAHQADH@Z",
    "??$common_set_variable_in_environment_nolock@_W@@YAHQA_WH@Z",
    "??$common_sopen_dispatch@_W@@YAHQB_WHHHQAHH@Z",
    "??$common_stat@U_stat64i32@@@@YAHQB_WQAU_stat64i32@@@Z",
    "??$common_stat_handle_file_not_opened@U_stat64i32@@@@YA_NQB_WAAU_stat64i32@@@Z",
    "??$common_stat_handle_file_opened@U_stat64i32@@@@YA_NQB_WHQAXAAU_stat64i32@@@Z",
    "??$common_tcsncpy_s@D@@YAHQADIQBDI@Z",
    "??$common_tcsncpy_s@_W@@YAHQA_WIQB_WI@Z",
    "??$common_tempnam@_W@@YAPA_WQB_W0HQBDH@Z",
    "??$common_tox_l@$1?internal_isupper_l@@YA_NHQAU__crt_locale_pointers@@@Z$1?internal_map_lower@@YAHH0@Z@@YAHHKQAU__crt_locale_pointers@@@Z",
    "??$common_vsprintf@Vstandard_base@__crt_stdio_output@@D@@YAH_KQADIQBDQAU__crt_locale_pointers@@1@Z",
    "??$common_vsprintf@Vstandard_base@__crt_stdio_output@@_W@@YAH_KQA_WIQB_WQAU__crt_locale_pointers@@QAD@Z",
    "??$common_xtox@K_W@@YAHKQA_WII_N@Z",
    "??$common_xtox_s@K_W@@YAHKQA_WII_N@Z",
    "??$compute_name@_W@@YA_NQB_WQA_WII@Z",
    "??$convert_file_time_to_time_t@_J@@YA_JABU_FILETIME@@@Z",
    "??$convert_large_integer_time_to_time_t@_J@@YA_JT_LARGE_INTEGER@@_J@Z",
    "??$copy_and_add_argument_to_buffer@_W@@YAHQB_W0IAAV?$argument_list@_W@?A0xfd16de3c@@@Z",
    "??$copy_environment@D@@YAPAPADQAPAD@Z",
    "??$copy_environment@_W@@YAPAPA_WQAPA_W@Z",
    "??$count@D@formatting_buffer@__crt_stdio_output@@QBEIXZ",
    "??$create_environment@D@@YAQAPADQAD@Z",
    "??$create_environment@_W@@YAQAPA_WQA_W@Z",
    "??$create_environment_string@_W@@YAPA_WQB_W0@Z",
    "??$ensure_buffer_is_big_enough@D@formatting_buffer@__crt_stdio_output@@QAE_NI@Z",
    "??$expand_argument_wildcards@_W@@YAHQA_W0AAV?$argument_list@_W@?A0xfd16de3c@@@Z",
    "??$find_in_environment_nolock@D@@YAHQBDI@Z",
    "??$find_in_environment_nolock@_W@@YAHQB_WI@Z",
    "??$free_environment@_W@@YAXQAPA_W@Z",
    "??$get_directory@_W@@YAPB_WQB_WQAPB_W@Z",
    "??$initialize_environment_by_cloning_nolock@D@@YAHXZ",
    "??$initialize_environment_by_cloning_nolock@_W@@YAHXZ",
    "??$is_overflow_condition@K@__crt_strtox@@YA_NIK@Z",
    "??$is_wide_character_specifier@D@__crt_stdio_output@@YA_N_KDW4length_modifier@0@@Z",
    "??$is_wide_character_specifier@_W@__crt_stdio_output@@YA_N_K_WW4length_modifier@0@@Z",
    "??$loctotime@AAGAAGAAGAAGAAGAAGH@?$__crt_integer_traits@_J@@SA_JAAG00000$$QAH@Z",
    "??$parse_command_line@_W@@YAXPA_WPAPA_W0PAI2@Z",
    "??$parse_integer@KV?$c_string_character_source@D@__crt_strtox@@@__crt_strtox@@YAKQAU__crt_locale_pointers@@V?$c_string_character_source@D@0@H_N@Z",
    "??$parse_integer@KV?$c_string_character_source@_W@__crt_strtox@@@__crt_strtox@@YAKQAU__crt_locale_pointers@@V?$c_string_character_source@_W@0@H_N@Z",
    "??$scratch_data@D@formatting_buffer@__crt_stdio_output@@QAEPADXZ",
    "??$set_variable_in_other_environment@_W@@YA_NQB_W0@Z",
    "??$strip_quotes@_W@@YAPB_WQB_W@Z",
    "??$translate_text_mode_nolock@D@@YAHHQADI@Z",
    "??$translate_text_mode_nolock@_W@@YAHHQA_WI@Z",
    "??$write_buffer_nolock@D@@YA_NDV__crt_stdio_stream@@@Z",
    "??$write_multiple_characters@V?$stream_output_adapter@D@__crt_stdio_output@@D@__crt_stdio_output@@YAXABV?$stream_output_adapter@D@0@DHQAH@Z",
    "??$write_multiple_characters@V?$string_output_adapter@D@__crt_stdio_output@@D@__crt_stdio_output@@YAXABV?$string_output_adapter@D@0@DHQAH@Z",
    "??$write_multiple_characters@V?$string_output_adapter@_W@__crt_stdio_output@@D@__crt_stdio_output@@YAXABV?$string_output_adapter@_W@0@DHQAH@Z",
    "??0?$common_data@D@__crt_stdio_output@@IAE@XZ",
    "??0?$common_data@_W@__crt_stdio_output@@IAE@XZ",
    "??0_LocaleUpdate@@QAE@QAU__crt_locale_pointers@@@Z",
    "??0scoped_fp_state_reset@?A0x3568b024@@QAE@XZ",
    "??1?$argument_list@_W@?A0xfd16de3c@@QAE@XZ",
    "??1formatting_buffer@__crt_stdio_output@@QAE@XZ",
    "??4?$__crt_unique_heap_ptr@DU__crt_internal_free_policy@@@@QAEAAV0@$$QAV0@@Z",
    "??R<lambda_275893d493268fdec8709772e3fcec0e>@@QBEHXZ",
    "??R<lambda_4e60a939b0d047cfe11ddc22648dfba9>@@QBEHXZ",
    "??R<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>@@QBEHXZ",
    "??R<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>@@QBEXXZ",
    "??R<lambda_b51c0495177f500e782686251704ae76>@@QBEIXZ",
    "??R<lambda_b721fa326cdb32351d23dfa67958c160>@@QBEHXZ",
    "?CPtoLocaleName@@YAPB_WH@Z",
    "?GetTableIndexFromLocaleName@@YAHPB_W@Z",
    "?InternalCompareStringA@@YAHPAU__crt_locale_pointers@@PB_WKPBDH2HH@Z",
    "?LongLongSub@@YAJ_J0PA_J@Z",
    "?__acrt_LCMapStringA_stat@@YAHPAU__crt_locale_pointers@@PB_WKPBDHPADHHH@Z",
    "?__acrt_fp_classify@@YA?AW4__acrt_fp_class@@ABN@Z",
    "?__acrt_fp_is_negative@@YA_NABN@Z",
    "?__acrt_stdio_allocate_stream@@YA?AV__crt_stdio_stream@@XZ",
    "?__acrt_stdio_free_stream@@YAXV__crt_stdio_stream@@@Z",
    "?__acrt_stdio_parse_mode_D@@YA_NAAU__acrt_stdio_stream_mode@@@Z",
    "?__acrt_stdio_parse_mode_T@@YA_NAAU__acrt_stdio_stream_mode@@@Z",
    "?__acrt_stdio_parse_mode_b@@YA_NAAU__acrt_stdio_stream_mode@@@Z",
    "?__acrt_stdio_parse_mode_c@@YA_NAAU__acrt_stdio_stream_mode@@AA_N@Z",
    "?__acrt_stdio_parse_mode_n@@YA_NAAU__acrt_stdio_stream_mode@@AA_N@Z",
    "?__acrt_stdio_parse_mode_plus@@YA_NAAU__acrt_stdio_stream_mode@@AA_N@Z",
    "?__acrt_stdio_parse_mode_t@@YA_NAAU__acrt_stdio_stream_mode@@@Z",
    "?__crt_stdio_path_requires_backslash@@YA_NQB_W@Z",
    "?__crt_time_is_day_valid@@YA_NHHH@Z",
    "?__scrt_common_main_seh@@YAHXZ",
    "?_isindst_nolock@@YAHQAUtm@@@Z",
    "?_mbstowcs_l_helper@@YAIPA_WPBDIPAU__crt_locale_pointers@@@Z",
    "?atexit_exception_filter@@YAHK@Z",
    "?call_wfullpath@@YAPA_WQA_WQB_WIQAPA_W@Z",
    "?common_exit@@YAXHW4_crt_exit_cleanup_mode@@W4_crt_exit_return_mode@@@Z",
    "?common_fseek@@YAHV__crt_stdio_stream@@_JH@Z",
    "?common_fseek_binary_mode_read_only_fast_track_nolock@@YA_NV__crt_stdio_stream@@_JH@Z",
    "?common_fseek_nolock@@YAHV__crt_stdio_stream@@_JH@Z",
    "?common_ftell_read_mode_nolock@@YA_JV__crt_stdio_stream@@_J1@Z",
    "?common_ftell_translated_utf8_nolock@@YA_JV__crt_stdio_stream@@_J@Z",
    "?compute_size@@YA_NABT_LARGE_INTEGER@@AAJ@Z",
    "?configure_text_mode@@YAHHUfile_options@?A0x3ac5ad54@@HAAW4__crt_lowio_text_mode@@@Z",
    "?construct_ptd@@YAXQAU__acrt_ptd@@QAPAU__crt_locale_data@@@Z",
    "?convert_to_stat_mode@@YAGHQB_W@Z",
    "?create_file@@YAPAXQB_WQAU_SECURITY_ATTRIBUTES@@Ufile_options@?A0x3ac5ad54@@@Z",
    "?crop_zeroes@__crt_stdio_output@@YAXPADQAU__crt_locale_pointers@@@Z",
    "?cvtdate@@YAXW4transition_type@?A0xe529774e@@W4date_type@2@HHHHHHHHH@Z",
    "?decode_open_create_flags@@YAKH@Z",
    "?decode_options@@YA?AUfile_options@?A0x3ac5ad54@@HHH@Z",
    "?destroy_fls@@YGXPAX@Z",
    "?destroy_ptd@@YAXQAU__acrt_ptd@@@Z",
    "?divide@__crt_strtox@@YA_KAAUbig_integer@1@ABU21@@Z",
    "?exit_or_terminate_process@@YAXI@Z",
    "?find_end_of_double_null_terminated_sequence@@YAPB_WQB_W@Z",
    "?find_or_allocate_unused_stream_nolock@@YA?AV__crt_stdio_stream@@XZ",
    "?find_pe_section@@YAPAU_IMAGE_SECTION_HEADER@@QAEI@Z",
    "?force_decimal_point@__crt_stdio_output@@YAXPADQAU__crt_locale_pointers@@@Z",
    "?fp_format_a@@YAHQBNPADIQADIH_NIQAU__crt_locale_pointers@@@Z",
    "?fp_format_e@@YAHQBNQADI1IH_NIQAU__crt_locale_pointers@@@Z",
    "?fp_format_e_internal@@YAHQADIH_NIQAU_strflt@@1QAU__crt_locale_pointers@@@Z",
    "?fp_format_f@@YAHQBNQADI1IHQAU__crt_locale_pointers@@@Z",
    "?fp_format_f_internal@@YAHQADIHQAU_strflt@@_NQAU__crt_locale_pointers@@@Z",
    "?fp_format_g@@YAHQBNQADI1IH_NIQAU__crt_locale_pointers@@@Z",
    "?fp_format_nan_or_infinity@@YAHW4__acrt_fp_class@@_NPADI1@Z",
    "?free_crt_array_internal@@YAXQAPBXI@Z",
    "?getSystemCP@@YAHH@Z",
    "?get_drive_number_from_path@@YAHQB_W@Z",
    "?get_drive_number_from_path@@YA_NQB_WAAH@Z",
    "?get_global_action_nolock@@YAPAP6AXH@ZH@Z",
    "?has_executable_extension@@YA_NQB_W@Z",
    "?initialize_inherited_file_handles_nolock@@YAXXZ",
    "?internal_isupper_l@@YA_NHQAU__crt_locale_pointers@@@Z",
    "?is_root_or_empty@@YA_NQB_W@Z",
    "?is_root_unc_name@@YA_NQB_W@Z",
    "?is_slash@@YA_N_W@Z",
    "?is_usable_drive_or_unc_root@@YA_NQB_W@Z",
    "?is_valid_drive@@YAHI@Z",
    "?process@?$output_processor@DV?$stream_output_adapter@D@__crt_stdio_output@@V?$standard_base@DV?$stream_output_adapter@D@__crt_stdio_output@@@2@@__crt_stdio_output@@QAEHXZ",
    "?process@?$output_processor@DV?$string_output_adapter@D@__crt_stdio_output@@V?$standard_base@DV?$string_output_adapter@D@__crt_stdio_output@@@2@@__crt_stdio_output@@QAEHXZ",
    "?process@?$output_processor@_WV?$string_output_adapter@_W@__crt_stdio_output@@V?$standard_base@_WV?$string_output_adapter@_W@__crt_stdio_output@@@2@@__crt_stdio_output@@QAEHXZ",
    "?replace_current_thread_locale_nolock@@YAXQAU__acrt_ptd@@QAU__crt_locale_data@@@Z",
    "?setSBCS@@YAXPAU__crt_multibyte_data@@@Z",
    "?setSBUpLow@@YAXPAU__crt_multibyte_data@@@Z",
    "?set_buffer@@YAHV__crt_stdio_stream@@QADIH@Z",
    "?setmbcp_internal@@YAHH_N@Z",
    "?shift_bytes@@YAXQADI0H@Z",
    "?shortsort@@YAXPAD0IP6AHPBX1@Z@Z",
    "?siglookup@@YAPAU__crt_signal_action_t@@HQAU1@@Z",
    "?signal_failed@@YAP6AXH@ZH@Z",
    "?state_case_type@?$output_processor@DV?$stream_output_adapter@D@__crt_stdio_output@@V?$standard_base@DV?$stream_output_adapter@D@__crt_stdio_output@@@2@@__crt_stdio_output@@AAE_NXZ",
    "?state_case_type@?$output_processor@DV?$string_output_adapter@D@__crt_stdio_output@@V?$standard_base@DV?$string_output_adapter@D@__crt_stdio_output@@@2@@__crt_stdio_output@@AAE_NXZ",
    "?state_case_type@?$output_processor@_WV?$string_output_adapter@_W@__crt_stdio_output@@V?$standard_base@_WV?$string_output_adapter@_W@__crt_stdio_output@@@2@@__crt_stdio_output@@AAE_NXZ",
    "?swap@@YAXPAD0I@Z",
    "?to_integer_size@__crt_stdio_output@@YAIW4length_modifier@1@@Z",
    "?translate_ansi_or_utf8_nolock@@YAHHQADIQA_WI@Z",
    "?translate_utf16_from_console_nolock@@YAHHQA_WI@Z",
    "?truncate_ctrl_z_if_present@@YAHH@Z",
    "?try_cor_exit_process@@YAXI@Z",
    "?try_get_CompareStringEx@@YAP6GHPB_WK0H0HPAU_nlsversioninfo@@PAXJ@ZXZ",
    "?try_get_function@@YAPAXW4function_id@?A0x89697e75@@QBDQBW4module_id@2@2@Z",
    "?try_get_function@@YAPAXW4function_id@?A0x9b56aee1@@QBDQBW4module_id@2@2@Z",
    "?try_get_module@@YAPAUHINSTANCE__@@W4module_id@?A0x89697e75@@@Z",
    "?tzset_from_environment_nolock@@YAXPAD@Z",
    "?tzset_from_system_nolock@@YAXXZ",
    "?tzset_nolock@@YAXXZ",
    "?unget@?$c_string_character_source@D@__crt_strtox@@QAEXD@Z",
    "?unget@?$c_string_character_source@_W@__crt_strtox@@QAEX_W@Z",
    "?validate@?$c_string_character_source@_W@__crt_strtox@@QBE_NXZ",
    "?validate@?$stream_output_adapter@D@__crt_stdio_output@@QBE_NXZ",
    "?validate_stream_is_ansi_if_required@?$__acrt_stdio_char_traits@D@@SA_NQAU_iobuf@@@Z",
    "?write_character@?$stream_output_adapter@D@__crt_stdio_output@@QBEXDQAH@Z",
    "?write_character@?$string_output_adapter@D@__crt_stdio_output@@QBE_NDQAH@Z",
    "?write_character@?$string_output_adapter@_W@__crt_stdio_output@@QBE_N_WQAH@Z",
    "?write_double_translated_ansi_nolock@@YA?AUwrite_result@?A0x4add88c5@@HQBDI@Z",
    "?write_double_translated_unicode_nolock@@YA?AUwrite_result@?A0x4add88c5@@QBDI@Z",
    "?write_requires_double_translation_nolock@@YA_NH@Z",
    "?write_string@?$stream_output_adapter@D@__crt_stdio_output@@QBEXQBDHQAH1@Z",
    "?write_string@?$string_output_adapter@D@__crt_stdio_output@@QBEXQBDHQAH1@Z",
    "?write_string@?$string_output_adapter@_W@__crt_stdio_output@@QBEXQB_WHQAH1@Z",
    "?write_text_ansi_nolock@@YA?AUwrite_result@?A0x4add88c5@@HQBDI@Z",
    "?write_text_utf16le_nolock@@YA?AUwrite_result@?A0x4add88c5@@HQBDI@Z",
    "?write_text_utf8_nolock@@YA?AUwrite_result@?A0x4add88c5@@HQBDI@Z",
    "@_EH4_CallFilterFunc@8",
    "@_EH4_GlobalUnwind2@8",
    "@_EH4_LocalUnwind@16",
    "@_EH4_TransferToHandler@8",
    "@__security_check_cookie@4",
    "ActivationContextStackPointer",
    "ActiveFrame",
    "ActiveRpcHandle",
    "ActivityId",
    "ArbitraryUserPointer",
    "CPtoLocaleName",
    "ClientId",
    "ConvertStringSecurityDescriptorToSecurityDescriptorW",
    "CountOfOwnedCriticalSections",
    "CrossTebFlags",
    "CsrClientThread",
    "CurrentLocale",
    "CurrentTransactionHandle",
    "DAT_00421190",
    "DAT_00421198",
    "DAT_0042119c",
    "DAT_004211b8",
    "DAT_004211bc",
    "DAT_004211d0",
    "DAT_004211d4",
    "DAT_004211d8",
    "DAT_00421200",
    "DAT_00421330",
    "DAT_00421488",
    "DAT_004214cc",
    "DAT_00421638",
    "DAT_00421688",
    "DAT_004217ac",
    "DAT_00421815",
    "DAT_004218a4",
    "DAT_0042279c",
    "DAT_00422984",
    "DAT_00422ba4",
    "DAT_00422ba8",
    "DAT_00422c40",
    "DAT_00422d10",
    "DAT_00422d90",
    "DAT_00422d92",
    "DAT_00422d94",
    "DAT_00422d96",
    "DAT_00422d98",
    "DAT_00422d9a",
    "DAT_00422d9c",
    "DAT_00422da0",
    "DAT_00422dd8",
    "DAT_0042316c",
    "DAT_0042317c",
    "DAT_0042318c",
    "DAT_00423198",
    "DAT_00423998",
    "DAT_00423a18",
    "DAT_00423c28",
    "DAT_00424028",
    "DAT_00424428",
    "DAT_00424828",
    "DAT_00425d00",
    "DAT_00425d40",
    "DAT_00425d80",
    "DAT_00425dc0",
    "DAT_00425eb8",
    "DAT_00425ecc",
    "DAT_00425ee8",
    "DAT_00425efc",
    "DAT_00426144",
    "DAT_00426154",
    "DAT_00426158",
    "DAT_0042615c",
    "DAT_00426160",
    "DAT_00426164",
    "DAT_00426168",
    "DAT_0042616c",
    "DAT_0042617c",
    "DAT_00426180",
    "DAT_00426184",
    "DAT_00426188",
    "DAT_0042618c",
    "DAT_00426190",
    "DAT_00426194",
    "DAT_00426198",
    "DAT_0042619c",
    "DAT_004261a0",
    "DAT_004261a4",
    "DAT_004261a8",
    "DAT_004261ac",
    "DAT_004261b0",
    "DAT_004261b4",
    "DAT_004261b8",
    "DAT_004261bc",
    "DAT_004261c0",
    "DAT_004261c4",
    "DAT_004261c8",
    "DAT_004261cc",
    "DAT_004261d0",
    "DAT_004261d4",
    "DAT_004261d8",
    "DAT_004261dc",
    "DAT_004261e0",
    "DAT_004261e4",
    "DAT_004261e8",
    "DAT_004261ec",
    "DAT_004261f0",
    "DAT_004261f4",
    "DAT_004263d4",
    "DAT_00426680",
    "DAT_00426684",
    "DAT_00426688",
    "DAT_0042672c",
    "DAT_00426734",
    "DAT_0042673c",
    "DAT_00426740",
    "DAT_00426744",
    "DAT_00426748",
    "DAT_00426750",
    "DAT_004267e0",
    "DAT_004267e4",
    "DAT_004267e8",
    "DAT_004267ec",
    "DAT_00426890",
    "DAT_00426898",
    "DAT_0042689c",
    "DAT_00426e98",
    "DAT_00426eac",
    "DAT_00426ec4",
    "DAT_00426ecc",
    "DAT_00426ed4",
    "DAT_00426edc",
    "DAT_00426ee4",
    "DAT_00426f00",
    "DAT_00426f28",
    "DAT_00426f30",
    "DAT_00426f48",
    "DAT_00427350",
    "DAT_00427354",
    "DAT_00427358",
    "DAT_0042735c",
    "DAT_00427360",
    "DAT_0042739c",
    "DAT_004273a0",
    "DAT_004273a4",
    "DAT_004273a8",
    "DAT_004273ac",
    "DAT_004273b0",
    "DAT_004273b4",
    "DAT_004273fc",
    "DAT_00427400",
    "DAT_00427404",
    "DAT_00427408",
    "DAT_0042740c",
    "DAT_00427410",
    "DAT_00427414",
    "DAT_00427418",
    "DAT_0042741c",
    "DAT_00427420",
    "DAT_00427424",
    "DAT_00427428",
    "DAT_00427450",
    "DAT_00427458",
    "DAT_00427494",
    "DAT_00427498",
    "DAT_004274c8",
    "DAT_004274d0",
    "DAT_004274d8",
    "DAT_004274e0",
    "DAT_004274e8",
    "DAT_004274f0",
    "DAT_004274f8",
    "DAT_0042757c",
    "DAT_00427584",
    "DAT_0042758c",
    "DAT_00427594",
    "DAT_0042759c",
    "DAT_004275a4",
    "DAT_004275ac",
    "DAT_004275b4",
    "DAT_004275bc",
    "DAT_004275c4",
    "DAT_004275cc",
    "DAT_004275d4",
    "DAT_0042768c",
    "DAT_00427694",
    "DAT_0042785c",
    "DAT_004278d2",
    "DAT_00427bd8",
    "DAT_00427e58",
    "DAT_00427fd8",
    "DAT_004280e0",
    "DAT_00428a10",
    "DAT_00429204",
    "DAT_0042a9e4",
    "DAT_0042aa56",
    "DAT_0042aa57",
    "DAT_0042aaec",
    "DAT_0042aaee",
    "DAT_0042aaef",
    "DAT_0042ab14",
    "DAT_0042ab38",
    "DAT_0042ab3c",
    "DAT_0042ab40",
    "DAT_0042ab6c",
    "DAT_0042ab70",
    "DAT_0042aba4",
    "DAT_0042abb0",
    "DAT_0042abe0",
    "DAT_0042abf0",
    "DAT_0042ac00",
    "DAT_0042ac10",
    "DAT_0042ac20",
    "DAT_0042ac30",
    "DAT_0042ac40",
    "DAT_0042ac50",
    "DAT_0042ac60",
    "DAT_0042ac70",
    "DAT_0042ac80",
    "DAT_0042ac90",
    "DAT_0042aca0",
    "DAT_0042acb0",
    "DAT_0042acc0",
    "DAT_0042acd0",
    "DAT_0042acd8",
    "DAT_0042acf0",
    "DAT_0042ad00",
    "DAT_0042ad10",
    "DAT_0042ad20",
    "DAT_0042ad3a",
    "DAT_0042ad90",
    "DAT_0042add0",
    "DAT_0042add8",
    "DAT_0042ae14",
    "DAT_0042ae20",
    "DAT_0042ae24",
    "DAT_0042ae28",
    "DAT_0042ae30",
    "DAT_0042ae38",
    "DAT_0042ae40",
    "DAT_0042ae50",
    "DAT_0042b260",
    "DAT_0042b670",
    "DAT_0042b708",
    "DAT_0042b710",
    "DAT_0042b800",
    "DAT_0042b808",
    "DAT_0042b810",
    "DAT_0042b8a0",
    "DAT_0042bb68",
    "DAT_0042bb6c",
    "DAT_0042bb70",
    "DAT_0042bb74",
    "DAT_0042bb78",
    "DAT_0042bb98",
    "DAT_0042bbb8",
    "DAT_0042bbd8",
    "DAT_0042bbf8",
    "DAT_0042bc18",
    "DAT_0042bc38",
    "DAT_0042bc58",
    "DAT_0042bc78",
    "DAT_0042bc98",
    "DAT_0042bcb8",
    "DAT_0042bcd8",
    "DAT_0042bcf8",
    "DAT_0042bd20",
    "DAT_0042bd40",
    "DAT_0042bd60",
    "DAT_0042bd80",
    "DAT_0042bda0",
    "DAT_0042bdc0",
    "DAT_0042bde0",
    "DAT_0042be00",
    "DAT_0042be20",
    "DAT_0042be40",
    "DAT_0042be68",
    "DAT_0042be88",
    "DAT_0042bea8",
    "DAT_0042bec8",
    "DAT_0042bee8",
    "DAT_0042bf08",
    "DAT_0042bf28",
    "DAT_0042bf48",
    "DAT_0042bf68",
    "DAT_0042bf88",
    "DAT_0042bfa8",
    "DAT_0042bfc8",
    "DAT_0042bfe8",
    "DAT_0042c008",
    "DAT_0042c028",
    "DAT_0042c048",
    "DAT_0042c068",
    "DAT_0042c088",
    "DAT_0042c0a8",
    "DAT_0042c0c8",
    "DAT_0042c0f0",
    "DAT_0042c110",
    "DAT_0042c130",
    "DAT_0042c150",
    "DAT_0042c170",
    "DAT_0042c190",
    "DAT_0042c1b0",
    "DAT_0042c1d0",
    "DAT_0042c1f0",
    "DAT_0042d000",
    "DAT_0042d004",
    "DAT_0042d008",
    "DAT_0042d014",
    "DAT_0042d020",
    "DAT_0042d030",
    "DAT_0042d040",
    "DAT_0042d044",
    "DAT_0042d048",
    "DAT_0042d04c",
    "DAT_0042d050",
    "DAT_0042d060",
    "DAT_0042d070",
    "DAT_0042d0a8",
    "DAT_0042d0f8",
    "DAT_0042d100",
    "DAT_0042d104",
    "DAT_0042d108",
    "DAT_0042d110",
    "DAT_0042d210",
    "DAT_0042d238",
    "DAT_0042d239",
    "DAT_0042d23d",
    "DAT_0042d240",
    "DAT_0042d308",
    "DAT_0042d30c",
    "DAT_0042d310",
    "DAT_0042d314",
    "DAT_0042d318",
    "DAT_0042d348",
    "DAT_0042d34c",
    "DAT_0042d34e",
    "DAT_0042d358",
    "DAT_0042d359",
    "DAT_0042d35a",
    "DAT_0042d35b",
    "DAT_0042d360",
    "DAT_0042d361",
    "DAT_0042d368",
    "DAT_0042d408",
    "DAT_0042d510",
    "DAT_0042d610",
    "DAT_0042d838",
    "DAT_0042d83c",
    "DAT_0042d890",
    "DAT_0042d918",
    "DAT_0042d91c",
    "DAT_0042d920",
    "DAT_0042d924",
    "DAT_0042d928",
    "DAT_0042d92c",
    "DAT_0042d930",
    "DAT_0042d934",
    "DAT_0042d954",
    "DAT_0042d958",
    "DAT_0042d95c",
    "DAT_0042d960",
    "DAT_0042d964",
    "DAT_0042d968",
    "DAT_0042d96c",
    "DAT_0042d970",
    "DAT_0042d974",
    "DAT_0042d978",
    "DAT_0042d97c",
    "DAT_0042d980",
    "DAT_0042d984",
    "DAT_0042d988",
    "DAT_0042d98c",
    "DAT_0042d990",
    "DAT_0042d994",
    "DAT_0042d998",
    "DAT_0042d99c",
    "DAT_0042d9a0",
    "DAT_0042d9a4",
    "DAT_0042d9a8",
    "DAT_0042d9ac",
    "DAT_0042d9b0",
    "DAT_0042d9b4",
    "DAT_0042d9b8",
    "DAT_0042d9bc",
    "DAT_0042d9c0",
    "DAT_0042d9c4",
    "DAT_0042d9c8",
    "DAT_0042d9cc",
    "DAT_0042d9d0",
    "DAT_0042d9d4",
    "DAT_0042d9d8",
    "DAT_0042d9dc",
    "DAT_0042d9e0",
    "DAT_0042d9e4",
    "DAT_0042d9e8",
    "DAT_0042d9ec",
    "DAT_0042d9f0",
    "DAT_0042d9f4",
    "DAT_0042d9f8",
    "DAT_0042d9fc",
    "DAT_0042da00",
    "DAT_0042da04",
    "DAT_0042da08",
    "DAT_0042da10",
    "DAT_0042fa20",
    "DAT_00431a30",
    "DAT_00432a38",
    "DAT_00433a40",
    "DAT_00435a48",
    "DAT_00437a50",
    "DAT_00439a60",
    "DAT_00439a68",
    "DAT_0043aa68",
    "DAT_0043aa6c",
    "DAT_0043aa74",
    "DAT_0043aa78",
    "DAT_0043aa7c",
    "DAT_0043aab8",
    "DAT_0043ab44",
    "DAT_0043ab48",
    "DAT_0043ab4c",
    "DAT_0043ab50",
    "DAT_0043ab54",
    "DAT_0043ab58",
    "DAT_0043ab5c",
    "DAT_0043ab60",
    "DAT_0043ab64",
    "DAT_0043ab68",
    "DAT_0043ab6c",
    "DAT_0043ab70",
    "DAT_0043ab74",
    "DAT_0043ab78",
    "DAT_0043ab7c",
    "DAT_0043ab80",
    "DAT_0043ad84",
    "DAT_0043ad88",
    "DAT_0043ad8c",
    "DAT_0043ad90",
    "DAT_0043ad94",
    "DAT_0043ad98",
    "DAT_0043ad9c",
    "DAT_0043ada0",
    "DAT_0043ada4",
    "DAT_0043ada8",
    "DAT_0043adb0",
    "DAT_0043adb8",
    "DAT_0043adbc",
    "DAT_0043adc0",
    "DAT_0043adc4",
    "DAT_0043add4",
    "DAT_0043adec",
    "DAT_0043ae04",
    "DAT_0043ae08",
    "DAT_0043ae0c",
    "DAT_0043ae18",
    "DAT_0043ae1c",
    "DAT_0043ae20",
    "DAT_0043ae3c",
    "DAT_0043ae7c",
    "DAT_0043ae80",
    "DAT_0043ae84",
    "DAT_0043ae88",
    "DAT_0043ae8c",
    "DAT_0043ae90",
    "DAT_0043ae94",
    "DAT_0043ae98",
    "DAT_0043ae9c",
    "DAT_0043aea0",
    "DAT_0043aea4",
    "DAT_0043aea8",
    "DAT_0043aeac",
    "DAT_0043aeb0",
    "DAT_0043aeb4",
    "DAT_0043aeb8",
    "DAT_0043aec0",
    "DAT_0043b0cc",
    "DAT_0043b0d0",
    "DAT_0043b0d4",
    "DAT_0043b0d8",
    "DAT_0043b0dc",
    "DAT_0043b0e0",
    "DAT_0043b0e4",
    "DAT_0043b0e8",
    "DAT_0043b0ec",
    "DAT_0043b0f0",
    "DAT_0043b0f4",
    "DAT_0043b100",
    "DAT_0043b10c",
    "DAT_0043b110",
    "DAT_0043b114",
    "DAT_0043b310",
    "DAT_0043b314",
    "DAT_0043b318",
    "DAT_0043b320",
    "DAT_0043b324",
    "DAT_0043b370",
    "DAT_0043b374",
    "DAT_0043b3e8",
    "DAT_0043b3f0",
    "DAT_0043b3f4",
    "DAT_0043b3f8",
    "DAT_0043b3fc",
    "DAT_0043b400",
    "DAT_0043b418",
    "DAT_0043b538",
    "DAT_0043b53c",
    "DAT_0043b540",
    "DAT_0043b544",
    "DAT_0043b548",
    "DAT_0043b54c",
    "DAT_0043b558",
    "DAT_0043b55c",
    "DAT_0043b55d",
    "DAT_0043b560",
    "DAT_0043b564",
    "DAT_0043b568",
    "DAT_0043b56c",
    "DAT_0043b570",
    "DAT_0043b574",
    "DAT_0043b578",
    "DAT_0043b57c",
    "DAT_0043b580",
    "DAT_0043b588",
    "DAT_0043b58c",
    "DAT_0043b5cc",
    "DAT_0043b5ce",
    "DAT_0043b5d0",
    "DAT_0043b5d2",
    "DAT_0043b5d4",
    "DAT_0043b5d6",
    "DAT_0043b5d8",
    "DAT_0043b5da",
    "DAT_0043b5dc",
    "DAT_0043b5e0",
    "DAT_0043b620",
    "DAT_0043b622",
    "DAT_0043b624",
    "DAT_0043b626",
    "DAT_0043b628",
    "DAT_0043b62a",
    "DAT_0043b62c",
    "DAT_0043b62e",
    "DAT_0043b630",
    "DAT_0043b634",
    "DAT_0043b638",
    "DAT_0043b63c",
    "DAT_0043b644",
    "DAT_0043b648",
    "DAT_0043b650",
    "DAT_0043b654",
    "DAT_0043b658",
    "DAT_0043b65c",
    "DAT_0043b660",
    "DAT_0043b668",
    "DAT_0043b66c",
    "DAT_0043b670",
    "DAT_0043b674",
    "DAT_0043b678",
    "DAT_0043b67c",
    "DAT_0043c000",
    "DWORD_0042c20c",
    "DWORD_0044c000",
    "DbgSsReserved",
    "DeallocationStack",
    "EnvironmentPointer",
    "EtwLocalData",
    "EtwTraceData",
    "ExceptionCode",
    "ExceptionList",
    "FID_conflict:___acrt_errno_from_os_error",
    "FID_conflict:___stdio_common_vfprintf",
    "FID_conflict:__acrt_stdio_parse_mode_b",
    "FID_conflict:__dupenv_s",
    "FID_conflict:__get_initial_narrow_environment",
    "FID_conflict:__sopen_s",
    "FID_conflict:__stat64i32",
    "FID_conflict:__wputenv_s",
    "FID_conflict:_free",
    "FUN_00401000",
    "FUN_00401030",
    "FUN_00401120",
    "FUN_00401220",
    "FUN_00401240",
    "FUN_00401340",
    "FUN_004013f0",
    "FUN_004014d0",
    "FUN_00401550",
    "FUN_00401580",
    "FUN_004016e0",
    "FUN_004017a0",
    "FUN_004017f0",
    "FUN_00401840",
    "FUN_00401850",
    "FUN_00401880",
    "FUN_004018a0",
    "FUN_004018c0",
    "FUN_004018f0",
    "FUN_00401920",
    "FUN_004019c0",
    "FUN_00401c50",
    "FUN_00401dd0",
    "FUN_00401e30",
    "FUN_00401e80",
    "FUN_00401f00",
    "FUN_00401f70",
    "FUN_00402050",
    "FUN_00402090",
    "FUN_004020d0",
    "FUN_004022f0",
    "FUN_004023d0",
    "FUN_00402760",
    "FUN_004027a0",
    "FUN_00402800",
    "FUN_004028d0",
    "FUN_00402930",
    "FUN_004029a0",
    "FUN_004029c0",
    "FUN_00402a40",
    "FUN_00402b40",
    "FUN_00403120",
    "FUN_00403130",
    "FUN_00403140",
    "FUN_00403150",
    "FUN_00403160",
    "FUN_00403170",
    "FUN_004031a0",
    "FUN_004031d0",
    "FUN_004033d0",
    "FUN_00403520",
    "FUN_00403680",
    "FUN_004038d0",
    "FUN_00403980",
    "FUN_00403c40",
    "FUN_00403d70",
    "FUN_00403de0",
    "FUN_00403fd0",
    "FUN_00404080",
    "FUN_00404270",
    "FUN_00404520",
    "FUN_00404560",
    "FUN_00404590",
    "FUN_00404740",
    "FUN_00404770",
    "FUN_004048c0",
    "FUN_004048f0",
    "FUN_00404a50",
    "FUN_00404b10",
    "FUN_00404b30",
    "FUN_00404c50",
    "FUN_00404d50",
    "FUN_00404df0",
    "FUN_00404e10",
    "FUN_00404ee0",
    "FUN_00404f00",
    "FUN_00404f90",
    "FUN_00405020",
    "FUN_00405120",
    "FUN_004051a0",
    "FUN_00405220",
    "FUN_004069b0",
    "FUN_00406a20",
    "FUN_00406ae0",
    "FUN_00406b00",
    "FUN_00406b60",
    "FUN_00406c10",
    "FUN_00406cf0",
    "FUN_00406df0",
    "FUN_00407060",
    "FUN_00407320",
    "FUN_00407340",
    "FUN_00407350",
    "FUN_00407800",
    "FUN_00408460",
    "FUN_00408463",
    "FUN_00408467",
    "FUN_0040846d",
    "FUN_00408479",
    "FUN_0040849a",
    "FUN_004084a0",
    "FUN_004084bd",
    "FUN_004084c9",
    "FUN_004084cf",
    "FUN_0040863d",
    "FUN_00408645",
    "FUN_00408670",
    "FUN_00408a20",
    "FUN_00408b50",
    "FUN_00408c90",
    "FUN_0040955e",
    "FUN_00409a34",
    "FUN_00409a50",
    "FUN_00409a53",
    "FUN_00409a59",
    "FUN_00409ad8",
    "FUN_00409bff",
    "FUN_00409dbb",
    "FUN_00409eb2",
    "FUN_0040a186",
    "FUN_0040a28c",
    "FUN_0040a4c6",
    "FUN_0040a9af",
    "FUN_0040a9ba",
    "FUN_0040aa0a",
    "FUN_0040ae58",
    "FUN_0040aea6",
    "FUN_0040e21d",
    "FUN_0040e228",
    "FUN_0040e696",
    "FUN_0040ea13",
    "FUN_0040ebb2",
    "FUN_0040ec60",
    "FUN_0040ec8a",
    "FUN_0040ece4",
    "FUN_0040ed57",
    "FUN_0040f011",
    "FUN_0040f2ff",
    "FUN_0040f325",
    "FUN_0040f330",
    "FUN_0040f479",
    "FUN_0040f665",
    "FUN_0040f7b7",
    "FUN_0040f893",
    "FUN_0040f9a5",
    "FUN_0040fb6e",
    "FUN_0040fd50",
    "FUN_0040fd68",
    "FUN_0040ff82",
    "FUN_004101e4",
    "FUN_0041035f",
    "FUN_00410365",
    "FUN_0041038d",
    "FUN_004106f9",
    "FUN_00410b81",
    "FUN_00410d8f",
    "FUN_00410e8d",
    "FUN_00410f72",
    "FUN_00410fdd",
    "FUN_00411012",
    "FUN_0041105d",
    "FUN_004110ae",
    "FUN_004122d3",
    "FUN_00412362",
    "FUN_004124a7",
    "FUN_0041264c",
    "FUN_00412d63",
    "FUN_004132c2",
    "FUN_004133a5",
    "FUN_0041353c",
    "FUN_0041363f",
    "FUN_00413cc6",
    "FUN_004140d8",
    "FUN_004147ab",
    "FUN_00414842",
    "FUN_0041484b",
    "FUN_00414851",
    "FUN_00414d5b",
    "FUN_00414dbc",
    "FUN_00414e07",
    "FUN_00414e4f",
    "FUN_004151be",
    "FUN_00416365",
    "FUN_004163b5",
    "FUN_00416d02",
    "FUN_00416d9e",
    "FUN_00416e72",
    "FUN_0041760b",
    "FUN_00417616",
    "FUN_0041777d",
    "FUN_0041797a",
    "FUN_00417a49",
    "FUN_00417c02",
    "FUN_00417c21",
    "FUN_00417cf7",
    "FUN_00417d02",
    "FUN_0041821c",
    "FUN_0041825e",
    "FUN_004187b0",
    "FUN_004192b8",
    "FUN_00419319",
    "FUN_0041947c",
    "FUN_0041951d",
    "FUN_0041b9fa",
    "FUN_0041ba00",
    "FUN_0041ba06",
    "FUN_0041ba0c",
    "FUN_0041c225",
    "FUN_0041c26f",
    "FUN_0041c5f4",
    "FUN_0041d167",
    "FUN_0041d6db",
    "FUN_0041d73f",
    "FUN_0041d890",
    "FUN_0041da50",
    "FUN_0041daa8",
    "FUN_0041db60",
    "FUN_0041e6b0",
    "FUN_0041e6ce",
    "FUN_0041ed6c",
    "FUN_0041edc8",
    "FUN_0041eed0",
    "FUN_0041f1f4",
    "FUN_0041f25e",
    "FUN_0041f494",
    "FUN_0041fb71",
    "FUN_0041ffc9",
    "FUN_00420170",
    "FUN_00420225",
    "FUN_004202c6",
    "FUN_00420380",
    "FiberData",
    "FlsData",
    "FpSoftwareStatusRegister",
    "GdiBatchCount",
    "GdiCLientTID",
    "GdiCachedProcessHandle",
    "GdiClientPID",
    "GdiTebBatch",
    "GdiThreadLocalInfo",
    "GetCurrentProcessId",
    "GetTableIndexFromLocaleName",
    "GuaranteedStackBytes",
    "HardErrorMode",
    "HeapVirtualAffinity",
    "IMAGE_DEBUG_DIRECTORY_0042b820",
    "IMAGE_DOS_HEADER_00400000",
    "IMAGE_DOS_HEADER_00400000.e_lfanew",
    "IMAGE_LOAD_CONFIG_DIRECTORY32_0042b840",
    "IMAGE_NT_HEADERS32_004000f8",
    "IMAGE_NT_HEADERS32_004000f8.OptionalHeader.Magic",
    "IMAGE_RESOURCE_DIRECTORY_0043d000",
    "IdealProcessorValue",
    "Instrumentation",
    "InternalCompareStringA",
    "IsImpersonating",
    "IsProcessorFeaturePresent",
    "LAB_00401065",
    "LAB_004010e1",
    "LAB_004010fb",
    "LAB_004011b6",
    "LAB_004011c0",
    "LAB_00401202",
    "LAB_00401217",
    "LAB_0040123a",
    "LAB_00401272",
    "LAB_004012ba",
    "LAB_004012ee",
    "LAB_00401325",
    "LAB_0040133a",
    "LAB_00401368",
    "LAB_004013a7",
    "LAB_004013d8",
    "LAB_00401440",
    "LAB_0040145d",
    "LAB_00401472",
    "LAB_004014e4",
    "LAB_004014f2",
    "LAB_0040150a",
    "LAB_00401528",
    "LAB_0040152d",
    "LAB_0040152f",
    "LAB_00401534",
    "LAB_00401577",
    "LAB_004015c4",
    "LAB_004015e7",
    "LAB_00401609",
    "LAB_00401668",
    "LAB_0040169d",
    "LAB_004016cc",
    "LAB_00401717",
    "LAB_00401723",
    "LAB_00401732",
    "LAB_00401740",
    "LAB_00401765",
    "LAB_00401784",
    "LAB_004017dc",
    "LAB_004017e1",
    "LAB_0040181a",
    "LAB_0040182f",
    "LAB_00401838",
    "LAB_0040198f",
    "LAB_00401abd",
    "LAB_00401ac6",
    "LAB_00401ad0",
    "LAB_00401ad8",
    "LAB_00401af3",
    "LAB_00401b5b",
    "LAB_00401bda",
    "LAB_00401bec",
    "LAB_00401c33",
    "LAB_00401c72",
    "LAB_00401c86",
    "LAB_00401c90",
    "LAB_00401cac",
    "LAB_00401cb0",
    "LAB_00401cb5",
    "LAB_00401cd0",
    "LAB_00401cfd",
    "LAB_00401d12",
    "LAB_00401dac",
    "LAB_00401db6",
    "LAB_00401e47",
    "LAB_00401ea0",
    "LAB_00401ea5",
    "LAB_00401ec1",
    "LAB_00401ec5",
    "LAB_00401eca",
    "LAB_00401edc",
    "LAB_00401eed",
    "LAB_00401ef3",
    "LAB_00401f12",
    "LAB_00401f17",
    "LAB_00401fb0",
    "LAB_00401fd9",
    "LAB_00401fdc",
    "LAB_00401ff0",
    "LAB_00402004",
    "LAB_00402018",
    "LAB_00402026",
    "LAB_00402087",
    "LAB_004020a0",
    "LAB_004020c4",
    "LAB_004020c8",
    "LAB_00402131",
    "LAB_0040216a",
    "LAB_00402175",
    "LAB_004021b0",
    "LAB_004021c2",
    "LAB_004021fb",
    "LAB_00402201",
    "LAB_00402258",
    "LAB_0040226d",
    "LAB_0040226f",
    "LAB_00402288",
    "LAB_004022a4",
    "LAB_004022c0",
    "LAB_00402360",
    "LAB_00402380",
    "LAB_004023af",
    "LAB_00402452",
    "LAB_004024c0",
    "LAB_004024f0",
    "LAB_0040254d",
    "LAB_00402587",
    "LAB_004025d0",
    "LAB_004025ec",
    "LAB_004025f0",
    "LAB_004025f5",
    "LAB_0040262c",
    "LAB_00402640",
    "LAB_0040264d",
    "LAB_00402669",
    "LAB_0040266d",
    "LAB_00402698",
    "LAB_004026a0",
    "LAB_0040272d",
    "LAB_00402736",
    "LAB_00402738",
    "LAB_00402770",
    "LAB_00402782",
    "LAB_004027b0",
    "LAB_004027d0",
    "LAB_004027e2",
    "LAB_004027f6",
    "LAB_00402861",
    "LAB_0040289e",
    "LAB_004029d0",
    "LAB_004029f0",
    "LAB_00402a02",
    "LAB_00402a24",
    "LAB_00402a60",
    "LAB_00402a70",
    "LAB_00402a92",
    "LAB_00402a95",
    "LAB_00402a9a",
    "LAB_00402ab0",
    "LAB_00402ad0",
    "LAB_00402ae6",
    "LAB_00402af0",
    "LAB_00402b15",
    "LAB_00402b17",
    "LAB_00402b23",
    "LAB_00402b75",
    "LAB_00402b9e",
    "LAB_00402bc7",
    "LAB_00402bf0",
    "LAB_00402c19",
    "LAB_00402c42",
    "LAB_00402c6b",
    "LAB_00402c94",
    "LAB_00402cbd",
    "LAB_00402ce6",
    "LAB_00402d0f",
    "LAB_00402d38",
    "LAB_00402d61",
    "LAB_00402d86",
    "LAB_00402da1",
    "LAB_00402dbc",
    "LAB_00402dd7",
    "LAB_00402df2",
    "LAB_00402e0d",
    "LAB_00402e28",
    "LAB_00402e43",
    "LAB_00402e5e",
    "LAB_00402e79",
    "LAB_00402e94",
    "LAB_00402eaf",
    "LAB_00402eca",
    "LAB_00402ee5",
    "LAB_00402f00",
    "LAB_00402f1b",
    "LAB_00402f36",
    "LAB_00402f51",
    "LAB_00402f71",
    "LAB_00402f8c",
    "LAB_00402fa7",
    "LAB_00402fc2",
    "LAB_00402fdd",
    "LAB_00402ff8",
    "LAB_00403013",
    "LAB_0040302e",
    "LAB_00403049",
    "LAB_0040306d",
    "LAB_0040308a",
    "LAB_004030a2",
    "LAB_004030ba",
    "LAB_004030d2",
    "LAB_004030ed",
    "LAB_00403101",
    "LAB_00403180",
    "LAB_00403193",
    "LAB_004031c0",
    "LAB_00403220",
    "LAB_00403234",
    "LAB_00403240",
    "LAB_00403260",
    "LAB_0040327b",
    "LAB_004032c3",
    "LAB_004032d4",
    "LAB_00403312",
    "LAB_00403329",
    "LAB_00403335",
    "LAB_0040333b",
    "LAB_00403369",
    "LAB_00403376",
    "LAB_00403384",
    "LAB_0040339a",
    "LAB_004033a6",
    "LAB_004033bc",
    "LAB_004033f1",
    "LAB_0040344f",
    "LAB_00403473",
    "LAB_00403477",
    "LAB_0040349f",
    "LAB_004034a7",
    "LAB_004034df",
    "LAB_004034fb",
    "LAB_00403512",
    "LAB_004035cc",
    "LAB_00403627",
    "LAB_0040364c",
    "LAB_00403659",
    "LAB_004036f0",
    "LAB_00403724",
    "LAB_0040376f",
    "LAB_004037a0",
    "LAB_00403858",
    "LAB_0040385a",
    "LAB_00403873",
    "LAB_00403922",
    "LAB_00403935",
    "LAB_00403960",
    "LAB_004039a8",
    "LAB_004039ba",
    "LAB_004039c6",
    "LAB_004039e2",
    "LAB_00403a2c",
    "LAB_00403a47",
    "LAB_00403a6b",
    "LAB_00403a81",
    "LAB_00403a92",
    "LAB_00403ab0",
    "LAB_00403b00",
    "LAB_00403b15",
    "LAB_00403b4f",
    "LAB_00403b72",
    "LAB_00403bf3",
    "LAB_00403bff",
    "LAB_00403c0a",
    "LAB_00403c31",
    "LAB_00403c37",
    "LAB_00403ca8",
    "LAB_00403cd2",
    "LAB_00403cf8",
    "LAB_00403d07",
    "LAB_00403d08",
    "LAB_00403d13",
    "LAB_00403d3c",
    "LAB_00403d41",
    "LAB_00403d49",
    "LAB_00403da1",
    "LAB_00403dc8",
    "LAB_00403dd2",
    "LAB_00403e66",
    "LAB_00403e6a",
    "LAB_00403ea0",
    "LAB_00403f17",
    "LAB_00403f2e",
    "LAB_00403f32",
    "LAB_00403f8c",
    "LAB_00403fa3",
    "LAB_00403fa8",
    "LAB_00404060",
    "LAB_004040f1",
    "LAB_00404120",
    "LAB_00404125",
    "LAB_00404142",
    "LAB_00404157",
    "LAB_00404165",
    "LAB_004041d9",
    "LAB_004041db",
    "LAB_004041f4",
    "LAB_00404236",
    "LAB_0040424a",
    "LAB_004042b0",
    "LAB_004042d2",
    "LAB_00404300",
    "LAB_00404314",
    "LAB_00404320",
    "LAB_004043a0",
    "LAB_004043c0",
    "LAB_004043e2",
    "LAB_004043e6",
    "LAB_004043eb",
    "LAB_00404400",
    "LAB_00404422",
    "LAB_00404426",
    "LAB_0040442b",
    "LAB_00404446",
    "LAB_00404460",
    "LAB_004044ad",
    "LAB_004044d2",
    "LAB_004044eb",
    "LAB_004044f7",
    "LAB_0040470b",
    "LAB_004047b5",
    "LAB_004047d7",
    "LAB_004047db",
    "LAB_004047e0",
    "LAB_004047f1",
    "LAB_00404813",
    "LAB_00404817",
    "LAB_0040481c",
    "LAB_00404830",
    "LAB_00404840",
    "LAB_00404886",
    "LAB_004048a4",
    "LAB_0040492c",
    "LAB_00404953",
    "LAB_00404962",
    "LAB_00404a10",
    "LAB_00404a39",
    "LAB_00404a79",
    "LAB_00404ac8",
    "LAB_00404b63",
    "LAB_00404bc0",
    "LAB_00404bc5",
    "LAB_00404bee",
    "LAB_00404bf5",
    "LAB_00404bfa",
    "LAB_00404c07",
    "LAB_00404c17",
    "LAB_00404c27",
    "LAB_00404c3a",
    "LAB_00404c3e",
    "LAB_00404c81",
    "LAB_00404cf0",
    "LAB_00404cf7",
    "LAB_00404cfc",
    "LAB_00404d0f",
    "LAB_00404d15",
    "LAB_00404d26",
    "LAB_00404d39",
    "LAB_00404dc3",
    "LAB_00404e46",
    "LAB_00404e86",
    "LAB_00404e8a",
    "LAB_00404e8f",
    "LAB_00404e9e",
    "LAB_00404ea3",
    "LAB_00404ed6",
    "LAB_00404f3b",
    "LAB_00404f4d",
    "LAB_00404f51",
    "LAB_00404f81",
    "LAB_00404fcd",
    "LAB_00404fdf",
    "LAB_00404fe3",
    "LAB_00405017",
    "LAB_00405051",
    "LAB_004050b8",
    "LAB_004050bf",
    "LAB_004050c4",
    "LAB_004050d7",
    "LAB_004050e0",
    "LAB_004050f1",
    "LAB_00405104",
    "LAB_00405155",
    "LAB_00405197",
    "LAB_004051e1",
    "LAB_004051f5",
    "LAB_0040528d",
    "LAB_0040529b",
    "LAB_0040530a",
    "LAB_00405310",
    "LAB_0040533a",
    "LAB_00405353",
    "LAB_00405391",
    "LAB_004053a6",
    "LAB_004053f1",
    "LAB_0040540c",
    "LAB_0040545a",
    "LAB_00405471",
    "LAB_00405475",
    "LAB_00405490",
    "LAB_004054b7",
    "LAB_004054d2",
    "LAB_004054ed",
    "LAB_004054fe",
    "LAB_0040552d",
    "LAB_00405543",
    "LAB_00405566",
    "LAB_00405570",
    "LAB_004055b1",
    "LAB_004055c7",
    "LAB_004055ea",
    "LAB_00405602",
    "LAB_00405631",
    "LAB_00405650",
    "LAB_00405673",
    "LAB_00405680",
    "LAB_004056af",
    "LAB_004056b9",
    "LAB_004056c7",
    "LAB_00405718",
    "LAB_0040571a",
    "LAB_0040572d",
    "LAB_0040574c",
    "LAB_0040575b",
    "LAB_00405765",
    "LAB_00405786",
    "LAB_004057b6",
    "LAB_004057c2",
    "LAB_004057ed",
    "LAB_004057fd",
    "LAB_00405801",
    "LAB_00405805",
    "LAB_0040585b",
    "LAB_00405889",
    "LAB_00405897",
    "LAB_004058c0",
    "LAB_004058f0",
    "LAB_004058fc",
    "LAB_00405927",
    "LAB_00405939",
    "LAB_00405947",
    "LAB_00405960",
    "LAB_00405983",
    "LAB_004059a8",
    "LAB_004059b0",
    "LAB_004059cd",
    "LAB_00405a00",
    "LAB_00405a23",
    "LAB_00405ac1",
    "LAB_00405ac6",
    "LAB_00405ae9",
    "LAB_00405b06",
    "LAB_00405ba0",
    "LAB_00405bc3",
    "LAB_00405be5",
    "LAB_00405c53",
    "LAB_00405c57",
    "LAB_00405c5b",
    "LAB_00405c6c",
    "LAB_00405c79",
    "LAB_00405c87",
    "LAB_00405cae",
    "LAB_00405d10",
    "LAB_00405d15",
    "LAB_00405d38",
    "LAB_00405d62",
    "LAB_00405d70",
    "LAB_00405d8b",
    "LAB_00405ddf",
    "LAB_00405df2",
    "LAB_00405e13",
    "LAB_00405e40",
    "LAB_00405e88",
    "LAB_00405eb8",
    "LAB_00405ed0",
    "LAB_00405ef4",
    "LAB_00405f32",
    "LAB_00405f50",
    "LAB_00405f76",
    "LAB_00405f8e",
    "LAB_00405fa0",
    "LAB_00405fc6",
    "LAB_00405fdc",
    "LAB_00405fec",
    "LAB_00406010",
    "LAB_00406031",
    "LAB_00406043",
    "LAB_00406075",
    "LAB_0040608c",
    "LAB_004060e1",
    "LAB_00406136",
    "LAB_004061cf",
    "LAB_00406200",
    "LAB_00406243",
    "LAB_004062a0",
    "LAB_004062f7",
    "LAB_00406310",
    "LAB_0040633e",
    "LAB_00406358",
    "LAB_00406373",
    "LAB_00406390",
    "LAB_004063b5",
    "LAB_004063d0",
    "LAB_00406406",
    "LAB_00406449",
    "LAB_004064a0",
    "LAB_004064f7",
    "LAB_0040650c",
    "LAB_00406541",
    "LAB_00406564",
    "LAB_00406589",
    "LAB_004065a4",
    "LAB_004065eb",
    "LAB_004065fe",
    "LAB_00406606",
    "LAB_00406613",
    "LAB_00406620",
    "LAB_00406622",
    "LAB_00406640",
    "LAB_004066a7",
    "LAB_004066ce",
    "LAB_00406704",
    "LAB_00406709",
    "LAB_0040671a",
    "LAB_00406753",
    "LAB_0040676f",
    "LAB_00406777",
    "LAB_00406790",
    "LAB_004067b3",
    "LAB_004067cf",
    "LAB_004067f5",
    "LAB_004067fd",
    "LAB_0040681e",
    "LAB_00406827",
    "LAB_0040682e",
    "LAB_00406839",
    "LAB_0040683d",
    "LAB_00406882",
    "LAB_00406896",
    "LAB_0040689a",
    "LAB_004068b1",
    "LAB_004068b6",
    "LAB_004068ea",
    "LAB_004068f1",
    "LAB_00406907",
    "LAB_00406913",
    "LAB_004069f4",
    "LAB_00406a0d",
    "LAB_00406a4e",
    "LAB_00406a69",
    "LAB_00406a76",
    "LAB_00406a95",
    "LAB_00406acf",
    "LAB_00406ad5",
    "LAB_00406b50",
    "LAB_00406baf",
    "LAB_00406bbf",
    "LAB_00406bcd",
    "LAB_00406bd7",
    "LAB_00406bf3",
    "LAB_00406c07",
    "LAB_00406c87",
    "LAB_00406cde",
    "LAB_00406d24",
    "LAB_00406d40",
    "LAB_00406d72",
    "LAB_00406db7",
    "LAB_00406dc9",
    "LAB_00406dd5",
    "LAB_00406e38",
    "LAB_00406e48",
    "LAB_00406e51",
    "LAB_00406e60",
    "LAB_00406e8b",
    "LAB_00406eb0",
    "LAB_00406ec0",
    "LAB_00406f79",
    "LAB_00406f90",
    "LAB_0040701e",
    "LAB_00407022",
    "LAB_00407031",
    "LAB_00407055",
    "LAB_00407069",
    "LAB_00407080",
    "LAB_00407094",
    "LAB_004070b1",
    "LAB_004070c1",
    "LAB_004072a2",
    "LAB_004072b0",
    "LAB_004072f3",
    "LAB_004072f8",
    "LAB_00407312",
    "LAB_00407395",
    "LAB_004073c0",
    "LAB_004073ce",
    "LAB_004073e0",
    "LAB_0040740f",
    "LAB_00407414",
    "LAB_00407419",
    "LAB_0040741e",
    "LAB_0040741f",
    "LAB_0040744c",
    "LAB_0040744e",
    "LAB_00407467",
    "LAB_00407474",
    "LAB_00407481",
    "LAB_00407485",
    "LAB_00407495",
    "LAB_004074c6",
    "LAB_004074e0",
    "LAB_00407501",
    "LAB_0040751d",
    "LAB_00407526",
    "LAB_0040754a",
    "LAB_00407565",
    "LAB_00407575",
    "LAB_004075c6",
    "LAB_004075d2",
    "LAB_004075e0",
    "LAB_004075e4",
    "LAB_0040760c",
    "LAB_00407627",
    "LAB_0040762e",
    "LAB_00407633",
    "LAB_00407664",
    "LAB_00407680",
    "LAB_00407686",
    "LAB_00407699",
    "LAB_0040769f",
    "LAB_004076cd",
    "LAB_00407725",
    "LAB_00407739",
    "LAB_0040773d",
    "LAB_00407767",
    "LAB_00407771",
    "LAB_00407777",
    "LAB_004077ab",
    "LAB_004077ce",
    "LAB_004077ea",
    "LAB_004077f2",
    "LAB_00407890",
    "LAB_004078b3",
    "LAB_004078d3",
    "LAB_0040790c",
    "LAB_00407917",
    "LAB_00407937",
    "LAB_00407949",
    "LAB_00407970",
    "LAB_00407995",
    "LAB_004079d2",
    "LAB_00407a0b",
    "LAB_00407a50",
    "LAB_00407a68",
    "LAB_00407a77",
    "LAB_00407a90",
    "LAB_00407ab0",
    "LAB_00407abf",
    "LAB_00407ac5",
    "LAB_00407ad2",
    "LAB_00407ad6",
    "LAB_00407ae8",
    "LAB_00407b09",
    "LAB_00407b1d",
    "LAB_00407b21",
    "LAB_00407b40",
    "LAB_00407b44",
    "LAB_00407b7b",
    "LAB_00407b95",
    "LAB_00407ba2",
    "LAB_00407bb3",
    "LAB_00407bbe",
    "LAB_00407bc6",
    "LAB_00407bcd",
    "LAB_00407c2f",
    "LAB_00407c54",
    "LAB_00407c64",
    "LAB_00407c6d",
    "LAB_00407cd8",
    "LAB_00407d01",
    "LAB_00407d09",
    "LAB_00407d11",
    "LAB_00407d43",
    "LAB_00407d4a",
    "LAB_00407d97",
    "LAB_00407db4",
    "LAB_00407db9",
    "LAB_00407de9",
    "LAB_00407e07",
    "LAB_00407e38",
    "LAB_00407e41",
    "LAB_00407e94",
    "LAB_00407ed1",
    "LAB_00407eed",
    "LAB_00407f09",
    "LAB_00407f17",
    "LAB_00407f45",
    "LAB_00407f46",
    "LAB_00407f4a",
    "LAB_00407f54",
    "LAB_00407f9b",
    "LAB_004080a2",
    "LAB_0040817e",
    "LAB_0040818d",
    "LAB_00408194",
    "LAB_00408196",
    "LAB_00408199",
    "LAB_004081a9",
    "LAB_004081ba",
    "LAB_004081be",
    "LAB_004081ce",
    "LAB_004081e2",
    "LAB_004081f0",
    "LAB_004081f4",
    "LAB_00408207",
    "LAB_0040821e",
    "LAB_0040823e",
    "LAB_00408251",
    "LAB_00408295",
    "LAB_0040829a",
    "LAB_0040831d",
    "LAB_00408326",
    "LAB_00408347",
    "LAB_0040835b",
    "LAB_0040836d",
    "LAB_00408395",
    "LAB_004083a0",
    "LAB_004083f1",
    "LAB_00408439",
    "LAB_00408449",
    "LAB_00408457",
    "LAB_00408492",
    "LAB_004084f0",
    "LAB_004085ea",
    "LAB_00408631",
    "LAB_00408637",
    "LAB_00408656",
    "LAB_00408665",
    "LAB_0040866d",
    "LAB_00408681",
    "LAB_00408690",
    "LAB_00408698",
    "LAB_004087ca",
    "LAB_004087db",
    "LAB_004087e1",
    "LAB_00408828",
    "LAB_0040889e",
    "LAB_00408905",
    "LAB_00408940",
    "LAB_0040897d",
    "LAB_00408990",
    "LAB_00408995",
    "LAB_004089b1",
    "LAB_004089c5",
    "LAB_004089cd",
    "LAB_004089db",
    "LAB_004089eb",
    "LAB_00408a00",
    "LAB_00408a13",
    "LAB_00408a53",
    "LAB_00408a77",
    "LAB_00408a88",
    "LAB_00408aa0",
    "LAB_00408ab5",
    "LAB_00408ac0",
    "LAB_00408afc",
    "LAB_00408afe",
    "LAB_00408b02",
    "LAB_00408b07",
    "LAB_00408b2f",
    "LAB_00408b36",
    "LAB_00408b3d",
    "LAB_00408b44",
    "LAB_00408b8d",
    "LAB_00408bbd",
    "LAB_00408bdd",
    "LAB_00408bef",
    "LAB_00408c04",
    "LAB_00408c08",
    "LAB_00408c1b",
    "LAB_00408c1e",
    "LAB_00408c43",
    "LAB_00408c57",
    "LAB_00408c5e",
    "LAB_00408c81",
    "LAB_00408c83",
    "LAB_00408cb0",
    "LAB_00408cd4",
    "LAB_00408ce7",
    "LAB_00408d00",
    "LAB_00408d39",
    "LAB_00408d50",
    "LAB_00408d6c",
    "LAB_00408dbd",
    "LAB_00408dc8",
    "LAB_00408e16",
    "LAB_00408e20",
    "LAB_00408e6c",
    "LAB_00408e84",
    "LAB_00408e97",
    "LAB_00408eae",
    "LAB_00408eb7",
    "LAB_00408ebf",
    "LAB_00408ed2",
    "LAB_00408f44",
    "LAB_00408f70",
    "LAB_00408f7d",
    "LAB_00408ff5",
    "LAB_00408ffd",
    "LAB_0040900c",
    "LAB_0040907c",
    "LAB_00409081",
    "LAB_004090a4",
    "LAB_004090ac",
    "LAB_004090c1",
    "LAB_004090c5",
    "LAB_004090d4",
    "LAB_004090e0",
    "LAB_004090ed",
    "LAB_00409100",
    "LAB_0040915d",
    "LAB_00409170",
    "LAB_0040918b",
    "LAB_00409197",
    "LAB_004091a6",
    "LAB_004091ad",
    "LAB_004091c0",
    "LAB_004091d0",
    "LAB_004091e3",
    "LAB_004091ec",
    "LAB_004091f1",
    "LAB_004091fe",
    "LAB_0040922f",
    "LAB_004092b1",
    "LAB_00409319",
    "LAB_0040931c",
    "LAB_0040932c",
    "LAB_0040932f",
    "LAB_0040933e",
    "LAB_0040934a",
    "LAB_00409353",
    "LAB_0040936e",
    "LAB_0040937a",
    "LAB_00409384",
    "LAB_00409396",
    "LAB_004093c9",
    "LAB_004093cc",
    "LAB_004093dc",
    "LAB_004093fa",
    "LAB_00409432",
    "LAB_00409454",
    "LAB_00409482",
    "LAB_00409490",
    "LAB_004094d5",
    "LAB_00409576",
    "LAB_0040958f",
    "LAB_00409592",
    "LAB_004095aa",
    "LAB_004095c5",
    "LAB_004095d1",
    "LAB_004095fa",
    "LAB_00409601",
    "LAB_00409619",
    "LAB_0040962f",
    "LAB_00409684",
    "LAB_00409688",
    "LAB_00409690",
    "LAB_004096aa",
    "LAB_004096ac",
    "LAB_004096cb",
    "LAB_004096d3",
    "LAB_004096d9",
    "LAB_004096e9",
    "LAB_004096eb",
    "LAB_00409718",
    "LAB_0040974c",
    "LAB_0040974e",
    "LAB_0040975b",
    "LAB_0040976a",
    "LAB_0040976c",
    "LAB_0040976d",
    "LAB_004097a3",
    "LAB_004097dc",
    "LAB_004097e2",
    "LAB_00409819",
    "LAB_0040981f",
    "LAB_00409859",
    "LAB_00409865",
    "LAB_00409896",
    "LAB_004098b1",
    "LAB_004098c3",
    "LAB_004098c6",
    "LAB_004098d2",
    "LAB_00409920",
    "LAB_00409964",
    "LAB_0040998e",
    "LAB_004099aa",
    "LAB_004099d5",
    "LAB_004099d7",
    "LAB_00409a37",
    "LAB_00409a80",
    "LAB_00409a97",
    "LAB_00409ac6",
    "LAB_00409ad0",
    "LAB_00409b05",
    "LAB_00409b0e",
    "LAB_00409b18",
    "LAB_00409b37",
    "LAB_00409b46",
    "LAB_00409b4a",
    "LAB_00409b51",
    "LAB_00409b57",
    "LAB_00409b5b",
    "LAB_00409b65",
    "LAB_00409b86",
    "LAB_00409b8f",
    "LAB_00409b99",
    "LAB_00409bb4",
    "LAB_00409bc6",
    "LAB_00409bca",
    "LAB_00409bd1",
    "LAB_00409bd7",
    "LAB_00409bdb",
    "LAB_00409bdf",
    "LAB_00409bed",
    "LAB_00409bf7",
    "LAB_00409bf9",
    "LAB_00409c2f",
    "LAB_00409c44",
    "LAB_00409c5f",
    "LAB_00409c6e",
    "LAB_00409c7b",
    "LAB_00409c9e",
    "LAB_00409cad",
    "LAB_00409cb1",
    "LAB_00409cbc",
    "LAB_00409cc4",
    "LAB_00409cc8",
    "LAB_00409cd4",
    "LAB_00409cf4",
    "LAB_00409d09",
    "LAB_00409d24",
    "LAB_00409d33",
    "LAB_00409d40",
    "LAB_00409d5f",
    "LAB_00409d71",
    "LAB_00409d75",
    "LAB_00409d80",
    "LAB_00409d88",
    "LAB_00409d8c",
    "LAB_00409d90",
    "LAB_00409d9e",
    "LAB_00409daa",
    "LAB_00409dac",
    "LAB_00409dae",
    "LAB_00409de8",
    "LAB_00409e1c",
    "LAB_00409e2f",
    "LAB_00409e39",
    "LAB_00409e69",
    "LAB_00409e6e",
    "LAB_00409e81",
    "LAB_00409ea9",
    "LAB_00409edc",
    "LAB_00409f07",
    "LAB_00409f31",
    "LAB_00409f3c",
    "LAB_00409f41",
    "LAB_00409f43",
    "LAB_00409f4a",
    "LAB_00409f60",
    "LAB_00409f74",
    "LAB_00409f84",
    "LAB_00409f9b",
    "LAB_00409fa2",
    "LAB_00409fb4",
    "LAB_00409fd7",
    "LAB_0040a008",
    "LAB_0040a01b",
    "LAB_0040a020",
    "LAB_0040a033",
    "LAB_0040a064",
    "LAB_0040a08d",
    "LAB_0040a08f",
    "LAB_0040a0a0",
    "LAB_0040a0b3",
    "LAB_0040a0c3",
    "LAB_0040a0c5",
    "LAB_0040a0cc",
    "LAB_0040a0da",
    "LAB_0040a12f",
    "LAB_0040a13f",
    "LAB_0040a141",
    "LAB_0040a147",
    "LAB_0040a1b3",
    "LAB_0040a1b7",
    "LAB_0040a1b9",
    "LAB_0040a1c5",
    "LAB_0040a1c9",
    "LAB_0040a1cb",
    "LAB_0040a1db",
    "LAB_0040a1df",
    "LAB_0040a1e1",
    "LAB_0040a1eb",
    "LAB_0040a1ed",
    "LAB_0040a202",
    "LAB_0040a20a",
    "LAB_0040a227",
    "LAB_0040a23c",
    "LAB_0040a24d",
    "LAB_0040a283",
    "LAB_0040a2a2",
    "LAB_0040a2a9",
    "LAB_0040a310",
    "LAB_0040a333",
    "LAB_0040a335",
    "LAB_0040a336",
    "LAB_0040a339",
    "LAB_0040a33c",
    "LAB_0040a352",
    "LAB_0040a361",
    "LAB_0040a391",
    "LAB_0040a3d3",
    "LAB_0040a403",
    "LAB_0040a424",
    "LAB_0040a441",
    "LAB_0040a443",
    "LAB_0040a490",
    "LAB_0040a4bd",
    "LAB_0040a4eb",
    "LAB_0040a4f9",
    "LAB_0040a523",
    "LAB_0040a53c",
    "LAB_0040a564",
    "LAB_0040a582",
    "LAB_0040a5e3",
    "LAB_0040a619",
    "LAB_0040a624",
    "LAB_0040a630",
    "LAB_0040a648",
    "LAB_0040a64f",
    "LAB_0040a652",
    "LAB_0040a670",
    "LAB_0040a683",
    "LAB_0040a687",
    "LAB_0040a689",
    "LAB_0040a68c",
    "LAB_0040a6dc",
    "LAB_0040a6f4",
    "LAB_0040a752",
    "LAB_0040a75c",
    "LAB_0040a765",
    "LAB_0040a76f",
    "LAB_0040a78e",
    "LAB_0040a79d",
    "LAB_0040a7bd",
    "LAB_0040a7c8",
    "LAB_0040a7da",
    "LAB_0040a7e1",
    "LAB_0040a80d",
    "LAB_0040a80f",
    "LAB_0040a84d",
    "LAB_0040a90c",
    "LAB_0040a926",
    "LAB_0040a944",
    "LAB_0040a961",
    "LAB_0040a96d",
    "LAB_0040a980",
    "LAB_0040a999",
    "LAB_0040a99e",
    "LAB_0040a9a0",
    "LAB_0040aaa4",
    "LAB_0040aab4",
    "LAB_0040aab6",
    "LAB_0040aabd",
    "LAB_0040aae3",
    "LAB_0040aae8",
    "LAB_0040aaf8",
    "LAB_0040ab18",
    "LAB_0040ab38",
    "LAB_0040ab58",
    "LAB_0040ab6c",
    "LAB_0040ab6f",
    "LAB_0040ab7a",
    "LAB_0040ab9c",
    "LAB_0040aba8",
    "LAB_0040abad",
    "LAB_0040abd6",
    "LAB_0040abde",
    "LAB_0040abe6",
    "LAB_0040abef",
    "LAB_0040ac27",
    "LAB_0040ac29",
    "LAB_0040ac2d",
    "LAB_0040ac55",
    "LAB_0040ac69",
    "LAB_0040ac6f",
    "LAB_0040ac74",
    "LAB_0040acbf",
    "LAB_0040acc7",
    "LAB_0040ad05",
    "LAB_0040ad0c",
    "LAB_0040ad2d",
    "LAB_0040ad3c",
    "LAB_0040adba",
    "LAB_0040adee",
    "LAB_0040ae11",
    "LAB_0040ae23",
    "LAB_0040af02",
    "LAB_0040af1a",
    "LAB_0040af22",
    "LAB_0040af74",
    "LAB_0040af7b",
    "LAB_0040afcf",
    "LAB_0040afe3",
    "LAB_0040aff9",
    "LAB_0040b003",
    "LAB_0040b006",
    "LAB_0040b027",
    "LAB_0040b02b",
    "LAB_0040b03a",
    "LAB_0040b03e",
    "LAB_0040b043",
    "LAB_0040b050",
    "LAB_0040b07e",
    "LAB_0040b096",
    "LAB_0040b09e",
    "LAB_0040b0f0",
    "LAB_0040b0f7",
    "LAB_0040b14a",
    "LAB_0040b15e",
    "LAB_0040b178",
    "LAB_0040b182",
    "LAB_0040b188",
    "LAB_0040b1a9",
    "LAB_0040b1ad",
    "LAB_0040b1bc",
    "LAB_0040b1c0",
    "LAB_0040b1c5",
    "LAB_0040b1d2",
    "LAB_0040b1ea",
    "LAB_0040b21e",
    "LAB_0040b233",
    "LAB_0040b23b",
    "LAB_0040b23f",
    "LAB_0040b267",
    "LAB_0040b270",
    "LAB_0040b271",
    "LAB_0040b2a6",
    "LAB_0040b2a8",
    "LAB_0040b2b1",
    "LAB_0040b2b5",
    "LAB_0040b2e7",
    "LAB_0040b2f5",
    "LAB_0040b2f7",
    "LAB_0040b300",
    "LAB_0040b304",
    "LAB_0040b321",
    "LAB_0040b323",
    "LAB_0040b33f",
    "LAB_0040b34d",
    "LAB_0040b358",
    "LAB_0040b37e",
    "LAB_0040b388",
    "LAB_0040b3b6",
    "LAB_0040b3c7",
    "LAB_0040b3d4",
    "LAB_0040b404",
    "LAB_0040b40e",
    "LAB_0040b434",
    "LAB_0040b44b",
    "LAB_0040b44c",
    "LAB_0040b460",
    "LAB_0040b477",
    "LAB_0040b478",
    "LAB_0040b492",
    "LAB_0040b4a7",
    "LAB_0040b4a9",
    "LAB_0040b63e",
    "LAB_0040b654",
    "LAB_0040b659",
    "LAB_0040b69d",
    "LAB_0040b77f",
    "LAB_0040b7b9",
    "LAB_0040b7be",
    "LAB_0040b7c4",
    "LAB_0040b7cd",
    "LAB_0040b7d6",
    "LAB_0040b7dc",
    "LAB_0040b7de",
    "LAB_0040b7e9",
    "LAB_0040b7f3",
    "LAB_0040b814",
    "LAB_0040b816",
    "LAB_0040b848",
    "LAB_0040b84a",
    "LAB_0040b873",
    "LAB_0040b87f",
    "LAB_0040b894",
    "LAB_0040b8a8",
    "LAB_0040b8fe",
    "LAB_0040b900",
    "LAB_0040b90b",
    "LAB_0040b95c",
    "LAB_0040b95e",
    "LAB_0040b969",
    "LAB_0040b98b",
    "LAB_0040b997",
    "LAB_0040b9af",
    "LAB_0040b9ba",
    "LAB_0040ba37",
    "LAB_0040ba3f",
    "LAB_0040ba52",
    "LAB_0040ba68",
    "LAB_0040baa7",
    "LAB_0040bab3",
    "LAB_0040bacb",
    "LAB_0040bad6",
    "LAB_0040bb53",
    "LAB_0040bb5b",
    "LAB_0040bb6e",
    "LAB_0040bb84",
    "LAB_0040bbc3",
    "LAB_0040bbcf",
    "LAB_0040bbe7",
    "LAB_0040bbf2",
    "LAB_0040bc70",
    "LAB_0040bc78",
    "LAB_0040bc8f",
    "LAB_0040bca5",
    "LAB_0040bcee",
    "LAB_0040bcf4",
    "LAB_0040bcfa",
    "LAB_0040bd00",
    "LAB_0040bd04",
    "LAB_0040bd2b",
    "LAB_0040bd31",
    "LAB_0040bd37",
    "LAB_0040bd3d",
    "LAB_0040bd41",
    "LAB_0040bd60",
    "LAB_0040bd7f",
    "LAB_0040bd9e",
    "LAB_0040bdb3",
    "LAB_0040bddd",
    "LAB_0040be6a",
    "LAB_0040be6c",
    "LAB_0040becb",
    "LAB_0040becd",
    "LAB_0040bee2",
    "LAB_0040bef7",
    "LAB_0040bf0b",
    "LAB_0040bf20",
    "LAB_0040bf44",
    "LAB_0040bf5b",
    "LAB_0040bf6e",
    "LAB_0040bfb6",
    "LAB_0040bfc2",
    "LAB_0040bfce",
    "LAB_0040bfda",
    "LAB_0040bffb",
    "LAB_0040c014",
    "LAB_0040c02c",
    "LAB_0040c035",
    "LAB_0040c03e",
    "LAB_0040c05b",
    "LAB_0040c064",
    "LAB_0040c06d",
    "LAB_0040c082",
    "LAB_0040c089",
    "LAB_0040c0ad",
    "LAB_0040c0c4",
    "LAB_0040c0d7",
    "LAB_0040c11f",
    "LAB_0040c12b",
    "LAB_0040c137",
    "LAB_0040c143",
    "LAB_0040c164",
    "LAB_0040c17d",
    "LAB_0040c195",
    "LAB_0040c19e",
    "LAB_0040c1a7",
    "LAB_0040c1c4",
    "LAB_0040c1cd",
    "LAB_0040c1d6",
    "LAB_0040c1eb",
    "LAB_0040c1f2",
    "LAB_0040c218",
    "LAB_0040c230",
    "LAB_0040c243",
    "LAB_0040c28c",
    "LAB_0040c298",
    "LAB_0040c2a4",
    "LAB_0040c2b0",
    "LAB_0040c2d4",
    "LAB_0040c2ef",
    "LAB_0040c30d",
    "LAB_0040c316",
    "LAB_0040c31f",
    "LAB_0040c33e",
    "LAB_0040c347",
    "LAB_0040c350",
    "LAB_0040c367",
    "LAB_0040c36e",
    "LAB_0040c3b7",
    "LAB_0040c3be",
    "LAB_0040c3c6",
    "LAB_0040c3cd",
    "LAB_0040c3ce",
    "LAB_0040c3d2",
    "LAB_0040c3e2",
    "LAB_0040c3ec",
    "LAB_0040c3f5",
    "LAB_0040c419",
    "LAB_0040c422",
    "LAB_0040c426",
    "LAB_0040c429",
    "LAB_0040c432",
    "LAB_0040c43b",
    "LAB_0040c447",
    "LAB_0040c465",
    "LAB_0040c472",
    "LAB_0040c499",
    "LAB_0040c4a3",
    "LAB_0040c4af",
    "LAB_0040c4b1",
    "LAB_0040c4be",
    "LAB_0040c4c7",
    "LAB_0040c4c9",
    "LAB_0040c4d7",
    "LAB_0040c4d9",
    "LAB_0040c4e1",
    "LAB_0040c4f4",
    "LAB_0040c4f6",
    "LAB_0040c508",
    "LAB_0040c52b",
    "LAB_0040c56c",
    "LAB_0040c597",
    "LAB_0040c59a",
    "LAB_0040c5e6",
    "LAB_0040c5ed",
    "LAB_0040c5f5",
    "LAB_0040c5fc",
    "LAB_0040c5fd",
    "LAB_0040c601",
    "LAB_0040c611",
    "LAB_0040c61b",
    "LAB_0040c624",
    "LAB_0040c648",
    "LAB_0040c651",
    "LAB_0040c655",
    "LAB_0040c658",
    "LAB_0040c661",
    "LAB_0040c66a",
    "LAB_0040c676",
    "LAB_0040c694",
    "LAB_0040c6a1",
    "LAB_0040c6c8",
    "LAB_0040c6d2",
    "LAB_0040c6de",
    "LAB_0040c6e0",
    "LAB_0040c6ed",
    "LAB_0040c6f6",
    "LAB_0040c6f8",
    "LAB_0040c706",
    "LAB_0040c708",
    "LAB_0040c710",
    "LAB_0040c723",
    "LAB_0040c725",
    "LAB_0040c737",
    "LAB_0040c75a",
    "LAB_0040c79b",
    "LAB_0040c7c6",
    "LAB_0040c7c9",
    "LAB_0040c822",
    "LAB_0040c829",
    "LAB_0040c831",
    "LAB_0040c838",
    "LAB_0040c83a",
    "LAB_0040c83e",
    "LAB_0040c84e",
    "LAB_0040c858",
    "LAB_0040c861",
    "LAB_0040c885",
    "LAB_0040c88e",
    "LAB_0040c892",
    "LAB_0040c895",
    "LAB_0040c89e",
    "LAB_0040c8a7",
    "LAB_0040c8b3",
    "LAB_0040c8d1",
    "LAB_0040c8ff",
    "LAB_0040c906",
    "LAB_0040c90e",
    "LAB_0040c91a",
    "LAB_0040c91c",
    "LAB_0040c92d",
    "LAB_0040c93a",
    "LAB_0040c93c",
    "LAB_0040c94d",
    "LAB_0040c94f",
    "LAB_0040c95a",
    "LAB_0040c973",
    "LAB_0040c975",
    "LAB_0040c98a",
    "LAB_0040c9ad",
    "LAB_0040c9ee",
    "LAB_0040ca19",
    "LAB_0040ca1a",
    "LAB_0040ca1c",
    "LAB_0040ca3c",
    "LAB_0040ca54",
    "LAB_0040ca68",
    "LAB_0040ca80",
    "LAB_0040ca99",
    "LAB_0040cb25",
    "LAB_0040cb2a",
    "LAB_0040cb38",
    "LAB_0040cb3c",
    "LAB_0040cb88",
    "LAB_0040cb8d",
    "LAB_0040cb9b",
    "LAB_0040cb9f",
    "LAB_0040cbcf",
    "LAB_0040cbd8",
    "LAB_0040cbe5",
    "LAB_0040cbec",
    "LAB_0040cc12",
    "LAB_0040cc1e",
    "LAB_0040cc51",
    "LAB_0040cc9d",
    "LAB_0040cca8",
    "LAB_0040ccbf",
    "LAB_0040cccf",
    "LAB_0040cce4",
    "LAB_0040cce8",
    "LAB_0040cceb",
    "LAB_0040cd32",
    "LAB_0040cd3b",
    "LAB_0040cd4b",
    "LAB_0040cd52",
    "LAB_0040cd78",
    "LAB_0040cd84",
    "LAB_0040cdb7",
    "LAB_0040ce03",
    "LAB_0040ce17",
    "LAB_0040ce2e",
    "LAB_0040ce3e",
    "LAB_0040ce53",
    "LAB_0040ce5a",
    "LAB_0040ce5d",
    "LAB_0040ceab",
    "LAB_0040cecc",
    "LAB_0040ced8",
    "LAB_0040ceeb",
    "LAB_0040cef7",
    "LAB_0040cf49",
    "LAB_0040cf69",
    "LAB_0040cf75",
    "LAB_0040cf78",
    "LAB_0040cf84",
    "LAB_0040cfdb",
    "LAB_0040cff2",
    "LAB_0040d008",
    "LAB_0040d00f",
    "LAB_0040d026",
    "LAB_0040d02c",
    "LAB_0040d043",
    "LAB_0040d047",
    "LAB_0040d04a",
    "LAB_0040d061",
    "LAB_0040d06e",
    "LAB_0040d07e",
    "LAB_0040d08f",
    "LAB_0040d099",
    "LAB_0040d0af",
    "LAB_0040d0b7",
    "LAB_0040d0cf",
    "LAB_0040d0db",
    "LAB_0040d0dd",
    "LAB_0040d0fc",
    "LAB_0040d110",
    "LAB_0040d139",
    "LAB_0040d140",
    "LAB_0040d149",
    "LAB_0040d14e",
    "LAB_0040d154",
    "LAB_0040d16c",
    "LAB_0040d1af",
    "LAB_0040d1d3",
    "LAB_0040d1e2",
    "LAB_0040d1ed",
    "LAB_0040d1f6",
    "LAB_0040d222",
    "LAB_0040d246",
    "LAB_0040d257",
    "LAB_0040d262",
    "LAB_0040d26c",
    "LAB_0040d289",
    "LAB_0040d2a5",
    "LAB_0040d2ac",
    "LAB_0040d2ad",
    "LAB_0040d2ce",
    "LAB_0040d2ee",
    "LAB_0040d330",
    "LAB_0040d332",
    "LAB_0040d354",
    "LAB_0040d35a",
    "LAB_0040d36e",
    "LAB_0040d370",
    "LAB_0040d38c",
    "LAB_0040d3a7",
    "LAB_0040d3ac",
    "LAB_0040d3ce",
    "LAB_0040d3d1",
    "LAB_0040d3d8",
    "LAB_0040d3ee",
    "LAB_0040d410",
    "LAB_0040d413",
    "LAB_0040d41a",
    "LAB_0040d433",
    "LAB_0040d464",
    "LAB_0040d4ab",
    "LAB_0040d4b1",
    "LAB_0040d4c9",
    "LAB_0040d50b",
    "LAB_0040d552",
    "LAB_0040d558",
    "LAB_0040d570",
    "LAB_0040d5a7",
    "LAB_0040d5e7",
    "LAB_0040d5ed",
    "LAB_0040d605",
    "LAB_0040d638",
    "LAB_0040d657",
    "LAB_0040d67d",
    "LAB_0040d683",
    "LAB_0040d686",
    "LAB_0040d691",
    "LAB_0040d693",
    "LAB_0040d6cd",
    "LAB_0040d6d5",
    "LAB_0040d6e2",
    "LAB_0040d70b",
    "LAB_0040d714",
    "LAB_0040d716",
    "LAB_0040d717",
    "LAB_0040d71a",
    "LAB_0040d725",
    "LAB_0040d760",
    "LAB_0040d768",
    "LAB_0040d774",
    "LAB_0040d7a5",
    "LAB_0040d7af",
    "LAB_0040d7b1",
    "LAB_0040d7b4",
    "LAB_0040d7bf",
    "LAB_0040d7f7",
    "LAB_0040d80c",
    "LAB_0040d83a",
    "LAB_0040d8bc",
    "LAB_0040d8de",
    "LAB_0040d8e3",
    "LAB_0040d8f6",
    "LAB_0040d8fe",
    "LAB_0040d906",
    "LAB_0040d91c",
    "LAB_0040d923",
    "LAB_0040d928",
    "LAB_0040d92f",
    "LAB_0040d935",
    "LAB_0040d93f",
    "LAB_0040d975",
    "LAB_0040d97f",
    "LAB_0040d989",
    "LAB_0040d98d",
    "LAB_0040d997",
    "LAB_0040d999",
    "LAB_0040d9a3",
    "LAB_0040d9ac",
    "LAB_0040da00",
    "LAB_0040da3f",
    "LAB_0040da61",
    "LAB_0040da66",
    "LAB_0040da98",
    "LAB_0040daa0",
    "LAB_0040dac4",
    "LAB_0040dad0",
    "LAB_0040dad2",
    "LAB_0040dad5",
    "LAB_0040daf8",
    "LAB_0040db5e",
    "LAB_0040db61",
    "LAB_0040dbd0",
    "LAB_0040dc98",
    "LAB_0040dcb1",
    "LAB_0040dcb5",
    "LAB_0040dcc4",
    "LAB_0040dd09",
    "LAB_0040dd0c",
    "LAB_0040dd43",
    "LAB_0040dda7",
    "LAB_0040ddb4",
    "LAB_0040ddb9",
    "LAB_0040de3d",
    "LAB_0040de46",
    "LAB_0040de61",
    "LAB_0040de88",
    "LAB_0040debd",
    "LAB_0040dec2",
    "LAB_0040dee5",
    "LAB_0040df22",
    "LAB_0040df31",
    "LAB_0040df4a",
    "LAB_0040df57",
    "LAB_0040df5c",
    "LAB_0040df63",
    "LAB_0040df65",
    "LAB_0040df79",
    "LAB_0040dfd0",
    "LAB_0040dfd4",
    "LAB_0040dfd6",
    "LAB_0040dff5",
    "LAB_0040e002",
    "LAB_0040e00c",
    "LAB_0040e014",
    "LAB_0040e018",
    "LAB_0040e02c",
    "LAB_0040e041",
    "LAB_0040e09a",
    "LAB_0040e0b2",
    "LAB_0040e0c7",
    "LAB_0040e0df",
    "LAB_0040e0ea",
    "LAB_0040e0ee",
    "LAB_0040e0f0",
    "LAB_0040e10b",
    "LAB_0040e13e",
    "LAB_0040e16f",
    "LAB_0040e18f",
    "LAB_0040e19f",
    "LAB_0040e1ae",
    "LAB_0040e1da",
    "LAB_0040e1fe",
    "LAB_0040e216",
    "LAB_0040e246",
    "LAB_0040e250",
    "LAB_0040e27b",
    "LAB_0040e28c",
    "LAB_0040e2bd",
    "LAB_0040e2c2",
    "LAB_0040e2c7",
    "LAB_0040e2cc",
    "LAB_0040e2cf",
    "LAB_0040e2e4",
    "LAB_0040e306",
    "LAB_0040e30d",
    "LAB_0040e320",
    "LAB_0040e322",
    "LAB_0040e324",
    "LAB_0040e32a",
    "LAB_0040e334",
    "LAB_0040e33e",
    "LAB_0040e37a",
    "LAB_0040e38a",
    "LAB_0040e3be",
    "LAB_0040e3c9",
    "LAB_0040e3e6",
    "LAB_0040e3fd",
    "LAB_0040e408",
    "LAB_0040e434",
    "LAB_0040e43f",
    "LAB_0040e45c",
    "LAB_0040e473",
    "LAB_0040e47e",
    "LAB_0040e49e",
    "LAB_0040e4a2",
    "LAB_0040e4a7",
    "LAB_0040e4b4",
    "LAB_0040e4da",
    "LAB_0040e4dd",
    "LAB_0040e4fd",
    "LAB_0040e501",
    "LAB_0040e506",
    "LAB_0040e513",
    "LAB_0040e539",
    "LAB_0040e53c",
    "LAB_0040e567",
    "LAB_0040e57b",
    "LAB_0040e589",
    "LAB_0040e5bf",
    "LAB_0040e5d1",
    "LAB_0040e5df",
    "LAB_0040e606",
    "LAB_0040e616",
    "LAB_0040e61a",
    "LAB_0040e648",
    "LAB_0040e664",
    "LAB_0040e68d",
    "LAB_0040e6a3",
    "LAB_0040e6d3",
    "LAB_0040e6d9",
    "LAB_0040e6f4",
    "LAB_0040e6f8",
    "LAB_0040e70d",
    "LAB_0040e73e",
    "LAB_0040e75b",
    "LAB_0040e784",
    "LAB_0040e7a2",
    "LAB_0040e7d7",
    "LAB_0040e7fd",
    "LAB_0040e808",
    "LAB_0040e80b",
    "LAB_0040e823",
    "LAB_0040e835",
    "LAB_0040e839",
    "LAB_0040e847",
    "LAB_0040e852",
    "LAB_0040e877",
    "LAB_0040e87a",
    "LAB_0040e88a",
    "LAB_0040e88c",
    "LAB_0040e8a8",
    "LAB_0040e8aa",
    "LAB_0040e8de",
    "LAB_0040e91b",
    "LAB_0040e96d",
    "LAB_0040e985",
    "LAB_0040e9ef",
    "LAB_0040e9fd",
    "LAB_0040ea1b",
    "LAB_0040ea26",
    "LAB_0040ea2b",
    "LAB_0040ea2e",
    "LAB_0040eaa5",
    "LAB_0040eab9",
    "LAB_0040eac1",
    "LAB_0040ead3",
    "LAB_0040eae0",
    "LAB_0040eaeb",
    "LAB_0040eafe",
    "LAB_0040eb19",
    "LAB_0040eb1d",
    "LAB_0040eb56",
    "LAB_0040eb65",
    "LAB_0040eb67",
    "LAB_0040eb68",
    "LAB_0040eb81",
    "LAB_0040eb8c",
    "LAB_0040eb91",
    "LAB_0040ebad",
    "LAB_0040ebaf",
    "LAB_0040ebef",
    "LAB_0040ec2d",
    "LAB_0040ec49",
    "LAB_0040ec55",
    "LAB_0040ec6a",
    "LAB_0040ec81",
    "LAB_0040ecaf",
    "LAB_0040ecd8",
    "LAB_0040ed0d",
    "LAB_0040ed7c",
    "LAB_0040ed99",
    "LAB_0040edbe",
    "LAB_0040edc2",
    "LAB_0040edd1",
    "LAB_0040edd4",
    "LAB_0040edde",
    "LAB_0040ee1b",
    "LAB_0040ee32",
    "LAB_0040ee81",
    "LAB_0040eebe",
    "LAB_0040eec5",
    "LAB_0040eeea",
    "LAB_0040eeee",
    "LAB_0040eefb",
    "LAB_0040ef04",
    "LAB_0040ef32",
    "LAB_0040ef3d",
    "LAB_0040ef58",
    "LAB_0040ef81",
    "LAB_0040ef8c",
    "LAB_0040ef8e",
    "LAB_0040ef9c",
    "LAB_0040efbe",
    "LAB_0040eff5",
    "LAB_0040f008",
    "LAB_0040f035",
    "LAB_0040f059",
    "LAB_0040f06e",
    "LAB_0040f0ab",
    "LAB_0040f0b6",
    "LAB_0040f0b9",
    "LAB_0040f0bb",
    "LAB_0040f0ca",
    "LAB_0040f0d7",
    "LAB_0040f0e0",
    "LAB_0040f157",
    "LAB_0040f182",
    "LAB_0040f192",
    "LAB_0040f195",
    "LAB_0040f1a4",
    "LAB_0040f1db",
    "LAB_0040f1e8",
    "LAB_0040f1f5",
    "LAB_0040f1fe",
    "LAB_0040f29f",
    "LAB_0040f2a6",
    "LAB_0040f2f1",
    "LAB_0040f321",
    "LAB_0040f35e",
    "LAB_0040f36e",
    "LAB_0040f3a6",
    "LAB_0040f3d0",
    "LAB_0040f3de",
    "LAB_0040f3e7",
    "LAB_0040f412",
    "LAB_0040f41a",
    "LAB_0040f431",
    "LAB_0040f458",
    "LAB_0040f466",
    "LAB_0040f473",
    "LAB_0040f4fc",
    "LAB_0040f501",
    "LAB_0040f504",
    "LAB_0040f50a",
    "LAB_0040f51d",
    "LAB_0040f533",
    "LAB_0040f57b",
    "LAB_0040f5d0",
    "LAB_0040f5d3",
    "LAB_0040f5e7",
    "LAB_0040f5f5",
    "LAB_0040f61c",
    "LAB_0040f620",
    "LAB_0040f65c",
    "LAB_0040f6c6",
    "LAB_0040f6cb",
    "LAB_0040f6ce",
    "LAB_0040f6d4",
    "LAB_0040f6e4",
    "LAB_0040f6fa",
    "LAB_0040f721",
    "LAB_0040f74c",
    "LAB_0040f764",
    "LAB_0040f80a",
    "LAB_0040f84d",
    "LAB_0040f85a",
    "LAB_0040f879",
    "LAB_0040f89c",
    "LAB_0040f8ad",
    "LAB_0040f8b0",
    "LAB_0040f8de",
    "LAB_0040f8e5",
    "LAB_0040f8ec",
    "LAB_0040f8f3",
    "LAB_0040f912",
    "LAB_0040f91e",
    "LAB_0040f920",
    "LAB_0040f943",
    "LAB_0040f94e",
    "LAB_0040f9e9",
    "LAB_0040f9fd",
    "LAB_0040fa08",
    "LAB_0040fa16",
    "LAB_0040fa1e",
    "LAB_0040fa33",
    "LAB_0040fa45",
    "LAB_0040fa4d",
    "LAB_0040fa63",
    "LAB_0040fa8a",
    "LAB_0040fa8c",
    "LAB_0040fab7",
    "LAB_0040fabe",
    "LAB_0040facc",
    "LAB_0040faef",
    "LAB_0040fb05",
    "LAB_0040fb15",
    "LAB_0040fb31",
    "LAB_0040fb7c",
    "LAB_0040fb7d",
    "LAB_0040fb8a",
    "LAB_0040fb99",
    "LAB_0040fbae",
    "LAB_0040fbb0",
    "LAB_0040fc16",
    "LAB_0040fc1c",
    "LAB_0040fc55",
    "LAB_0040fc82",
    "LAB_0040fc93",
    "LAB_0040fc96",
    "LAB_0040fc9d",
    "LAB_0040fcbf",
    "LAB_0040fce2",
    "LAB_0040fcf9",
    "LAB_0040fd2f",
    "LAB_0040fd59",
    "LAB_0040fd5c",
    "LAB_0040fd62",
    "LAB_0040fd8c",
    "LAB_0040fdbe",
    "LAB_0040fdcf",
    "LAB_0040fdd1",
    "LAB_0040fdd7",
    "LAB_0040fe40",
    "LAB_0040fe59",
    "LAB_0040fe5e",
    "LAB_0040fe94",
    "LAB_0040fe98",
    "LAB_0040feaf",
    "LAB_0040feed",
    "LAB_0040feff",
    "LAB_0040ff5a",
    "LAB_0040ff64",
    "LAB_0040ff6b",
    "LAB_0040ffbc",
    "LAB_0040ffdb",
    "LAB_00410003",
    "LAB_0041000a",
    "LAB_00410021",
    "LAB_00410025",
    "LAB_00410040",
    "LAB_00410042",
    "LAB_00410052",
    "LAB_00410080",
    "LAB_00410087",
    "LAB_004100ae",
    "LAB_004100b8",
    "LAB_004100c6",
    "LAB_004100ce",
    "LAB_004100d3",
    "LAB_004100de",
    "LAB_004100e0",
    "LAB_004100f5",
    "LAB_0041010c",
    "LAB_00410110",
    "LAB_00410171",
    "LAB_004101bf",
    "LAB_004101c4",
    "LAB_004101db",
    "LAB_00410222",
    "LAB_0041022d",
    "LAB_0041022f",
    "LAB_0041023a",
    "LAB_00410241",
    "LAB_00410251",
    "LAB_00410278",
    "LAB_0041027e",
    "LAB_004102b9",
    "LAB_004102c2",
    "LAB_004102cb",
    "LAB_004102d4",
    "LAB_004102dd",
    "LAB_00410306",
    "LAB_0041030f",
    "LAB_00410318",
    "LAB_0041031f",
    "LAB_00410334",
    "LAB_00410344",
    "LAB_0041034b",
    "LAB_0041034e",
    "LAB_00410350",
    "LAB_004103cd",
    "LAB_004103db",
    "LAB_0041042a",
    "LAB_00410455",
    "LAB_00410457",
    "LAB_0041048f",
    "LAB_004104c0",
    "LAB_004104c4",
    "LAB_004104de",
    "LAB_004104e9",
    "LAB_004104f1",
    "LAB_00410504",
    "LAB_0041050e",
    "LAB_00410519",
    "LAB_0041054e",
    "LAB_0041055c",
    "LAB_0041055f",
    "LAB_0041056e",
    "LAB_0041057d",
    "LAB_00410588",
    "LAB_0041059b",
    "LAB_004105a7",
    "LAB_004105aa",
    "LAB_004105b2",
    "LAB_004105bb",
    "LAB_004105ca",
    "LAB_004105cf",
    "LAB_004105e6",
    "LAB_004105ed",
    "LAB_004105f8",
    "LAB_004105fc",
    "LAB_00410626",
    "LAB_00410630",
    "LAB_00410637",
    "LAB_00410642",
    "LAB_00410644",
    "LAB_00410661",
    "LAB_00410670",
    "LAB_00410672",
    "LAB_0041067a",
    "LAB_0041068c",
    "LAB_00410695",
    "LAB_0041069b",
    "LAB_004106b9",
    "LAB_004106d8",
    "LAB_004106dc",
    "LAB_004106f5",
    "LAB_004106f6",
    "LAB_00410715",
    "LAB_00410718",
    "LAB_00410732",
    "LAB_00410744",
    "LAB_00410747",
    "LAB_00410761",
    "LAB_0041076e",
    "LAB_00410785",
    "LAB_00410795",
    "LAB_004107a7",
    "LAB_004107af",
    "LAB_004107c7",
    "LAB_004107d9",
    "LAB_004107e9",
    "LAB_004107fb",
    "LAB_00410803",
    "LAB_00410824",
    "LAB_00410829",
    "LAB_0041082e",
    "LAB_0041083c",
    "LAB_00410858",
    "LAB_0041085d",
    "LAB_004108a8",
    "LAB_004108aa",
    "LAB_004108b1",
    "LAB_004108c0",
    "LAB_004108c2",
    "LAB_004108d3",
    "LAB_00410901",
    "LAB_00410907",
    "LAB_0041090c",
    "LAB_0041092d",
    "LAB_00410947",
    "LAB_0041094c",
    "LAB_004109a1",
    "LAB_004109a4",
    "LAB_004109ab",
    "LAB_004109bb",
    "LAB_004109bd",
    "LAB_004109cd",
    "LAB_004109ee",
    "LAB_004109fa",
    "LAB_00410a06",
    "LAB_00410a1b",
    "LAB_00410a21",
    "LAB_00410a72",
    "LAB_00410a78",
    "LAB_00410a7c",
    "LAB_00410a83",
    "LAB_00410a9a",
    "LAB_00410aa0",
    "LAB_00410aeb",
    "LAB_00410af1",
    "LAB_00410af5",
    "LAB_00410afc",
    "LAB_00410b1a",
    "LAB_00410b2b",
    "LAB_00410b5a",
    "LAB_00410b75",
    "LAB_00410bcb",
    "LAB_00410c00",
    "LAB_00410c14",
    "LAB_00410c1c",
    "LAB_00410c44",
    "LAB_00410c58",
    "LAB_00410c5b",
    "LAB_00410c62",
    "LAB_00410caa",
    "LAB_00410d10",
    "LAB_00410d17",
    "LAB_00410d21",
    "LAB_00410d27",
    "LAB_00410d40",
    "LAB_00410d5c",
    "LAB_00410d98",
    "LAB_00410dcc",
    "LAB_00410ded",
    "LAB_00410df0",
    "LAB_00410e6f",
    "LAB_00410e70",
    "LAB_00410e7f",
    "LAB_00410f29",
    "LAB_00410f6c",
    "LAB_00410fc3",
    "LAB_00410fc8",
    "LAB_00410fcb",
    "LAB_00410fd3",
    "LAB_00410fda",
    "LAB_00411009",
    "LAB_00411132",
    "LAB_00411168",
    "LAB_0041116b",
    "LAB_00411173",
    "LAB_004111ce",
    "LAB_004111da",
    "LAB_004111ec",
    "LAB_00411217",
    "LAB_0041121b",
    "LAB_00411248",
    "LAB_00411280",
    "LAB_0041128a",
    "LAB_004112ab",
    "LAB_004112d3",
    "LAB_00411319",
    "LAB_00411324",
    "LAB_00411364",
    "LAB_00411366",
    "LAB_004113b0",
    "LAB_004113d6",
    "LAB_004113d8",
    "LAB_004113ff",
    "LAB_00411411",
    "LAB_0041142b",
    "LAB_00411470",
    "LAB_00411479",
    "LAB_004114a3",
    "LAB_00411512",
    "LAB_0041151c",
    "LAB_00411574",
    "LAB_00411587",
    "LAB_00411598",
    "LAB_0041159d",
    "LAB_004115a1",
    "LAB_004115d3",
    "LAB_004115da",
    "LAB_00411618",
    "LAB_0041162f",
    "LAB_00411643",
    "LAB_00411658",
    "LAB_00411665",
    "LAB_00411686",
    "LAB_0041168d",
    "LAB_00411695",
    "LAB_0041169a",
    "LAB_0041169f",
    "LAB_004116ae",
    "LAB_004116be",
    "LAB_004116d3",
    "LAB_004116ec",
    "LAB_004116fd",
    "LAB_0041171e",
    "LAB_00411729",
    "LAB_0041173d",
    "LAB_00411752",
    "LAB_0041175f",
    "LAB_0041176e",
    "LAB_00411772",
    "LAB_00411784",
    "LAB_00411791",
    "LAB_004117ae",
    "LAB_004117d7",
    "LAB_004117e7",
    "LAB_004117e9",
    "LAB_004117f5",
    "LAB_004117fd",
    "LAB_00411816",
    "LAB_00411819",
    "LAB_0041184e",
    "LAB_00411853",
    "LAB_00411861",
    "LAB_00411864",
    "LAB_0041186d",
    "LAB_0041187d",
    "LAB_0041188d",
    "LAB_0041189d",
    "LAB_004118a0",
    "LAB_004118ad",
    "LAB_004118c5",
    "LAB_004118d5",
    "LAB_004118dc",
    "LAB_004118e5",
    "LAB_004118f5",
    "LAB_00411905",
    "LAB_00411915",
    "LAB_00411925",
    "LAB_00411928",
    "LAB_00411945",
    "LAB_0041194a",
    "LAB_00411952",
    "LAB_0041195d",
    "LAB_0041197d",
    "LAB_004119a2",
    "LAB_004119ae",
    "LAB_004119b5",
    "LAB_004119bc",
    "LAB_004119be",
    "LAB_00411a01",
    "LAB_00411a11",
    "LAB_00411a13",
    "LAB_00411a1f",
    "LAB_00411a27",
    "LAB_00411a40",
    "LAB_00411a43",
    "LAB_00411a6b",
    "LAB_00411a71",
    "LAB_00411a7f",
    "LAB_00411a82",
    "LAB_00411a9e",
    "LAB_00411aba",
    "LAB_00411aeb",
    "LAB_00411b0e",
    "LAB_00411b31",
    "LAB_00411b54",
    "LAB_00411b77",
    "LAB_00411b9a",
    "LAB_00411bbd",
    "LAB_00411be0",
    "LAB_00411c03",
    "LAB_00411c26",
    "LAB_00411c49",
    "LAB_00411c6c",
    "LAB_00411c8c",
    "LAB_00411ca8",
    "LAB_00411cc4",
    "LAB_00411ce0",
    "LAB_00411cf4",
    "LAB_00411cf7",
    "LAB_00411cfc",
    "LAB_00411d0c",
    "LAB_00411d15",
    "LAB_00411d24",
    "LAB_00411d29",
    "LAB_00411d2c",
    "LAB_00411d3d",
    "LAB_00411d5b",
    "LAB_00411d69",
    "LAB_00411d70",
    "LAB_00411d79",
    "LAB_00411d83",
    "LAB_00411da2",
    "LAB_00411dd3",
    "LAB_00411df6",
    "LAB_00411e19",
    "LAB_00411e3c",
    "LAB_00411e5f",
    "LAB_00411e82",
    "LAB_00411ea5",
    "LAB_00411ec8",
    "LAB_00411eeb",
    "LAB_00411f0e",
    "LAB_00411f31",
    "LAB_00411f54",
    "LAB_00411f74",
    "LAB_00411f90",
    "LAB_00411fac",
    "LAB_00411fc8",
    "LAB_00411fdc",
    "LAB_00411fdf",
    "LAB_00411fe4",
    "LAB_00411ff4",
    "LAB_00411ffd",
    "LAB_0041200c",
    "LAB_00412011",
    "LAB_00412014",
    "LAB_0041202e",
    "LAB_00412033",
    "LAB_0041203c",
    "LAB_0041204a",
    "LAB_00412062",
    "LAB_00412087",
    "LAB_00412093",
    "LAB_0041209a",
    "LAB_004120a1",
    "LAB_004120a3",
    "LAB_004120e1",
    "LAB_0041210d",
    "LAB_0041212a",
    "LAB_00412136",
    "LAB_0041215d",
    "LAB_00412169",
    "LAB_004121bd",
    "LAB_004122c4",
    "LAB_0041231a",
    "LAB_00412336",
    "LAB_00412382",
    "LAB_004123af",
    "LAB_004123cb",
    "LAB_004123df",
    "LAB_0041241a",
    "LAB_0041242d",
    "LAB_0041247d",
    "LAB_0041248b",
    "LAB_004124ff",
    "LAB_0041253a",
    "LAB_00412552",
    "LAB_00412555",
    "LAB_00412570",
    "LAB_00412574",
    "LAB_00412587",
    "LAB_00412592",
    "LAB_004125a8",
    "LAB_004125c2",
    "LAB_004125f0",
    "LAB_004125f2",
    "LAB_00412635",
    "LAB_004126b3",
    "LAB_004126d4",
    "LAB_004126f1",
    "LAB_004126f4",
    "LAB_004126f8",
    "LAB_004126fe",
    "LAB_00412705",
    "LAB_0041270c",
    "LAB_0041278d",
    "LAB_004127d2",
    "LAB_004127d7",
    "LAB_004127ec",
    "LAB_00412806",
    "LAB_00412821",
    "LAB_0041282c",
    "LAB_0041286d",
    "LAB_0041287d",
    "LAB_00412890",
    "LAB_004128a7",
    "LAB_004128ab",
    "LAB_004128ae",
    "LAB_004128b1",
    "LAB_004128b4",
    "LAB_004128be",
    "LAB_004128d8",
    "LAB_004128dd",
    "LAB_0041292c",
    "LAB_00412931",
    "LAB_00412946",
    "LAB_00412978",
    "LAB_0041299c",
    "LAB_004129b0",
    "LAB_00412a02",
    "LAB_00412a2e",
    "LAB_00412a46",
    "LAB_00412a60",
    "LAB_00412a69",
    "LAB_00412a6c",
    "LAB_00412a6f",
    "LAB_00412a7a",
    "LAB_00412a91",
    "LAB_00412a9a",
    "LAB_00412af7",
    "LAB_00412b09",
    "LAB_00412b11",
    "LAB_00412b1f",
    "LAB_00412b28",
    "LAB_00412b48",
    "LAB_00412b51",
    "LAB_00412b76",
    "LAB_00412b8c",
    "LAB_00412b90",
    "LAB_00412ba4",
    "LAB_00412bce",
    "LAB_00412bd3",
    "LAB_00412bf1",
    "LAB_00412bf2",
    "LAB_00412bf3",
    "LAB_00412c14",
    "LAB_00412c41",
    "LAB_00412c4d",
    "LAB_00412c53",
    "LAB_00412c6d",
    "LAB_00412c6e",
    "LAB_00412ca5",
    "LAB_00412d02",
    "LAB_00412d39",
    "LAB_00412d4d",
    "LAB_00412d6b",
    "LAB_00412d7e",
    "LAB_00412d83",
    "LAB_00412d86",
    "LAB_00412db6",
    "LAB_00412e06",
    "LAB_00412e1e",
    "LAB_00412e5c",
    "LAB_00412e6a",
    "LAB_00412e75",
    "LAB_00412e91",
    "LAB_00412ea2",
    "LAB_00412edd",
    "LAB_00412f06",
    "LAB_00412ff4",
    "LAB_0041304c",
    "LAB_00413053",
    "LAB_00413056",
    "LAB_00413065",
    "LAB_00413070",
    "LAB_00413074",
    "LAB_00413099",
    "LAB_004130c6",
    "LAB_004130ca",
    "LAB_004130dc",
    "LAB_004130e1",
    "LAB_004130e8",
    "LAB_0041310c",
    "LAB_0041311c",
    "LAB_00413120",
    "LAB_00413133",
    "LAB_00413138",
    "LAB_0041313b",
    "LAB_00413166",
    "LAB_004131a6",
    "LAB_004131c2",
    "LAB_00413247",
    "LAB_0041324c",
    "LAB_00413261",
    "LAB_0041328e",
    "LAB_00413291",
    "LAB_004132a0",
    "LAB_004132bb",
    "LAB_004132be",
    "LAB_004132bf",
    "LAB_004132f9",
    "LAB_00413370",
    "LAB_0041338c",
    "LAB_004133ad",
    "LAB_004133c5",
    "LAB_004133ca",
    "LAB_004133f7",
    "LAB_004133fd",
    "LAB_00413424",
    "LAB_0041344a",
    "LAB_004134c6",
    "LAB_004134d8",
    "LAB_004134e2",
    "LAB_00413505",
    "LAB_00413526",
    "LAB_00413529",
    "LAB_00413535",
    "LAB_00413538",
    "LAB_00413543",
    "LAB_00413569",
    "LAB_00413580",
    "LAB_00413584",
    "LAB_00413586",
    "LAB_004135a2",
    "LAB_004135a4",
    "LAB_004135bb",
    "LAB_004135c6",
    "LAB_004135e4",
    "LAB_004135f2",
    "LAB_00413628",
    "LAB_00413648",
    "LAB_0041364d",
    "LAB_00413665",
    "LAB_004136d7",
    "LAB_0041370e",
    "LAB_00413745",
    "LAB_00413748",
    "LAB_0041375d",
    "LAB_004137e0",
    "LAB_004137eb",
    "LAB_0041380c",
    "LAB_00413814",
    "LAB_0041384c",
    "LAB_00413879",
    "LAB_00413883",
    "LAB_0041388b",
    "LAB_004138ad",
    "LAB_004138e6",
    "LAB_004138ea",
    "LAB_00413904",
    "LAB_00413905",
    "LAB_00413963",
    "LAB_00413969",
    "LAB_0041397b",
    "LAB_0041398b",
    "LAB_004139c8",
    "LAB_004139ce",
    "LAB_004139d6",
    "LAB_00413a41",
    "LAB_00413a47",
    "LAB_00413a63",
    "LAB_00413a76",
    "LAB_00413ab6",
    "LAB_00413abc",
    "LAB_00413ac4",
    "LAB_00413b37",
    "LAB_00413b43",
    "LAB_00413b5b",
    "LAB_00413b68",
    "LAB_00413b9d",
    "LAB_00413be9",
    "LAB_00413bf1",
    "LAB_00413c30",
    "LAB_00413c9c",
    "LAB_00413cb0",
    "LAB_00413cce",
    "LAB_00413ce6",
    "LAB_00413ce9",
    "LAB_00413d1d",
    "LAB_00413d40",
    "LAB_00413d6c",
    "LAB_00413d91",
    "LAB_00413d94",
    "LAB_00413daa",
    "LAB_00413dd4",
    "LAB_00413ddb",
    "LAB_00413de9",
    "LAB_00413dee",
    "LAB_00413e28",
    "LAB_00413e38",
    "LAB_00413e48",
    "LAB_00413e74",
    "LAB_00413e77",
    "LAB_00413ea6",
    "LAB_00413eaf",
    "LAB_00413eb2",
    "LAB_00413ecf",
    "LAB_00413ee2",
    "LAB_00413ee7",
    "LAB_00413eea",
    "LAB_00413eeb",
    "LAB_00413f22",
    "LAB_00413f25",
    "LAB_00413f36",
    "LAB_00413f50",
    "LAB_00413f82",
    "LAB_00413fcd",
    "LAB_00413fd8",
    "LAB_00413fe1",
    "LAB_00413fe2",
    "LAB_00414005",
    "LAB_00414008",
    "LAB_00414009",
    "LAB_0041405c",
    "LAB_00414070",
    "LAB_00414090",
    "LAB_00414095",
    "LAB_004140bf",
    "LAB_004140d4",
    "LAB_00414105",
    "LAB_0041411d",
    "LAB_0041412d",
    "LAB_00414178",
    "LAB_0041418d",
    "LAB_00414191",
    "LAB_00414193",
    "LAB_00414195",
    "LAB_004141cd",
    "LAB_004141cf",
    "LAB_0041421b",
    "LAB_0041421f",
    "LAB_00414227",
    "LAB_00414241",
    "LAB_00414243",
    "LAB_00414262",
    "LAB_0041426a",
    "LAB_00414270",
    "LAB_00414280",
    "LAB_00414282",
    "LAB_004142a8",
    "LAB_004142dd",
    "LAB_004142df",
    "LAB_004142ec",
    "LAB_004142fb",
    "LAB_004142fd",
    "LAB_004142ff",
    "LAB_0041433e",
    "LAB_00414341",
    "LAB_00414393",
    "LAB_004143b3",
    "LAB_00414403",
    "LAB_00414409",
    "LAB_00414459",
    "LAB_0041445f",
    "LAB_004144af",
    "LAB_004144b5",
    "LAB_00414508",
    "LAB_0041450e",
    "LAB_00414567",
    "LAB_00414571",
    "LAB_004145c7",
    "LAB_004145d3",
    "LAB_0041463b",
    "LAB_0041465b",
    "LAB_004146ae",
    "LAB_004146b7",
    "LAB_004146c8",
    "LAB_00414713",
    "LAB_0041475a",
    "LAB_00414766",
    "LAB_00414767",
    "LAB_00414786",
    "LAB_00414798",
    "LAB_0041479b",
    "LAB_004147a7",
    "LAB_004147ca",
    "LAB_00414801",
    "LAB_0041482a",
    "LAB_0041482d",
    "LAB_0041488b",
    "LAB_004148ab",
    "LAB_00414908",
    "LAB_0041490f",
    "LAB_0041491f",
    "LAB_00414926",
    "LAB_00414966",
    "LAB_0041497c",
    "LAB_004149c7",
    "LAB_004149e2",
    "LAB_004149ff",
    "LAB_00414a01",
    "LAB_00414a5b",
    "LAB_00414a69",
    "LAB_00414aee",
    "LAB_00414af0",
    "LAB_00414af6",
    "LAB_00414b1b",
    "LAB_00414b23",
    "LAB_00414b66",
    "LAB_00414b69",
    "LAB_00414b71",
    "LAB_00414b76",
    "LAB_00414b99",
    "LAB_00414ba7",
    "LAB_00414bb7",
    "LAB_00414bfb",
    "LAB_00414bff",
    "LAB_00414c09",
    "LAB_00414c23",
    "LAB_00414c5c",
    "LAB_00414c66",
    "LAB_00414c76",
    "LAB_00414c79",
    "LAB_00414c7f",
    "LAB_00414c89",
    "LAB_00414c98",
    "LAB_00414cc8",
    "LAB_00414ce6",
    "LAB_00414da8",
    "LAB_00414f91",
    "LAB_00414fb2",
    "LAB_00415075",
    "LAB_00415087",
    "LAB_004150ab",
    "LAB_004150c0",
    "LAB_004150c8",
    "LAB_004150db",
    "LAB_004150f4",
    "LAB_00415100",
    "LAB_00415132",
    "LAB_00415147",
    "LAB_0041514f",
    "LAB_00415162",
    "LAB_0041517a",
    "LAB_00415183",
    "LAB_0041518c",
    "LAB_00415192",
    "LAB_004151a6",
    "LAB_004151a9",
    "LAB_004151bb",
    "LAB_004151d5",
    "LAB_00415202",
    "LAB_0041522f",
    "LAB_00415269",
    "LAB_00415286",
    "LAB_00415289",
    "LAB_00415293",
    "LAB_00415297",
    "LAB_00415299",
    "LAB_004152b8",
    "LAB_004152d2",
    "LAB_004152fe",
    "LAB_00415344",
    "LAB_00415365",
    "LAB_0041536c",
    "LAB_0041537c",
    "LAB_004153bd",
    "LAB_004153c6",
    "LAB_004153ca",
    "LAB_004153d9",
    "LAB_004153e8",
    "LAB_004153fe",
    "LAB_00415410",
    "LAB_0041543f",
    "LAB_00415467",
    "LAB_00415493",
    "LAB_0041549f",
    "LAB_004154a4",
    "LAB_004154ba",
    "LAB_004154c0",
    "LAB_004154c3",
    "LAB_004154d7",
    "LAB_004154e1",
    "LAB_00415516",
    "LAB_0041551f",
    "LAB_0041552d",
    "LAB_00415543",
    "LAB_00415559",
    "LAB_00415564",
    "LAB_00415577",
    "LAB_00415586",
    "LAB_00415599",
    "LAB_004155a6",
    "LAB_004155b6",
    "LAB_00415609",
    "LAB_00415638",
    "LAB_00415654",
    "LAB_0041566f",
    "LAB_00415671",
    "LAB_0041568a",
    "LAB_00415690",
    "LAB_004156cb",
    "LAB_004156db",
    "LAB_004156f4",
    "LAB_0041570e",
    "LAB_0041572d",
    "LAB_00415746",
    "LAB_00415755",
    "LAB_00415764",
    "LAB_00415767",
    "LAB_00415781",
    "LAB_00415791",
    "LAB_00415798",
    "LAB_004157eb",
    "LAB_00415816",
    "LAB_0041582c",
    "LAB_0041586f",
    "LAB_0041587c",
    "LAB_00415898",
    "LAB_0041589a",
    "LAB_004158d5",
    "LAB_004158d9",
    "LAB_004158f0",
    "LAB_00415903",
    "LAB_0041595d",
    "LAB_00415975",
    "LAB_0041598c",
    "LAB_00415996",
    "LAB_004159ae",
    "LAB_004159ca",
    "LAB_004159fd",
    "LAB_00415a0c",
    "LAB_00415a18",
    "LAB_00415a91",
    "LAB_00415adf",
    "LAB_00415afb",
    "LAB_00415b23",
    "LAB_00415b37",
    "LAB_00415b4d",
    "LAB_00415b68",
    "LAB_00415b6c",
    "LAB_00415ba9",
    "LAB_00415bb8",
    "LAB_00415bba",
    "LAB_00415bcc",
    "LAB_00415be8",
    "LAB_00415beb",
    "LAB_00415c0e",
    "LAB_00415c26",
    "LAB_00415c3d",
    "LAB_00415c40",
    "LAB_00415c41",
    "LAB_00415c62",
    "LAB_00415caa",
    "LAB_00415cbc",
    "LAB_00415ce3",
    "LAB_00415cfb",
    "LAB_00415d18",
    "LAB_00415d1d",
    "LAB_00415d34",
    "LAB_00415d3b",
    "LAB_00415d3f",
    "LAB_00415d5e",
    "LAB_00415d88",
    "LAB_00415d8d",
    "LAB_00415def",
    "LAB_00415e10",
    "LAB_00415e1d",
    "LAB_00415e26",
    "LAB_00415e31",
    "LAB_00415e58",
    "LAB_00415e64",
    "LAB_00415e74",
    "LAB_00415e7e",
    "LAB_00415e80",
    "LAB_00415e9a",
    "LAB_00415eb1",
    "LAB_00415ec3",
    "LAB_00415ed9",
    "LAB_00415edb",
    "LAB_00415eee",
    "LAB_00415efb",
    "LAB_00415f08",
    "LAB_00415f3d",
    "LAB_00415f57",
    "LAB_00415f6c",
    "LAB_00415f82",
    "LAB_00415f84",
    "LAB_00415f97",
    "LAB_00415fa6",
    "LAB_00415fd9",
    "LAB_00415fe2",
    "LAB_00415ff4",
    "LAB_0041601d",
    "LAB_0041603c",
    "LAB_00416072",
    "LAB_004160a5",
    "LAB_004160b1",
    "LAB_004160b9",
    "LAB_004160bc",
    "LAB_004160bd",
    "LAB_00416111",
    "LAB_00416125",
    "LAB_0041617e",
    "LAB_004161de",
    "LAB_004162ea",
    "LAB_004162f2",
    "LAB_00416302",
    "LAB_00416313",
    "LAB_0041632d",
    "LAB_0041635c",
    "LAB_00416360",
    "LAB_00416362",
    "LAB_00416439",
    "LAB_00416462",
    "LAB_0041646b",
    "LAB_00416472",
    "LAB_00416477",
    "LAB_0041647f",
    "LAB_004164c8",
    "LAB_004164dd",
    "LAB_004164ee",
    "LAB_004164f7",
    "LAB_00416504",
    "LAB_00416528",
    "LAB_00416551",
    "LAB_0041657c",
    "LAB_00416583",
    "LAB_00416599",
    "LAB_0041659f",
    "LAB_004165b5",
    "LAB_004165be",
    "LAB_004165d1",
    "LAB_004165e7",
    "LAB_004165e8",
    "LAB_00416622",
    "LAB_0041664d",
    "LAB_00416654",
    "LAB_00416675",
    "LAB_00416682",
    "LAB_00416695",
    "LAB_0041669e",
    "LAB_004166b3",
    "LAB_004166c9",
    "LAB_004166ca",
    "LAB_00416703",
    "LAB_0041670e",
    "LAB_00416736",
    "LAB_0041674d",
    "LAB_00416758",
    "LAB_00416784",
    "LAB_0041678f",
    "LAB_004167b7",
    "LAB_004167ce",
    "LAB_004167d9",
    "LAB_004167f7",
    "LAB_004167fb",
    "LAB_0041681e",
    "LAB_00416831",
    "LAB_00416851",
    "LAB_00416855",
    "LAB_00416878",
    "LAB_0041688b",
    "LAB_004168c7",
    "LAB_004168cb",
    "LAB_004168d0",
    "LAB_004168fe",
    "LAB_00416900",
    "LAB_00416977",
    "LAB_00416979",
    "LAB_0041699e",
    "LAB_004169a9",
    "LAB_004169af",
    "LAB_004169b2",
    "LAB_004169c4",
    "LAB_00416a08",
    "LAB_00416a15",
    "LAB_00416a1d",
    "LAB_00416a22",
    "LAB_00416a26",
    "LAB_00416a30",
    "LAB_00416a33",
    "LAB_00416a3c",
    "LAB_00416a45",
    "LAB_00416a6a",
    "LAB_00416a76",
    "LAB_00416a82",
    "LAB_00416a8a",
    "LAB_00416a90",
    "LAB_00416a96",
    "LAB_00416a99",
    "LAB_00416aad",
    "LAB_00416ab0",
    "LAB_00416ab4",
    "LAB_00416ab7",
    "LAB_00416ac0",
    "LAB_00416ad4",
    "LAB_00416af1",
    "LAB_00416af4",
    "LAB_00416aff",
    "LAB_00416b26",
    "LAB_00416b45",
    "LAB_00416b64",
    "LAB_00416b67",
    "LAB_00416b71",
    "LAB_00416b81",
    "LAB_00416bb2",
    "LAB_00416bb6",
    "LAB_00416c0b",
    "LAB_00416c21",
    "LAB_00416c41",
    "LAB_00416c5e",
    "LAB_00416c7a",
    "LAB_00416c9c",
    "LAB_00416cba",
    "LAB_00416cbe",
    "LAB_00416cf7",
    "LAB_00416d42",
    "LAB_00416d46",
    "LAB_00416d51",
    "LAB_00416d7a",
    "LAB_00416d84",
    "LAB_00416db5",
    "LAB_00416dcb",
    "LAB_00416e48",
    "LAB_00416e56",
    "LAB_00416ec2",
    "LAB_00416efd",
    "LAB_00416f0d",
    "LAB_00416f10",
    "LAB_00416f35",
    "LAB_00416f3c",
    "LAB_00416f44",
    "LAB_00416f49",
    "LAB_00416f4e",
    "LAB_00416f62",
    "LAB_00416f75",
    "LAB_00416f99",
    "LAB_00416fdc",
    "LAB_00416ffc",
    "LAB_00417007",
    "LAB_0041700a",
    "LAB_00417015",
    "LAB_0041701a",
    "LAB_00417022",
    "LAB_0041706a",
    "LAB_00417070",
    "LAB_00417074",
    "LAB_004170aa",
    "LAB_004170b2",
    "LAB_004170d3",
    "LAB_00417123",
    "LAB_00417129",
    "LAB_00417137",
    "LAB_0041719d",
    "LAB_004171a9",
    "LAB_004171d4",
    "LAB_00417219",
    "LAB_00417238",
    "LAB_00417243",
    "LAB_00417246",
    "LAB_00417251",
    "LAB_00417256",
    "LAB_00417287",
    "LAB_0041729e",
    "LAB_004172a8",
    "LAB_004172e3",
    "LAB_004172eb",
    "LAB_0041730c",
    "LAB_0041735c",
    "LAB_00417362",
    "LAB_00417370",
    "LAB_004173da",
    "LAB_004173e6",
    "LAB_00417406",
    "LAB_0041740e",
    "LAB_00417417",
    "LAB_00417435",
    "LAB_0041743a",
    "LAB_00417480",
    "LAB_0041748b",
    "LAB_00417490",
    "LAB_00417495",
    "LAB_004174b8",
    "LAB_004174c7",
    "LAB_004174cf",
    "LAB_004174ea",
    "LAB_004174ef",
    "LAB_0041753e",
    "LAB_00417549",
    "LAB_0041754e",
    "LAB_00417553",
    "LAB_00417578",
    "LAB_00417597",
    "LAB_0041759f",
    "LAB_004175a6",
    "LAB_004175ad",
    "LAB_004175cc",
    "LAB_004175ee",
    "LAB_004175f6",
    "LAB_004175fd",
    "LAB_00417604",
    "LAB_00417644",
    "LAB_00417646",
    "LAB_0041765a",
    "LAB_0041766a",
    "LAB_0041768a",
    "LAB_00417692",
    "LAB_004176aa",
    "LAB_004176bc",
    "LAB_004176c3",
    "LAB_004176cf",
    "LAB_004176ef",
    "LAB_0041770b",
    "LAB_00417795",
    "LAB_004177a8",
    "LAB_004177b8",
    "LAB_004177d2",
    "LAB_00417804",
    "LAB_00417805",
    "LAB_0041780b",
    "LAB_00417823",
    "LAB_00417827",
    "LAB_00417853",
    "LAB_0041785e",
    "LAB_00417868",
    "LAB_0041788d",
    "LAB_00417890",
    "LAB_00417895",
    "LAB_00417897",
    "LAB_0041789d",
    "LAB_004178c9",
    "LAB_004178dc",
    "LAB_004178e6",
    "LAB_00417913",
    "LAB_0041791c",
    "LAB_0041791e",
    "LAB_00417924",
    "LAB_004179a5",
    "LAB_004179b7",
    "LAB_004179be",
    "LAB_004179d5",
    "LAB_004179ed",
    "LAB_004179ee",
    "LAB_004179f4",
    "LAB_004179f8",
    "LAB_00417a0b",
    "LAB_00417a1a",
    "LAB_00417a1e",
    "LAB_00417a71",
    "LAB_00417a76",
    "LAB_00417a7d",
    "LAB_00417a85",
    "LAB_00417a8c",
    "LAB_00417a90",
    "LAB_00417a9d",
    "LAB_00417aa3",
    "LAB_00417ab7",
    "LAB_00417afe",
    "LAB_00417b25",
    "LAB_00417b45",
    "LAB_00417b6e",
    "LAB_00417b77",
    "LAB_00417b79",
    "LAB_00417b7a",
    "LAB_00417b89",
    "LAB_00417b93",
    "LAB_00417bb1",
    "LAB_00417bf3",
    "LAB_00417bfc",
    "LAB_00417c0c",
    "LAB_00417c44",
    "LAB_00417c48",
    "LAB_00417c4c",
    "LAB_00417c5e",
    "LAB_00417c6a",
    "LAB_00417c71",
    "LAB_00417c7b",
    "LAB_00417c80",
    "LAB_00417c8d",
    "LAB_00417ca3",
    "LAB_00417cbc",
    "LAB_00417cc8",
    "LAB_00417ce6",
    "LAB_00417d14",
    "LAB_00417d50",
    "LAB_00417d6a",
    "LAB_00417da3",
    "LAB_00417db2",
    "LAB_00417dcb",
    "LAB_00417df5",
    "LAB_00417dfd",
    "LAB_00417e28",
    "LAB_00417e41",
    "LAB_00417e5a",
    "LAB_00417e62",
    "LAB_00417eaf",
    "LAB_00417eb8",
    "LAB_00417ebf",
    "LAB_00417ecb",
    "LAB_00417eda",
    "LAB_00417ef7",
    "LAB_00417f1b",
    "LAB_00417f43",
    "LAB_00417f72",
    "LAB_00417f78",
    "LAB_00417fbe",
    "LAB_00417fd7",
    "LAB_00417fdb",
    "LAB_00417ffd",
    "LAB_0041801d",
    "LAB_00418020",
    "LAB_00418074",
    "LAB_00418076",
    "LAB_00418082",
    "LAB_00418084",
    "LAB_00418095",
    "LAB_004180ac",
    "LAB_004180d0",
    "LAB_004180eb",
    "LAB_00418145",
    "LAB_00418150",
    "LAB_00418181",
    "LAB_0041818f",
    "LAB_004181a3",
    "LAB_004181a7",
    "LAB_004181c7",
    "LAB_004181cc",
    "LAB_004181d7",
    "LAB_004181fe",
    "LAB_0041820e",
    "LAB_00418219",
    "LAB_0041833e",
    "LAB_00418378",
    "LAB_0041837f",
    "LAB_00418386",
    "LAB_0041838d",
    "LAB_004183c7",
    "LAB_004183de",
    "LAB_004183f3",
    "LAB_00418403",
    "LAB_00418446",
    "LAB_0041845c",
    "LAB_004184a8",
    "LAB_004184c9",
    "LAB_004184d2",
    "LAB_004184df",
    "LAB_004184e3",
    "LAB_004184e8",
    "LAB_00418555",
    "LAB_0041856f",
    "LAB_0041857f",
    "LAB_00418588",
    "LAB_0041858f",
    "LAB_00418596",
    "LAB_004185a9",
    "LAB_004185c5",
    "LAB_004185d8",
    "LAB_004185dc",
    "LAB_004185de",
    "LAB_004185ef",
    "LAB_00418630",
    "LAB_00418675",
    "LAB_00418677",
    "LAB_00418683",
    "LAB_00418687",
    "LAB_00418692",
    "LAB_004186b4",
    "LAB_0041871c",
    "LAB_0041874d",
    "LAB_00418756",
    "LAB_0041878b",
    "LAB_0041879f",
    "LAB_004187b9",
    "LAB_004187f5",
    "LAB_004187ff",
    "LAB_00418882",
    "LAB_00418891",
    "LAB_00418897",
    "LAB_004188a3",
    "LAB_004188ab",
    "LAB_004188ca",
    "LAB_004188cd",
    "LAB_004188da",
    "LAB_004188ed",
    "LAB_004188f5",
    "LAB_00418917",
    "LAB_0041891e",
    "LAB_0041892d",
    "LAB_00418944",
    "LAB_00418948",
    "LAB_00418950",
    "LAB_00418953",
    "LAB_00418987",
    "LAB_00418998",
    "LAB_0041899e",
    "LAB_004189a1",
    "LAB_004189a2",
    "LAB_004189c3",
    "LAB_004189dd",
    "LAB_004189f9",
    "LAB_00418a14",
    "LAB_00418a20",
    "LAB_00418a2c",
    "LAB_00418a2f",
    "LAB_00418a30",
    "LAB_00418a44",
    "LAB_00418a49",
    "LAB_00418a64",
    "LAB_00418acc",
    "LAB_00418ace",
    "LAB_00418ad7",
    "LAB_00418ad9",
    "LAB_00418ae4",
    "LAB_00418b01",
    "LAB_00418b28",
    "LAB_00418b38",
    "LAB_00418bad",
    "LAB_00418bbf",
    "LAB_00418bd1",
    "LAB_00418be3",
    "LAB_00418bf5",
    "LAB_00418c07",
    "LAB_00418c19",
    "LAB_00418c2b",
    "LAB_00418c3d",
    "LAB_00418c4f",
    "LAB_00418c61",
    "LAB_00418c73",
    "LAB_00418c85",
    "LAB_00418ca6",
    "LAB_00418cb8",
    "LAB_00418cca",
    "LAB_00418cdc",
    "LAB_00418cee",
    "LAB_00418d18",
    "LAB_00418d28",
    "LAB_00418e0e",
    "LAB_00418e1f",
    "LAB_00418e26",
    "LAB_00418e40",
    "LAB_00418e7d",
    "LAB_00418ee3",
    "LAB_00418efc",
    "LAB_00418f01",
    "LAB_00418f03",
    "LAB_00418f3b",
    "LAB_00418f42",
    "LAB_00418f52",
    "LAB_00418f86",
    "LAB_00418f9e",
    "LAB_00418fab",
    "LAB_00418fb8",
    "LAB_00418fc5",
    "LAB_00418fcc",
    "LAB_00418fde",
    "LAB_00418fee",
    "LAB_00419050",
    "LAB_00419072",
    "LAB_00419087",
    "LAB_004190d6",
    "LAB_004190f1",
    "LAB_00419114",
    "LAB_00419117",
    "LAB_00419130",
    "LAB_00419133",
    "LAB_00419171",
    "LAB_004191a5",
    "LAB_004191ca",
    "LAB_004191eb",
    "LAB_004191f8",
    "LAB_00419205",
    "LAB_00419212",
    "LAB_00419219",
    "LAB_0041922b",
    "LAB_0041923b",
    "LAB_00419250",
    "LAB_0041927e",
    "LAB_004192c1",
    "LAB_004192e4",
    "LAB_004192e8",
    "LAB_00419313",
    "LAB_00419315",
    "LAB_00419324",
    "LAB_0041934c",
    "LAB_00419360",
    "LAB_00419362",
    "LAB_0041938a",
    "LAB_0041938e",
    "LAB_00419391",
    "LAB_004193a2",
    "LAB_004193c9",
    "LAB_004193cd",
    "LAB_004193e1",
    "LAB_004193e9",
    "LAB_004193f2",
    "LAB_004193f9",
    "LAB_00419412",
    "LAB_0041941c",
    "LAB_0041941e",
    "LAB_00419420",
    "LAB_0041944c",
    "LAB_0041945f",
    "LAB_0041946b",
    "LAB_004194c3",
    "LAB_004194c5",
    "LAB_0041953a",
    "LAB_00419549",
    "LAB_00419553",
    "LAB_0041955d",
    "LAB_00419567",
    "LAB_00419576",
    "LAB_00419594",
    "LAB_0041959b",
    "LAB_004195a0",
    "LAB_004195c5",
    "LAB_004195ca",
    "LAB_004195cf",
    "LAB_00419604",
    "LAB_0041960b",
    "LAB_00419612",
    "LAB_00419619",
    "LAB_00419620",
    "LAB_00419626",
    "LAB_00419645",
    "LAB_0041964c",
    "LAB_00419653",
    "LAB_0041965a",
    "LAB_00419661",
    "LAB_00419667",
    "LAB_0041966e",
    "LAB_00419681",
    "LAB_00419689",
    "LAB_00419691",
    "LAB_00419699",
    "LAB_004196a1",
    "LAB_004196ab",
    "LAB_004196c8",
    "LAB_004196cf",
    "LAB_004196d6",
    "LAB_004196dd",
    "LAB_004196e4",
    "LAB_004196ee",
    "LAB_00419720",
    "LAB_00419724",
    "LAB_0041972a",
    "LAB_0041973e",
    "LAB_00419744",
    "LAB_00419754",
    "LAB_0041978b",
    "LAB_00419792",
    "LAB_00419799",
    "LAB_004197a0",
    "LAB_004197a7",
    "LAB_004197b1",
    "LAB_004197d6",
    "LAB_004197de",
    "LAB_004197e4",
    "LAB_004197fc",
    "LAB_00419802",
    "LAB_00419812",
    "LAB_00419835",
    "LAB_0041983f",
    "LAB_00419849",
    "LAB_00419853",
    "LAB_0041985a",
    "LAB_00419867",
    "LAB_0041988e",
    "LAB_00419896",
    "LAB_0041989c",
    "LAB_004198bb",
    "LAB_004198c3",
    "LAB_004198c9",
    "LAB_004198fd",
    "LAB_00419907",
    "LAB_00419911",
    "LAB_0041991b",
    "LAB_00419925",
    "LAB_00419932",
    "LAB_00419959",
    "LAB_00419961",
    "LAB_00419967",
    "LAB_00419983",
    "LAB_0041998b",
    "LAB_00419991",
    "LAB_004199a4",
    "LAB_004199a8",
    "LAB_004199aa",
    "LAB_004199c1",
    "LAB_004199c9",
    "LAB_004199d1",
    "LAB_004199d9",
    "LAB_004199e1",
    "LAB_004199ec",
    "LAB_00419a15",
    "LAB_00419a1c",
    "LAB_00419a21",
    "LAB_00419a37",
    "LAB_00419a39",
    "LAB_00419a48",
    "LAB_00419a5f",
    "LAB_00419a63",
    "LAB_00419a7b",
    "LAB_00419a9f",
    "LAB_00419aa5",
    "LAB_00419adf",
    "LAB_00419b0d",
    "LAB_00419b18",
    "LAB_00419b51",
    "LAB_00419b55",
    "LAB_00419b59",
    "LAB_00419b6c",
    "LAB_00419b95",
    "LAB_00419bbd",
    "LAB_00419bcd",
    "LAB_00419c0c",
    "LAB_00419c21",
    "LAB_00419c48",
    "LAB_00419c4d",
    "LAB_00419c54",
    "LAB_00419c6f",
    "LAB_00419c8b",
    "LAB_00419cb1",
    "LAB_00419cc7",
    "LAB_00419cc9",
    "LAB_00419cdc",
    "LAB_00419cef",
    "LAB_00419d0e",
    "LAB_00419d14",
    "LAB_00419d21",
    "LAB_00419d28",
    "LAB_00419d57",
    "LAB_00419d8a",
    "LAB_00419d9c",
    "LAB_00419e04",
    "LAB_00419e21",
    "LAB_00419e26",
    "LAB_00419e28",
    "LAB_00419eab",
    "LAB_00419ee5",
    "LAB_00419efe",
    "LAB_00419f03",
    "LAB_00419f05",
    "LAB_00419f2f",
    "LAB_00419f41",
    "LAB_00419f48",
    "LAB_00419f4a",
    "LAB_00419f53",
    "LAB_00419f67",
    "LAB_00419f6f",
    "LAB_00419fbf",
    "LAB_00419fd0",
    "LAB_00419fd7",
    "LAB_00419fe6",
    "LAB_00419ffa",
    "LAB_00419ffc",
    "LAB_0041a00b",
    "LAB_0041a023",
    "LAB_0041a02c",
    "LAB_0041a02e",
    "LAB_0041a039",
    "LAB_0041a047",
    "LAB_0041a04a",
    "LAB_0041a052",
    "LAB_0041a05c",
    "LAB_0041a061",
    "LAB_0041a078",
    "LAB_0041a07c",
    "LAB_0041a09a",
    "LAB_0041a0a5",
    "LAB_0041a0cc",
    "LAB_0041a0e0",
    "LAB_0041a12c",
    "LAB_0041a179",
    "LAB_0041a1a0",
    "LAB_0041a1d5",
    "LAB_0041a21f",
    "LAB_0041a241",
    "LAB_0041a254",
    "LAB_0041a265",
    "LAB_0041a266",
    "LAB_0041a26a",
    "LAB_0041a275",
    "LAB_0041a296",
    "LAB_0041a29b",
    "LAB_0041a2d5",
    "LAB_0041a302",
    "LAB_0041a30c",
    "LAB_0041a30e",
    "LAB_0041a372",
    "LAB_0041a3a1",
    "LAB_0041a3cb",
    "LAB_0041a3d6",
    "LAB_0041a3f7",
    "LAB_0041a419",
    "LAB_0041a41c",
    "LAB_0041a41f",
    "LAB_0041a42b",
    "LAB_0041a445",
    "LAB_0041a46f",
    "LAB_0041a48b",
    "LAB_0041a498",
    "LAB_0041a4b0",
    "LAB_0041a4d1",
    "LAB_0041a4d8",
    "LAB_0041a4df",
    "LAB_0041a516",
    "LAB_0041a518",
    "LAB_0041a530",
    "LAB_0041a53e",
    "LAB_0041a544",
    "LAB_0041a553",
    "LAB_0041a5a8",
    "LAB_0041a5e3",
    "LAB_0041a5fe",
    "LAB_0041a665",
    "LAB_0041a66e",
    "LAB_0041a6c4",
    "LAB_0041a6cc",
    "LAB_0041a712",
    "LAB_0041a77e",
    "LAB_0041a780",
    "LAB_0041a7b0",
    "LAB_0041a7b2",
    "LAB_0041a7d1",
    "LAB_0041a7fb",
    "LAB_0041a807",
    "LAB_0041a809",
    "LAB_0041a81b",
    "LAB_0041a81d",
    "LAB_0041a86c",
    "LAB_0041a878",
    "LAB_0041a888",
    "LAB_0041a8a1",
    "LAB_0041a8a9",
    "LAB_0041a8d4",
    "LAB_0041a8f4",
    "LAB_0041a910",
    "LAB_0041a965",
    "LAB_0041a967",
    "LAB_0041a997",
    "LAB_0041a999",
    "LAB_0041a9b8",
    "LAB_0041a9e2",
    "LAB_0041a9ee",
    "LAB_0041a9f0",
    "LAB_0041a9fc",
    "LAB_0041a9fe",
    "LAB_0041aa4d",
    "LAB_0041aa5c",
    "LAB_0041aa6c",
    "LAB_0041aa85",
    "LAB_0041aa8d",
    "LAB_0041aab8",
    "LAB_0041aadb",
    "LAB_0041ab0b",
    "LAB_0041ab38",
    "LAB_0041ab3a",
    "LAB_0041ab58",
    "LAB_0041ab66",
    "LAB_0041ab6d",
    "LAB_0041ab79",
    "LAB_0041ab7b",
    "LAB_0041abab",
    "LAB_0041ac00",
    "LAB_0041ac18",
    "LAB_0041ac1a",
    "LAB_0041ac3e",
    "LAB_0041ac40",
    "LAB_0041ac59",
    "LAB_0041ac6f",
    "LAB_0041ac7d",
    "LAB_0041ac84",
    "LAB_0041ac90",
    "LAB_0041ac92",
    "LAB_0041acc1",
    "LAB_0041acc7",
    "LAB_0041acdb",
    "LAB_0041ace3",
    "LAB_0041ad0e",
    "LAB_0041ad40",
    "LAB_0041ad6c",
    "LAB_0041ad9d",
    "LAB_0041ada5",
    "LAB_0041ae33",
    "LAB_0041ae59",
    "LAB_0041ae7e",
    "LAB_0041ae90",
    "LAB_0041aee4",
    "LAB_0041af0a",
    "LAB_0041af2a",
    "LAB_0041af5b",
    "LAB_0041af7e",
    "LAB_0041af8e",
    "LAB_0041afa4",
    "LAB_0041afc4",
    "LAB_0041aff5",
    "LAB_0041affd",
    "LAB_0041b015",
    "LAB_0041b035",
    "LAB_0041b071",
    "LAB_0041b093",
    "LAB_0041b0a9",
    "LAB_0041b0be",
    "LAB_0041b0c7",
    "LAB_0041b0d2",
    "LAB_0041b0d9",
    "LAB_0041b0ea",
    "LAB_0041b0ec",
    "LAB_0041b10e",
    "LAB_0041b121",
    "LAB_0041b132",
    "LAB_0041b147",
    "LAB_0041b15c",
    "LAB_0041b16c",
    "LAB_0041b17e",
    "LAB_0041b19f",
    "LAB_0041b1e8",
    "LAB_0041b202",
    "LAB_0041b20a",
    "LAB_0041b289",
    "LAB_0041b2a3",
    "LAB_0041b2c9",
    "LAB_0041b2e9",
    "LAB_0041b312",
    "LAB_0041b372",
    "LAB_0041b397",
    "LAB_0041b3ba",
    "LAB_0041b3ca",
    "LAB_0041b3e0",
    "LAB_0041b400",
    "LAB_0041b431",
    "LAB_0041b439",
    "LAB_0041b451",
    "LAB_0041b471",
    "LAB_0041b4ad",
    "LAB_0041b4cf",
    "LAB_0041b4e5",
    "LAB_0041b4fa",
    "LAB_0041b503",
    "LAB_0041b515",
    "LAB_0041b526",
    "LAB_0041b528",
    "LAB_0041b54e",
    "LAB_0041b586",
    "LAB_0041b5c4",
    "LAB_0041b5f1",
    "LAB_0041b603",
    "LAB_0041b612",
    "LAB_0041b61f",
    "LAB_0041b629",
    "LAB_0041b645",
    "LAB_0041b690",
    "LAB_0041b6b6",
    "LAB_0041b6b8",
    "LAB_0041b6fe",
    "LAB_0041b741",
    "LAB_0041b769",
    "LAB_0041b776",
    "LAB_0041b783",
    "LAB_0041b789",
    "LAB_0041b7a6",
    "LAB_0041b7b0",
    "LAB_0041b7c4",
    "LAB_0041b7d8",
    "LAB_0041b81d",
    "LAB_0041b843",
    "LAB_0041b863",
    "LAB_0041b875",
    "LAB_0041b883",
    "LAB_0041b897",
    "LAB_0041b89c",
    "LAB_0041b8a3",
    "LAB_0041b8aa",
    "LAB_0041b8b1",
    "LAB_0041b8b6",
    "LAB_0041b8c6",
    "LAB_0041b8df",
    "LAB_0041b8ed",
    "LAB_0041b942",
    "LAB_0041b94a",
    "LAB_0041b969",
    "LAB_0041b96e",
    "LAB_0041b97f",
    "LAB_0041b987",
    "LAB_0041b9a3",
    "LAB_0041b9ab",
    "LAB_0041b9af",
    "LAB_0041b9bf",
    "LAB_0041b9c3",
    "LAB_0041ba33",
    "LAB_0041ba5f",
    "LAB_0041ba8b",
    "LAB_0041badc",
    "LAB_0041bb2e",
    "LAB_0041bb42",
    "LAB_0041bb93",
    "LAB_0041bba9",
    "LAB_0041bbb4",
    "LAB_0041bbd1",
    "LAB_0041bc03",
    "LAB_0041bc26",
    "LAB_0041bc29",
    "LAB_0041bc2b",
    "LAB_0041bc30",
    "LAB_0041bc40",
    "LAB_0041bc44",
    "LAB_0041bc67",
    "LAB_0041bc72",
    "LAB_0041bcb0",
    "LAB_0041bcb6",
    "LAB_0041bce4",
    "LAB_0041bcf7",
    "LAB_0041bcfd",
    "LAB_0041bd0c",
    "LAB_0041bd23",
    "LAB_0041bd2a",
    "LAB_0041bd2d",
    "LAB_0041bd5a",
    "LAB_0041bd60",
    "LAB_0041bd9e",
    "LAB_0041bdaf",
    "LAB_0041bdb5",
    "LAB_0041bdbd",
    "LAB_0041be1e",
    "LAB_0041be3a",
    "LAB_0041be3e",
    "LAB_0041be43",
    "LAB_0041be4e",
    "LAB_0041be5a",
    "LAB_0041be8e",
    "LAB_0041bec6",
    "LAB_0041bed1",
    "LAB_0041bedd",
    "LAB_0041beed",
    "LAB_0041befb",
    "LAB_0041befe",
    "LAB_0041bf18",
    "LAB_0041bf1d",
    "LAB_0041bf23",
    "LAB_0041bf3a",
    "LAB_0041bf3f",
    "LAB_0041bf45",
    "LAB_0041bf4e",
    "LAB_0041bf75",
    "LAB_0041bf7b",
    "LAB_0041bf8f",
    "LAB_0041bf95",
    "LAB_0041c046",
    "LAB_0041c065",
    "LAB_0041c06b",
    "LAB_0041c09a",
    "LAB_0041c09e",
    "LAB_0041c0c9",
    "LAB_0041c0ce",
    "LAB_0041c0f2",
    "LAB_0041c158",
    "LAB_0041c170",
    "LAB_0041c177",
    "LAB_0041c195",
    "LAB_0041c19d",
    "LAB_0041c19e",
    "LAB_0041c1c0",
    "LAB_0041c1c5",
    "LAB_0041c213",
    "LAB_0041c21f",
    "LAB_0041c29e",
    "LAB_0041c2b5",
    "LAB_0041c2cb",
    "LAB_0041c2ce",
    "LAB_0041c2e4",
    "LAB_0041c2e6",
    "LAB_0041c2fa",
    "LAB_0041c30c",
    "LAB_0041c318",
    "LAB_0041c32b",
    "LAB_0041c34d",
    "LAB_0041c367",
    "LAB_0041c394",
    "LAB_0041c397",
    "LAB_0041c3ad",
    "LAB_0041c3af",
    "LAB_0041c3c3",
    "LAB_0041c3d7",
    "LAB_0041c410",
    "LAB_0041c428",
    "LAB_0041c42a",
    "LAB_0041c445",
    "LAB_0041c45c",
    "LAB_0041c480",
    "LAB_0041c487",
    "LAB_0041c49a",
    "LAB_0041c4d7",
    "LAB_0041c4e9",
    "LAB_0041c504",
    "LAB_0041c506",
    "LAB_0041c535",
    "LAB_0041c537",
    "LAB_0041c547",
    "LAB_0041c54e",
    "LAB_0041c550",
    "LAB_0041c56e",
    "LAB_0041c581",
    "LAB_0041c5a7",
    "LAB_0041c5e6",
    "LAB_0041c5e8",
    "LAB_0041c617",
    "LAB_0041c61f",
    "LAB_0041c653",
    "LAB_0041c684",
    "LAB_0041c6bc",
    "LAB_0041c6c1",
    "LAB_0041c6c5",
    "LAB_0041c6d2",
    "LAB_0041c6d7",
    "LAB_0041c6d9",
    "LAB_0041c707",
    "LAB_0041c71d",
    "LAB_0041c71f",
    "LAB_0041c720",
    "LAB_0041c726",
    "LAB_0041c75a",
    "LAB_0041c75d",
    "LAB_0041c765",
    "LAB_0041c788",
    "LAB_0041c7a6",
    "LAB_0041c7bd",
    "LAB_0041c7c9",
    "LAB_0041c7eb",
    "LAB_0041c800",
    "LAB_0041c808",
    "LAB_0041c826",
    "LAB_0041c830",
    "LAB_0041c838",
    "LAB_0041c862",
    "LAB_0041c8c9",
    "LAB_0041c8cd",
    "LAB_0041c8cf",
    "LAB_0041c8d2",
    "LAB_0041c8e4",
    "LAB_0041c8f9",
    "LAB_0041c8fd",
    "LAB_0041c942",
    "LAB_0041c949",
    "LAB_0041c96a",
    "LAB_0041c96c",
    "LAB_0041c9a9",
    "LAB_0041c9b3",
    "LAB_0041c9b7",
    "LAB_0041c9b9",
    "LAB_0041c9bc",
    "LAB_0041c9c1",
    "LAB_0041c9c3",
    "LAB_0041c9d8",
    "LAB_0041c9fc",
    "LAB_0041c9ff",
    "LAB_0041ca1d",
    "LAB_0041ca34",
    "LAB_0041ca3f",
    "LAB_0041ca4e",
    "LAB_0041ca5c",
    "LAB_0041ca68",
    "LAB_0041ca71",
    "LAB_0041caa4",
    "LAB_0041caa8",
    "LAB_0041cad7",
    "LAB_0041cad9",
    "LAB_0041cadb",
    "LAB_0041cae0",
    "LAB_0041cb10",
    "LAB_0041cb25",
    "LAB_0041cb6d",
    "LAB_0041cb79",
    "LAB_0041cb9e",
    "LAB_0041cc29",
    "LAB_0041cc4e",
    "LAB_0041cc54",
    "LAB_0041cca6",
    "LAB_0041ccb2",
    "LAB_0041ccbc",
    "LAB_0041cd1a",
    "LAB_0041cd42",
    "LAB_0041cd51",
    "LAB_0041cdb5",
    "LAB_0041ce36",
    "LAB_0041ce4e",
    "LAB_0041ce50",
    "LAB_0041ce93",
    "LAB_0041cead",
    "LAB_0041ced4",
    "LAB_0041cee2",
    "LAB_0041cee5",
    "LAB_0041cefb",
    "LAB_0041cefd",
    "LAB_0041cf11",
    "LAB_0041cf23",
    "LAB_0041cf2e",
    "LAB_0041cf41",
    "LAB_0041cf5e",
    "LAB_0041cf7e",
    "LAB_0041cfa0",
    "LAB_0041cfbf",
    "LAB_0041cfe2",
    "LAB_0041cffb",
    "LAB_0041cffd",
    "LAB_0041d012",
    "LAB_0041d014",
    "LAB_0041d029",
    "LAB_0041d033",
    "LAB_0041d058",
    "LAB_0041d05b",
    "LAB_0041d06b",
    "LAB_0041d06e",
    "LAB_0041d06f",
    "LAB_0041d088",
    "LAB_0041d0c1",
    "LAB_0041d0cf",
    "LAB_0041d0e6",
    "LAB_0041d101",
    "LAB_0041d121",
    "LAB_0041d14b",
    "LAB_0041d14e",
    "LAB_0041d15e",
    "LAB_0041d176",
    "LAB_0041d18e",
    "LAB_0041d1d3",
    "LAB_0041d1e0",
    "LAB_0041d1f7",
    "LAB_0041d203",
    "LAB_0041d211",
    "LAB_0041d22c",
    "LAB_0041d237",
    "LAB_0041d270",
    "LAB_0041d285",
    "LAB_0041d286",
    "LAB_0041d2cd",
    "LAB_0041d2ed",
    "LAB_0041d30f",
    "LAB_0041d315",
    "LAB_0041d33b",
    "LAB_0041d36b",
    "LAB_0041d39d",
    "LAB_0041d3c5",
    "LAB_0041d3e0",
    "LAB_0041d3e4",
    "LAB_0041d415",
    "LAB_0041d41b",
    "LAB_0041d421",
    "LAB_0041d446",
    "LAB_0041d452",
    "LAB_0041d460",
    "LAB_0041d485",
    "LAB_0041d4b1",
    "LAB_0041d4d8",
    "LAB_0041d4f3",
    "LAB_0041d500",
    "LAB_0041d52b",
    "LAB_0041d531",
    "LAB_0041d554",
    "LAB_0041d55a",
    "LAB_0041d58e",
    "LAB_0041d5ab",
    "LAB_0041d5c7",
    "LAB_0041d5e4",
    "LAB_0041d5ec",
    "LAB_0041d5f2",
    "LAB_0041d619",
    "LAB_0041d61a",
    "LAB_0041d644",
    "LAB_0041d648",
    "LAB_0041d64c",
    "LAB_0041d65b",
    "LAB_0041d665",
    "LAB_0041d66c",
    "LAB_0041d676",
    "LAB_0041d67b",
    "LAB_0041d688",
    "LAB_0041d699",
    "LAB_0041d6ad",
    "LAB_0041d6b7",
    "LAB_0041d6cf",
    "LAB_0041d704",
    "LAB_0041d713",
    "LAB_0041d718",
    "LAB_0041d72a",
    "LAB_0041d730",
    "LAB_0041d75f",
    "LAB_0041d78a",
    "LAB_0041d79b",
    "LAB_0041d7a0",
    "LAB_0041d7ab",
    "LAB_0041d7ad",
    "LAB_0041d7ae",
    "LAB_0041d7b1",
    "LAB_0041d7c5",
    "LAB_0041d838",
    "LAB_0041d841",
    "LAB_0041d84b",
    "LAB_0041d8aa",
    "LAB_0041d8bf",
    "LAB_0041d8ce",
    "LAB_0041d8dc",
    "LAB_0041d8e7",
    "LAB_0041d91c",
    "LAB_0041d932",
    "LAB_0041d941",
    "LAB_0041d94d",
    "LAB_0041d9ad",
    "LAB_0041d9b0",
    "LAB_0041d9d2",
    "LAB_0041d9d7",
    "LAB_0041da00",
    "LAB_0041da80",
    "LAB_0041da8b",
    "LAB_0041dac1",
    "LAB_0041dacf",
    "LAB_0041dad5",
    "LAB_0041daf2",
    "LAB_0041dafb",
    "LAB_0041db10",
    "LAB_0041db1f",
    "LAB_0041db26",
    "LAB_0041db41",
    "LAB_0041db94",
    "LAB_0041dba0",
    "LAB_0041dbf3",
    "LAB_0041dc1d",
    "LAB_0041dc22",
    "LAB_0041dc5a",
    "LAB_0041dc61",
    "LAB_0041dc9e",
    "LAB_0041dcdc",
    "LAB_0041dcf8",
    "LAB_0041dd02",
    "LAB_0041dd0b",
    "LAB_0041dd11",
    "LAB_0041dd1a",
    "LAB_0041dd4c",
    "LAB_0041dd58",
    "LAB_0041dd8c",
    "LAB_0041ddb0",
    "LAB_0041ddc3",
    "LAB_0041ddd1",
    "LAB_0041ddd8",
    "LAB_0041ddda",
    "LAB_0041ddff",
    "LAB_0041de13",
    "LAB_0041de2a",
    "LAB_0041de33",
    "LAB_0041de48",
    "LAB_0041de5a",
    "LAB_0041de64",
    "LAB_0041dea9",
    "LAB_0041deab",
    "LAB_0041deac",
    "LAB_0041decc",
    "LAB_0041dede",
    "LAB_0041df00",
    "LAB_0041df09",
    "LAB_0041df17",
    "LAB_0041df5c",
    "LAB_0041df70",
    "LAB_0041df75",
    "LAB_0041df7c",
    "LAB_0041df81",
    "LAB_0041df93",
    "LAB_0041df9f",
    "LAB_0041dfa5",
    "LAB_0041dfab",
    "LAB_0041dfb0",
    "LAB_0041dfb8",
    "LAB_0041dfbd",
    "LAB_0041dfc1",
    "LAB_0041dfe5",
    "LAB_0041dffa",
    "LAB_0041e003",
    "LAB_0041e01b",
    "LAB_0041e030",
    "LAB_0041e03c",
    "LAB_0041e09b",
    "LAB_0041e0b9",
    "LAB_0041e0c1",
    "LAB_0041e0c6",
    "LAB_0041e13e",
    "LAB_0041e157",
    "LAB_0041e15c",
    "LAB_0041e15e",
    "LAB_0041e196",
    "LAB_0041e199",
    "LAB_0041e1a2",
    "LAB_0041e1a5",
    "LAB_0041e1ae",
    "LAB_0041e206",
    "LAB_0041e223",
    "LAB_0041e230",
    "LAB_0041e23b",
    "LAB_0041e246",
    "LAB_0041e251",
    "LAB_0041e268",
    "LAB_0041e278",
    "LAB_0041e282",
    "LAB_0041e283",
    "LAB_0041e2a1",
    "LAB_0041e2a9",
    "LAB_0041e2b1",
    "LAB_0041e2b9",
    "LAB_0041e2c1",
    "LAB_0041e2d8",
    "LAB_0041e2e8",
    "LAB_0041e2f6",
    "LAB_0041e312",
    "LAB_0041e31a",
    "LAB_0041e322",
    "LAB_0041e32a",
    "LAB_0041e332",
    "LAB_0041e349",
    "LAB_0041e359",
    "LAB_0041e367",
    "LAB_0041e387",
    "LAB_0041e394",
    "LAB_0041e39f",
    "LAB_0041e3aa",
    "LAB_0041e3b5",
    "LAB_0041e3cc",
    "LAB_0041e3d8",
    "LAB_0041e3e6",
    "LAB_0041e3e7",
    "LAB_0041e409",
    "LAB_0041e419",
    "LAB_0041e429",
    "LAB_0041e43a",
    "LAB_0041e448",
    "LAB_0041e46a",
    "LAB_0041e47a",
    "LAB_0041e48a",
    "LAB_0041e49b",
    "LAB_0041e4a9",
    "LAB_0041e4cd",
    "LAB_0041e512",
    "LAB_0041e527",
    "LAB_0041e531",
    "LAB_0041e53b",
    "LAB_0041e545",
    "LAB_0041e54f",
    "LAB_0041e561",
    "LAB_0041e56c",
    "LAB_0041e577",
    "LAB_0041e582",
    "LAB_0041e58d",
    "LAB_0041e611",
    "LAB_0041e691",
    "LAB_0041e698",
    "LAB_0041e6d3",
    "LAB_0041e826",
    "LAB_0041e884",
    "LAB_0041e88b",
    "LAB_0041e8a6",
    "LAB_0041e8bc",
    "LAB_0041e8cd",
    "LAB_0041e8da",
    "LAB_0041e907",
    "LAB_0041ed79",
    "LAB_0041edd9",
    "LAB_0041edde",
    "LAB_0041ede9",
    "LAB_0041ee10",
    "LAB_0041ee13",
    "LAB_0041eef0",
    "LAB_0041ef21",
    "LAB_0041ef50",
    "LAB_0041ef55",
    "LAB_0041ef97",
    "LAB_0041efdd",
    "LAB_0041efec",
    "LAB_0041eff5",
    "LAB_0041f004",
    "LAB_0041f017",
    "LAB_0041f031",
    "LAB_0041f064",
    "LAB_0041f06d",
    "LAB_0041f076",
    "LAB_0041f078",
    "LAB_0041f082",
    "LAB_0041f0ab",
    "LAB_0041f0b2",
    "LAB_0041f0be",
    "LAB_0041f0ca",
    "LAB_0041f0d6",
    "LAB_0041f0e2",
    "LAB_0041f0e9",
    "LAB_0041f0f0",
    "LAB_0041f126",
    "LAB_0041f12b",
    "LAB_0041f13b",
    "LAB_0041f18b",
    "LAB_0041f1a7",
    "LAB_0041f1be",
    "LAB_0041f1d0",
    "LAB_0041f1e6",
    "LAB_0041f1ee",
    "LAB_0041f251",
    "LAB_0041f256",
    "LAB_0041f258",
    "LAB_0041f25a",
    "LAB_0041f288",
    "LAB_0041f297",
    "LAB_0041f2b2",
    "LAB_0041f2d3",
    "LAB_0041f2f2",
    "LAB_0041f327",
    "LAB_0041f364",
    "LAB_0041f37c",
    "LAB_0041f380",
    "LAB_0041f383",
    "LAB_0041f385",
    "LAB_0041f3e5",
    "LAB_0041f3e9",
    "LAB_0041f3ed",
    "LAB_0041f3f1",
    "LAB_0041f3f3",
    "LAB_0041f41e",
    "LAB_0041f430",
    "LAB_0041f44d",
    "LAB_0041f453",
    "LAB_0041f479",
    "LAB_0041f481",
    "LAB_0041f4ba",
    "LAB_0041f4c3",
    "LAB_0041f4cb",
    "LAB_0041f4d1",
    "LAB_0041f4d4",
    "LAB_0041f544",
    "LAB_0041f581",
    "LAB_0041f599",
    "LAB_0041f5d9",
    "LAB_0041f5f2",
    "LAB_0041f641",
    "LAB_0041f657",
    "LAB_0041f66d",
    "LAB_0041f67b",
    "LAB_0041f683",
    "LAB_0041f689",
    "LAB_0041f68b",
    "LAB_0041f68d",
    "LAB_0041f695",
    "LAB_0041f6b1",
    "LAB_0041f6f6",
    "LAB_0041f702",
    "LAB_0041f720",
    "LAB_0041f72b",
    "LAB_0041f73e",
    "LAB_0041f746",
    "LAB_0041f74f",
    "LAB_0041f756",
    "LAB_0041f759",
    "LAB_0041f766",
    "LAB_0041f769",
    "LAB_0041f77f",
    "LAB_0041f7e5",
    "LAB_0041f7f6",
    "LAB_0041f807",
    "LAB_0041f818",
    "LAB_0041f829",
    "LAB_0041f89c",
    "LAB_0041f8a8",
    "LAB_0041f8b4",
    "LAB_0041f8c0",
    "LAB_0041f8cb",
    "LAB_0041f8f0",
    "LAB_0041f8fb",
    "LAB_0041f8ff",
    "LAB_0041f90b",
    "LAB_0041f911",
    "LAB_0041f92f",
    "LAB_0041f93c",
    "LAB_0041f947",
    "LAB_0041f949",
    "LAB_0041f994",
    "LAB_0041f9ce",
    "LAB_0041f9ee",
    "LAB_0041f9f7",
    "LAB_0041fa00",
    "LAB_0041fa09",
    "LAB_0041fa12",
    "LAB_0041fa38",
    "LAB_0041fa44",
    "LAB_0041fa48",
    "LAB_0041fa56",
    "LAB_0041fa58",
    "LAB_0041fa73",
    "LAB_0041fa7e",
    "LAB_0041fa87",
    "LAB_0041fa89",
    "LAB_0041fa97",
    "LAB_0041fa9c",
    "LAB_0041fac2",
    "LAB_0041facd",
    "LAB_0041fade",
    "LAB_0041faef",
    "LAB_0041faf6",
    "LAB_0041fb4c",
    "LAB_0041fb52",
    "LAB_0041fb6d",
    "LAB_0041fb8e",
    "LAB_0041fbaf",
    "LAB_0041fbc2",
    "LAB_0041fbc4",
    "LAB_0041fbca",
    "LAB_0041fbd9",
    "LAB_0041fbe9",
    "LAB_0041fc05",
    "LAB_0041fc19",
    "LAB_0041fc3c",
    "LAB_0041fc3d",
    "LAB_0041fc8c",
    "LAB_0041fc9b",
    "LAB_0041fc9e",
    "LAB_0041fcb3",
    "LAB_0041fcca",
    "LAB_0041fcce",
    "LAB_0041fd0e",
    "LAB_0041fd12",
    "LAB_0041fd14",
    "LAB_0041fd17",
    "LAB_0041fd1e",
    "LAB_0041fd3b",
    "LAB_0041fd4a",
    "LAB_0041fd64",
    "LAB_0041fdb4",
    "LAB_0041fdc4",
    "LAB_0041fdcc",
    "LAB_0041fdce",
    "LAB_0041fe7f",
    "LAB_0041feb4",
    "LAB_0041fecf",
    "LAB_0041ff11",
    "LAB_0041ff1f",
    "LAB_0041ff4d",
    "LAB_0041ff56",
    "LAB_0041ff58",
    "LAB_0041fff9",
    "LAB_00420044",
    "LAB_00420060",
    "LAB_0042008c",
    "LAB_0042009a",
    "LAB_004200c8",
    "LAB_004200d1",
    "LAB_004200d3",
    "LAB_004200e5",
    "LAB_004200f9",
    "LAB_00420110",
    "LAB_0042011a",
    "LAB_00420160",
    "LAB_0042016a",
    "LAB_004201b0",
    "LAB_004201d3",
    "LAB_004201f7",
    "LAB_0042020f",
    "LAB_00420223",
    "LAB_00420239",
    "LAB_00420248",
    "LAB_00420254",
    "LAB_0042025d",
    "LAB_00420261",
    "LAB_0042026a",
    "LAB_00420274",
    "LAB_0042027c",
    "LAB_00420295",
    "LAB_00420298",
    "LAB_004202a8",
    "LAB_004202af",
    "LAB_004202ba",
    "LAB_004202c1",
    "LAB_004202c3",
    "LAB_004202ff",
    "LAB_0042032c",
    "LAB_00420334",
    "LAB_0042033c",
    "LAB_00420349",
    "LAB_00420358",
    "LAB_0042035d",
    "LAB_00420367",
    "LAB_0042036b",
    "LAB_0042036d",
    "LAB_004203a0",
    "LAB_004203c4",
    "LAB_004203d7",
    "LAB_004203f0",
    "LAB_00420429",
    "LAB_00420440",
    "LAB_0042045c",
    "LAB_004204ad",
    "LAB_004204b8",
    "LAB_00420506",
    "LAB_00420510",
    "LAB_0042055c",
    "LAB_00420574",
    "LAB_00420587",
    "LAB_0042059e",
    "LAB_004205a7",
    "LAB_004205af",
    "LAB_004205c2",
    "LAB_00420634",
    "LAB_00420660",
    "LAB_0042066d",
    "LAB_004206e5",
    "LAB_004206ed",
    "LAB_004206fc",
    "LAB_0042076c",
    "LAB_00420771",
    "LAB_00420794",
    "LAB_0042079c",
    "LAB_004207b1",
    "LAB_004207b5",
    "LAB_004207c4",
    "LAB_004207d0",
    "LAB_004207dd",
    "LAB_004207f0",
    "LAB_0042084d",
    "LAB_00420860",
    "LAB_0042087b",
    "LAB_00420887",
    "LAB_00420896",
    "LAB_0042089d",
    "LAB_004208b0",
    "LAB_004208c0",
    "LAB_004208d3",
    "LAB_004208dc",
    "LAB_004208e1",
    "LAB_004208ee",
    "LastErrorValue",
    "LastStatusValue",
    "LockCount",
    "LongLongSub",
    "MergedPrefLanguages",
    "MuiGeneration",
    "MuiImpersonation",
    "NlsCache",
    "Ordinal_14",
    "PTR_CloseHandle_004210d4",
    "PTR_CompareStringW_00421134",
    "PTR_ConvertStringSecurityDescriptorToSecurityDescriptorW_00421000",
    "PTR_CreateDirectoryW_00421040",
    "PTR_CreateFileW_004210c8",
    "PTR_CreateProcessW_00421034",
    "PTR_DAT_00425e00",
    "PTR_DAT_004276f8",
    "PTR_DAT_00429200",
    "PTR_DAT_0042b714",
    "PTR_DAT_0042d248",
    "PTR_DAT_0042d304",
    "PTR_DAT_0042d830",
    "PTR_DAT_0042d834",
    "PTR_DAT_0042d840",
    "PTR_DAT_0042d844",
    "PTR_DAT_0042d848",
    "PTR_DAT_0042d84c",
    "PTR_DAT_0042d850",
    "PTR_DAT_0042d854",
    "PTR_DAT_0042d858",
    "PTR_DAT_0042d85c",
    "PTR_DAT_0042d860",
    "PTR_DAT_0042d864",
    "PTR_DAT_0042d870",
    "PTR_DAT_0042d874",
    "PTR_DAT_0042d878",
    "PTR_DAT_0042d87c",
    "PTR_DAT_0042d880",
    "PTR_DAT_0042d884",
    "PTR_DAT_0042d888",
    "PTR_DAT_0042d88c",
    "PTR_DAT_0042d910",
    "PTR_DecodePointer_00421060",
    "PTR_DeleteCriticalSection_004210a4",
    "PTR_DeleteFileW_00421104",
    "PTR_EnterCriticalSection_0042109c",
    "PTR_ExitProcess_00421110",
    "PTR_ExpandEnvironmentStringsW_00421020",
    "PTR_FileTimeToSystemTime_004210e0",
    "PTR_FindClose_004210f0",
    "PTR_FindFirstFileExW_004210f4",
    "PTR_FindNextFileW_004210f8",
    "PTR_FlushFileBuffers_00421140",
    "PTR_FormatMessageW_00421048",
    "PTR_FreeEnvironmentStringsW_0042115c",
    "PTR_FreeLibrary_004210bc",
    "PTR_GetACP_00421118",
    "PTR_GetCPInfo_00421154",
    "PTR_GetCommandLineA_004210c0",
    "PTR_GetCommandLineW_00421014",
    "PTR_GetConsoleCP_00421130",
    "PTR_GetConsoleMode_00421124",
    "PTR_GetCurrentDirectoryW_0042113c",
    "PTR_GetCurrentProcessId_0042107c",
    "PTR_GetCurrentProcess_0042106c",
    "PTR_GetCurrentThreadId_00421080",
    "PTR_GetDriveTypeW_004210cc",
    "PTR_GetEnvironmentStringsW_00421158",
    "PTR_GetEnvironmentVariableW_00421018",
    "PTR_GetExitCodeProcess_00421030",
    "PTR_GetFileAttributesExW_00421148",
    "PTR_GetFileType_004210d0",
    "PTR_GetFullPathNameA_004210e8",
    "PTR_GetFullPathNameW_004210e4",
    "PTR_GetLastError_0042105c",
    "PTR_GetModuleFileNameW_00421008",
    "PTR_GetModuleHandleExW_00421114",
    "PTR_GetModuleHandleW_00421090",
    "PTR_GetOEMCP_00421150",
    "PTR_GetProcAddress_0042100c",
    "PTR_GetProcessHeap_00421164",
    "PTR_GetShortPathNameW_00421044",
    "PTR_GetStartupInfoW_00421038",
    "PTR_GetStdHandle_00421108",
    "PTR_GetStringTypeW_00421160",
    "PTR_GetSystemTimeAsFileTime_00421084",
    "PTR_GetTempPathW_00421024",
    "PTR_GetTimeZoneInformation_0042116c",
    "PTR_HeapAlloc_00421120",
    "PTR_HeapFree_0042111c",
    "PTR_HeapReAlloc_00421174",
    "PTR_HeapSize_00421170",
    "PTR_InitializeCriticalSectionAndSpinCount_004210a8",
    "PTR_InitializeSListHead_00421088",
    "PTR_IsDebuggerPresent_0042108c",
    "PTR_IsProcessorFeaturePresent_00421074",
    "PTR_IsValidCodePage_0042114c",
    "PTR_LAB_00426818",
    "PTR_LCMapStringW_00421138",
    "PTR_LeaveCriticalSection_004210a0",
    "PTR_LoadLibraryA_0042104c",
    "PTR_LoadLibraryExW_0042103c",
    "PTR_MultiByteToWideChar_00421050",
    "PTR_Ordinal_14_00421184",
    "PTR_PTR_0042d300",
    "PTR_PeekNamedPipe_004210d8",
    "PTR_QueryPerformanceCounter_00421078",
    "PTR_RaiseException_0042117c",
    "PTR_ReadConsoleW_00421128",
    "PTR_ReadFile_004210c4",
    "PTR_RemoveDirectoryW_004210ec",
    "PTR_RtlUnwind_00421094",
    "PTR_SetConsoleCtrlHandler_00421100",
    "PTR_SetDllDirectoryW_0042102c",
    "PTR_SetEndOfFile_00421178",
    "PTR_SetEnvironmentVariableA_00421144",
    "PTR_SetEnvironmentVariableW_0042101c",
    "PTR_SetErrorMode_00421010",
    "PTR_SetFilePointerEx_0042112c",
    "PTR_SetLastError_00421098",
    "PTR_SetStdHandle_004210fc",
    "PTR_SetUnhandledExceptionFilter_00421068",
    "PTR_Sleep_00421058",
    "PTR_SystemTimeToTzSpecificLocalTime_004210dc",
    "PTR_TerminateProcess_00421070",
    "PTR_TlsAlloc_004210ac",
    "PTR_TlsFree_004210b8",
    "PTR_TlsGetValue_004210b0",
    "PTR_TlsSetValue_004210b4",
    "PTR_UnhandledExceptionFilter_00421064",
    "PTR_WaitForSingleObject_00421028",
    "PTR_WideCharToMultiByte_00421054",
    "PTR_WriteConsoleW_00421168",
    "PTR_WriteFile_0042110c",
    "PTR_caseD_405aa2_00406950",
    "PTR_caseD_406811_00406994",
    "PTR_guard_check_icall_0042118c",
    "PTR_s_No_error_00426f68",
    "PTR_u_advapi32_00425e08",
    "PTR_u_api-ms-win-appmodel-runtime-l1-1_004269f8",
    "PTR_u_id-id_00429588",
    "PTR_u_ja-JP_00427890",
    "PTR_u_ko-KR_00427898",
    "PTR_u_zh-CN_00427894",
    "PTR_u_zh-TW_0042789c",
    "PreferredLanguages",
    "ProcessEnvironmentBlock",
    "RealClientId",
    "ReservedForNtRpc",
    "ReservedForOle",
    "ReservedForPerf",
    "ResourceRetValue",
    "Rsrc_GroupIcon_65_0",
    "Rsrc_Icon_1_0",
    "Rsrc_Icon_2_0",
    "Rsrc_Icon_3_0",
    "Rsrc_Icon_4_0",
    "Rsrc_Icon_5_0",
    "Rsrc_Icon_6_0",
    "Rsrc_Icon_7_0",
    "RtlUnwind",
    "SameTebFlags",
    "SavedPriorityState",
    "Self",
    "SoftPatchPtr1",
    "SpareBytes",
    "StackBase",
    "StackLimit",
    "StaticUnicodeBuffer",
    "SubProcessTag",
    "SubSystemTib",
    "SystemReserved1",
    "ThreadLocalStoragePointer",
    "ThreadPoolData",
    "TlsExpansionSlots",
    "TlsLinks.Blink",
    "TlsLinks.Flink",
    "TlsSlots",
    "TxFsContext",
    "TxnScopeContext",
    "TxnScopeEnterCallback",
    "TxnScopeExitCallback",
    "User32Reserved",
    "UserPrefLanguages",
    "UserReserved",
    "Vdm",
    "WOW32Reserved",
    "WaitingOnLoaderLock",
    "Win32ClientInfo",
    "Win32ThreadInfo",
    "WinSockData",
    "_EH4_CallFilterFunc",
    "_EH4_GlobalUnwind2",
    "_EH4_LocalUnwind",
    "_EH4_TransferToHandler",
    "_ValidateLocalCookies",
    "__87except",
    "__FindPESection",
    "__IsNonwritableInCurrentImage",
    "__NLG_Notify",
    "__SEH_epilog4",
    "__SEH_prolog4",
    "__SEH_prolog4_GS",
    "__ValidateImageBase",
    "____lc_codepage_func",
    "___acrt_AreFileApisANSI@0",
    "___acrt_CompareStringA",
    "___acrt_CompareStringEx@36",
    "___acrt_CompareStringW",
    "___acrt_DownlevelLocaleNameToLCID",
    "___acrt_FlsAlloc@4",
    "___acrt_FlsFree@4",
    "___acrt_FlsGetValue@4",
    "___acrt_FlsSetValue@8",
    "___acrt_GetFileInformationByHandleEx@16",
    "___acrt_GetStringTypeA",
    "___acrt_InitializeCriticalSectionEx@12",
    "___acrt_LCMapStringA",
    "___acrt_LCMapStringEx@36",
    "___acrt_LCMapStringW",
    "___acrt_LocaleNameToLCID@8",
    "___acrt_add_locale_ref",
    "___acrt_allocate_buffer_for_argv",
    "___acrt_call_reportfault",
    "___acrt_copy_path_to_wide_string",
    "___acrt_errno_from_os_error",
    "___acrt_errno_map_os_error",
    "___acrt_execute_initializers",
    "___acrt_execute_uninitializers",
    "___acrt_fltout",
    "___acrt_fp_format",
    "___acrt_fp_strflt_to_string",
    "___acrt_free_locale",
    "___acrt_get_sigabrt_handler",
    "___acrt_getptd",
    "___acrt_getptd_noexit",
    "___acrt_has_user_matherr",
    "___acrt_initialize",
    "___acrt_initialize_multibyte",
    "___acrt_initialize_signal_handlers",
    "___acrt_invoke_user_matherr",
    "___acrt_iob_func",
    "___acrt_is_packaged_app",
    "___acrt_locale_add_lc_time_reference",
    "___acrt_locale_free_lc_time_if_unreferenced",
    "___acrt_locale_free_monetary",
    "___acrt_locale_free_numeric",
    "___acrt_locale_free_time",
    "___acrt_locale_release_lc_time_reference",
    "___acrt_lock",
    "___acrt_lowio_create_handle_array",
    "___acrt_lowio_destroy_handle_array",
    "___acrt_lowio_ensure_fh_exists",
    "___acrt_lowio_lock_fh",
    "___acrt_lowio_set_os_handle",
    "___acrt_lowio_unlock_fh",
    "___acrt_release_locale_ref",
    "___acrt_set_locale_changed",
    "___acrt_stdio_allocate_buffer_nolock",
    "___acrt_stdio_begin_temporary_buffering_nolock",
    "___acrt_stdio_end_temporary_buffering_nolock",
    "___acrt_stdio_flush_nolock",
    "___acrt_stdio_free_buffer_nolock",
    "___acrt_strtok_s_novalidation",
    "___acrt_uninitialize",
    "___acrt_uninitialize_winapi_thunks",
    "___acrt_unlock",
    "___acrt_update_locale_info",
    "___acrt_update_multibyte_info",
    "___acrt_update_thread_locale_data",
    "___acrt_update_thread_multibyte_data",
    "___ascii_strnicmp",
    "___dcrt_get_narrow_environment_from_os",
    "___dcrt_get_wide_environment_from_os",
    "___dcrt_lowio_initialize_console_output",
    "___doserrno",
    "___get_abstract_control_sse2",
    "___get_abstract_control_x87",
    "___get_machine_control",
    "___get_machine_control_sse2",
    "___get_machine_status_sse2",
    "___get_machine_status_x87",
    "___hw_cw_sse2",
    "___isa_available_init",
    "___libm_error_support",
    "___pctype_func",
    "___raise_securityfailure",
    "___report_gsfailure",
    "___report_rangecheckfailure",
    "___report_securityfailure",
    "___scrt_acquire_startup_lock",
    "___scrt_fastfail",
    "___scrt_initialize_crt",
    "___scrt_initialize_onexit_tables",
    "___scrt_is_managed_app",
    "___scrt_is_nonwritable_in_current_image",
    "___scrt_is_ucrt_dll_in_use",
    "___scrt_release_startup_lock",
    "___scrt_unhandled_exception_filter@4",
    "___scrt_uninitialize_crt",
    "___security_init_cookie",
    "___set_fpsr_sse2",
    "___setusermatherr",
    "___stdio_common_vfprintf",
    "___stdio_common_vfprintf_p",
    "___stdio_common_vfprintf_s",
    "___stdio_common_vfwprintf",
    "___stdio_common_vfwprintf_p",
    "___stdio_common_vfwprintf_s",
    "___stdio_common_vsprintf",
    "___stdio_common_vswprintf",
    "___strncnt",
    "___tzset",
    "___vcrt_FlsAlloc",
    "___vcrt_FlsFree",
    "___vcrt_FlsSetValue",
    "___vcrt_InitializeCriticalSectionEx",
    "___vcrt_initialize",
    "___vcrt_initialize_locks",
    "___vcrt_initialize_ptd",
    "___vcrt_initialize_pure_virtual_call_handler",
    "___vcrt_initialize_winapi_thunks",
    "___vcrt_uninitialize",
    "___vcrt_uninitialize_locks",
    "___vcrt_uninitialize_ptd",
    "___vcrt_uninitialize_winapi_thunks",
    "__acrt_LCMapStringA_stat",
    "__acrt_fp_classify",
    "__acrt_fp_is_negative",
    "__acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>",
    "__acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>",
    "__acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>",
    "__acrt_lock_and_call<class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>_>",
    "__acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>",
    "__acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>",
    "__acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>",
    "__acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>",
    "__acrt_lock_stream_and_call<>",
    "__acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>",
    "__acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>",
    "__acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>",
    "__acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>",
    "__acrt_stdio_allocate_stream",
    "__acrt_stdio_free_stream",
    "__acrt_stdio_parse_mode<wchar_t>",
    "__acrt_stdio_parse_mode_D",
    "__acrt_stdio_parse_mode_T",
    "__acrt_stdio_parse_mode_c",
    "__acrt_stdio_parse_mode_n",
    "__acrt_stdio_parse_mode_plus",
    "__alldiv",
    "__alldvrm",
    "__allmul",
    "__alloc_osfhnd",
    "__alloca_probe",
    "__alloca_probe_16",
    "__alloca_probe_8",
    "__allshl",
    "__aulldvrm",
    "__aullshr",
    "__callnewh",
    "__calloc_base",
    "__cexit",
    "__chsize_nolock",
    "__chvalidchk_l",
    "__clearfp",
    "__close",
    "__close_nolock",
    "__clrfp",
    "__commit",
    "__configthreadlocale",
    "__control87",
    "__controlfp_s",
    "__crt_atexit",
    "__crt_fast_encode_pointer<>",
    "__crt_fast_encode_pointer<void*>",
    "__crt_stdio_path_requires_backslash",
    "__crt_time_elapsed_leap_years<int>",
    "__crt_time_is_day_valid",
    "__crt_time_is_leap_year<int>",
    "__ctrlfp",
    "__dupenv_s",
    "__errcode",
    "__errno",
    "__except1",
    "__except_handler4",
    "__execute_onexit_table",
    "__exit",
    "__fclose_nolock",
    "__fflush_nolock",
    "__fileno",
    "__fpclass",
    "__fputc_nolock",
    "__fread_nolock_s",
    "__free_base",
    "__free_osfhnd",
    "__freea_crt",
    "__fullpath",
    "__fwrite_nolock",
    "__get_daylight",
    "__get_dstbias",
    "__get_errno_from_oserr",
    "__get_fmode",
    "__get_initial_narrow_environment",
    "__get_initial_wide_environment",
    "__get_osfhandle",
    "__get_printf_count_output",
    "__get_sys_err_msg",
    "__get_timezone",
    "__getcwd",
    "__getdrive",
    "__getfpcontrolword",
    "__getfpstatusword",
    "__global_unwind2",
    "__handle_exc",
    "__hw_cw",
    "__initialize_onexit_table",
    "__initterm",
    "__initterm_e",
    "__invalid_parameter",
    "__invoke_watson",
    "__isatty",
    "__ischartype_l",
    "__isctype_l",
    "__isdigit_l",
    "__isindst",
    "__isleadbyte_l",
    "__local_unwind2",
    "__local_unwind4",
    "__lock_file",
    "__lseeki64",
    "__lseeki64_nolock",
    "__malloc_base",
    "__math_exit",
    "__mbtowc_l",
    "__onexit",
    "__putenv_s",
    "__putwch_nolock",
    "__query_new_handler",
    "__raise_exc",
    "__raise_exc_ex",
    "__read",
    "__read_nolock",
    "__realloc_base",
    "__register_onexit_function",
    "__register_thread_local_exe_atexit_callback",
    "__scrt_common_main_seh",
    "__security_check_cookie",
    "__seh_filter_exe",
    "__set_errno_from_matherr",
    "__set_exp",
    "__set_fmode",
    "__set_new_mode",
    "__setfpcontrolword",
    "__setfpstatusword",
    "__setmbcp_nolock",
    "__setmode",
    "__setmode_nolock",
    "__sopen_s",
    "__sptype",
    "__startOneArgErrorHandling",
    "__stat32i64",
    "__stat64",
    "__stat64i32",
    "__statfp",
    "__strdup",
    "__strnicmp",
    "__strnicmp_l",
    "__strnicoll",
    "__strnicoll_l",
    "__tolower_l",
    "__towlower_l",
    "__ultow_s",
    "__umatherr",
    "__unlock_file",
    "__updatetlocinfoEx_nolock",
    "__waccess_s",
    "__wcsicmp",
    "__wcsicmp_l",
    "__wcsnicmp",
    "__wcsnicmp_l",
    "__wcsnicoll",
    "__wcsnicoll_l",
    "__wctomb_s_l",
    "__wdupenv_s",
    "__wfopen",
    "__wfullpath",
    "__wgetcwd",
    "__wputenv_s",
    "__write",
    "__write_nolock",
    "__wsopen_nolock",
    "__wsopen_s",
    "__wtempnam",
    "_abort",
    "_atexit",
    "_atol",
    "_clearerr_s",
    "_common_flush_all",
    "_exit",
    "_fclose",
    "_fegetenv",
    "_feholdexcept",
    "_feof",
    "_ferror",
    "_fesetenv",
    "_fflush",
    "_fread",
    "_fread_s",
    "_free",
    "_fseek",
    "_fwrite",
    "_guard_check_icall",
    "_isdigit",
    "_isindst_nolock",
    "_iswctype",
    "_mbstowcs",
    "_mbstowcs_l_helper",
    "_mbtowc",
    "_memcpy_s",
    "_memset",
    "_perror",
    "_qsort",
    "_raise",
    "_setbuf",
    "_setvbuf",
    "_signal",
    "_strcpy_s",
    "_strncat",
    "_strncmp",
    "_strncpy",
    "_strpbrk",
    "_strtok",
    "_strtol",
    "_terminate",
    "_tolower",
    "_wcscat_s",
    "_wcscpy_s",
    "_wcsncmp",
    "_wcspbrk",
    "_wcstol",
    "_wctomb_s",
    "append",
    "atexit_exception_filter",
    "call_wfullpath",
    "common_configure_argv<wchar_t>",
    "common_dupenv_s<wchar_t>",
    "common_dupenv_s_nolock<wchar_t>",
    "common_exit",
    "common_expand_argv_wildcards<wchar_t>",
    "common_find_first_wide<struct__wfinddata64i32_t>",
    "common_find_next_wide<struct__wfinddata64i32_t>",
    "common_flush_all",
    "common_flush_and_write_nolock<char>",
    "common_fseek",
    "common_fseek_binary_mode_read_only_fast_track_nolock",
    "common_fseek_nolock",
    "common_fsopen<wchar_t>",
    "common_ftell<long>",
    "common_ftell_nolock<__int64>",
    "common_ftell_nolock<long>",
    "common_ftell_read_mode_nolock",
    "common_ftell_translated_utf8_nolock",
    "common_fullpath_dynamic_buffer<char>",
    "common_fullpath_dynamic_buffer<wchar_t>",
    "common_fullpath_user_buffer<char>",
    "common_fullpath_user_buffer<wchar_t>",
    "common_get_or_create_environment_nolock<char>",
    "common_get_or_create_environment_nolock<wchar_t>",
    "common_getdcwd<char>",
    "common_getdcwd<wchar_t>",
    "common_getdcwd_dynamic_buffer<char>",
    "common_getdcwd_dynamic_buffer<wchar_t>",
    "common_getdcwd_user_buffer<char>",
    "common_getdcwd_user_buffer<wchar_t>",
    "common_getenv_nolock<char>",
    "common_getenv_nolock<wchar_t>",
    "common_getenv_s<char>",
    "common_getenv_s_nolock<char>",
    "common_initialize_environment_nolock<char>",
    "common_initialize_environment_nolock<wchar_t>",
    "common_loctotime_t<__int64>",
    "common_lseek<__int64>",
    "common_lseek_nolock<__int64>",
    "common_openfile<wchar_t>",
    "common_putenv<>",
    "common_putenv_nolock<wchar_t>",
    "common_refill_and_read_nolock<char>",
    "common_set_variable_in_environment_nolock<char>",
    "common_set_variable_in_environment_nolock<wchar_t>",
    "common_sopen_dispatch<wchar_t>",
    "common_stat<struct__stat64i32>",
    "common_stat_handle_file_not_opened<struct__stat64i32>",
    "common_stat_handle_file_opened<struct__stat64i32>",
    "common_tcsncpy_s<char>",
    "common_tcsncpy_s<wchar_t>",
    "common_tempnam<wchar_t>",
    "common_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>",
    "common_vsprintf<class___crt_stdio_output::standard_base,char>",
    "common_vsprintf<class___crt_stdio_output::standard_base,wchar_t>",
    "common_xtox<unsigned_long,wchar_t>",
    "common_xtox_s<unsigned_long,wchar_t>",
    "compute_name<wchar_t>",
    "compute_size",
    "configure_text_mode",
    "construct_ptd",
    "convert_file_time_to_time_t<__int64>",
    "convert_large_integer_time_to_time_t<__int64>",
    "convert_to_stat_mode",
    "copy_and_add_argument_to_buffer<wchar_t>",
    "copy_environment<char>",
    "copy_environment<wchar_t>",
    "create_environment<char>",
    "create_environment<wchar_t>",
    "create_environment_string<wchar_t>",
    "create_file",
    "cvtdate",
    "decode_open_create_flags",
    "decode_options",
    "destroy_fls",
    "destroy_ptd",
    "entry",
    "exit_or_terminate_process",
    "expand_argument_wildcards<wchar_t>",
    "expand_if_necessary",
    "fegetenv",
    "feholdexcept",
    "fesetenv",
    "find_end_of_double_null_terminated_sequence",
    "find_in_environment_nolock<char>",
    "find_in_environment_nolock<wchar_t>",
    "find_next_state",
    "find_or_allocate_unused_stream_nolock",
    "find_pe_section",
    "fp_format_a",
    "fp_format_e",
    "fp_format_e_internal",
    "fp_format_f",
    "fp_format_f_internal",
    "fp_format_g",
    "fp_format_nan_or_infinity",
    "free_crt_array_internal",
    "free_environment<wchar_t>",
    "getSystemCP",
    "get_directory<wchar_t>",
    "get_drive_number_from_path",
    "get_global_action_nolock",
    "glContext",
    "glCurrentRC",
    "glDispatchTable",
    "glReserved1",
    "glReserved2",
    "glSection",
    "glSectionInfo",
    "glTable",
    "guard_check_icall",
    "has_executable_extension",
    "initialize",
    "initialize_environment_by_cloning_nolock<char>",
    "initialize_environment_by_cloning_nolock<wchar_t>",
    "initialize_inherited_file_handles_nolock",
    "internal_isupper_l",
    "is_root_or_empty",
    "is_root_unc_name",
    "is_slash",
    "is_usable_drive_or_unc_root",
    "is_valid_drive",
    "make_c_string_character_source<>",
    "operator()<>",
    "output_adapter_data<>",
    "output_processor<>",
    "pShimData",
    "parse_command_line<wchar_t>",
    "parse_int_from_format_string",
    "replace_current_thread_locale_nolock",
    "s_%U?%d_00422c38",
    "s_%s%s%s%s%s%s%s_0042168c",
    "s_%s%s%s%s%s_0042163c",
    "s_%s%s%s.exe_004216dc",
    "s_%s%s%s.pkg_004216d0",
    "s_%s%s%s_004216e8",
    "s_%s:_%s_00421494",
    "s_%s?%d_00422c30",
    "s_%s_could_not_be_extracted!_004212e0",
    "s_(null)_004266e4",
    "s_1#IND_0042ab30",
    "s_1#INF_0042ab18",
    "s_1#QNAN_0042ab20",
    "s_1#SNAN_0042ab28",
    "s_1.2.11_0042122c",
    "s_ActivateActCtx_00422f3c",
    "s_April_00427448",
    "s_Archive_not_found:_%s_004216f0",
    "s_Archive_path_exceeds_PATH_MAX_00421584",
    "s_AreFileApisANSI_00426e9c",
    "s_Arg_list_too_long_004270b4",
    "s_August_00427460",
    "s_Bad_address_00427150",
    "s_Bad_file_descriptor_004270dc",
    "s_Base_Class_Array'_00426630",
    "s_Base_Class_Descriptor_at_(_00426614",
    "s_Broken_pipe_00427294",
    "s_Cannot_allocate_memory_for_ARCHI_00421864",
    "s_Cannot_open_archive_file_00421270",
    "s_Cannot_open_self_%s_or_archive_%_004218c8",
    "s_Cannot_read_Table_of_Contents._004211e0",
    "s_Class_Hierarchy_Descriptor'_00426644",
    "s_CompareStringEx_00426eb4",
    "s_Complete_Object_Locator'_00426664",
    "s_CorExitProcess_00426808",
    "s_Could_not_allocate_buffer_for_TO_00421400",
    "s_Could_not_allocate_read_buffer_0042128c",
    "s_Could_not_get___main___module's_d_0042176c",
    "s_Could_not_get___main___module._0042174c",
    "s_Could_not_read_from_file._0042142c",
    "s_Could_not_read_from_file_004212ac",
    "s_CreateActCtxW_00422f2c",
    "s_CreateProcessW_00422e70",
    "s_DLL_name_length_exceeds_buffer_00422700",
    "s_December_00427488",
    "s_Directory_not_empty_00427324",
    "s_Domain_error_004272a0",
    "s_Error_%d_from_inflate:_%s_00421234",
    "s_Error_%d_from_inflateInit:_%s_00421250",
    "s_Error_allocating_decompression_b_00421204",
    "s_Error_allocating_memory_for_stat_00421560",
    "s_Error_copying_%s_00421674",
    "s_Error_creating_child_process!_00422e50",
    "s_Error_decompressing_%s_004212c8",
    "s_Error_detected_starting_Python_V_00422aa4",
    "s_Error_extracting_%s_00421708",
    "s_Error_loading_Python_DLL_'%s'._00422770",
    "s_Error_on_file_._00421450",
    "s_Error_opening_archive_%s_004215a4",
    "s_Exec_format_error_004270c8",
    "s_Failed_to_append_to_sys.path_00422c70",
    "s_Failed_to_convert_%s_to_ShortFil_00422c08",
    "s_Failed_to_convert_Wflag_%s_using_004227e0",
    "s_Failed_to_convert_argv_to_mbcs_00422844",
    "s_Failed_to_convert_argv_to_wchar__00422864",
    "s_Failed_to_convert_executable_pat_00421aac",
    "s_Failed_to_convert_progname_to_wc_00422888",
    "s_Failed_to_convert_pyhome_to_ANSI_004228ec",
    "s_Failed_to_convert_pyhome_to_wcha_00422948",
    "s_Failed_to_convert_pypath_to_ANSI_00422a64",
    "s_Failed_to_convert_pypath_to_wcha_00422988",
    "s_Failed_to_decode_wchar_t_from_UT_00423144",
    "s_Failed_to_encode__MEIPASS_as_ANS_00422ae8",
    "s_Failed_to_encode_filename_as_ANS_0042305c",
    "s_Failed_to_encode_wchar_t_as_UTF-_004230e8",
    "s_Failed_to_execute_script_%s_004217f8",
    "s_Failed_to_get_ANSI_buffer_size._00423024",
    "s_Failed_to_get_UTF-8_buffer_size._004230c4",
    "s_Failed_to_get__MEIPASS_as_PyObje_00422b1c",
    "s_Failed_to_get_address_for_PyDict_00421f68",
    "s_Failed_to_get_address_for_PyErr__00421fa4",
    "s_Failed_to_get_address_for_PyErr__00421fdc",
    "s_Failed_to_get_address_for_PyErr__00422014",
    "s_Failed_to_get_address_for_PyEval_004224ac",
    "s_Failed_to_get_address_for_PyImpo_00422050",
    "s_Failed_to_get_address_for_PyImpo_00422098",
    "s_Failed_to_get_address_for_PyImpo_004220e4",
    "s_Failed_to_get_address_for_PyList_00422128",
    "s_Failed_to_get_address_for_PyList_00422160",
    "s_Failed_to_get_address_for_PyLong_00422198",
    "s_Failed_to_get_address_for_PyMars_004224f8",
    "s_Failed_to_get_address_for_PyModu_004221d8",
    "s_Failed_to_get_address_for_PyObje_0042221c",
    "s_Failed_to_get_address_for_PyObje_00422268",
    "s_Failed_to_get_address_for_PyRun__004222b0",
    "s_Failed_to_get_address_for_PyStri_004222f4",
    "s_Failed_to_get_address_for_PyStri_00422338",
    "s_Failed_to_get_address_for_PySys__0042237c",
    "s_Failed_to_get_address_for_PySys__004223bc",
    "s_Failed_to_get_address_for_PySys__004223f8",
    "s_Failed_to_get_address_for_PySys__00422434",
    "s_Failed_to_get_address_for_PySys__00422470",
    "s_Failed_to_get_address_for_PyUnic_0042254c",
    "s_Failed_to_get_address_for_PyUnic_0042260c",
    "s_Failed_to_get_address_for_PyUnic_00422650",
    "s_Failed_to_get_address_for_PyUnic_00422698",
    "s_Failed_to_get_address_for_Py_Bui_00421d60",
    "s_Failed_to_get_address_for_Py_Dec_00421d98",
    "s_Failed_to_get_address_for_Py_Dec_0042258c",
    "s_Failed_to_get_address_for_Py_Don_00421b28",
    "s_Failed_to_get_address_for_Py_Fil_00421b8c",
    "s_Failed_to_get_address_for_Py_Fin_00421dcc",
    "s_Failed_to_get_address_for_Py_Fro_00421bd4",
    "s_Failed_to_get_address_for_Py_Get_00421ea4",
    "s_Failed_to_get_address_for_Py_Ign_00421c1c",
    "s_Failed_to_get_address_for_Py_Inc_00421e00",
    "s_Failed_to_get_address_for_Py_Ini_00421e38",
    "s_Failed_to_get_address_for_Py_NoS_00421c60",
    "s_Failed_to_get_address_for_Py_NoU_00421ca4",
    "s_Failed_to_get_address_for_Py_Opt_00421ce8",
    "s_Failed_to_get_address_for_Py_Set_00421e70",
    "s_Failed_to_get_address_for_Py_Set_00421ee0",
    "s_Failed_to_get_address_for_Py_Set_00421f24",
    "s_Failed_to_get_address_for_Py_Ver_00421d24",
    "s_Failed_to_get_address_for__Py_ch_004225c8",
    "s_Failed_to_get_executable_path._00421a78",
    "s_Failed_to_get_short_path_name_fo_00423080",
    "s_Failed_to_get_wchar_t_buffer_siz_0042310c",
    "s_Failed_to_unmarshal_code_object_f_004217d0",
    "s_Failed_to_write_all_bytes_for_%s_00421304",
    "s_February_00427434",
    "s_File_exists_0042717c",
    "s_File_too_large_00427234",
    "s_Filename_too_long_004272e0",
    "s_FlsAlloc_00425ec0",
    "s_FlsFree_00425ed4",
    "s_FlsGetValue_00425edc",
    "s_FlsSetValue_00425ef0",
    "s_FormatMessageW_00422ea0",
    "s_Friday_004273e8",
    "s_Function_not_implemented_00427308",
    "s_GetCurrentPackageId_00426eec",
    "s_GetFileInformationByHandleEx_00426f08",
    "s_GetModuleFileNameW_00421a98",
    "s_GetProcAddress_00421b5c",
    "s_HH:mm:ss_004274bc",
    "s_INTERNAL_ERROR:_cannot_create_te_00422d5c",
    "s_Illegal_byte_sequence_00427338",
    "s_Improper_link_00427188",
    "s_Inappropriate_I/O_control_operat_00427210",
    "s_InitializeCriticalSectionEx_00425f04",
    "s_Input/output_error_00427084",
    "s_Installing_PYZ:_Could_not_get_sy_00422c48",
    "s_Interrupted_function_call_00427068",
    "s_Invalid_argument_004271c8",
    "s_Invalid_seek_0042725c",
    "s_Is_a_directory_004271b8",
    "s_January_0042742c",
    "s_LCMapStringEx_00426f38",
    "s_LOADER:_%s_contains_a_digital_si_00421378",
    "s_LOADER:_Activation_context_activ_00422fc0",
    "s_LOADER:_Activation_context_creat_00422f9c",
    "s_LOADER:_Already_in_the_child_-_r_00421960",
    "s_LOADER:_Archive_found:_%s_00421514",
    "s_LOADER:_Back_to_parent_(RC:_%d)_00421a3c",
    "s_LOADER:_Bootloader_option:_%s_004227a4",
    "s_LOADER:_Cannot_find_CreateActCtx_00422f50",
    "s_LOADER:_Cannot_open_archive:_%s_004213c0",
    "s_LOADER:_Checking_if_file_exists_00421614",
    "s_LOADER:_Checking_next_archive_in_00421530",
    "s_LOADER:_Cleaning_up_Python_inter_00422ce4",
    "s_LOADER:_Coping_file_%s_to_%s_004214d0",
    "s_LOADER:_Could_not_find_a_valid_m_0042133c",
    "s_LOADER:_Creating_child_process_00422e00",
    "s_LOADER:_Doing_cleanup_00421a60",
    "s_LOADER:_Error_activating_the_con_00422fe8",
    "s_LOADER:_Error_extracting_binarie_004219d4",
    "s_LOADER:_Executing_self_as_child_004219f8",
    "s_LOADER:_Extracting_binaries_00421720",
    "s_LOADER:_Extracting_dependencies_004215f0",
    "s_LOADER:_Extracting_dependencies_f_004215c0",
    "s_LOADER:_File_%s_found,_assuming_i_00421648",
    "s_LOADER:_File_%s_not_found,_assum_0042169c",
    "s_LOADER:_Found_runtime-tmpdir_%s_00422d38",
    "s_LOADER:_Freeing_archive_status_f_00421460",
    "s_LOADER:_Getting_file_from_archiv_004214f0",
    "s_LOADER:_Initializing_python_004229f8",
    "s_LOADER:_Installing_PYZ_archive_w_00422c90",
    "s_LOADER:_Loaded_functions_from_Py_004226d0",
    "s_LOADER:_Manipulating_environment_004228b0",
    "s_LOADER:_No_need_to_extract_files_004218f0",
    "s_LOADER:_OK._00421838",
    "s_LOADER:_Overriding_Python's_sys._00422a18",
    "s_LOADER:_PYZ_archive:_%s_00422cc8",
    "s_LOADER:_Post-init_sys.path_is_%s_00422a40",
    "s_LOADER:_Pre-init_sys.path_is_%s_004229b0",
    "s_LOADER:_Python_library:_%s_00422754",
    "s_LOADER:_Running_%s_004217b0",
    "s_LOADER:_Runtime_option:_%s_004227c4",
    "s_LOADER:_SetDllDirectory(%s)_00421940",
    "s_LOADER:_Setting_runtime_options_004229d4",
    "s_LOADER:_Setting_sys.argv_00422828",
    "s_LOADER:_Setting_up_to_run_child_00422ddc",
    "s_LOADER:_Splitting_item_into_path_0042149c",
    "s_LOADER:_Waiting_for_child_proces_00422e20",
    "s_LOADER:__MEIPASS2_is_%s_004218ac",
    "s_LOADER:_archivename_is_%s_004213a4",
    "s_LOADER:_callfunction_returned..._00422bac",
    "s_LOADER:_callfunction_returned_NU_00422bd0",
    "s_LOADER:_executable_is_%s_00421ad8",
    "s_LOADER:_extracted_%s_00422b8c",
    "s_LOADER:_homepath_is_%s_00421af4",
    "s_LOADER:_importing_modules_from_C_00422b50",
    "s_LOADER:_manifestpath:_%s_00422f04",
    "s_LOADER:_set__MEIPASS2_to_%s_00421a1c",
    "s_LOADER:_setting_sys._MEIPASS_00422ac8",
    "s_LOADER:_sys.prefix_is_%s_0042292c",
    "s_LOADER:_temppath_exceeds_PATH_MA_00421998",
    "s_LOADER:_temppath_is_%s_004219bc",
    "s_LOADER:_ucrtbase.dll_is_exists:_%_00422730",
    "s_LoadLibrary_00422790",
    "s_Loader:_Cannot_find_cookie_004213e4",
    "s_LocaleNameToLCID_00426f50",
    "s_MM/dd/yy_0042749c",
    "s_March_00427440",
    "s_Monday_004273c0",
    "s_MultiByteToWideChar_00423130",
    "s_NAN(IND)_0042737c",
    "s_NAN(SNAN)_00427364",
    "s_Name_exceeds_PATH_MAX_00421794",
    "s_No_child_processes_004270f0",
    "s_No_error_00427018",
    "s_No_error_messages_generated._00422e80",
    "s_No_locks_available_004272f4",
    "s_No_space_left_on_device_00427244",
    "s_No_such_device_00427198",
    "s_No_such_device_or_address_00427098",
    "s_No_such_file_or_directory_0042703c",
    "s_No_such_process_00427058",
    "s_Not_a_directory_004271a8",
    "s_Not_enough_space_00427128",
    "s_November_0042747c",
    "s_October_00427474",
    "s_Operation_not_permitted_00427024",
    "s_Permission_denied_0042713c",
    "s_PyDict_GetItemString_00421f50",
    "s_PyErr_Clear_00421f98",
    "s_PyErr_Occurred_00421fcc",
    "s_PyErr_Print_00422008",
    "s_PyEval_EvalCode_0042249c",
    "s_PyImport_AddModule_0042203c",
    "s_PyImport_ExecCodeModule_00422080",
    "s_PyImport_ImportModule_004220cc",
    "s_PyInstaller:_FormatMessageW_fail_00422eb0",
    "s_PyInstaller:_pyi_win32_utils_to__00422ed4",
    "s_PyInstaller_Bootloader_3.x_00421848",
    "s_PyList_Append_00422118",
    "s_PyList_New_00422154",
    "s_PyLong_AsLong_00422188",
    "s_PyMarshal_ReadObjectFromString_004224d8",
    "s_PyModule_GetDict_004221c4",
    "s_PyObject_CallFunction_00422204",
    "s_PyObject_SetAttrString_00422250",
    "s_PyRun_SimpleString_0042229c",
    "s_PyString_FromFormat_00422324",
    "s_PyString_FromString_004222e0",
    "s_PySys_AddWarnOption_00422368",
    "s_PySys_GetObject_004223e8",
    "s_PySys_SetArgvEx_004223ac",
    "s_PySys_SetObject_00422424",
    "s_PySys_SetPath_00422460",
    "s_PyUnicode_DecodeFSDefault_0042267c",
    "s_PyUnicode_Decode_0042263c",
    "s_PyUnicode_FromFormat_004225f4",
    "s_PyUnicode_FromString_00422534",
    "s_Py_BuildValue_00421d50",
    "s_Py_DecRef_00421d8c",
    "s_Py_DecodeLocale_0042257c",
    "s_Py_DontWriteBytecodeFlag_00421b0c",
    "s_Py_FileSystemDefaultEncoding_00421b6c",
    "s_Py_Finalize_00421dc0",
    "s_Py_FrozenFlag_00421bc4",
    "s_Py_GetPath_00421e98",
    "s_Py_IgnoreEnvironmentFlag_00421c00",
    "s_Py_IncRef_00421df4",
    "s_Py_Initialize_00421e28",
    "s_Py_NoSiteFlag_00421c50",
    "s_Py_NoUserSiteDirectory_00421c8c",
    "s_Py_OptimizeFlag_00421cd8",
    "s_Py_SetPath_00421e64",
    "s_Py_SetProgramName_00421ecc",
    "s_Py_SetPythonHome_00421f10",
    "s_Py_VerboseFlag_00421d14",
    "s_Read-only_file_system_0042726c",
    "s_Resource_deadlock_avoided_004272c4",
    "s_Resource_device_0042716c",
    "s_Resource_temporarily_unavailable_00427104",
    "s_Result_too_large_004272b0",
    "s_Saturday_004273f0",
    "s_September_00427468",
    "s_Sunday_004273b8",
    "s_Thursday_004273dc",
    "s_Too_many_links_00427284",
    "s_Too_many_open_files_004271fc",
    "s_Too_many_open_files_in_system_004271dc",
    "s_Tuesday_004273c8",
    "s_Type_Descriptor'_00426600",
    "s_Unknown_error_0042715c",
    "s_WARNING:_file_already_exists_but_00422da4",
    "s_Wednesday_004273d0",
    "s_WideCharToMultiByte_00423048",
    "s_[%d]_0042148c",
    "s__MEIPASS2_00421898",
    "s__MEIPASS_00422b44",
    "s__Py_char2wchar_004225b8",
    "s___based(_004260b0",
    "s___cdecl_004260bc",
    "s___clrcall_00426104",
    "s___eabi_00426110",
    "s___fastcall_004260e8",
    "s___file___004217c4",
    "s___main___00421740",
    "s___pascal_004260c4",
    "s___ptr64_00426118",
    "s___restrict_00426120",
    "s___stdcall_004260d0",
    "s___thiscall_004260dc",
    "s___unaligned_0042612c",
    "s___vectorcall_004260f4",
    "s_`RTTI_004263d8",
    "s_`copy_constructor_closure'_004263a8",
    "s_`default_constructor_closure'_0042627c",
    "s_`dynamic_atexit_destructor_for_'_00426534",
    "s_`dynamic_initializer_for_'_00426518",
    "s_`eh_vector_constructor_iterator'_0042633c",
    "s_`eh_vector_copy_constructor_iter_004264c4",
    "s_`eh_vector_destructor_iterator'_00426360",
    "s_`eh_vector_vbase_constructor_ite_00426380",
    "s_`eh_vector_vbase_copy_constructo_004264ec",
    "s_`local_static_guard'_00426224",
    "s_`local_static_thread_guard'_004265d4",
    "s_`local_vftable'_004263e0",
    "s_`local_vftable_constructor_closu_004263f0",
    "s_`managed_vector_constructor_iter_00426474",
    "s_`managed_vector_copy_constructor_004265a8",
    "s_`managed_vector_destructor_itera_0042649c",
    "s_`omni_callsig'_00426428",
    "s_`placement_delete[]_closure'_00426454",
    "s_`placement_delete_closure'_00426438",
    "s_`scalar_deleting_destructor'_0042629c",
    "s_`string'_0042623c",
    "s_`typeof'_00426218",
    "s_`udt_returning'_004263c4",
    "s_`vbase_destructor'_00426248",
    "s_`vbtable'_00426204",
    "s_`vcall'_00426210",
    "s_`vector_constructor_iterator'_004262bc",
    "s_`vector_copy_constructor_iterato_00426558",
    "s_`vector_deleting_destructor'_0042625c",
    "s_`vector_destructor_iterator'_004262dc",
    "s_`vector_vbase_constructor_iterat_004262fc",
    "s_`vector_vbase_copy_constructor_i_0042657c",
    "s_`vftable'_004261f8",
    "s_`virtual_displacement_map'_00426320",
    "s_base_library.zip_00422970",
    "s_buffer_error_00425ca8",
    "s_calloc_00421890",
    "s_data_error_00425c88",
    "s_dddd,_MMMM_dd,_yyyy_004274a8",
    "s_delete[]_0042641c",
    "s_delete_0042614c",
    "s_e+000_00427394",
    "s_file_error_00425c6c",
    "s_fopen_004212fc",
    "s_fread_00421448",
    "s_fwrite_00421328",
    "s_header_crc_mismatch_00423aa4",
    "s_incompatible_version_00425cb8",
    "s_incorrect_data_check_00423bf8",
    "s_incorrect_header_check_00423a40",
    "s_incorrect_length_check_00423c10",
    "s_insufficient_memory_00425c94",
    "s_invalid_bit_length_repeat_00423b2c",
    "s_invalid_block_type_00423ab8",
    "s_invalid_code_--_missing_end-of-b_00423b48",
    "s_invalid_code_lengths_set_00423b10",
    "s_invalid_distance_code_00423bc0",
    "s_invalid_distance_too_far_back_00423bd8",
    "s_invalid_distances_set_00423b8c",
    "s_invalid_literal/length_code_00423ba4",
    "s_invalid_literal/lengths_set_00423b70",
    "s_invalid_stored_block_lengths_00423acc",
    "s_invalid_window_size_00423a74",
    "s_kernel32_00422f20",
    "s_loads_00422b84",
    "s_log10_0042abd0",
    "s_log10_0042ae18",
    "s_malloc_00421424",
    "s_marshal_00422b7c",
    "s_mod_is_NULL_-_%s_00422bf4",
    "s_nan(ind)_00427388",
    "s_nan(snan)_00427370",
    "s_need_dictionary_00425c50",
    "s_new[]_00426414",
    "s_operator_\"\"_004265f0",
    "s_operator_00426170",
    "s_plete_Object_Locator'_00426668",
    "s_pyi-runtime-tmpdir_00422d24",
    "s_pyi-windows-manifest-filename_00421818",
    "s_restrict(_00426138",
    "s_stream_end_00425c60",
    "s_stream_error_00425c78",
    "s_strict_00422b0c",
    "s_too_many_length_or_distance_symb_00423aec",
    "s_ucrtbase.dll_00422720",
    "s_unknown_compression_method_00423a58",
    "s_unknown_header_flags_set_00423a88",
    "s_utf-8_00422b14",
    "setSBCS",
    "setSBUpLow",
    "set_buffer",
    "set_variable_in_other_environment<wchar_t>",
    "setmbcp_internal",
    "shift_bytes",
    "shortsort",
    "siglookup",
    "signal_failed",
    "state_case_flag",
    "state_case_normal",
    "state_case_normal_common",
    "state_case_normal_tchar",
    "state_case_precision",
    "state_case_size",
    "state_case_width",
    "strip_quotes<wchar_t>",
    "swap",
    "terminate",
    "thunk_FUN_004031a0",
    "thunk_FUN_00406df0",
    "translate_ansi_or_utf8_nolock",
    "translate_text_mode_nolock<char>",
    "translate_text_mode_nolock<wchar_t>",
    "translate_utf16_from_console_nolock",
    "truncate_ctrl_z_if_present",
    "try_cor_exit_process",
    "try_get_CompareStringEx",
    "try_get_function",
    "try_get_module",
    "type_case_Z",
    "type_case_a",
    "type_case_c_tchar",
    "type_case_integer",
    "type_case_integer_parse_into_buffer<>",
    "type_case_n",
    "type_case_o",
    "type_case_p",
    "type_case_s",
    "type_case_s_compute_narrow_string_length",
    "tzset_from_environment_nolock",
    "tzset_from_system_nolock",
    "tzset_nolock",
    "u_(null)_004266ec",
    "u_.bat_00426714",
    "u_.cmd_00426708",
    "u_.com_00426720",
    "u_.exe_004266fc",
    "u_April_0042760c",
    "u_August_00427630",
    "u_CONOUT$_0042abbc",
    "u_December_00427678",
    "u_February_004275ec",
    "u_Friday_00427558",
    "u_HH:mm:ss_004276d8",
    "u_January_004275dc",
    "u_July_00427624",
    "u_June_00427618",
    "u_MM/dd/yy_0042769c",
    "u_March_00427600",
    "u_Monday_00427510",
    "u_November_00427664",
    "u_October_00427654",
    "u_Saturday_00427568",
    "u_September_00427640",
    "u_Sunday_00427500",
    "u_Thursday_00427544",
    "u_Tuesday_00427520",
    "u_UNICODE_00427880",
    "u_UTF-16LEUNICODE_00427870",
    "u_UTF-8_00427864",
    "u_Wednesday_00427530",
    "u__MEI%d_00422d14",
    "u_advapi32_00425e18",
    "u_api-ms-win-appmodel-runtime-l1-1_00426a48",
    "u_api-ms-win-core-datetime-l1-1-1_00426a90",
    "u_api-ms-win-core-fibers-l1-1-1_00425e2c",
    "u_api-ms-win-core-file-l2-1-1_00426ad0",
    "u_api-ms-win-core-localization-l1-_00426b08",
    "u_api-ms-win-core-localization-obs_00426b50",
    "u_api-ms-win-core-processthreads-l_00426bb0",
    "u_api-ms-win-core-string-l1-1-0_00426bfc",
    "u_api-ms-win-core-synch-l1-2-0_00425e68",
    "u_api-ms-win-core-sysinfo-l1-2-1_00426c38",
    "u_api-ms-win-core-winrt-l1-1-0_00426c78",
    "u_api-ms-win-core-xstate-l2-1-0_00426cb4",
    "u_api-ms-win-rtcore-ntuser-window-_00426cf0",
    "u_api-ms-win-security-systemfuncti_00426d40",
    "u_dddd,_MMMM_dd,_yyyy_004276b0",
    "u_ext-ms-win-kernel32-package-curr_00426d98",
    "u_ext-ms-win-ntuser-dialogbox-l1-1_00426df0",
    "u_ext-ms-win-ntuser-windowstation-_00426e38",
    "u_id-id_00429d44",
    "u_ja-JP_004278a0",
    "u_kernel32_00425ea4",
    "u_ko-KR_004278b8",
    "u_mscoree.dll_004267f0",
    "u_user32_00426e88",
    "u_zh-CN_004278ac",
    "u_zh-TW_004278c4",
    "uninitialize<>",
    "uninitialize_environment_internal<>",
    "write_buffer_nolock<char>",
    "write_double_translated_ansi_nolock",
    "write_double_translated_unicode_nolock",
    "write_requires_double_translation_nolock",
    "write_stored_string_tchar",
    "write_text_ansi_nolock",
    "write_text_utf16le_nolock",
    "write_text_utf8_nolock"
  ],
  "entry_points": [],
  "decompiled": [
    {
      "name": "FUN_00401000",
      "entry": "00401000",
      "c": "\nvoid FUN_00401000(uint param_1,undefined4 param_2,int param_3)\n\n{\n  int *piVar1;\n  undefined4 *puVar2;\n  LPCWSTR unaff_ESI;\n  int unaff_retaddr;\n  \n  piVar1 = FUN_00409a59();\n  puVar2 = (undefined4 *)FUN_00409a53();\n  puVar2 = FUN_00404c50((LPCWSTR)*puVar2,*piVar1,unaff_ESI,unaff_retaddr);\n  FUN_004023d0(param_1,(int)puVar2,param_3);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00401030",
      "entry": "00401030",
      "c": "\nint __cdecl FUN_00401030(undefined4 param_1,int param_2)\n\n{\n  size_t sVar1;\n  int iVar2;\n  int iVar3;\n  \n  sVar1 = Ordinal_14(*(undefined4 *)(param_2 + 0xc));\n  iVar2 = FUN_00409dbb(sVar1);\n  if (iVar2 == 0) {\n    FUN_004018c0(\"Error allocating decompression buffer\\n\");\n    return 0;\n  }\n  Ordinal_14(*(undefined4 *)(param_2 + 8));\n  Ordinal_14(*(undefined4 *)(param_2 + 0xc));\n  iVar3 = FUN_00406ae0((int)&stack0xffffffc0,\"1.2.11\",0x38);\n  if (-1 < iVar3) {\n    iVar3 = FUN_00405220((int *)&stack0xffffffc0,4);\n    if (-1 < iVar3) {\n      FUN_004069b0((int)&stack0xffffffc0);\n      return iVar2;\n    }\n    FUN_004018c0(\"Error %d from inflate: %s\\n\");\n    return 0;\n  }\n  FUN_004018c0(\"Error %d from inflateInit: %s\\n\");\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_00401120",
      "entry": "00401120",
      "c": "\nint __cdecl FUN_00401120(undefined4 *param_1)\n\n{\n  undefined4 *puVar1;\n  char cVar2;\n  int iVar3;\n  int local_4;\n  \n  puVar1 = param_1;\n  local_4 = 0;\n  _fseek((FILE *)*param_1,0,0);\n  _fread(&param_1,1,2,(FILE *)*puVar1);\n  if ((char)param_1 != 'M') {\n    return -1;\n  }\n  if ((char)((uint)param_1 >> 8) != 'Z') {\n    return -1;\n  }\n  _fseek((FILE *)*puVar1,0x3c,0);\n  _fread(&local_4,4,1,(FILE *)*puVar1);\n  _fseek((FILE *)*puVar1,local_4 + 0x18,0);\n  _fread(&param_1,2,1,(FILE *)*puVar1);\n  cVar2 = (char)((uint)param_1 >> 8);\n  if ((char)param_1 == '\\v') {\n    if (cVar2 == '\\x01') {\n      iVar3 = 0x98;\n    }\n    else {\n      if (cVar2 != '\\x02') goto LAB_00401202;\n      iVar3 = 0xa8;\n    }\n    _fseek((FILE *)*puVar1,local_4 + iVar3,0);\n    _fread(&local_4,4,1,(FILE *)*puVar1);\n    if (local_4 != 0) {\n      FUN_004018c0(\"LOADER: %s contains a digital signature\\n\");\n      return local_4;\n    }\n  }\n  else {\nLAB_00401202:\n    FUN_004018c0(\"LOADER: Could not find a valid magic value (was %x %x).\\n\");\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "FUN_00401220",
      "entry": "00401220",
      "c": "\nvoid __cdecl FUN_00401220(undefined4 *param_1)\n\n{\n  if ((FILE *)*param_1 != (FILE *)0x0) {\n    _fclose((FILE *)*param_1);\n    *param_1 = 0;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00401240",
      "entry": "00401240",
      "c": "\nvoid * __cdecl FUN_00401240(int *param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  void *_DstBuf;\n  size_t _ElementSize;\n  void *pvVar4;\n  FILE *_File;\n  \n  if (*param_1 == 0) {\n    iVar1 = FUN_00402930((LPCSTR)(param_1 + 0x1a),\"rb\");\n    *param_1 = iVar1;\n    if (iVar1 == 0) {\n      FUN_004018c0(\"Cannot open archive file\\n\");\n      return (void *)0x0;\n    }\n  }\n  iVar1 = *(int *)(param_2 + 4);\n  iVar2 = Ordinal_14(iVar1,0);\n  _fseek((FILE *)*param_1,iVar2 + param_1[1],iVar1);\n  sVar3 = Ordinal_14(*(undefined4 *)(param_2 + 8));\n  _DstBuf = (void *)FUN_00409dbb(sVar3);\n  if (_DstBuf == (void *)0x0) {\n    FUN_004018c0(\"Could not allocate read buffer\\n\");\n    return (void *)0x0;\n  }\n  _File = (FILE *)0x1;\n  sVar3 = *(size_t *)(param_2 + 8);\n  _ElementSize = Ordinal_14(sVar3,1,*param_1);\n  sVar3 = _fread(_DstBuf,_ElementSize,sVar3,_File);\n  if (sVar3 == 0) {\n    FUN_004018c0(\"Could not read from file\\n\");\n    FID_conflict__free(_DstBuf);\n    return (void *)0x0;\n  }\n  pvVar4 = _DstBuf;\n  if (*(char *)(param_2 + 0x10) == '\\x01') {\n    pvVar4 = (void *)FUN_00401030(_DstBuf,param_2);\n    FID_conflict__free(_DstBuf);\n    if (pvVar4 == (void *)0x0) {\n      FUN_004018c0(\"Error decompressing %s\\n\");\n      return (void *)0x0;\n    }\n  }\n  if ((FILE *)*param_1 != (FILE *)0x0) {\n    _fclose((FILE *)*param_1);\n    *param_1 = 0;\n  }\n  return pvVar4;\n}\n\n"
    },
    {
      "name": "FUN_00401340",
      "entry": "00401340",
      "c": "\nundefined4 __cdecl FUN_00401340(int *param_1,int param_2)\n\n{\n  void *_Str;\n  int iVar1;\n  FILE *_File;\n  size_t _Size;\n  size_t sVar2;\n  \n  _Str = FUN_00401240(param_1,param_2);\n  iVar1 = FUN_00403d70((int)param_1);\n  if (iVar1 == -1) {\n    return 0xffffffff;\n  }\n  _File = (FILE *)FUN_00404080((char *)(param_1 + 0x81a),(char *)(param_2 + 0x12));\n  _Size = Ordinal_14(*(undefined4 *)(param_2 + 0xc));\n  if (_File == (FILE *)0x0) {\n    FUN_004018a0(\"fopen\",\"%s could not be extracted!\\n\");\n    return 0xffffffff;\n  }\n  sVar2 = _fwrite(_Str,_Size,1,_File);\n  if ((sVar2 != 1) && (_Size != 0)) {\n    FUN_004018a0(\"fwrite\",\"Failed to write all bytes for %s\\n\");\n    return 0xffffffff;\n  }\n  _fclose(_File);\n  FID_conflict__free(_Str);\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_004013f0",
      "entry": "004013f0",
      "c": "\nvoid __cdecl FUN_004013f0(undefined4 *param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  size_t sVar5;\n  char *_Str2;\n  char local_64 [8];\n  char local_5c [84];\n  uint uStack_8;\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_64;\n  _Str2 = local_5c;\n  iVar4 = _fseek((FILE *)*param_1,param_2 + -0x60,0);\n  if (iVar4 == 0) {\n    sVar5 = _fread(local_64,0x60,1,(FILE *)*param_1);\n    if (sVar5 != 0) {\n      do {\n        iVar4 = _strncmp(\"MEI\\f\\v\\n\\v\\x0e\",_Str2,8);\n        if (iVar4 == 0) {\n          uVar1 = *(undefined4 *)(_Str2 + 4);\n          uVar2 = *(undefined4 *)(_Str2 + 8);\n          uVar3 = *(undefined4 *)(_Str2 + 0xc);\n          param_1[4] = *(undefined4 *)_Str2;\n          param_1[5] = uVar1;\n          param_1[6] = uVar2;\n          param_1[7] = uVar3;\n          uVar1 = *(undefined4 *)(_Str2 + 0x14);\n          uVar2 = *(undefined4 *)(_Str2 + 0x18);\n          uVar3 = *(undefined4 *)(_Str2 + 0x1c);\n          param_1[8] = *(undefined4 *)(_Str2 + 0x10);\n          param_1[9] = uVar1;\n          param_1[10] = uVar2;\n          param_1[0xb] = uVar3;\n          uVar1 = *(undefined4 *)(_Str2 + 0x24);\n          uVar2 = *(undefined4 *)(_Str2 + 0x28);\n          uVar3 = *(undefined4 *)(_Str2 + 0x2c);\n          param_1[0xc] = *(undefined4 *)(_Str2 + 0x20);\n          param_1[0xd] = uVar1;\n          param_1[0xe] = uVar2;\n          param_1[0xf] = uVar3;\n          uVar1 = *(undefined4 *)(_Str2 + 0x34);\n          uVar2 = *(undefined4 *)(_Str2 + 0x38);\n          uVar3 = *(undefined4 *)(_Str2 + 0x3c);\n          param_1[0x10] = *(undefined4 *)(_Str2 + 0x30);\n          param_1[0x11] = uVar1;\n          param_1[0x12] = uVar2;\n          param_1[0x13] = uVar3;\n          uVar1 = *(undefined4 *)(_Str2 + 0x44);\n          uVar2 = *(undefined4 *)(_Str2 + 0x48);\n          uVar3 = *(undefined4 *)(_Str2 + 0x4c);\n          param_1[0x14] = *(undefined4 *)(_Str2 + 0x40);\n          param_1[0x15] = uVar1;\n          param_1[0x16] = uVar2;\n          param_1[0x17] = uVar3;\n          *(undefined8 *)(param_1 + 0x18) = *(undefined8 *)(_Str2 + 0x50);\n          iVar4 = Ordinal_14(param_1[6]);\n          param_1[1] = _Str2 + (((param_2 + -0x60) - (int)&stack0xffffff98) - iVar4) + 0x58;\n          __security_check_cookie(uStack_8 ^ (uint)&stack0xffffff98);\n          return;\n        }\n        _Str2 = _Str2 + -1;\n      } while (local_64 <= _Str2);\n    }\n  }\n  __security_check_cookie(local_4 ^ (uint)local_64);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004014d0",
      "entry": "004014d0",
      "c": "\nchar * __cdecl FUN_004014d0(int param_1,char *param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  char *pcVar4;\n  size_t _MaxCount;\n  \n  puVar3 = *(undefined4 **)(param_1 + 8);\n  pcVar4 = param_2;\n  do {\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n  } while (cVar1 != '\\0');\n  _MaxCount = (int)pcVar4 - (int)(param_2 + 1);\n  if (puVar3 < *(undefined4 **)(param_1 + 0xc)) {\n    do {\n      if ((*(char *)((int)puVar3 + 0x11) == 'o') &&\n         (iVar2 = _strncmp((char *)((int)puVar3 + 0x12),param_2,_MaxCount), iVar2 == 0)) {\n        pcVar4 = (char *)((int)puVar3 + _MaxCount + 0x12);\n        if (*pcVar4 == '\\0') {\n          return pcVar4;\n        }\n        return (char *)((int)puVar3 + _MaxCount + 0x13);\n      }\n      iVar2 = Ordinal_14(*puVar3);\n      puVar3 = (undefined4 *)((int)puVar3 + iVar2);\n      if (puVar3 < *(undefined4 **)(param_1 + 8)) {\n        FUN_004018c0(\"Cannot read Table of Contents.\\n\");\n        puVar3 = *(undefined4 **)(param_1 + 0xc);\n      }\n    } while (puVar3 < *(undefined4 **)(param_1 + 0xc));\n  }\n  return (char *)0x0;\n}\n\n"
    },
    {
      "name": "FUN_00401550",
      "entry": "00401550",
      "c": "\nuint __cdecl FUN_00401550(undefined4 param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  int unaff_retaddr;\n  \n  iVar1 = Ordinal_14(*param_2);\n  uVar2 = iVar1 + (int)param_2;\n  if (uVar2 < *(uint *)(unaff_retaddr + 8)) {\n    FUN_004018c0(\"Cannot read Table of Contents.\\n\");\n    uVar2 = *(uint *)(unaff_retaddr + 0xc);\n  }\n  return uVar2;\n}\n\n"
    },
    {
      "name": "FUN_00401580",
      "entry": "00401580",
      "c": "\nundefined4 __cdecl FUN_00401580(int *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  size_t _ElementSize;\n  FILE *_File;\n  \n  FUN_004018c0(\"LOADER: archivename is %s\\n\");\n  if (*param_1 == 0) {\n    iVar1 = FUN_00402930((LPCSTR)(param_1 + 0x1a),\"rb\");\n    *param_1 = iVar1;\n    if (iVar1 == 0) {\n      FUN_004018c0(\"LOADER: Cannot open archive: %s\\n\");\n      return 0xffffffff;\n    }\n  }\n  iVar1 = FUN_00401120(param_1);\n  if (iVar1 < 1) {\n    _fseek((FILE *)*param_1,0,2);\n    iVar1 = FUN_0040a9ba();\n  }\n  iVar1 = FUN_004013f0(param_1,iVar1);\n  if (iVar1 == -1) {\n    FUN_004018c0(\"Loader: Cannot find cookie\");\n    return 0xffffffff;\n  }\n  param_1[0x101b] = 0;\n  DAT_0042d954 = Ordinal_14(param_1[9]);\n  iVar1 = param_1[7];\n  iVar2 = Ordinal_14(iVar1,0);\n  _fseek((FILE *)*param_1,iVar2 + param_1[1],iVar1);\n  sVar3 = Ordinal_14(param_1[8]);\n  iVar1 = FUN_00409dbb(sVar3);\n  param_1[2] = iVar1;\n  if (iVar1 == 0) {\n    FUN_004018a0(\"malloc\",\"Could not allocate buffer for TOC.\");\n    return 0xffffffff;\n  }\n  _File = (FILE *)0x1;\n  sVar3 = param_1[8];\n  _ElementSize = Ordinal_14(sVar3,1,*param_1);\n  sVar3 = _fread((void *)param_1[2],_ElementSize,sVar3,_File);\n  if (sVar3 == 0) {\n    FUN_004018a0(\"fread\",\"Could not read from file.\");\n    return 0xffffffff;\n  }\n  iVar1 = Ordinal_14(param_1[8]);\n  param_1[3] = iVar1 + param_1[2];\n  iVar1 = _ferror((FILE *)*param_1);\n  if (iVar1 != 0) {\n    FUN_004018c0(\"Error on file\\n.\");\n    return 0xffffffff;\n  }\n  FUN_00401220(param_1);\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_004016e0",
      "entry": "004016e0",
      "c": "\nundefined4 __cdecl FUN_004016e0(int param_1,char *param_2,char *param_3)\n\n{\n  char cVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  char *pcVar5;\n  char *pcVar6;\n  \n  uVar2 = FUN_00409ad8(param_2,0x1000);\n  uVar3 = FUN_00409ad8(param_3,0x1000);\n  if (uVar3 + 1 + uVar2 < 0x1001) {\n    pcVar6 = param_2;\n    do {\n      cVar1 = *pcVar6;\n      pcVar6 = pcVar6 + 1;\n      pcVar6[(param_1 - (int)param_2) + 0x67] = cVar1;\n      pcVar5 = param_3;\n    } while (cVar1 != '\\0');\n    do {\n      cVar1 = *pcVar5;\n      pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    uVar2 = (int)pcVar5 - (int)param_3;\n    pcVar6 = (char *)(param_1 + 0x67);\n    do {\n      pcVar5 = pcVar6 + 1;\n      pcVar6 = pcVar6 + 1;\n    } while (*pcVar5 != '\\0');\n    for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n      *(undefined4 *)pcVar6 = *(undefined4 *)param_3;\n      param_3 = param_3 + 4;\n      pcVar6 = pcVar6 + 4;\n    }\n    for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n      *pcVar6 = *param_3;\n      param_3 = param_3 + 1;\n      pcVar6 = pcVar6 + 1;\n    }\n    pcVar5 = (char *)(param_1 + 0x1068);\n    pcVar6 = param_2;\n    do {\n      cVar1 = *pcVar6;\n      pcVar6 = pcVar6 + 1;\n      pcVar6[(int)(pcVar5 + (-1 - (int)param_2))] = cVar1;\n    } while (cVar1 != '\\0');\n    *(undefined4 *)(param_1 + 0x4068) = 0;\n    iVar4 = param_1 - (int)pcVar5;\n    do {\n      cVar1 = *pcVar5;\n      pcVar5 = pcVar5 + 1;\n      pcVar5[iVar4 + 0x3067] = cVar1;\n    } while (cVar1 != '\\0');\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n"
    },
    {
      "name": "FUN_004017a0",
      "entry": "004017a0",
      "c": "\nundefined4 __cdecl FUN_004017a0(int *param_1,char *param_2,char *param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_004016e0((int)param_1,param_2,param_3);\n  if (iVar1 == 0) {\n    iVar1 = FUN_00401580(param_1);\n    if (iVar1 == 0) {\n      return 0;\n    }\n    if ((FILE *)*param_1 != (FILE *)0x0) {\n      _fclose((FILE *)*param_1);\n      *param_1 = 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n"
    },
    {
      "name": "FUN_004017f0",
      "entry": "004017f0",
      "c": "\nvoid __cdecl FUN_004017f0(undefined4 *param_1)\n\n{\n  if (param_1 != (undefined4 *)0x0) {\n    FUN_004018c0(\"LOADER: Freeing archive status for %s\\n\");\n    if ((void *)param_1[2] != (void *)0x0) {\n      FID_conflict__free((void *)param_1[2]);\n    }\n    if ((FILE *)*param_1 != (FILE *)0x0) {\n      _fclose((FILE *)*param_1);\n      *param_1 = 0;\n    }\n    FID_conflict__free(param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00401840",
      "entry": "00401840",
      "c": "\nundefined * FUN_00401840(void)\n\n{\n  return &DAT_0043b660;\n}\n\n"
    },
    {
      "name": "FUN_00401850",
      "entry": "00401850",
      "c": "\nvoid __cdecl FUN_00401850(int param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  undefined1 *puVar3;\n  \n  puVar3 = &stack0x0000000c;\n  uVar2 = 0;\n  puVar1 = (undefined4 *)FUN_00401840();\n  FID_conflict____stdio_common_vfprintf(*puVar1,puVar1[1],param_1,param_2,uVar2,puVar3);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00401880",
      "entry": "00401880",
      "c": "\nvoid __cdecl FUN_00401880(char *param_1)\n\n{\n  FUN_00401920(param_1,&stack0x00000008);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004018a0",
      "entry": "004018a0",
      "c": "\nvoid __cdecl FUN_004018a0(char *param_1,char *param_2)\n\n{\n  FUN_00401920(param_2,&stack0x0000000c);\n  _perror(param_1);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004018c0",
      "entry": "004018c0",
      "c": "\nvoid __cdecl FUN_004018c0(char *param_1)\n\n{\n  undefined *puVar1;\n  char *pcVar2;\n  \n  GetCurrentProcessId();\n  pcVar2 = \"[%d] \";\n  puVar1 = ___acrt_iob_func(2);\n  FUN_00401850((int)puVar1,(int)pcVar2);\n  FUN_00401920(param_1,&stack0x00000008);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004018f0",
      "entry": "004018f0",
      "c": "\nvoid __cdecl FUN_004018f0(undefined4 param_1,char *param_2)\n\n{\n  DWORD DVar1;\n  \n  FUN_00401920(param_2,&stack0x0000000c);\n  DVar1 = GetLastError();\n  FUN_00404a50(DVar1);\n  FUN_00401880(\"%s: %s\");\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00401920",
      "entry": "00401920",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00401920(char *param_1,char *param_2)\n\n{\n  uint *puVar1;\n  undefined *puVar2;\n  char *pcVar3;\n  uint uVar4;\n  __crt_locale_pointers *p_Var5;\n  undefined *puVar6;\n  char local_1004 [2048];\n  WCHAR local_804 [1024];\n  uint local_4;\n  \n  pcVar3 = local_1004;\n  local_4 = DAT_0042d008 ^ (uint)local_1004;\n  p_Var5 = (__crt_locale_pointers *)0x0;\n  uVar4 = 0x800;\n  puVar1 = (uint *)FUN_00401840();\n  ___stdio_common_vsprintf(*puVar1 | 1,puVar1[1],pcVar3,uVar4,param_1,p_Var5,param_2);\n  FUN_00404df0(local_804,local_1004,(char *)0x800);\n  puVar6 = &DAT_00421488;\n  puVar2 = ___acrt_iob_func(2);\n  FUN_00401850((int)puVar2,(int)puVar6);\n  __security_check_cookie(local_4 ^ (uint)local_1004);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004019c0",
      "entry": "004019c0",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_004019c0(int *param_1,char *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int *_Memory;\n  char *pcVar3;\n  byte local_5004 [4096];\n  CHAR local_4004 [4096];\n  byte local_3004 [4096];\n  char local_2004 [4096];\n  undefined1 local_1004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_5004;\n  iVar2 = *param_1;\n  FUN_004018c0(\"LOADER: Extracting dependencies\\n\");\n  iVar1 = FUN_004022f0(local_2004,(char *)local_5004,param_2);\n  if (iVar1 == -1) goto LAB_00401ad8;\n  FUN_004027a0((undefined1 (*) [16])local_1004,local_2004);\n  FUN_004018c0(\"LOADER: Checking if file exists\\n\");\n  iVar1 = FUN_00401dd0(local_4004,\"%s%s%s%s%s\");\n  if (iVar1 == 0) {\n    FUN_004018c0(\"LOADER: File %s found, assuming is onedir\\n\");\n    iVar1 = FUN_00403d70(iVar2);\n    if (iVar1 != -1) {\n      FUN_004018c0(\"LOADER: Coping file %s to %s\\n\");\n      iVar2 = FUN_00403c40(local_4004,(char *)(iVar2 + 0x2068),(char *)local_5004);\nLAB_00401abd:\n      if (iVar2 != -1) goto LAB_00401c33;\n    }\n    pcVar3 = \"Error copying %s\\n\";\n  }\n  else {\n    iVar1 = FUN_00401dd0(local_4004,\"%s%s%s%s%s%s%s\");\n    if (iVar1 == 0) {\n      FUN_004018c0(\"LOADER: File %s found, assuming is onedir\\n\");\n      iVar2 = FUN_00401e30(iVar2,local_4004,(char *)local_5004);\n      goto LAB_00401abd;\n    }\n    FUN_004018c0(\"LOADER: File %s not found, assuming is onefile.\\n\");\n    iVar2 = FUN_00401dd0((LPCSTR)local_3004,\"%s%s%s.pkg\");\n    if (iVar2 == 0) {\nLAB_00401bec:\n      _Memory = FUN_00401c50(param_1,local_3004);\n      if (_Memory != (int *)0x0) {\n        iVar2 = FUN_00401e80(_Memory,local_5004);\n        if (iVar2 != -1) {\nLAB_00401c33:\n          __security_check_cookie(local_4 ^ (uint)local_5004);\n          return;\n        }\n        FUN_004018c0(\"Error extracting %s\\n\");\n        FID_conflict__free(_Memory);\n        goto LAB_00401ad8;\n      }\n    }\n    else {\n      iVar2 = FUN_00401dd0((LPCSTR)local_3004,\"%s%s%s.exe\");\n      if (iVar2 == 0) goto LAB_00401bec;\n      iVar2 = FUN_00401dd0((LPCSTR)local_3004,\"%s%s%s\");\n      if (iVar2 == 0) goto LAB_00401bec;\n    }\n    pcVar3 = \"Archive not found: %s\\n\";\n  }\n  FUN_004018c0(pcVar3);\nLAB_00401ad8:\n  __security_check_cookie(local_4 ^ (uint)local_5004);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00401c50",
      "entry": "00401c50",
      "c": "\nint * __cdecl FUN_00401c50(int *param_1,byte *param_2)\n\n{\n  byte bVar1;\n  int iVar2;\n  byte *pbVar3;\n  uint uVar4;\n  int *piVar5;\n  byte *pbVar6;\n  int iVar7;\n  bool bVar8;\n  \n  FUN_004018c0(\"LOADER: Getting file from archive.\\n\");\n  iVar2 = FUN_00403d70(*param_1);\n  if (iVar2 == -1) {\n    return (int *)0x0;\n  }\n  iVar2 = param_1[1];\n  piVar5 = param_1 + 1;\n  iVar7 = 1;\n  do {\n    if (iVar2 == 0) {\n      piVar5 = (int *)FUN_00409dbb(0x4078);\n      if (piVar5 == (int *)0x0) {\n        FUN_004018a0(\"malloc\",\"Error allocating memory for status\\n\");\n        return (int *)0x0;\n      }\n      _strncpy((char *)(piVar5 + 0x1a),(char *)param_2,0x1000);\n      _strncpy((char *)(piVar5 + 0x41a),(char *)(*param_1 + 0x1068),0x1000);\n      _strncpy((char *)(piVar5 + 0x81a),(char *)(*param_1 + 0x2068),0x1000);\n      if (((*(char *)((int)piVar5 + 0x1067) == '\\0') && (*(char *)((int)piVar5 + 0x2067) == '\\0'))\n         && (*(char *)((int)piVar5 + 0x3067) == '\\0')) {\n        piVar5[0x101a] = *(int *)(*param_1 + 0x4068);\n        iVar2 = FUN_00401580(piVar5);\n        if (iVar2 == 0) {\n          param_1[iVar7] = (int)piVar5;\n          return piVar5;\n        }\n        FUN_004018a0(\"malloc\",\"Error opening archive %s\\n\");\n        FID_conflict__free(piVar5);\n        return (int *)0x0;\n      }\n      FUN_004018c0(\"Archive path exceeds PATH_MAX\\n\");\n      FID_conflict__free(piVar5);\n      return (int *)0x0;\n    }\n    pbVar3 = (byte *)(*piVar5 + 0x68);\n    pbVar6 = param_2;\n    do {\n      bVar1 = *pbVar3;\n      bVar8 = bVar1 < *pbVar6;\n      if (bVar1 != *pbVar6) {\nLAB_00401cb0:\n        uVar4 = -(uint)bVar8 | 1;\n        goto LAB_00401cb5;\n      }\n      if (bVar1 == 0) break;\n      bVar1 = pbVar3[1];\n      bVar8 = bVar1 < pbVar6[1];\n      if (bVar1 != pbVar6[1]) goto LAB_00401cb0;\n      pbVar3 = pbVar3 + 2;\n      pbVar6 = pbVar6 + 2;\n    } while (bVar1 != 0);\n    uVar4 = 0;\nLAB_00401cb5:\n    if (uVar4 == 0) {\n      FUN_004018c0(\"LOADER: Archive found: %s\\n\");\n      return (int *)param_1[iVar7];\n    }\n    FUN_004018c0(\"LOADER: Checking next archive in the list...\\n\");\n    iVar7 = iVar7 + 1;\n    iVar2 = param_1[iVar7];\n    piVar5 = param_1 + iVar7;\n  } while( true );\n}\n\n"
    },
    {
      "name": "FUN_00401dd0",
      "entry": "00401dd0",
      "c": "\nvoid __cdecl FUN_00401dd0(LPCSTR param_1,char *param_2)\n\n{\n  uint *puVar1;\n  LPCSTR pCVar2;\n  uint uVar3;\n  __crt_locale_pointers *p_Var4;\n  char *pcVar5;\n  _stat64i32 local_34 [48];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_34;\n  pcVar5 = &stack0x0000000c;\n  p_Var4 = (__crt_locale_pointers *)0x0;\n  uVar3 = 0x1000;\n  pCVar2 = param_1;\n  puVar1 = (uint *)FUN_00401840();\n  ___stdio_common_vsprintf(*puVar1 | 1,puVar1[1],pCVar2,uVar3,param_2,p_Var4,pcVar5);\n  FID_conflict___stat64i32(param_1,local_34);\n  __security_check_cookie(local_4 ^ (uint)local_34);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00401e30",
      "entry": "00401e30",
      "c": "\nint __cdecl FUN_00401e30(int param_1,LPCSTR param_2,char *param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00403d70(param_1);\n  if (iVar1 == -1) {\n    return -1;\n  }\n  FUN_004018c0(\"LOADER: Coping file %s to %s\\n\");\n  iVar1 = FUN_00403c40(param_2,(char *)(param_1 + 0x2068),param_3);\n  return (iVar1 != -1) - 1;\n}\n\n"
    },
    {
      "name": "FUN_00401e80",
      "entry": "00401e80",
      "c": "\nundefined4 __cdecl FUN_00401e80(int *param_1,byte *param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  uint uVar3;\n  int iVar4;\n  undefined4 *puVar5;\n  byte *pbVar6;\n  bool bVar7;\n  \n  puVar5 = (undefined4 *)param_1[2];\n  FUN_004018c0(\"LOADER: Extracting dependencies from archive\\n\");\n  if (puVar5 < (undefined4 *)param_1[3]) {\n    do {\n      pbVar6 = (byte *)((int)puVar5 + 0x12);\n      pbVar2 = param_2;\n      do {\n        bVar1 = *pbVar6;\n        bVar7 = bVar1 < *pbVar2;\n        if (bVar1 != *pbVar2) {\nLAB_00401ec5:\n          uVar3 = -(uint)bVar7 | 1;\n          goto LAB_00401eca;\n        }\n        if (bVar1 == 0) break;\n        bVar1 = pbVar6[1];\n        bVar7 = bVar1 < pbVar2[1];\n        if (bVar1 != pbVar2[1]) goto LAB_00401ec5;\n        pbVar6 = pbVar6 + 2;\n        pbVar2 = pbVar2 + 2;\n      } while (bVar1 != 0);\n      uVar3 = 0;\nLAB_00401eca:\n      if ((uVar3 == 0) && (iVar4 = FUN_00401340(param_1,(int)puVar5), iVar4 != 0)) {\n        return 0xffffffff;\n      }\n      puVar5 = (undefined4 *)FUN_00401550(param_1,puVar5);\n    } while (puVar5 < (undefined4 *)param_1[3]);\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_00401f00",
      "entry": "00401f00",
      "c": "\nundefined4 __cdecl FUN_00401f00(int *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  iVar1 = FUN_00403520((int)param_1);\n  if (iVar1 == 0) {\n    param_1[0x101b] = 1;\n    iVar1 = FUN_00403980((int)param_1);\n    if (iVar1 == 0) {\n      iVar1 = FUN_004031d0(param_1);\n      if (iVar1 == 0) {\n        iVar1 = FUN_004033d0((int)param_1);\n        if (iVar1 == 0) {\n          uVar2 = FUN_004020d0(param_1);\n          FUN_004018c0(\"LOADER: OK.\\n\");\n          return uVar2;\n        }\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n"
    },
    {
      "name": "FUN_00401f70",
      "entry": "00401f70",
      "c": "\nvoid __cdecl FUN_00401f70(int *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  int *local_54 [20];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_54;\n  puVar3 = (undefined4 *)param_1[2];\n  _memset(local_54,0,0x50);\n  local_54[0] = param_1;\n  FUN_004018c0(\"LOADER: Extracting binaries\\n\");\n  if (puVar3 < (undefined4 *)param_1[3]) {\n    do {\n      cVar1 = *(char *)((int)puVar3 + 0x11);\n      if (((cVar1 == 'b') || (cVar1 == 'x')) || (cVar1 == 'Z')) {\n        iVar2 = FUN_00401340(param_1,(int)puVar3);\n        if (iVar2 != 0) break;\n      }\n      else if ((cVar1 == 'd') &&\n              (iVar2 = FUN_004019c0((int *)local_54,(char *)((int)puVar3 + 0x12)), iVar2 == -1))\n      break;\n      puVar3 = (undefined4 *)FUN_00401550(param_1,puVar3);\n    } while (puVar3 < (undefined4 *)param_1[3]);\n  }\n  iVar2 = 1;\n  while (local_54[1] != (int *)0x0) {\n    FUN_004017f0(local_54[1]);\n    iVar2 = iVar2 + 1;\n    local_54[1] = local_54[iVar2];\n  }\n  __security_check_cookie(local_4 ^ (uint)local_54);\n  return;\n}\n\n"
    },
    {
      "name": "thunk_FUN_004031a0",
      "entry": "00402040",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid __cdecl thunk_FUN_004031a0(int param_1)\n\n{\n  if (*(int *)(param_1 + 0x406c) == 1) {\n    FUN_004018c0(\"LOADER: Cleaning up Python interpreter.\\n\");\n                    /* WARNING: Could not recover jumptable at 0x004031ba. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*_DAT_0042d97c)();\n    return;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00402050",
      "entry": "00402050",
      "c": "\nvoid __cdecl FUN_00402050(int param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = FUN_004014d0(param_1,\"pyi-windows-manifest-filename\");\n  if (pcVar1 != (char *)0x0) {\n    pcVar1 = FUN_00402a40((char *)0x0,(char *)(param_1 + 0x3068),pcVar1);\n    FUN_004048f0(pcVar1);\n    FID_conflict__free(pcVar1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00402090",
      "entry": "00402090",
      "c": "\nundefined4 __cdecl FUN_00402090(int param_1)\n\n{\n  char cVar1;\n  undefined4 *puVar2;\n  \n  puVar2 = *(undefined4 **)(param_1 + 8);\n  if (puVar2 < *(undefined4 **)(param_1 + 0xc)) {\n    do {\n      cVar1 = *(char *)((int)puVar2 + 0x11);\n      if ((((cVar1 == 'b') || (cVar1 == 'x')) || (cVar1 == 'Z')) || (cVar1 == 'd')) {\n        return 1;\n      }\n      puVar2 = (undefined4 *)FUN_00401550(param_1,puVar2);\n    } while (puVar2 < *(undefined4 **)(param_1 + 0xc));\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_004020d0",
      "entry": "004020d0",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_004020d0(int *param_1)\n\n{\n  char *pcVar1;\n  char cVar2;\n  void *_Memory;\n  uint uVar3;\n  undefined4 uVar4;\n  int iVar5;\n  undefined4 *puVar6;\n  char *pcVar7;\n  undefined4 *puVar8;\n  void *pvStack_1010;\n  void *pvStack_100c;\n  undefined1 auStack_1008 [4];\n  char acStack_1004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)&pvStack_1010;\n  puVar6 = (undefined4 *)param_1[2];\n  pvStack_1010 = (void *)(*DAT_0042d9ac)(\"__main__\");\n  if (pvStack_1010 == (void *)0x0) {\n    FUN_004018c0(\"Could not get __main__ module.\");\n    __security_check_cookie(local_4 ^ (uint)&pvStack_1010);\n    return;\n  }\n  auStack_1008 = (undefined1  [4])(*DAT_0042d9cc)(pvStack_1010);\n  if (auStack_1008 == (undefined1  [4])0x0) {\n    FUN_004018c0(\"Could not get __main__ module\\'s dict.\");\n    __security_check_cookie(local_4 ^ (uint)&pvStack_1010);\n    return;\n  }\n  if (puVar6 < (undefined4 *)param_1[3]) {\n    do {\n      if (*(char *)((int)puVar6 + 0x11) == 's') {\n        pvStack_100c = FUN_00401240(param_1,(int)puVar6);\n        pcVar1 = (char *)((int)puVar6 + 0x12);\n        uVar3 = FUN_00409ad8(pcVar1,0x1000);\n        if (0xffb < uVar3) {\n          FUN_004018c0(\"Name exceeds PATH_MAX\\n\");\n          break;\n        }\n        pcVar7 = pcVar1;\n        do {\n          cVar2 = *pcVar7;\n          pcVar7 = pcVar7 + 1;\n          pcVar7[(int)(acStack_1004 + (-1 - (int)pcVar1))] = cVar2;\n        } while (cVar2 != '\\0');\n        puVar8 = (undefined4 *)(auStack_1008 + 3);\n        do {\n          pcVar1 = (char *)((int)puVar8 + 1);\n          puVar8 = (undefined4 *)((int)puVar8 + 1);\n        } while (*pcVar1 != '\\0');\n        *puVar8 = DAT_004217ac;\n        FUN_004018c0(\"LOADER: Running %s\\n\");\n        if (DAT_0043b65c == 0) {\n          uVar4 = (*DAT_0042d9c4)(acStack_1004);\n        }\n        else {\n          uVar4 = (*DAT_0042d9c0)();\n        }\n        (*DAT_0042d9b0)(pvStack_1010,\"__file__\",uVar4);\n        (*DAT_0042d984)(uVar4);\n        uVar4 = Ordinal_14(puVar6[3]);\n        _Memory = pvStack_1010;\n        iVar5 = (*DAT_0042da08)(pvStack_1010,uVar4);\n        if (iVar5 == 0) {\n          FUN_004018c0(\"Failed to unmarshal code object for %s\\n\");\n          (*DAT_0042d9dc)();\n          break;\n        }\n        iVar5 = (*DAT_0042da04)(iVar5,pvStack_100c,pvStack_100c);\n        if (iVar5 == 0) {\n          (*DAT_0042d9dc)();\n          FUN_004018c0(\"Failed to execute script %s\\n\");\n          break;\n        }\n        FID_conflict__free(_Memory);\n      }\n      puVar6 = (undefined4 *)FUN_00401550(param_1,puVar6);\n    } while (puVar6 < (undefined4 *)param_1[3]);\n  }\n  __security_check_cookie(local_4 ^ (uint)&pvStack_1010);\n  return;\n}\n\n"
    },
    {
      "name": "guard_check_icall",
      "entry": "004022e0",
      "c": "\n/* guard_check_icall */\n\nvoid __cdecl guard_check_icall(void)\n\n{\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004022f0",
      "entry": "004022f0",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_004022f0(char *param_1,char *param_2,char *param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char local_1008 [4096];\n  char local_8;\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_1008;\n  FUN_004018c0(\"LOADER: Splitting item into path and filename\\n\");\n  _strncpy(local_1008,param_3,0x1001);\n  if (local_8 == '\\0') {\n    pcVar2 = _strtok(local_1008,\":\");\n    pcVar3 = pcVar2;\n    do {\n      cVar1 = *pcVar3;\n      pcVar3 = pcVar3 + 1;\n      pcVar3[(int)(param_1 + (-1 - (int)pcVar2))] = cVar1;\n    } while (cVar1 != '\\0');\n    pcVar2 = _strtok((char *)0x0,\":\");\n    pcVar3 = pcVar2;\n    do {\n      cVar1 = *pcVar3;\n      pcVar3 = pcVar3 + 1;\n      pcVar3[(int)(param_2 + (-1 - (int)pcVar2))] = cVar1;\n    } while (cVar1 != '\\0');\n    if ((*param_1 != '\\0') && (*param_2 != '\\0')) {\n      __security_check_cookie(local_4 ^ (uint)local_1008);\n      return;\n    }\n  }\n  __security_check_cookie(local_4 ^ (uint)local_1008);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004023d0",
      "entry": "004023d0",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_004023d0(uint param_1,int param_2,int param_3)\n\n{\n  int *_Dest;\n  byte bVar1;\n  FILE *_File;\n  int *piVar2;\n  byte *pbVar3;\n  int iVar4;\n  LPWSTR lpPathName;\n  byte *pbVar5;\n  uint uVar6;\n  byte *pbVar7;\n  LPCSTR unaff_EBP;\n  int *piVar8;\n  bool bVar9;\n  char *_Buffer;\n  int local_3008 [2];\n  undefined1 auStack_3000 [4];\n  byte abStack_2ffc [4096];\n  CHAR aCStack_1ffc [4096];\n  char acStack_ffc [4088];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_3008;\n  _Buffer = (char *)0x0;\n  local_3008[0] = param_2;\n  _File = (FILE *)___acrt_iob_func(2);\n  _setbuf(_File,_Buffer);\n  FUN_004018c0(\"PyInstaller Bootloader 3.x\\n\");\n  piVar2 = (int *)FUN_0040e228(1,0x4078);\n  if (piVar2 == (int *)0x0) {\n    FUN_004018a0(\"calloc\",\"Cannot allocate memory for ARCHIVE_STATUS\\n\");\n    local_3008[1] = 0x40244b;\n    __security_check_cookie(param_1 ^ (uint)auStack_3000);\n    return;\n  }\n  FUN_00402800(aCStack_1ffc);\n  FUN_00402760(acStack_ffc,aCStack_1ffc);\n  FUN_004029c0((undefined1 (*) [16])abStack_2ffc,aCStack_1ffc);\n  pbVar3 = (byte *)FUN_00403fd0(\"_MEIPASS2\");\n  FUN_00404560(\"_MEIPASS2\");\n  FUN_004018c0(\"LOADER: _MEIPASS2 is %s\\n\");\n  pbVar5 = abStack_2ffc;\n  do {\n    pbVar7 = pbVar5;\n    pbVar5 = pbVar7 + 1;\n  } while (*pbVar7 != 0);\n  iVar4 = FUN_004017a0(piVar2,(char *)abStack_2ffc,(char *)(pbVar7 + 0x1000));\n  if (iVar4 != 0) {\n    pbVar5 = abStack_2ffc;\n    do {\n      pbVar7 = pbVar5;\n      pbVar5 = pbVar7 + 1;\n    } while (*pbVar7 != 0);\n    iVar4 = FUN_004017a0(piVar2,(char *)abStack_2ffc,(char *)(pbVar7 + 0x2000));\n    if (iVar4 != 0) {\n      FUN_004018c0(\"Cannot open self %s or archive %s\\n\");\n      local_3008[1] = 0x402546;\n      __security_check_cookie(param_1 ^ (uint)auStack_3000);\n      return;\n    }\n  }\n  piVar2[0x101d] = param_2;\n  piVar2[0x101c] = param_3;\n  if (pbVar3 == (byte *)0x0) {\n    iVar4 = FUN_00402090((int)piVar2);\n    if (iVar4 == 0) {\n      FUN_004018c0(\"LOADER: No need to extract files to run; setting extractionpath to homepath\\n\");\n      pbVar3 = abStack_2ffc;\n      goto LAB_00402587;\n    }\n  }\n  else {\nLAB_00402587:\n    lpPathName = FUN_00404f00((LPWSTR)0x0,(LPCSTR)pbVar3,0,unaff_EBP);\n    SetDllDirectoryW(lpPathName);\n    FUN_004018c0(\"LOADER: SetDllDirectory(%s)\\n\");\n    FID_conflict__free(lpPathName);\n    if (pbVar3 != (byte *)0x0) {\n      FUN_004018c0(\"LOADER: Already in the child - running user\\'s code.\\n\");\n      pbVar5 = abStack_2ffc;\n      pbVar7 = pbVar3;\n      do {\n        bVar1 = *pbVar5;\n        bVar9 = bVar1 < *pbVar7;\n        if (bVar1 != *pbVar7) {\nLAB_004025f0:\n          uVar6 = -(uint)bVar9 | 1;\n          goto LAB_004025f5;\n        }\n        if (bVar1 == 0) break;\n        bVar1 = pbVar5[1];\n        bVar9 = bVar1 < pbVar7[1];\n        if (bVar1 != pbVar7[1]) goto LAB_004025f0;\n        pbVar5 = pbVar5 + 2;\n        pbVar7 = pbVar7 + 2;\n      } while (bVar1 != 0);\n      uVar6 = 0;\nLAB_004025f5:\n      if (uVar6 != 0) {\n        _Dest = piVar2 + 0x81a;\n        _strncpy((char *)_Dest,(char *)pbVar3,0x1000);\n        if (*(char *)((int)piVar2 + 0x3067) != '\\0') {\n          FUN_004018c0(\"LOADER: temppath exceeds PATH_MAX\\n\");\n          goto LAB_00402738;\n        }\n        piVar2[0x101a] = 1;\n        piVar8 = _Dest;\n        do {\n          iVar4 = *piVar8;\n          piVar8 = (int *)((int)piVar8 + 1);\n          *(char *)((int)piVar2 + (0x3067 - (int)_Dest) + (int)piVar8) = (char)iVar4;\n        } while ((char)iVar4 != '\\0');\n      }\n      FUN_00402050((int)piVar2);\n      FUN_00401f00(piVar2);\n      thunk_FUN_004031a0((int)piVar2);\n      goto LAB_00402738;\n    }\n  }\n  iVar4 = FUN_00401f70(piVar2);\n  if (iVar4 == 0) {\n    FUN_004018c0(\"LOADER: Executing self as child\\n\");\n    pbVar3 = abStack_2ffc;\n    if ((char)piVar2[0x81a] != '\\0') {\n      pbVar3 = (byte *)(piVar2 + 0x81a);\n    }\n    FUN_00404520(\"_MEIPASS2\",(LPCSTR)pbVar3);\n    FUN_00403fd0(\"_MEIPASS2\");\n    FUN_004018c0(\"LOADER: set _MEIPASS2 to %s\\n\");\n    iVar4 = FUN_00408460();\n    if (iVar4 != -1) {\n      guard_check_icall();\n      FUN_00404590(aCStack_1ffc);\n      FUN_004018c0(\"LOADER: Back to parent (RC: %d)\\n\");\n      FUN_004018c0(\"LOADER: Doing cleanup\\n\");\n      if (piVar2[0x101a] == 1) {\n        FUN_00404270((LPCSTR)(piVar2 + 0x81a));\n      }\n      FUN_004017f0(piVar2);\n    }\n  }\n  else {\n    FUN_004018c0(\"LOADER: temppath is %s\\n\");\n    FUN_004018c0(\"LOADER: Error extracting binaries\\n\");\n  }\nLAB_00402738:\n  local_3008[1] = 0x40274a;\n  __security_check_cookie(param_1 ^ (uint)auStack_3000);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00402760",
      "entry": "00402760",
      "c": "\nvoid __cdecl FUN_00402760(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  \n  pcVar2 = param_2;\n  do {\n    cVar1 = *pcVar2;\n    pcVar2 = pcVar2 + 1;\n    pcVar2[(int)(param_1 + (-1 - (int)param_2))] = cVar1;\n  } while (cVar1 != '\\0');\n  do {\n    pcVar2 = param_1;\n    param_1 = pcVar2 + 1;\n  } while (*pcVar2 != '\\0');\n  builtin_strncpy(pcVar2 + -0xffffffff00000003,\"pkg\",4);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004027a0",
      "entry": "004027a0",
      "c": "\nvoid __cdecl FUN_004027a0(undefined1 (*param_1) [16],char *param_2)\n\n{\n  char cVar1;\n  undefined1 *puVar2;\n  undefined1 (*pauVar3) [16];\n  char *pcVar4;\n  int iVar5;\n  \n  pcVar4 = param_2;\n  do {\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n  } while (cVar1 != '\\0');\n  _strncpy((char *)param_1,param_2,(size_t)(pcVar4 + (1 - (int)(param_2 + 1))));\n  pauVar3 = param_1;\n  do {\n    puVar2 = *pauVar3;\n    pauVar3 = (undefined1 (*) [16])(*pauVar3 + 1);\n  } while (*puVar2 != '\\0');\n  iVar5 = (int)pauVar3 - (int)(*param_1 + 1);\n  if (*(char *)(iVar5 + (int)param_1) == '\\\\') {\n    *(undefined1 *)(iVar5 + (int)param_1) = 0;\n  }\n  pauVar3 = FUN_00408b50(param_1,0x5c);\n  if (pauVar3 != (undefined1 (*) [16])0x0) {\n    (*pauVar3)[0] = 0;\n    return;\n  }\n  *(undefined2 *)*param_1 = 0x2e;\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00402800",
      "entry": "00402800",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00402800(LPSTR param_1)\n\n{\n  DWORD DVar1;\n  LPSTR pCVar2;\n  LPCWSTR unaff_ESI;\n  WCHAR local_2004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_2004;\n  DVar1 = GetModuleFileNameW((HMODULE)0x0,local_2004,0x1000);\n  if (DVar1 == 0) {\n    FUN_004018f0(\"GetModuleFileNameW\",\"Failed to get executable path.\");\n    __security_check_cookie(local_4 ^ (uint)local_2004);\n    return;\n  }\n  pCVar2 = FUN_00404f90(param_1,local_2004,0x1000,unaff_ESI);\n  if (pCVar2 == (LPSTR)0x0) {\n    FUN_004018c0(\"Failed to convert executable path to UTF-8.\");\n    __security_check_cookie(local_4 ^ (uint)local_2004);\n    return;\n  }\n  FUN_004018c0(\"LOADER: executable is %s\\n\");\n  __security_check_cookie(local_4 ^ (uint)local_2004);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004028d0",
      "entry": "004028d0",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_004028d0(LPCSTR param_1)\n\n{\n  LPCSTR in_stack_ffffdfc8;\n  WCHAR local_2008 [4098];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)&stack0xffffdfc8;\n  FUN_00404f00(local_2008,param_1,0x1000,in_stack_ffffdfc8);\n  FUN_0040e21d(local_2008,(_stat64i32 *)&stack0xffffdfc8);\n  __security_check_cookie(local_4 ^ (uint)&stack0xffffdfc8);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00402930",
      "entry": "00402930",
      "c": "\nvoid __cdecl FUN_00402930(LPCSTR param_1,LPCSTR param_2)\n\n{\n  LPCSTR unaff_ESI;\n  LPWSTR pWVar1;\n  WCHAR local_220 [10];\n  WCHAR local_20c [260];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_220;\n  pWVar1 = local_20c;\n  FUN_00404f00(pWVar1,param_1,0x104,unaff_ESI);\n  FUN_00404f00(local_220,param_2,10,(LPCSTR)pWVar1);\n  __wfopen(local_20c,local_220);\n  __security_check_cookie(local_4 ^ (uint)local_220);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004029a0",
      "entry": "004029a0",
      "c": "\nbool __cdecl FUN_004029a0(char *param_1,size_t param_2,char *param_3)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = __fullpath(param_1,param_3,param_2);\n  return pcVar1 != (char *)0x0;\n}\n\n"
    },
    {
      "name": "FUN_004029c0",
      "entry": "004029c0",
      "c": "\nvoid __cdecl FUN_004029c0(undefined1 (*param_1) [16],char *param_2)\n\n{\n  char cVar1;\n  undefined1 *puVar2;\n  undefined1 (*pauVar3) [16];\n  char *pcVar4;\n  int iVar5;\n  \n  pcVar4 = param_2;\n  do {\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n  } while (cVar1 != '\\0');\n  _strncpy((char *)param_1,param_2,(size_t)(pcVar4 + (1 - (int)(param_2 + 1))));\n  pauVar3 = param_1;\n  do {\n    puVar2 = *pauVar3;\n    pauVar3 = (undefined1 (*) [16])(*pauVar3 + 1);\n  } while (*puVar2 != '\\0');\n  iVar5 = (int)pauVar3 - (int)(*param_1 + 1);\n  if (*(char *)(iVar5 + (int)param_1) == '\\\\') {\n    *(undefined1 *)(iVar5 + (int)param_1) = 0;\n  }\n  pauVar3 = FUN_00408b50(param_1,0x5c);\n  if (pauVar3 != (undefined1 (*) [16])0x0) {\n    (*pauVar3)[0] = 0;\n    FUN_004018c0(\"LOADER: homepath is %s\\n\");\n    return;\n  }\n  *(undefined2 *)*param_1 = 0x2e;\n  FUN_004018c0(\"LOADER: homepath is %s\\n\");\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00402a40",
      "entry": "00402a40",
      "c": "\nchar * __cdecl FUN_00402a40(char *param_1,char *param_2,char *param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  uint uVar3;\n  char *pcVar4;\n  uint uVar5;\n  \n  if (param_1 == (char *)0x0) {\n    pcVar2 = param_2;\n    do {\n      cVar1 = *pcVar2;\n      pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    pcVar4 = param_3;\n    do {\n      cVar1 = *pcVar4;\n      pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    pcVar4 = pcVar4 + (int)(pcVar2 + ((2 - (int)(param_2 + 1)) - (int)(param_3 + 1)));\n    param_1 = (char *)FUN_00409dbb((size_t)pcVar4);\n    if (param_1 == (char *)0x0) {\n      return (char *)0x0;\n    }\n  }\n  else {\n    pcVar4 = (char *)0x1000;\n  }\n  _memset(param_1,0,(size_t)pcVar4);\n  pcVar4 = param_2;\n  do {\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n  } while (cVar1 != '\\0');\n  _strncpy(param_1,param_2,(int)pcVar4 - (int)(param_2 + 1));\n  pcVar4 = param_1;\n  do {\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n  } while (cVar1 != '\\0');\n  if (param_1[((int)pcVar4 - (int)(param_1 + 1)) + -1] != '\\\\') {\n    (param_1 + ((int)pcVar4 - (int)(param_1 + 1)))[0] = '\\\\';\n    (param_1 + ((int)pcVar4 - (int)(param_1 + 1)))[1] = '\\0';\n  }\n  pcVar4 = param_3;\n  do {\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n  } while (cVar1 != '\\0');\n  pcVar2 = param_3;\n  if (param_3[(int)(pcVar4 + (-1 - (int)(param_3 + 1)))] != '\\\\') {\n    do {\n      cVar1 = *pcVar2;\n      pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    uVar5 = (int)pcVar2 - (int)param_3;\n    pcVar4 = param_1 + -1;\n    do {\n      pcVar2 = pcVar4 + 1;\n      pcVar4 = pcVar4 + 1;\n    } while (*pcVar2 != '\\0');\n    for (uVar3 = uVar5 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n      *(undefined4 *)pcVar4 = *(undefined4 *)param_3;\n      param_3 = param_3 + 4;\n      pcVar4 = pcVar4 + 4;\n    }\n    for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n      *pcVar4 = *param_3;\n      param_3 = param_3 + 1;\n      pcVar4 = pcVar4 + 1;\n    }\n    return param_1;\n  }\n  _strncat(param_1,param_3,(size_t)(pcVar4 + (-2 - (int)(param_3 + 1))));\n  return param_1;\n}\n\n"
    },
    {
      "name": "FUN_00402b40",
      "entry": "00402b40",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 __cdecl FUN_00402b40(HMODULE param_1,int param_2)\n\n{\n  char *pcVar1;\n  \n  DAT_0042d970 = GetProcAddress(param_1,\"Py_DontWriteBytecodeFlag\");\n  if (DAT_0042d970 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_DontWriteBytecodeFlag\\n\");\n    return 0xffffffff;\n  }\n  _DAT_0042d964 = GetProcAddress(param_1,\"Py_FileSystemDefaultEncoding\");\n  if (_DAT_0042d964 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_FileSystemDefaultEncoding\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d958 = GetProcAddress(param_1,\"Py_FrozenFlag\");\n  if (DAT_0042d958 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_FrozenFlag\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d96c = GetProcAddress(param_1,\"Py_IgnoreEnvironmentFlag\");\n  if (DAT_0042d96c == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_IgnoreEnvironmentFlag\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d95c = GetProcAddress(param_1,\"Py_NoSiteFlag\");\n  if (DAT_0042d95c == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_NoSiteFlag\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d974 = GetProcAddress(param_1,\"Py_NoUserSiteDirectory\");\n  if (DAT_0042d974 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_NoUserSiteDirectory\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d960 = GetProcAddress(param_1,\"Py_OptimizeFlag\");\n  if (DAT_0042d960 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_OptimizeFlag\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d968 = GetProcAddress(param_1,\"Py_VerboseFlag\");\n  if (DAT_0042d968 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_VerboseFlag\\n\");\n    return 0xffffffff;\n  }\n  _DAT_0042d9bc = GetProcAddress(param_1,\"Py_BuildValue\");\n  if (_DAT_0042d9bc == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_BuildValue\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d984 = GetProcAddress(param_1,\"Py_DecRef\");\n  if (DAT_0042d984 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_DecRef\\n\");\n    return 0xffffffff;\n  }\n  _DAT_0042d97c = GetProcAddress(param_1,\"Py_Finalize\");\n  if (_DAT_0042d97c == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_Finalize\\n\");\n    return 0xffffffff;\n  }\n  _DAT_0042d980 = GetProcAddress(param_1,\"Py_IncRef\");\n  if (_DAT_0042d980 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_IncRef\\n\");\n    return 0xffffffff;\n  }\n  DAT_0042d978 = GetProcAddress(param_1,\"Py_Initialize\");\n  if (DAT_0042d978 == (FARPROC)0x0) {\n    FUN_004018f0(\"GetProcAddress\",\"Failed to get address for Py_Initialize\\n\");\n    return 0xffffffff;\n  }\n  if (0x1d < param_2) {\n    DAT_0042d990 = GetProcAddress(param_1,\"Py_SetPath\");\n    if (DAT_0042d990 == (FARPROC)0x0) {\n      pcVar1 = \"Failed to get address for Py_SetPath\\n\";\n      goto LAB_004030ed;\n    }\n    DAT_0042d994 = GetProcAddress(param_1,\"Py_GetPath\");\n    if (DAT_0042d994 == (FARPROC)0x0) {\n      pcVar1 = \"Failed to get address for Py_GetPath\\n\";\n      goto LAB_004030ed;\n    }\n  }\n  DAT_0042d988 = GetProcAddress(param_1,\"Py_SetProgramName\");\n  if (DAT_0042d988 == (FARPROC)0x0) {\n    pcVar1 = \"Failed to get address for Py_SetProgramName\\n\";\n  }\n  else {\n    DAT_0042d98c = GetProcAddress(param_1,\"Py_SetPythonHome\");\n    if (DAT_0042d98c == (FARPROC)0x0) {\n      pcVar1 = \"Failed to get address for Py_SetPythonHome\\n\";\n    }\n    else {\n      DAT_0042d9d0 = GetProcAddress(param_1,\"PyDict_GetItemString\");\n      if (DAT_0042d9d0 == (FARPROC)0x0) {\n        pcVar1 = \"Failed to get address for PyDict_GetItemString\\n\";\n      }\n      else {\n        DAT_0042d9d4 = GetProcAddress(param_1,\"PyErr_Clear\");\n        if (DAT_0042d9d4 == (FARPROC)0x0) {\n          pcVar1 = \"Failed to get address for PyErr_Clear\\n\";\n        }\n        else {\n          DAT_0042d9d8 = GetProcAddress(param_1,\"PyErr_Occurred\");\n          if (DAT_0042d9d8 == (FARPROC)0x0) {\n            pcVar1 = \"Failed to get address for PyErr_Occurred\\n\";\n          }\n          else {\n            DAT_0042d9dc = GetProcAddress(param_1,\"PyErr_Print\");\n            if (DAT_0042d9dc == (FARPROC)0x0) {\n              pcVar1 = \"Failed to get address for PyErr_Print\\n\";\n            }\n            else {\n              DAT_0042d9ac = GetProcAddress(param_1,\"PyImport_AddModule\");\n              if (DAT_0042d9ac == (FARPROC)0x0) {\n                pcVar1 = \"Failed to get address for PyImport_AddModule\\n\";\n              }\n              else {\n                DAT_0042d9a4 = GetProcAddress(param_1,\"PyImport_ExecCodeModule\");\n                if (DAT_0042d9a4 == (FARPROC)0x0) {\n                  pcVar1 = \"Failed to get address for PyImport_ExecCodeModule\\n\";\n                }\n                else {\n                  DAT_0042d9a8 = GetProcAddress(param_1,\"PyImport_ImportModule\");\n                  if (DAT_0042d9a8 == (FARPROC)0x0) {\n                    pcVar1 = \"Failed to get address for PyImport_ImportModule\\n\";\n                  }\n                  else {\n                    DAT_0042d9b8 = GetProcAddress(param_1,\"PyList_Append\");\n                    if (DAT_0042d9b8 == (FARPROC)0x0) {\n                      pcVar1 = \"Failed to get address for PyList_Append\\n\";\n                    }\n                    else {\n                      _DAT_0042d9b4 = GetProcAddress(param_1,\"PyList_New\");\n                      if (_DAT_0042d9b4 == (FARPROC)0x0) {\n                        pcVar1 = \"Failed to get address for PyList_New\\n\";\n                      }\n                      else {\n                        _DAT_0042d9e4 = GetProcAddress(param_1,\"PyLong_AsLong\");\n                        if (_DAT_0042d9e4 == (FARPROC)0x0) {\n                          pcVar1 = \"Failed to get address for PyLong_AsLong\\n\";\n                        }\n                        else {\n                          DAT_0042d9cc = GetProcAddress(param_1,\"PyModule_GetDict\");\n                          if (DAT_0042d9cc == (FARPROC)0x0) {\n                            pcVar1 = \"Failed to get address for PyModule_GetDict\\n\";\n                          }\n                          else {\n                            DAT_0042d9c8 = GetProcAddress(param_1,\"PyObject_CallFunction\");\n                            if (DAT_0042d9c8 == (FARPROC)0x0) {\n                              pcVar1 = \"Failed to get address for PyObject_CallFunction\\n\";\n                            }\n                            else {\n                              DAT_0042d9b0 = GetProcAddress(param_1,\"PyObject_SetAttrString\");\n                              if (DAT_0042d9b0 == (FARPROC)0x0) {\n                                pcVar1 = \"Failed to get address for PyObject_SetAttrString\\n\";\n                              }\n                              else {\n                                _DAT_0042d9a0 = GetProcAddress(param_1,\"PyRun_SimpleString\");\n                                if (_DAT_0042d9a0 == (FARPROC)0x0) {\n                                  pcVar1 = \"Failed to get address for PyRun_SimpleString\\n\";\n                                }\n                                else {\n                                  if (param_2 < 0x1e) {\n                                    DAT_0042d9c0 = GetProcAddress(param_1,\"PyString_FromString\");\n                                    if (DAT_0042d9c0 == (FARPROC)0x0) {\n                                      pcVar1 = \"Failed to get address for PyString_FromString\\n\";\n                                      goto LAB_004030ed;\n                                    }\n                                    DAT_0042d9f4 = GetProcAddress(param_1,\"PyString_FromFormat\");\n                                    if (DAT_0042d9f4 == (FARPROC)0x0) {\n                                      pcVar1 = \"Failed to get address for PyString_FromFormat\\n\";\n                                      goto LAB_004030ed;\n                                    }\n                                  }\n                                  DAT_0042d9e0 = GetProcAddress(param_1,\"PySys_AddWarnOption\");\n                                  if (DAT_0042d9e0 == (FARPROC)0x0) {\n                                    pcVar1 = \"Failed to get address for PySys_AddWarnOption\\n\";\n                                  }\n                                  else {\n                                    DAT_0042d99c = GetProcAddress(param_1,\"PySys_SetArgvEx\");\n                                    if (DAT_0042d99c == (FARPROC)0x0) {\n                                      pcVar1 = \"Failed to get address for PySys_SetArgvEx\\n\";\n                                    }\n                                    else {\n                                      DAT_0042d9f0 = GetProcAddress(param_1,\"PySys_GetObject\");\n                                      if (DAT_0042d9f0 == (FARPROC)0x0) {\n                                        pcVar1 = \"Failed to get address for PySys_GetObject\\n\";\n                                      }\n                                      else {\n                                        DAT_0042d9e8 = GetProcAddress(param_1,\"PySys_SetObject\");\n                                        if (DAT_0042d9e8 == (FARPROC)0x0) {\n                                          pcVar1 = \"Failed to get address for PySys_SetObject\\n\";\n                                        }\n                                        else {\n                                          DAT_0042d998 = GetProcAddress(param_1,\"PySys_SetPath\");\n                                          if (DAT_0042d998 == (FARPROC)0x0) {\n                                            pcVar1 = \"Failed to get address for PySys_SetPath\\n\";\n                                          }\n                                          else {\n                                            DAT_0042da04 = GetProcAddress(param_1,\"PyEval_EvalCode\")\n                                            ;\n                                            if (DAT_0042da04 == (FARPROC)0x0) {\n                                              pcVar1 = \"Failed to get address for PyEval_EvalCode\\n\"\n                                              ;\n                                            }\n                                            else {\n                                              DAT_0042da08 = GetProcAddress(param_1,\n                                                  \"PyMarshal_ReadObjectFromString\");\n                                              if (DAT_0042da08 != (FARPROC)0x0) {\n                                                if (0x1d < param_2) {\n                                                  DAT_0042d9c4 = GetProcAddress(param_1,\n                                                  \"PyUnicode_FromString\");\n                                                  if (DAT_0042d9c4 == (FARPROC)0x0) {\n                                                    pcVar1 = \n                                                  \"Failed to get address for PyUnicode_FromString\\n\"\n                                                  ;\n                                                  goto LAB_004030ed;\n                                                  }\n                                                  if (param_2 < 0x23) {\n                                                    _DAT_0042d9ec =\n                                                         GetProcAddress(param_1,\"_Py_char2wchar\");\n                                                    if (_DAT_0042d9ec == (FARPROC)0x0) {\n                                                      pcVar1 = \n                                                  \"Failed to get address for _Py_char2wchar\\n\";\n                                                  goto LAB_004030ed;\n                                                  }\n                                                  }\n                                                  else {\n                                                    _DAT_0042d9ec =\n                                                         GetProcAddress(param_1,\"Py_DecodeLocale\");\n                                                    if (_DAT_0042d9ec == (FARPROC)0x0) {\n                                                      pcVar1 = \n                                                  \"Failed to get address for Py_DecodeLocale\\n\";\n                                                  goto LAB_004030ed;\n                                                  }\n                                                  }\n                                                  DAT_0042d9f8 = GetProcAddress(param_1,\n                                                  \"PyUnicode_FromFormat\");\n                                                  if (DAT_0042d9f8 == (FARPROC)0x0) {\n                                                    pcVar1 = \n                                                  \"Failed to get address for PyUnicode_FromFormat\\n\"\n                                                  ;\n                                                  goto LAB_004030ed;\n                                                  }\n                                                  DAT_0042da00 = GetProcAddress(param_1,\n                                                  \"PyUnicode_Decode\");\n                                                  if (DAT_0042da00 == (FARPROC)0x0) {\n                                                    pcVar1 = \n                                                  \"Failed to get address for PyUnicode_Decode\\n\";\n                                                  goto LAB_004030ed;\n                                                  }\n                                                }\n                                                if (0x1f < param_2) {\n                                                  _DAT_0042d9fc =\n                                                       GetProcAddress(param_1,\n                                                  \"PyUnicode_DecodeFSDefault\");\n                                                  if (_DAT_0042d9fc == (FARPROC)0x0) {\n                                                    pcVar1 = \n                                                  \"Failed to get address for PyUnicode_DecodeFSDefault\\n\"\n                                                  ;\n                                                  _DAT_0042d9fc = (FARPROC)0x0;\n                                                  goto LAB_004030ed;\n                                                  }\n                                                }\n                                                FUN_004018c0(\n                                                  \"LOADER: Loaded functions from Python library.\\n\")\n                                                ;\n                                                return 0;\n                                              }\n                                              pcVar1 = \n                                              \"Failed to get address for PyMarshal_ReadObjectFromString\\n\"\n                                              ;\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_004030ed:\n  FUN_004018f0(\"GetProcAddress\",pcVar1);\n  return 0xffffffff;\n}\n\n"
    },
    {
      "name": "FUN_00403120",
      "entry": "00403120",
      "c": "\nvoid FUN_00403120(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00403120. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*DAT_0042d9e0)();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403130",
      "entry": "00403130",
      "c": "\nvoid FUN_00403130(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00403130. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*DAT_0042d99c)();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403140",
      "entry": "00403140",
      "c": "\nvoid FUN_00403140(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00403140. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*DAT_0042d998)();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403150",
      "entry": "00403150",
      "c": "\nvoid FUN_00403150(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00403150. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*DAT_0042d988)();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403160",
      "entry": "00403160",
      "c": "\nvoid FUN_00403160(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00403160. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*DAT_0042d98c)();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403170",
      "entry": "00403170",
      "c": "\nvoid __cdecl FUN_00403170(undefined4 *param_1)\n\n{\n  undefined4 *puVar1;\n  void *_Memory;\n  undefined4 *puVar2;\n  \n  _Memory = (void *)*param_1;\n  puVar2 = param_1;\n  while (_Memory != (void *)0x0) {\n    FID_conflict__free(_Memory);\n    puVar1 = puVar2 + 1;\n    puVar2 = puVar2 + 1;\n    _Memory = (void *)*puVar1;\n  }\n  FID_conflict__free(param_1);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004031a0",
      "entry": "004031a0",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid __cdecl FUN_004031a0(int param_1)\n\n{\n  if (*(int *)(param_1 + 0x406c) == 1) {\n    FUN_004018c0(\"LOADER: Cleaning up Python interpreter.\\n\");\n                    /* WARNING: Could not recover jumptable at 0x004031ba. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*_DAT_0042d97c)();\n    return;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004031d0",
      "entry": "004031d0",
      "c": "\nundefined4 __cdecl FUN_004031d0(int *param_1)\n\n{\n  void *pvVar1;\n  int iVar2;\n  undefined4 uVar3;\n  int iVar4;\n  undefined4 *puVar5;\n  int *piVar6;\n  undefined4 unaff_EBX;\n  undefined *puVar7;\n  \n  FUN_004018c0(\"LOADER: setting sys._MEIPASS\\n\");\n  if (DAT_0043b65c == 0) {\n    piVar6 = param_1 + 0xc1a;\n    do {\n      iVar2 = *piVar6;\n      piVar6 = (int *)((int)piVar6 + 1);\n    } while ((char)iVar2 != '\\0');\n    iVar2 = (*DAT_0042da00)(param_1 + 0xc1a,(int)piVar6 - ((int)param_1 + 0x3069),\"utf-8\",\"strict\");\n  }\n  else {\n    pvVar1 = (void *)FUN_00404ee0((LPCWSTR)0x0,(LPCSTR)(param_1 + 0xc1a),(char *)0x0);\n    if (pvVar1 == (void *)0x0) {\n      FUN_004018c0(\"Failed to encode _MEIPASS as ANSI.\\n\");\n      return 0xffffffff;\n    }\n    iVar2 = (*DAT_0042d9c0)(pvVar1);\n    FID_conflict__free(pvVar1);\n  }\n  if (iVar2 == 0) {\n    FUN_004018c0(\"Failed to get _MEIPASS as PyObject.\\n\");\n    return 0xffffffff;\n  }\n  (*DAT_0042d9e8)(\"_MEIPASS\",iVar2);\n  FUN_004018c0(\"LOADER: importing modules from CArchive\\n\");\n  uVar3 = (*DAT_0042d9a8)(\"marshal\");\n  uVar3 = (*DAT_0042d9cc)(uVar3);\n  (*DAT_0042d9d0)(uVar3,\"loads\");\n  puVar5 = (undefined4 *)param_1[2];\n  if (puVar5 < (undefined4 *)param_1[3]) {\n    do {\n      if ((*(char *)((int)puVar5 + 0x11) == 'm') || (*(char *)((int)puVar5 + 0x11) == 'M')) {\n        pvVar1 = FUN_00401240(param_1,(int)puVar5);\n        FUN_004018c0(\"LOADER: extracted %s\\n\");\n        uVar3 = puVar5[3];\n        if (DAT_0043b65c == 0) {\n          if (DAT_0042d954 < 0x25) {\n            iVar4 = Ordinal_14(uVar3);\n            iVar4 = iVar4 + -0xc;\n            iVar2 = (int)pvVar1 + 0xc;\n          }\n          else {\n            iVar4 = Ordinal_14(uVar3);\n            iVar4 = iVar4 + -0x10;\n            iVar2 = (int)pvVar1 + 0x10;\n          }\n          puVar7 = &DAT_00422ba8;\n        }\n        else {\n          iVar4 = Ordinal_14(uVar3);\n          iVar4 = iVar4 + -8;\n          iVar2 = (int)pvVar1 + 8;\n          puVar7 = &DAT_00422ba4;\n        }\n        iVar2 = (*DAT_0042d9c8)(unaff_EBX,puVar7,iVar2,iVar4);\n        if (iVar2 == 0) {\n          FUN_004018c0(\"LOADER: callfunction returned NULL\");\nLAB_00403376:\n          FUN_004018c0(\"mod is NULL - %s\");\n        }\n        else {\n          FUN_004018c0(\"LOADER: callfunction returned...\\n\");\n          iVar2 = (*DAT_0042d9a4)((int)puVar5 + 0x12,iVar2);\n          if (iVar2 == 0) goto LAB_00403376;\n        }\n        iVar2 = (*DAT_0042d9d8)();\n        if (iVar2 != 0) {\n          (*DAT_0042d9dc)();\n          (*DAT_0042d9d4)();\n        }\n        FID_conflict__free(pvVar1);\n      }\n      puVar5 = (undefined4 *)FUN_00401550(param_1,puVar5);\n    } while (puVar5 < (undefined4 *)param_1[3]);\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_004033d0",
      "entry": "004033d0",
      "c": "\nundefined4 __cdecl FUN_004033d0(int param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  LPCSTR _Memory;\n  undefined4 uVar3;\n  char *pcVar4;\n  undefined4 uVar5;\n  undefined4 *puVar6;\n  \n  FUN_004018c0(\"LOADER: Installing PYZ archive with Python modules.\\n\");\n  puVar6 = *(undefined4 **)(param_1 + 8);\n  if (puVar6 < *(undefined4 **)(param_1 + 0xc)) {\n    do {\n      if (*(char *)((int)puVar6 + 0x11) == 'z') {\n        FUN_004018c0(\"LOADER: PYZ archive: %s\\n\");\n        iVar2 = Ordinal_14(puVar6[1]);\n        iVar2 = iVar2 + *(int *)(param_1 + 4);\n        if (DAT_0043b65c == 0) {\n          pcVar4 = (char *)(param_1 + 0x68);\n          do {\n            cVar1 = *pcVar4;\n            pcVar4 = pcVar4 + 1;\n          } while (cVar1 != '\\0');\n          uVar5 = (*DAT_0042da00)((char *)(param_1 + 0x68),(int)pcVar4 - (param_1 + 0x69),\"utf-8\",\n                                  \"strict\");\n          uVar3 = (*DAT_0042d9f8)(\"%U?%d\",uVar5,iVar2);\n          (*DAT_0042d984)(uVar5);\n        }\n        else {\n          _Memory = (LPCSTR)FUN_00404ee0((LPCWSTR)0x0,(LPCSTR)(param_1 + 0x68),(char *)0x0);\n          if (_Memory == (LPCSTR)0x0) {\n            FUN_004018c0(\"Failed to convert %s to ShortFileName\\n\");\n            goto LAB_004034fb;\n          }\n          uVar3 = (*DAT_0042d9f4)(\"%s?%d\",_Memory,iVar2);\n          if (_Memory != (LPCSTR)(param_1 + 0x68)) {\n            FID_conflict__free(_Memory);\n          }\n        }\n        iVar2 = (*DAT_0042d9f0)(&DAT_00422c40);\n        if (iVar2 == 0) {\n          FUN_004018c0(\"Installing PYZ: Could not get sys.path\\n\");\n          (*DAT_0042d984)(uVar3);\n        }\n        else {\n          iVar2 = (*DAT_0042d9b8)(iVar2,uVar3);\n          if (iVar2 != 0) {\n            FUN_004018c0(\"Failed to append to sys.path\\n\");\n          }\n        }\n      }\nLAB_004034fb:\n      puVar6 = (undefined4 *)FUN_00401550(param_1,puVar6);\n    } while (puVar6 < *(undefined4 **)(param_1 + 0xc));\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_00403520",
      "entry": "00403520",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00403520(int param_1)\n\n{\n  int iVar1;\n  HMODULE pHVar2;\n  char local_2044 [63];\n  char local_2005;\n  char local_2004 [4096];\n  char local_1004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_2044;\n  DAT_0043b65c = (uint)(DAT_0042d954 / 10 == 2);\n  _strncpy(local_2044,(char *)(param_1 + 0x28),0x40);\n  if (local_2005 == '\\0') {\n    if (*(int *)(param_1 + 0x4068) != 0) {\n      FUN_00402a40(local_2004,(char *)(param_1 + 0x2068),\"ucrtbase.dll\");\n      iVar1 = FUN_004028d0(local_2004);\n      if (iVar1 != 0) {\n        FUN_004018c0(\"LOADER: ucrtbase.dll is exists: %s\\n\");\n        FUN_00404740(local_2004);\n      }\n    }\n    FUN_00402a40(local_1004,(char *)(param_1 + 0x3068),local_2044);\n    FUN_004018c0(\"LOADER: Python library: %s\\n\");\n    pHVar2 = FUN_00404740(local_1004);\n    if (pHVar2 != (HMODULE)0x0) {\n      FUN_00402b40(pHVar2,DAT_0042d954);\n      __security_check_cookie(local_4 ^ (uint)local_2044);\n      return;\n    }\n    FUN_004018f0(\"LoadLibrary\",\"Error loading Python DLL \\'%s\\'.\\n\");\n  }\n  else {\n    FUN_004018c0(\"DLL name length exceeds buffer\\n\");\n  }\n  __security_check_cookie(local_4 ^ (uint)local_2044);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403680",
      "entry": "00403680",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00403680(int param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  size_t sVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  FILE *pFVar6;\n  int iVar7;\n  char *pcVar8;\n  wchar_t local_2008 [4098];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_2008;\n  bVar1 = false;\n  puVar5 = *(undefined4 **)(param_1 + 8);\n  *DAT_0042d95c = 1;\n  *DAT_0042d958 = 1;\n  *DAT_0042d970 = 1;\n  *DAT_0042d974 = 1;\n  *DAT_0042d96c = 1;\n  *DAT_0042d968 = 0;\n  if (puVar5 < *(undefined4 **)(param_1 + 0xc)) {\n    do {\n      if (*(char *)((int)puVar5 + 0x11) != 'o') goto switchD_00403743_caseD_50;\n      iVar2 = _strncmp((char *)((int)puVar5 + 0x12),\"pyi-\",4);\n      if (iVar2 == 0) {\n        FUN_004018c0(\"LOADER: Bootloader option: %s\\n\");\n        goto switchD_00403743_caseD_50;\n      }\n      FUN_004018c0(\"LOADER: Runtime option: %s\\n\");\n      switch(*(char *)((int)puVar5 + 0x12)) {\n      case 'O':\n        puVar4 = DAT_0042d960;\n        goto LAB_004037a0;\n      case 'W':\n        if (DAT_0043b65c == 0) {\n          sVar3 = _mbstowcs(local_2008,(char *)(puVar5 + 5),0x1000);\n          if (sVar3 == 0xffffffff) {\n            FUN_004018c0(\"Failed to convert Wflag %s using mbstowcs (invalid multibyte string)\\n\");\n            goto LAB_0040385a;\n          }\n          (*DAT_0042d9e0)(local_2008);\n        }\n        else {\n          FUN_00403120();\n        }\n        break;\n      case 'u':\n        bVar1 = true;\n        break;\n      case 'v':\n        puVar4 = DAT_0042d968;\nLAB_004037a0:\n        *puVar4 = 1;\n      }\nswitchD_00403743_caseD_50:\n      puVar5 = (undefined4 *)FUN_00401550(param_1,puVar5);\n    } while (puVar5 < *(undefined4 **)(param_1 + 0xc));\n    if (bVar1) {\n      iVar7 = 0x8000;\n      pFVar6 = (FILE *)___acrt_iob_func(0);\n      iVar2 = __fileno(pFVar6);\n      __setmode(iVar2,iVar7);\n      iVar7 = 0x8000;\n      pFVar6 = (FILE *)___acrt_iob_func(1);\n      iVar2 = __fileno(pFVar6);\n      __setmode(iVar2,iVar7);\n      pFVar6 = (FILE *)___acrt_iob_func(1);\n      _fflush(pFVar6);\n      pFVar6 = (FILE *)___acrt_iob_func(2);\n      _fflush(pFVar6);\n      pcVar8 = (char *)0x0;\n      pFVar6 = (FILE *)___acrt_iob_func(0);\n      _setbuf(pFVar6,pcVar8);\n      pcVar8 = (char *)0x0;\n      pFVar6 = (FILE *)___acrt_iob_func(1);\n      _setbuf(pFVar6,pcVar8);\n      pcVar8 = (char *)0x0;\n      pFVar6 = (FILE *)___acrt_iob_func(2);\n      _setbuf(pFVar6,pcVar8);\n    }\n  }\nLAB_0040385a:\n  __security_check_cookie(local_4 ^ (uint)local_2008);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004038d0",
      "entry": "004038d0",
      "c": "\nundefined4 __cdecl FUN_004038d0(int param_1)\n\n{\n  void *_Memory;\n  undefined4 *puVar1;\n  int unaff_ESI;\n  LPCSTR unaff_EDI;\n  \n  FUN_004018c0(\"LOADER: Setting sys.argv\\n\");\n  if (DAT_0043b65c == 0) {\n    puVar1 = FUN_00405020(*(LPCSTR *)(param_1 + 0x4070),*(int *)(param_1 + 0x4074),unaff_EDI,\n                          unaff_ESI);\n    if (puVar1 != (undefined4 *)0x0) {\n      (*DAT_0042d99c)(*(undefined4 *)(param_1 + 0x4070),puVar1,0);\n      FUN_00403170(puVar1);\n      return 0;\n    }\n    FUN_004018c0(\"Failed to convert argv to wchar_t\\n\");\n    return 0xffffffff;\n  }\n  _Memory = (void *)FUN_00404b10(*(LPCSTR *)(param_1 + 0x4070),*(int *)(param_1 + 0x4074));\n  if (_Memory != (void *)0x0) {\n    FUN_00403130();\n    FID_conflict__free(_Memory);\n    return 0;\n  }\n  FUN_004018c0(\"Failed to convert argv to mbcs\\n\");\n  return 0xffffffff;\n}\n\n"
    },
    {
      "name": "FUN_00403980",
      "entry": "00403980",
      "c": "\nundefined4 __cdecl FUN_00403980(int param_1)\n\n{\n  LPCSTR _Source;\n  char cVar1;\n  int iVar2;\n  LPWSTR pWVar3;\n  LPCSTR pCVar4;\n  LPCSTR unaff_ESI;\n  LPCSTR unaff_EDI;\n  char *pcVar5;\n  undefined *puVar6;\n  \n  if (DAT_0043b65c == 0) {\n    pWVar3 = FUN_00404f00((LPWSTR)&DAT_00437a50,(LPCSTR)(param_1 + 0x68),0x1000,unaff_EDI);\n    if (pWVar3 != (LPWSTR)0x0) {\n      (*DAT_0042d988)(&DAT_00437a50);\n      goto LAB_004039e2;\n    }\n  }\n  else {\n    iVar2 = FUN_00404ee0((LPCWSTR)&DAT_00432a38,(LPCSTR)(param_1 + 0x68),(char *)0x1000);\n    if (iVar2 != 0) {\n      FUN_00403150();\nLAB_004039e2:\n      FUN_004018c0(\"LOADER: Manipulating environment (sys.path, sys.prefix)\\n\");\n      _Source = (LPCSTR)(param_1 + 0x3068);\n      if (DAT_0043b65c == 0) {\n        pWVar3 = FUN_00404f00((LPWSTR)&DAT_00435a48,_Source,0x1000,unaff_ESI);\n        if (pWVar3 == (LPWSTR)0x0) {\n          FUN_004018c0(\"Failed to convert pyhome to wchar_t\\n\");\n          return 0xffffffff;\n        }\n        pcVar5 = \"LOADER: sys.prefix is %s\\n\";\n        pCVar4 = _Source;\n        FUN_004018c0(\"LOADER: sys.prefix is %s\\n\");\n        (*DAT_0042d98c)(&DAT_00435a48,pcVar5,pCVar4);\n      }\n      else {\n        iVar2 = FUN_00404ee0((LPCWSTR)&DAT_00431a30,_Source,(char *)0x1000);\n        if (iVar2 == 0) {\n          FUN_004018c0(\"Failed to convert pyhome to ANSI (invalid multibyte string)\\n\");\n          return 0xffffffff;\n        }\n        FUN_004018c0(\"LOADER: sys.prefix is %s\\n\");\n        FUN_00403160();\n      }\n      pCVar4 = _Source;\n      if (DAT_0043b65c == 0) {\n        do {\n          cVar1 = *pCVar4;\n          pCVar4 = pCVar4 + 1;\n        } while (cVar1 != '\\0');\n        _strncpy(&DAT_0042da10,_Source,(int)pCVar4 - (param_1 + 0x3069));\n        _strncat(&DAT_0042da10,\"\\\\\",1);\n        _strncat(&DAT_0042da10,\"base_library.zip\",0x10);\n        _strncat(&DAT_0042da10,\";\",1);\n        pCVar4 = _Source;\n        do {\n          cVar1 = *pCVar4;\n          pCVar4 = pCVar4 + 1;\n        } while (cVar1 != '\\0');\n        _strncat(&DAT_0042da10,_Source,(int)pCVar4 - (param_1 + 0x3069));\n      }\n      else {\n        do {\n          cVar1 = *pCVar4;\n          pCVar4 = pCVar4 + 1;\n        } while (cVar1 != '\\0');\n        _strncpy(&DAT_0042da10,_Source,(int)pCVar4 - (param_1 + 0x3069));\n      }\n      if (DAT_0043b65c == 0) {\n        pWVar3 = FUN_00404f00((LPWSTR)&DAT_00433a40,&DAT_0042da10,0x1000,unaff_ESI);\n        if (pWVar3 == (LPWSTR)0x0) {\n          FUN_004018c0(\"Failed to convert pypath to wchar_t\\n\");\n          return 0xffffffff;\n        }\n        puVar6 = &DAT_0042da10;\n        pcVar5 = \"LOADER: Pre-init sys.path is %s\\n\";\n        FUN_004018c0(\"LOADER: Pre-init sys.path is %s\\n\");\n        (*DAT_0042d994)(pcVar5,puVar6);\n        (*DAT_0042d990)(&DAT_00433a40);\n      }\n      FUN_004018c0(\"LOADER: Setting runtime options\\n\");\n      FUN_00403680(param_1);\n      SetErrorMode(3);\n      FUN_004018c0(\"LOADER: Initializing python\\n\");\n      (*DAT_0042d978)();\n      SetErrorMode(0);\n      FUN_004018c0(\"LOADER: Overriding Python\\'s sys.path\\n\");\n      FUN_004018c0(\"LOADER: Post-init sys.path is %s\\n\");\n      if (DAT_0043b65c == 0) {\n        (*DAT_0042d998)(&DAT_00433a40);\n      }\n      else {\n        iVar2 = FUN_00404ee0((LPCWSTR)&DAT_0042fa20,&DAT_0042da10,(char *)0x1000);\n        if (iVar2 == 0) {\n          FUN_004018c0(\"Failed to convert pypath to ANSI (invalid multibyte string)\\n\");\n        }\n        FUN_00403140();\n      }\n      iVar2 = FUN_004038d0(param_1);\n      if (iVar2 == 0) {\n        iVar2 = (*DAT_0042d9d8)();\n        if (iVar2 == 0) {\n          return 0;\n        }\n        FUN_004018c0(\"Error detected starting Python VM.\");\n      }\n      return 0xffffffff;\n    }\n  }\n  FUN_004018c0(\"Failed to convert progname to wchar_t\\n\");\n  return 0xffffffff;\n}\n\n"
    },
    {
      "name": "FUN_00403c40",
      "entry": "00403c40",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00403c40(LPCSTR param_1,char *param_2,char *param_3)\n\n{\n  FILE *_File;\n  FILE *_File_00;\n  int iVar1;\n  size_t sVar2;\n  FILE *_File_01;\n  undefined1 local_1004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_1004;\n  _File = (FILE *)FUN_00402930(param_1,\"rb\");\n  _File_00 = (FILE *)FUN_00404080(param_2,param_3);\n  if (_File == (FILE *)0x0) {\n    _File = _File_00;\n    if (_File_00 == (FILE *)0x0) goto LAB_00403d49;\n  }\n  else if (_File_00 != (FILE *)0x0) {\n    iVar1 = _feof(_File);\n    do {\n      if (iVar1 != 0) {\nLAB_00403d13:\n        _fclose(_File);\n        _fclose(_File_00);\n        __security_check_cookie(local_4 ^ (uint)local_1004);\n        return;\n      }\n      sVar2 = _fread(local_1004,0x1000,1,_File);\n      if (sVar2 != 0xffffffff) {\n        sVar2 = _fwrite(local_1004,0x1000,1,_File_00);\n        _File_01 = _File_00;\n        if (0 < (int)sVar2) {\n          iVar1 = _ferror(_File_00);\n          goto joined_r0x00403cf6;\n        }\nLAB_00403d08:\n        _clearerr_s(_File_01);\n        goto LAB_00403d13;\n      }\n      iVar1 = _ferror(_File);\n      _File_01 = _File;\njoined_r0x00403cf6:\n      if (iVar1 != 0) goto LAB_00403d08;\n      iVar1 = _feof(_File);\n    } while( true );\n  }\n  _fclose(_File);\nLAB_00403d49:\n  __security_check_cookie(local_4 ^ (uint)local_1004);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403d70",
      "entry": "00403d70",
      "c": "\nundefined4 __cdecl FUN_00403d70(int param_1)\n\n{\n  char *pcVar1;\n  int iVar2;\n  \n  if (*(int *)(param_1 + 0x4068) != 1) {\n    pcVar1 = FUN_004014d0(param_1,\"pyi-runtime-tmpdir\");\n    if (pcVar1 != (char *)0x0) {\n      FUN_004018c0(\"LOADER: Found runtime-tmpdir %s\\n\");\n    }\n    iVar2 = FUN_00403de0((LPCSTR)(param_1 + 0x2068),pcVar1);\n    if (iVar2 == 0) {\n      FUN_004018c0(\"INTERNAL ERROR: cannot create temporary directory!\\n\");\n      return 0xffffffff;\n    }\n    *(undefined4 *)(param_1 + 0x4068) = 1;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_00403de0",
      "entry": "00403de0",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00403de0(LPCSTR param_1,char *param_2)\n\n{\n  LPWSTR pWVar1;\n  LPWSTR pWVar2;\n  wchar_t *_Memory;\n  int iVar3;\n  int iVar4;\n  LPCWSTR unaff_EDI;\n  LPCSTR pCVar5;\n  char *pcVar6;\n  LPCSTR local_302c;\n  wchar_t awStack_3028 [16];\n  char local_3008 [4100];\n  WCHAR local_2004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)&local_302c;\n  local_302c = param_1;\n  if (param_2 != (char *)0x0) {\n    param_1 = (LPCSTR)FUN_00403fd0(\"TMP\");\n    pcVar6 = local_3008;\n    FUN_004029a0(pcVar6,0x1000,param_2);\n    pCVar5 = (LPCSTR)0x0;\n    pWVar1 = FUN_00404f00((LPWSTR)0x0,\"TMP\",0,pcVar6);\n    pWVar2 = FUN_00404f00((LPWSTR)0x0,local_3008,0,pCVar5);\n    FID_conflict___wputenv_s(pWVar1,pWVar2);\n    FID_conflict__free(pWVar1);\n    FID_conflict__free(pWVar2);\n  }\n  GetTempPathW(0x1000,local_2004);\n  GetCurrentProcessId();\n  FUN_004048c0(awStack_3028,0x10,L\"_MEI%d\");\n  iVar4 = 0;\n  do {\n    _Memory = __wtempnam(local_2004,awStack_3028);\n    iVar3 = FUN_00404d50(_Memory);\n    if (iVar3 == 0) {\n      FUN_00404f90(local_302c,_Memory,0x1000,unaff_EDI);\n      FID_conflict__free(_Memory);\n      if (param_2 != (char *)0x0) {\n        pCVar5 = (LPCSTR)0x0;\n        pWVar1 = FUN_00404f00((LPWSTR)0x0,\"TMP\",0,(LPCSTR)unaff_EDI);\n        if (param_1 == (LPCSTR)0x0) {\n          SetEnvironmentVariableW(pWVar1,(LPCWSTR)0x0);\n          FID_conflict__free(pWVar1);\n        }\n        else {\n          pWVar2 = FUN_00404f00((LPWSTR)0x0,param_1,0,pCVar5);\n          FID_conflict___wputenv_s(pWVar1,pWVar2);\n          FID_conflict__free(pWVar1);\n          FID_conflict__free(pWVar2);\n          FID_conflict__free(param_1);\n        }\n      }\n      goto LAB_00403fa8;\n    }\n    FID_conflict__free(_Memory);\n    iVar4 = iVar4 + 1;\n  } while (iVar4 < 5);\n  if (param_2 != (char *)0x0) {\n    pCVar5 = (LPCSTR)0x0;\n    pWVar1 = FUN_00404f00((LPWSTR)0x0,\"TMP\",0,(LPCSTR)unaff_EDI);\n    if (param_1 == (LPCSTR)0x0) {\n      SetEnvironmentVariableW(pWVar1,(LPCWSTR)0x0);\n      FID_conflict__free(pWVar1);\n    }\n    else {\n      pWVar2 = FUN_00404f00((LPWSTR)0x0,param_1,0,pCVar5);\n      FID_conflict___wputenv_s(pWVar1,pWVar2);\n      FID_conflict__free(pWVar1);\n      FID_conflict__free(pWVar2);\n      FID_conflict__free(param_1);\n    }\n  }\nLAB_00403fa8:\n  __security_check_cookie(local_4 ^ (uint)&local_302c);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00403fd0",
      "entry": "00403fd0",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00403fd0(LPCSTR param_1)\n\n{\n  LPWSTR lpName;\n  DWORD DVar1;\n  LPSTR _Src;\n  LPCWSTR in_stack_ffffbffc;\n  WCHAR aWStack_2004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)&stack0xffffbffc;\n  lpName = FUN_00404f00((LPWSTR)0x0,param_1,0,(LPCSTR)in_stack_ffffbffc);\n  DVar1 = GetEnvironmentVariableW(lpName,(LPWSTR)&stack0xffffbffc,0x2000);\n  if (DVar1 != 0) {\n    ExpandEnvironmentStringsW((LPCWSTR)&stack0xffffbffc,aWStack_2004,0x2000);\n    _Src = FUN_00404f90((LPSTR)0x0,(LPCWSTR)&stack0xffffbffc,0,in_stack_ffffbffc);\n    if ((_Src != (LPSTR)0x0) && (*_Src != '\\0')) {\n      __strdup(_Src);\n      __security_check_cookie(local_4 ^ (uint)&stack0xffffbffc);\n      return;\n    }\n  }\n  __security_check_cookie(local_4 ^ (uint)&stack0xffffbffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404080",
      "entry": "00404080",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00404080(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  int iVar3;\n  char *pcVar4;\n  uint uVar5;\n  char *pcVar6;\n  char *pcVar7;\n  LPCSTR unaff_EDI;\n  char *pcVar8;\n  _stat64i32 local_4034 [47];\n  char cStack_4005;\n  char local_4004 [4095];\n  char local_3005;\n  char local_3004 [4095];\n  char local_2005;\n  WCHAR local_2004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_4034;\n  _strncpy(local_4004,param_1,0x1000);\n  _strncpy(local_3004,param_2,0x1000);\n  if ((local_3005 != '\\0') || (local_2005 != '\\0')) {\n    __security_check_cookie(local_4 ^ (uint)local_4034);\n    return;\n  }\n  pcVar6 = local_4004;\n  do {\n    cVar1 = *pcVar6;\n    pcVar6 = pcVar6 + 1;\n  } while (cVar1 != '\\0');\n  pcVar6 = pcVar6 + -(int)(local_4004 + 1);\n  pcVar2 = _strtok(local_3004,\"\\\\\");\n  if (pcVar2 != (char *)0x0) {\n    while( true ) {\n      pcVar4 = pcVar2;\n      do {\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n      } while (cVar1 != '\\0');\n      pcVar6 = pcVar4 + (int)(pcVar6 + (1 - (int)(pcVar2 + 1)));\n      if ((char *)0xffe < pcVar6) goto LAB_004041db;\n      pcVar4 = &cStack_4005;\n      do {\n        pcVar8 = pcVar4 + 1;\n        pcVar4 = pcVar4 + 1;\n      } while (*pcVar8 != '\\0');\n      *(undefined2 *)pcVar4 = DAT_00421638;\n      pcVar4 = pcVar2;\n      do {\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n      } while (cVar1 != '\\0');\n      pcVar8 = &cStack_4005;\n      do {\n        pcVar7 = pcVar8 + 1;\n        pcVar8 = pcVar8 + 1;\n      } while (*pcVar7 != '\\0');\n      pcVar7 = pcVar2;\n      for (uVar5 = (uint)((int)pcVar4 - (int)pcVar2) >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *(undefined4 *)pcVar8 = *(undefined4 *)pcVar7;\n        pcVar7 = pcVar7 + 4;\n        pcVar8 = pcVar8 + 4;\n      }\n      for (uVar5 = (int)pcVar4 - (int)pcVar2 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *pcVar8 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n        pcVar8 = pcVar8 + 1;\n      }\n      pcVar2 = _strtok((char *)0x0,\"\\\\\");\n      if (pcVar2 == (char *)0x0) break;\n      FUN_00404f00(local_2004,local_4004,0x1000,unaff_EDI);\n      iVar3 = FUN_0040e21d(local_2004,local_4034);\n      if (iVar3 < 0) {\n        FUN_00404d50(local_2004);\n      }\n    }\n  }\n  FUN_00404f00(local_2004,local_4004,0x1000,unaff_EDI);\n  iVar3 = FUN_0040e21d(local_2004,local_4034);\n  if (iVar3 == 0) {\n    FUN_004018c0(\"WARNING: file already exists but should not: %s\\n\");\n  }\n  FUN_00402930(local_4004,\"wb\");\nLAB_004041db:\n  __security_check_cookie(local_4 ^ (uint)local_4034);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404270",
      "entry": "00404270",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00404270(LPCSTR param_1)\n\n{\n  short *psVar1;\n  short sVar2;\n  wchar_t wVar3;\n  ushort uVar4;\n  ushort *puVar5;\n  uint uVar6;\n  int iVar7;\n  ushort *puVar8;\n  uint uVar9;\n  wchar_t *pwVar10;\n  int iVar11;\n  _wfinddata64i32_t *p_Var12;\n  LPCWSTR unaff_EDI;\n  undefined4 *puVar13;\n  short *psVar14;\n  bool bVar15;\n  undefined4 auStack_56c8 [135];\n  undefined4 uStack_54ac;\n  HANDLE local_548c;\n  _wfinddata64i32_t local_5488 [560];\n  undefined4 local_5258 [9];\n  ushort local_5234 [261];\n  short sStack_502a;\n  wchar_t local_5028;\n  undefined1 auStack_5026 [8198];\n  CHAR local_3020 [4104];\n  WCHAR local_2018 [4102];\n  uint local_c;\n  \n  local_c = DAT_0042d008 ^ (uint)&local_548c;\n  FUN_00404f00(local_2018,param_1,0x1000,(LPCSTR)unaff_EDI);\n  iVar11 = 0;\n  do {\n    sVar2 = *(short *)((int)local_2018 + iVar11);\n    *(short *)(auStack_5026 + iVar11 + -2) = sVar2;\n    iVar11 = iVar11 + 2;\n  } while (sVar2 != 0);\n  pwVar10 = &local_5028;\n  do {\n    wVar3 = *pwVar10;\n    pwVar10 = pwVar10 + 1;\n  } while (wVar3 != L'\\0');\n  iVar11 = (int)pwVar10 - (int)auStack_5026 >> 1;\n  if (((&sStack_502a)[iVar11] != 0x2f) && ((&sStack_502a)[iVar11] != 0x5c)) {\n    psVar14 = &sStack_502a;\n    do {\n      psVar1 = psVar14 + 1;\n      psVar14 = psVar14 + 1;\n    } while (*psVar1 != 0);\n    iVar11 = iVar11 + 1;\n    *(undefined4 *)psVar14 = DAT_00422d9c;\n  }\n  psVar14 = &sStack_502a;\n  do {\n    psVar1 = psVar14 + 1;\n    psVar14 = psVar14 + 1;\n  } while (*psVar1 != 0);\n  *(undefined4 *)psVar14 = DAT_00422da0;\n  local_548c = (HANDLE)FUN_0040f325(&local_5028,local_5488);\n  if (local_548c != (HANDLE)0xffffffff) {\n    p_Var12 = local_5488;\n    puVar13 = auStack_56c8;\n    for (iVar7 = 0x8c; iVar7 != 0; iVar7 = iVar7 + -1) {\n      *puVar13 = *(undefined4 *)p_Var12;\n      p_Var12 = p_Var12 + 4;\n      puVar13 = puVar13 + 1;\n    }\n    FUN_00404770(&local_5028,iVar11);\n    iVar7 = FUN_0040f330((int)local_548c,local_5488);\n    while (iVar7 == 0) {\n      p_Var12 = local_5488;\n      puVar13 = local_5258;\n      for (iVar7 = 0x8c; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar13 = *(undefined4 *)p_Var12;\n        p_Var12 = p_Var12 + 4;\n        puVar13 = puVar13 + 1;\n      }\n      puVar8 = &DAT_00422d90;\n      puVar5 = local_5234;\n      do {\n        uVar4 = *puVar5;\n        bVar15 = uVar4 < *puVar8;\n        if (uVar4 != *puVar8) {\nLAB_004043e6:\n          uVar6 = -(uint)bVar15 | 1;\n          goto LAB_004043eb;\n        }\n        if (uVar4 == 0) break;\n        uVar4 = puVar5[1];\n        bVar15 = uVar4 < puVar8[1];\n        if (uVar4 != puVar8[1]) goto LAB_004043e6;\n        puVar5 = puVar5 + 2;\n        puVar8 = puVar8 + 2;\n      } while (uVar4 != 0);\n      uVar6 = 0;\nLAB_004043eb:\n      if (uVar6 != 0) {\n        puVar8 = &DAT_00422d94;\n        puVar5 = local_5234;\n        do {\n          uVar4 = *puVar5;\n          bVar15 = uVar4 < *puVar8;\n          if (uVar4 != *puVar8) {\nLAB_00404426:\n            uVar6 = -(uint)bVar15 | 1;\n            goto LAB_0040442b;\n          }\n          if (uVar4 == 0) break;\n          uVar4 = puVar5[1];\n          bVar15 = uVar4 < puVar8[1];\n          if (uVar4 != puVar8[1]) goto LAB_00404426;\n          puVar5 = puVar5 + 2;\n          puVar8 = puVar8 + 2;\n        } while (uVar4 != 0);\n        uVar6 = 0;\nLAB_0040442b:\n        if (uVar6 != 0) {\n          *(undefined2 *)(auStack_5026 + iVar11 * 2 + -2) = 0;\n          puVar5 = local_5234;\n          do {\n            uVar4 = *puVar5;\n            puVar5 = puVar5 + 1;\n          } while (uVar4 != 0);\n          uVar6 = (int)puVar5 - (int)local_5234;\n          psVar14 = &sStack_502a;\n          do {\n            psVar1 = psVar14 + 1;\n            psVar14 = psVar14 + 1;\n          } while (*psVar1 != 0);\n          puVar5 = local_5234;\n          for (uVar9 = uVar6 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {\n            *(undefined4 *)psVar14 = *(undefined4 *)puVar5;\n            puVar5 = puVar5 + 2;\n            psVar14 = psVar14 + 2;\n          }\n          for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n            *(char *)psVar14 = (char)*puVar5;\n            puVar5 = (ushort *)((int)puVar5 + 1);\n            psVar14 = (short *)((int)psVar14 + 1);\n          }\n          if (((byte)local_5488[0] & 0x10) == 0) {\n            iVar7 = FUN_0040fd68(&local_5028);\n            if (iVar7 != 0) {\n              Sleep(100);\n              FUN_0040fd68(&local_5028);\n            }\n          }\n          else {\n            FUN_00404f90(local_3020,&local_5028,0x1000,unaff_EDI);\n            uStack_54ac = 0x4044a8;\n            FUN_00404270(local_3020);\n          }\n        }\n      }\n      iVar7 = FUN_0040f330((int)local_548c,local_5488);\n    }\n    FUN_0040f2ff(local_548c);\n  }\n  FUN_0040f011(local_2018);\n  __security_check_cookie(local_c ^ (uint)&local_548c);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404520",
      "entry": "00404520",
      "c": "\nerrno_t __cdecl FUN_00404520(LPCSTR param_1,LPCSTR param_2)\n\n{\n  LPWSTR _Name;\n  LPWSTR _Value;\n  errno_t eVar1;\n  LPCSTR unaff_EDI;\n  LPCSTR pCVar2;\n  \n  pCVar2 = (LPCSTR)0x0;\n  _Name = FUN_00404f00((LPWSTR)0x0,param_1,0,unaff_EDI);\n  _Value = FUN_00404f00((LPWSTR)0x0,param_2,0,pCVar2);\n  eVar1 = FID_conflict___wputenv_s(_Name,_Value);\n  FID_conflict__free(_Name);\n  FID_conflict__free(_Value);\n  return eVar1;\n}\n\n"
    },
    {
      "name": "FUN_00404560",
      "entry": "00404560",
      "c": "\nBOOL __cdecl FUN_00404560(LPCSTR param_1)\n\n{\n  LPWSTR lpName;\n  BOOL BVar1;\n  LPCSTR unaff_EDI;\n  \n  lpName = FUN_00404f00((LPWSTR)0x0,param_1,0,unaff_EDI);\n  BVar1 = SetEnvironmentVariableW(lpName,(LPCWSTR)0x0);\n  FID_conflict__free(lpName);\n  return BVar1;\n}\n\n"
    },
    {
      "name": "FUN_00404590",
      "entry": "00404590",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00404590(LPCSTR param_1)\n\n{\n  FILE *pFVar1;\n  int iVar2;\n  LPWSTR lpCommandLine;\n  _SECURITY_ATTRIBUTES *lpProcessAttributes;\n  LPSECURITY_ATTRIBUTES lpThreadAttributes;\n  BOOL BVar3;\n  DWORD dwCreationFlags;\n  LPVOID lpEnvironment;\n  LPCWSTR lpCurrentDirectory;\n  _STARTUPINFOW *lpStartupInfo;\n  _PROCESS_INFORMATION *lpProcessInformation;\n  _SECURITY_ATTRIBUTES local_2064;\n  _PROCESS_INFORMATION _Stack_2058;\n  _STARTUPINFOW local_2048;\n  WCHAR local_2004 [4096];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)&stack0xffffdf98;\n  FUN_00404f00(local_2004,param_1,0x1000,(LPCSTR)0x0);\n  _signal(0x16);\n  _signal(2);\n  _signal(0xf);\n  _signal(0x15);\n  FUN_004018c0(\"LOADER: Setting up to run child\\n\");\n  local_2064.nLength = 0xc;\n  local_2064.lpSecurityDescriptor = (LPVOID)0x0;\n  local_2064.bInheritHandle = 1;\n  GetStartupInfoW(&local_2048);\n  local_2048.lpReserved = (LPWSTR)0x0;\n  local_2048.lpDesktop = (LPWSTR)0x0;\n  local_2048.lpTitle = (LPWSTR)0x0;\n  local_2048.dwFlags = 0x101;\n  local_2048.wShowWindow = 1;\n  pFVar1 = (FILE *)___acrt_iob_func(0);\n  iVar2 = __fileno(pFVar1);\n  local_2048.hStdInput = (HANDLE)__get_osfhandle(iVar2);\n  pFVar1 = (FILE *)___acrt_iob_func(1);\n  iVar2 = __fileno(pFVar1);\n  local_2048.hStdOutput = (HANDLE)__get_osfhandle(iVar2);\n  pFVar1 = (FILE *)___acrt_iob_func(2);\n  iVar2 = __fileno(pFVar1);\n  local_2048.hStdError = (HANDLE)__get_osfhandle(iVar2);\n  FUN_004018c0(\"LOADER: Creating child process\\n\");\n  lpProcessInformation = &_Stack_2058;\n  lpStartupInfo = &local_2048;\n  lpCurrentDirectory = (LPCWSTR)0x0;\n  lpEnvironment = (LPVOID)0x0;\n  dwCreationFlags = 0;\n  BVar3 = 1;\n  lpThreadAttributes = (LPSECURITY_ATTRIBUTES)0x0;\n  lpProcessAttributes = &local_2064;\n  lpCommandLine = GetCommandLineW();\n  BVar3 = CreateProcessW(local_2004,lpCommandLine,lpProcessAttributes,lpThreadAttributes,BVar3,\n                         dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,\n                         lpProcessInformation);\n  if (BVar3 != 0) {\n    FUN_004018c0(\"LOADER: Waiting for child process to finish...\\n\");\n    WaitForSingleObject(_Stack_2058.hProcess,0xffffffff);\n    GetExitCodeProcess(_Stack_2058.hProcess,(LPDWORD)&stack0xffffdf98);\n    __security_check_cookie(local_4 ^ (uint)&stack0xffffdf98);\n    return;\n  }\n  FUN_004018f0(\"CreateProcessW\",\"Error creating child process!\\n\");\n  __security_check_cookie(local_4 ^ (uint)&stack0xffffdf98);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404740",
      "entry": "00404740",
      "c": "\nHMODULE __cdecl FUN_00404740(LPCSTR param_1)\n\n{\n  LPWSTR lpLibFileName;\n  HMODULE pHVar1;\n  LPCSTR unaff_EDI;\n  \n  lpLibFileName = FUN_00404f00((LPWSTR)0x0,param_1,0,unaff_EDI);\n  pHVar1 = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,8);\n  FID_conflict__free(lpLibFileName);\n  return pHVar1;\n}\n\n"
    },
    {
      "name": "FUN_00404770",
      "entry": "00404770",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00404770(LPCWSTR param_1,int param_2)\n\n{\n  LPCWSTR pWVar1;\n  ushort uVar2;\n  uint uVar3;\n  ushort *puVar4;\n  int iVar5;\n  ushort *puVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  LPCWSTR unaff_EDI;\n  byte *pbVar9;\n  LPCWSTR pWVar10;\n  bool bVar11;\n  byte local_1238 [36];\n  ushort local_1214 [262];\n  CHAR local_1008 [4100];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)local_1238;\n  puVar4 = local_1214;\n  puVar8 = (undefined4 *)&stack0x0000000c;\n  pbVar9 = local_1238;\n  for (iVar5 = 0x8c; iVar5 != 0; iVar5 = iVar5 + -1) {\n    *(undefined4 *)pbVar9 = *puVar8;\n    puVar8 = puVar8 + 1;\n    pbVar9 = (byte *)((int)pbVar9 + 4);\n  }\n  puVar6 = &DAT_00422d90;\n  do {\n    uVar2 = *puVar4;\n    bVar11 = uVar2 < *puVar6;\n    if (uVar2 != *puVar6) {\nLAB_004047db:\n      uVar3 = -(uint)bVar11 | 1;\n      goto LAB_004047e0;\n    }\n    if (uVar2 == 0) break;\n    uVar2 = puVar4[1];\n    bVar11 = uVar2 < puVar6[1];\n    if (uVar2 != puVar6[1]) goto LAB_004047db;\n    puVar4 = puVar4 + 2;\n    puVar6 = puVar6 + 2;\n  } while (uVar2 != 0);\n  uVar3 = 0;\nLAB_004047e0:\n  if (uVar3 != 0) {\n    puVar6 = &DAT_00422d94;\n    puVar4 = local_1214;\n    do {\n      uVar2 = *puVar4;\n      bVar11 = uVar2 < *puVar6;\n      if (uVar2 != *puVar6) {\nLAB_00404817:\n        uVar3 = -(uint)bVar11 | 1;\n        goto LAB_0040481c;\n      }\n      if (uVar2 == 0) break;\n      uVar2 = puVar4[1];\n      bVar11 = uVar2 < puVar6[1];\n      if (uVar2 != puVar6[1]) goto LAB_00404817;\n      puVar4 = puVar4 + 2;\n      puVar6 = puVar6 + 2;\n    } while (uVar2 != 0);\n    uVar3 = 0;\nLAB_0040481c:\n    if (uVar3 != 0) {\n      param_1[param_2] = L'\\0';\n      puVar4 = local_1214;\n      do {\n        uVar2 = *puVar4;\n        puVar4 = puVar4 + 1;\n      } while (uVar2 != 0);\n      uVar3 = (int)puVar4 - (int)local_1214;\n      pWVar10 = param_1 + -1;\n      do {\n        pWVar1 = pWVar10 + 1;\n        pWVar10 = pWVar10 + 1;\n      } while (*pWVar1 != L'\\0');\n      puVar4 = local_1214;\n      for (uVar7 = uVar3 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *(undefined4 *)pWVar10 = *(undefined4 *)puVar4;\n        puVar4 = puVar4 + 2;\n        pWVar10 = pWVar10 + 2;\n      }\n      for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *(char *)pWVar10 = (char)*puVar4;\n        puVar4 = (ushort *)((int)puVar4 + 1);\n        pWVar10 = (LPCWSTR)((int)pWVar10 + 1);\n      }\n      if ((local_1238[0] & 0x10) == 0) {\n        iVar5 = FUN_0040fd68(param_1);\n        if (iVar5 != 0) {\n          Sleep(100);\n          FUN_0040fd68(param_1);\n        }\n      }\n      else {\n        FUN_00404f90(local_1008,param_1,0x1000,unaff_EDI);\n        FUN_00404270(local_1008);\n      }\n    }\n  }\n  __security_check_cookie(local_4 ^ (uint)local_1238);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004048c0",
      "entry": "004048c0",
      "c": "\nint __cdecl FUN_004048c0(wchar_t *param_1,uint param_2,wchar_t *param_3)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  __crt_locale_pointers *p_Var3;\n  char *pcVar4;\n  \n  pcVar4 = &stack0x00000010;\n  p_Var3 = (__crt_locale_pointers *)0x0;\n  puVar1 = (undefined4 *)FUN_00401840();\n  iVar2 = ___stdio_common_vswprintf(*puVar1,puVar1[1],param_1,param_2,param_3,p_Var3,pcVar4);\n  if (iVar2 < 0) {\n    iVar2 = -1;\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "FUN_004048f0",
      "entry": "004048f0",
      "c": "\nundefined4 __cdecl FUN_004048f0(LPCSTR param_1)\n\n{\n  int iVar1;\n  HMODULE hModule;\n  FARPROC pFVar2;\n  FARPROC pFVar3;\n  LPWSTR lpWideCharStr;\n  char *unaff_ESI;\n  undefined4 uStack_18;\n  undefined4 uStack_14;\n  LPWSTR pWStack_10;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  FUN_004018c0(\"LOADER: manifestpath: %s\\n\");\n  iVar1 = MultiByteToWideChar(0xfde9,0,param_1,-1,(LPWSTR)0x0,0);\n  if (iVar1 != 0) {\n    lpWideCharStr = (LPWSTR)FUN_0040e228(iVar1 + 1,2);\n    iVar1 = MultiByteToWideChar(0xfde9,0,param_1,-1,lpWideCharStr,iVar1);\n    if (iVar1 != 0) goto LAB_00404962;\n    unaff_ESI = \"Failed to decode wchar_t from UTF-8\\n\";\n  }\n  FUN_004018f0(\"MultiByteToWideChar\",unaff_ESI);\n  lpWideCharStr = (LPWSTR)0x0;\nLAB_00404962:\n  hModule = LoadLibraryA(\"kernel32\");\n  pFVar2 = GetProcAddress(hModule,\"CreateActCtxW\");\n  pFVar3 = GetProcAddress(hModule,\"ActivateActCtx\");\n  if ((pFVar2 != (FARPROC)0x0) && (pFVar3 != (FARPROC)0x0)) {\n    uStack_c = 0;\n    uStack_8 = 0;\n    uStack_4 = 0;\n    uStack_18 = 0x20;\n    uStack_14 = 0x10;\n    pWStack_10 = lpWideCharStr;\n    DAT_0042d000 = (*pFVar2)(&uStack_18);\n    FID_conflict__free(lpWideCharStr);\n    if (DAT_0042d000 != -1) {\n      FUN_004018c0(\"LOADER: Activation context created\\n\");\n      iVar1 = (*pFVar3)(DAT_0042d000,&DAT_00439a60);\n      if (iVar1 != 0) {\n        FUN_004018c0(\"LOADER: Activation context activated\\n\");\n        return 1;\n      }\n    }\n    DAT_0042d000 = -1;\n    FUN_00404a50(0);\n    FUN_004018c0(\"LOADER: Error activating the context: ActivateActCtx: \\n%s\\n\");\n    return 0;\n  }\n  FUN_004018c0(\"LOADER: Cannot find CreateActCtx/ActivateActCtx exports in kernel32.dll\\n\");\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_00404a50",
      "entry": "00404a50",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nvoid __cdecl FUN_00404a50(DWORD param_1)\n\n{\n  uint uVar1;\n  DWORD DVar2;\n  LPCWSTR in_stack_ffffdffc;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xffffdffc;\n  if (param_1 == 0) {\n    param_1 = GetLastError();\n  }\n  DVar2 = FormatMessageW(0x1000,(LPCVOID)0x0,param_1,0x400,(LPWSTR)&stack0xffffdffc,0x1000,\n                         (va_list *)0x0);\n  if (DVar2 == 0) {\n    FUN_004018f0(\"FormatMessageW\",\"No error messages generated.\\n\");\n    __security_check_cookie(uVar1 ^ (uint)&stack0xffffdffc);\n    return;\n  }\n  FUN_00404f90(&DAT_00439a68,(LPCWSTR)&stack0xffffdffc,0x1000,in_stack_ffffdffc);\n  __security_check_cookie(uVar1 ^ (uint)&stack0xffffdffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404b10",
      "entry": "00404b10",
      "c": "\nvoid __cdecl FUN_00404b10(LPCSTR param_1,undefined4 param_2)\n\n{\n  int unaff_retaddr;\n  \n  FUN_00404b30(param_1,param_2,(LPCSTR)0x0,unaff_retaddr,(int)param_1);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404b30",
      "entry": "00404b30",
      "c": "\nundefined4 * __cdecl\nFUN_00404b30(LPCSTR param_1,undefined4 param_2,LPCSTR param_3,int param_4,int param_5)\n\n{\n  undefined4 *_Memory;\n  LPCWSTR cchWideChar;\n  LPCWSTR lpWideCharStr;\n  int iVar1;\n  LPSTR pCVar2;\n  undefined4 *puVar3;\n  int iVar4;\n  char *pcVar5;\n  LPCWSTR pWVar6;\n  \n  _Memory = (undefined4 *)FUN_0040e228((uint)(param_1 + 1),4);\n  iVar4 = 0;\n  if (0 < (int)param_1) {\n    puVar3 = _Memory;\n    do {\n      cchWideChar = (LPCWSTR)MultiByteToWideChar(0xfde9,0,*(LPCSTR *)\n                                                           ((param_4 - (int)_Memory) + (int)puVar3),\n                                                 -1,(LPWSTR)0x0,0);\n      if (cchWideChar == (LPCWSTR)0x0) {\n        pcVar5 = \"Failed to get wchar_t buffer size.\\n\";\nLAB_00404bfa:\n        FUN_004018f0(\"MultiByteToWideChar\",pcVar5);\nLAB_00404c07:\n        *puVar3 = 0;\n        iVar1 = 0;\n        if (-1 < iVar4) {\n          do {\n            FID_conflict__free((void *)_Memory[iVar1]);\n            iVar1 = iVar1 + 1;\n          } while (iVar1 <= iVar4);\n        }\n        FID_conflict__free(_Memory);\n        return (undefined4 *)0x0;\n      }\n      lpWideCharStr = (LPCWSTR)FUN_0040e228((int)cchWideChar + 1,2);\n      pWVar6 = lpWideCharStr;\n      iVar1 = MultiByteToWideChar(0xfde9,0,param_3,-1,lpWideCharStr,(int)cchWideChar);\n      if (iVar1 == 0) {\n        pcVar5 = \"Failed to decode wchar_t from UTF-8\\n\";\n        goto LAB_00404bfa;\n      }\n      if (lpWideCharStr == (LPCWSTR)0x0) goto LAB_00404c07;\n      if (param_5 == 0) {\n        pCVar2 = FUN_00405120(lpWideCharStr,pWVar6,cchWideChar);\n      }\n      else {\n        pCVar2 = FUN_004051a0(lpWideCharStr);\n      }\n      FID_conflict__free(lpWideCharStr);\n      if (pCVar2 == (LPSTR)0x0) goto LAB_00404c07;\n      iVar4 = iVar4 + 1;\n      *puVar3 = pCVar2;\n      puVar3 = puVar3 + 1;\n      param_1 = param_3;\n    } while (iVar4 < (int)param_3);\n  }\n  _Memory[(int)param_1] = 0;\n  return _Memory;\n}\n\n"
    },
    {
      "name": "FUN_00404c50",
      "entry": "00404c50",
      "c": "\nundefined4 * __cdecl FUN_00404c50(LPCWSTR param_1,int param_2,LPCWSTR param_3,int param_4)\n\n{\n  undefined4 *_Memory;\n  int iVar1;\n  LPSTR lpMultiByteStr;\n  undefined4 *puVar2;\n  int iVar3;\n  char *pcVar4;\n  \n  _Memory = (undefined4 *)FUN_0040e228((int)param_1 + 1,4);\n  iVar3 = 0;\n  if (0 < (int)param_1) {\n    puVar2 = _Memory;\n    do {\n      iVar1 = WideCharToMultiByte(0xfde9,0,*(LPCWSTR *)((param_4 - (int)_Memory) + (int)puVar2),-1,\n                                  (LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);\n      if (iVar1 == 0) {\n        pcVar4 = \"Failed to get UTF-8 buffer size.\\n\";\nLAB_00404cfc:\n        FUN_004018f0(\"WideCharToMultiByte\",pcVar4);\n        *puVar2 = 0;\nLAB_00404d0f:\n        iVar1 = 0;\n        if (-1 < iVar3) {\n          do {\n            FID_conflict__free((void *)_Memory[iVar1]);\n            iVar1 = iVar1 + 1;\n          } while (iVar1 <= iVar3);\n        }\n        FID_conflict__free(_Memory);\n        return (undefined4 *)0x0;\n      }\n      lpMultiByteStr = (LPSTR)FUN_0040e228(iVar1 + 1,1);\n      iVar1 = WideCharToMultiByte(0xfde9,0,param_3,-1,lpMultiByteStr,param_2,(LPCSTR)0x0,(LPBOOL)0x0\n                                 );\n      if (iVar1 == 0) {\n        pcVar4 = \"Failed to encode wchar_t as UTF-8.\\n\";\n        goto LAB_00404cfc;\n      }\n      *puVar2 = lpMultiByteStr;\n      if (lpMultiByteStr == (LPSTR)0x0) goto LAB_00404d0f;\n      iVar3 = iVar3 + 1;\n      puVar2 = puVar2 + 1;\n      param_1 = param_3;\n    } while (iVar3 < (int)param_3);\n  }\n  _Memory[(int)param_1] = 0;\n  return _Memory;\n}\n\n"
    },
    {
      "name": "FUN_00404d50",
      "entry": "00404d50",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid __cdecl FUN_00404d50(LPCWSTR param_1)\n\n{\n  int iVar1;\n  _SECURITY_ATTRIBUTES _Stack_48;\n  undefined4 local_38;\n  undefined1 local_34 [4];\n  undefined4 local_30;\n  undefined4 local_2c;\n  undefined4 uStack_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 local_1c;\n  undefined4 uStack_18;\n  uint uStack_14;\n  undefined4 uStack_10;\n  undefined8 local_c;\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)&local_38;\n  _Stack_48.lpSecurityDescriptor = local_34;\n  local_2c = _DAT_0042316c;\n  uStack_28 = _UNK_00423170;\n  uStack_24 = _UNK_00423174;\n  uStack_20 = _UNK_00423178;\n  _Stack_48.bInheritHandle = 0;\n  _Stack_48.nLength = 1;\n  local_1c = _DAT_0042317c;\n  uStack_18 = _UNK_00423180;\n  uStack_14 = _UNK_00423184;\n  uStack_10 = _UNK_00423188;\n  local_38 = 0xc;\n  local_c = DAT_0042318c;\n  local_30 = 0;\n  iVar1 = ConvertStringSecurityDescriptorToSecurityDescriptorW(&local_2c);\n  if (iVar1 == 0) {\n    __security_check_cookie(uStack_14 ^ (uint)&_Stack_48);\n    return;\n  }\n  CreateDirectoryW(param_1,&_Stack_48);\n  __security_check_cookie(uStack_14 ^ (uint)&_Stack_48);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404df0",
      "entry": "00404df0",
      "c": "\nvoid __cdecl FUN_00404df0(LPCWSTR param_1,LPCSTR param_2,char *param_3)\n\n{\n  size_t unaff_retaddr;\n  \n  FUN_00404e10(param_1,param_2,param_3,(LPCSTR)0x0,unaff_retaddr,(int)param_1);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404e10",
      "entry": "00404e10",
      "c": "\nchar * __cdecl\nFUN_00404e10(LPCWSTR param_1,LPCSTR param_2,char *param_3,LPCSTR param_4,size_t param_5,int param_6)\n\n{\n  int iVar1;\n  LPCWSTR lpWideCharStr;\n  char *_Source;\n  undefined4 unaff_retaddr;\n  \n  iVar1 = MultiByteToWideChar(0xfde9,0,param_2,-1,(LPWSTR)0x0,0);\n  if (iVar1 == 0) {\n    FUN_004018f0(\"MultiByteToWideChar\",\"Failed to get wchar_t buffer size.\\n\");\n    return (char *)0x0;\n  }\n  lpWideCharStr = (LPCWSTR)FUN_0040e228(iVar1 + 1,2);\n  iVar1 = MultiByteToWideChar(0xfde9,0,param_4,-1,lpWideCharStr,iVar1);\n  if (iVar1 == 0) {\n    FUN_004018f0(\"MultiByteToWideChar\",\"Failed to decode wchar_t from UTF-8\\n\");\n    return (char *)0x0;\n  }\n  if (lpWideCharStr != (LPCWSTR)0x0) {\n    if (param_6 == 0) {\n      _Source = FUN_00405120(lpWideCharStr,unaff_retaddr,param_1);\n    }\n    else {\n      _Source = FUN_004051a0(lpWideCharStr);\n    }\n    FID_conflict__free(lpWideCharStr);\n    if (_Source != (char *)0x0) {\n      if (param_3 != (char *)0x0) {\n        _strncpy(param_3,_Source,param_5);\n        FID_conflict__free(_Source);\n        return param_3;\n      }\n      return _Source;\n    }\n  }\n  return (char *)0x0;\n}\n\n"
    },
    {
      "name": "FUN_00404ee0",
      "entry": "00404ee0",
      "c": "\nvoid __cdecl FUN_00404ee0(LPCWSTR param_1,LPCSTR param_2,char *param_3)\n\n{\n  size_t unaff_retaddr;\n  \n  FUN_00404e10(param_1,param_2,param_3,(LPCSTR)0x1,unaff_retaddr,(int)param_1);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00404f00",
      "entry": "00404f00",
      "c": "\nLPWSTR __cdecl FUN_00404f00(LPWSTR param_1,LPCSTR param_2,int param_3,LPCSTR param_4)\n\n{\n  int iVar1;\n  \n  if (param_1 == (LPWSTR)0x0) {\n    param_3 = MultiByteToWideChar(0xfde9,0,param_2,-1,(LPWSTR)0x0,0);\n    if (param_3 == 0) {\n      FUN_004018f0(\"MultiByteToWideChar\",\"Failed to get wchar_t buffer size.\\n\");\n      return (LPWSTR)0x0;\n    }\n    param_1 = (LPWSTR)FUN_0040e228(param_3 + 1,2);\n  }\n  iVar1 = MultiByteToWideChar(0xfde9,0,param_4,-1,param_1,param_3);\n  if (iVar1 != 0) {\n    return param_1;\n  }\n  FUN_004018f0(\"MultiByteToWideChar\",\"Failed to decode wchar_t from UTF-8\\n\");\n  return (LPWSTR)0x0;\n}\n\n"
    },
    {
      "name": "FUN_00404f90",
      "entry": "00404f90",
      "c": "\nLPSTR __cdecl FUN_00404f90(LPSTR param_1,LPCWSTR param_2,int param_3,LPCWSTR param_4)\n\n{\n  int iVar1;\n  \n  if (param_1 == (LPSTR)0x0) {\n    param_3 = WideCharToMultiByte(0xfde9,0,param_2,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);\n    if (param_3 == 0) {\n      FUN_004018f0(\"WideCharToMultiByte\",\"Failed to get UTF-8 buffer size.\\n\");\n      return (LPSTR)0x0;\n    }\n    param_1 = (LPSTR)FUN_0040e228(param_3 + 1,1);\n  }\n  iVar1 = WideCharToMultiByte(0xfde9,0,param_4,-1,param_1,param_3,(LPCSTR)0x0,(LPBOOL)0x0);\n  if (iVar1 != 0) {\n    return param_1;\n  }\n  FUN_004018f0(\"WideCharToMultiByte\",\"Failed to encode wchar_t as UTF-8.\\n\");\n  return (LPSTR)0x0;\n}\n\n"
    },
    {
      "name": "FUN_00405020",
      "entry": "00405020",
      "c": "\nundefined4 * __cdecl FUN_00405020(LPCSTR param_1,int param_2,LPCSTR param_3,int param_4)\n\n{\n  undefined4 *_Memory;\n  int iVar1;\n  LPWSTR lpWideCharStr;\n  undefined4 *puVar2;\n  int iVar3;\n  char *pcVar4;\n  \n  _Memory = (undefined4 *)FUN_0040e228((uint)(param_1 + 1),4);\n  iVar3 = 0;\n  if (0 < (int)param_1) {\n    puVar2 = _Memory;\n    do {\n      iVar1 = MultiByteToWideChar(0xfde9,0,*(LPCSTR *)((param_4 - (int)_Memory) + (int)puVar2),-1,\n                                  (LPWSTR)0x0,0);\n      if (iVar1 == 0) {\n        pcVar4 = \"Failed to get wchar_t buffer size.\\n\";\nLAB_004050c4:\n        FUN_004018f0(\"MultiByteToWideChar\",pcVar4);\n        *puVar2 = 0;\nLAB_004050d7:\n        iVar1 = 0;\n        if (-1 < iVar3) {\n          do {\n            FID_conflict__free((void *)_Memory[iVar1]);\n            iVar1 = iVar1 + 1;\n          } while (iVar1 <= iVar3);\n        }\n        FID_conflict__free(_Memory);\n        return (undefined4 *)0x0;\n      }\n      lpWideCharStr = (LPWSTR)FUN_0040e228(iVar1 + 1,2);\n      iVar1 = MultiByteToWideChar(0xfde9,0,param_3,-1,lpWideCharStr,param_2);\n      if (iVar1 == 0) {\n        pcVar4 = \"Failed to decode wchar_t from UTF-8\\n\";\n        goto LAB_004050c4;\n      }\n      *puVar2 = lpWideCharStr;\n      if (lpWideCharStr == (LPWSTR)0x0) goto LAB_004050d7;\n      iVar3 = iVar3 + 1;\n      puVar2 = puVar2 + 1;\n      param_1 = param_3;\n    } while (iVar3 < (int)param_3);\n  }\n  _Memory[(int)param_1] = 0;\n  return _Memory;\n}\n\n"
    },
    {
      "name": "FUN_00405120",
      "entry": "00405120",
      "c": "\nLPSTR __cdecl FUN_00405120(LPCWSTR param_1,undefined4 param_2,LPCWSTR param_3)\n\n{\n  int iVar1;\n  LPSTR lpMultiByteStr;\n  \n  iVar1 = WideCharToMultiByte(0,0,param_1,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);\n  if (iVar1 == 0) {\n    FUN_004018f0(\"WideCharToMultiByte\",\"Failed to get ANSI buffer size.\\n\");\n    return (LPSTR)0x0;\n  }\n  lpMultiByteStr = (LPSTR)FUN_0040e228(iVar1 + 1,1);\n  iVar1 = WideCharToMultiByte(0,0,param_3,-1,lpMultiByteStr,iVar1,(LPCSTR)0x0,(LPBOOL)0x0);\n  if (iVar1 == 0) {\n    FUN_004018f0(\"WideCharToMultiByte\",\"Failed to encode filename as ANSI.\\n\");\n    return (LPSTR)0x0;\n  }\n  return lpMultiByteStr;\n}\n\n"
    },
    {
      "name": "FUN_004051a0",
      "entry": "004051a0",
      "c": "\nLPSTR __cdecl FUN_004051a0(LPCWSTR param_1)\n\n{\n  LPCWSTR pWVar1;\n  LPCWSTR lpszShortPath;\n  DWORD DVar2;\n  LPSTR pCVar3;\n  char *pcVar4;\n  LPCWSTR pWVar5;\n  \n  pCVar3 = (LPSTR)0x0;\n  pWVar1 = (LPCWSTR)GetShortPathNameW(param_1,(LPWSTR)0x0,0);\n  if (pWVar1 != (LPCWSTR)0x0) {\n    lpszShortPath = (LPCWSTR)FUN_0040e228((int)pWVar1 + 1,2);\n    pWVar5 = lpszShortPath;\n    DVar2 = GetShortPathNameW(param_1,lpszShortPath,(DWORD)pWVar1);\n    if (DVar2 != 0) {\n      pCVar3 = FUN_00405120(lpszShortPath,pWVar5,pWVar1);\n    }\n    FID_conflict__free(lpszShortPath);\n    if (pCVar3 != (LPSTR)0x0) {\n      return pCVar3;\n    }\n  }\n  pWVar1 = (LPCWSTR)FUN_00404a50(0);\n  pcVar4 = \"Failed to get short path name for filename. GetShortPathNameW: \\n%s\\n\";\n  FUN_004018c0(\"Failed to get short path name for filename. GetShortPathNameW: \\n%s\\n\");\n  pCVar3 = FUN_00405120(param_1,pcVar4,pWVar1);\n  return pCVar3;\n}\n\n"
    },
    {
      "name": "FUN_00405220",
      "entry": "00405220",
      "c": "\nint __cdecl FUN_00405220(int *param_1,int param_2)\n\n{\n  byte *pbVar1;\n  char cVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint *puVar7;\n  uint *puVar8;\n  uint uVar9;\n  int iVar10;\n  byte bVar11;\n  ushort uVar12;\n  uint uVar13;\n  uint uVar14;\n  int iVar15;\n  int *piVar16;\n  uint local_34;\n  uint *local_30;\n  undefined2 local_2c;\n  undefined1 local_2a;\n  undefined1 local_29;\n  uint local_28;\n  uint *local_24;\n  int *local_20;\n  uint local_1c;\n  int local_18;\n  uint local_14;\n  uint local_10;\n  uint local_c;\n  int *local_8;\n  uint local_4;\n  \n  if ((((((param_1 == (int *)0x0) || (param_1[8] == 0)) || (param_1[9] == 0)) ||\n       ((piVar16 = (int *)param_1[7], piVar16 == (int *)0x0 || ((int *)*piVar16 != param_1)))) ||\n      (iVar4 = piVar16[1], iVar4 < 0x3f34)) ||\n     (((0x3f53 < iVar4 || (param_1[3] == 0)) || ((*param_1 == 0 && (param_1[1] != 0)))))) {\n    return -2;\n  }\n  if (iVar4 == 0x3f3f) {\n    piVar16[1] = 0x3f40;\n  }\n  local_24 = (uint *)param_1[3];\n  uVar14 = piVar16[0xf];\n  local_28 = param_1[4];\n  puVar8 = (uint *)*param_1;\n  local_18 = 0;\n  uVar13 = param_1[1];\n  uVar3 = piVar16[1] - 0x3f34;\n  uVar9 = piVar16[0x10];\n  if (uVar3 < 0x1f) {\n    local_8 = piVar16 + 0x16;\n    local_34 = uVar14;\n    local_30 = puVar8;\n    local_20 = piVar16;\n    local_1c = local_28;\n    local_c = uVar13;\n    do {\n      uVar6 = uVar9;\n      switch((&switchD_004052f0::switchdataD_00406920)[uVar3]) {\n      case (undefined *)0x4052f7:\n        uVar3 = piVar16[3];\n        if (uVar3 == 0) {\n          piVar16[1] = 0x3f40;\n        }\n        else {\n          if (uVar9 < 0x10) {\n            do {\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar3 = *puVar8;\n              puVar8 = (uint *)((int)puVar8 + 1);\n              uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n              uVar9 = uVar9 + 8;\n              uVar13 = uVar13 - 1;\n              local_34 = uVar14;\n              local_30 = puVar8;\n            } while (uVar9 < 0x10);\n            uVar3 = piVar16[3];\n          }\n          if (((uVar3 & 2) == 0) || (uVar14 != 0x8b1f)) {\n            piVar16[5] = 0;\n            if (piVar16[9] != 0) {\n              *(undefined4 *)(piVar16[9] + 0x30) = 0xffffffff;\n            }\n            uVar3 = uVar14;\n            if (((*(byte *)(piVar16 + 3) & 1) == 0) ||\n               (uVar3 = local_34, ((uVar14 >> 8) + (uVar14 & 0xff) * 0x100) % 0x1f != 0)) {\n              param_1[6] = (int)\"incorrect header check\";\n              piVar16[1] = 0x3f51;\n              uVar14 = uVar3;\n            }\n            else if (((byte)local_34 & 0xf) == 8) {\n              uVar14 = local_34 >> 4;\n              uVar9 = uVar9 - 4;\n              uVar3 = (uVar14 & 0xf) + 8;\n              if (piVar16[10] == 0) {\n                piVar16[10] = uVar3;\n              }\n              if ((uVar3 < 0x10) && (uVar3 <= (uint)piVar16[10])) {\n                piVar16[6] = 1 << (sbyte)uVar3;\n                uVar14 = thunk_FUN_00406df0(0,(byte *)0x0,0);\n                piVar16[7] = uVar14;\n                param_1[0xc] = uVar14;\n                piVar16[1] = ~(local_34 >> 0xc) & 2 | 0x3f3d;\n                local_34 = 0;\n                uVar9 = 0;\n                uVar14 = 0;\n              }\n              else {\n                param_1[6] = (int)\"invalid window size\";\n                piVar16[1] = 0x3f51;\n                local_34 = uVar14;\n              }\n            }\n            else {\n              param_1[6] = (int)\"unknown compression method\";\n              piVar16[1] = 0x3f51;\n              uVar14 = local_34;\n            }\n          }\n          else {\n            if (piVar16[10] == 0) {\n              piVar16[10] = 0xf;\n            }\n            puVar7 = FUN_00407060(0,(uint *)0x0,0);\n            piVar16[7] = (int)puVar7;\n            local_2c = 0x8b1f;\n            puVar7 = FUN_00407060(piVar16[7],(uint *)&local_2c,2);\n            piVar16[7] = (int)puVar7;\n            local_34 = 0;\n            uVar9 = 0;\n            piVar16[1] = 0x3f35;\n            uVar14 = 0;\n          }\n        }\n        break;\n      case (undefined *)0x405488:\n        for (; uVar9 < 0x10; uVar9 = uVar9 + 8) {\n          if (uVar13 == 0) goto LAB_00405805;\n          uVar3 = *puVar8;\n          puVar8 = (uint *)((int)puVar8 + 1);\n          uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n          uVar13 = uVar13 - 1;\n          local_34 = uVar14;\n          local_30 = puVar8;\n        }\n        piVar16[5] = uVar14;\n        if ((char)uVar14 == '\\b') {\n          if ((uVar14 & 0xe000) == 0) {\n            if ((uint *)piVar16[9] != (uint *)0x0) {\n              *(uint *)piVar16[9] = uVar14 >> 8 & 1;\n            }\n            if (((piVar16[5] & 0x200U) != 0) && ((*(byte *)(piVar16 + 3) & 4) != 0)) {\n              local_2c = (undefined2)uVar14;\n              puVar7 = FUN_00407060(piVar16[7],(uint *)&local_2c,2);\n              piVar16[7] = (int)puVar7;\n            }\n            uVar14 = 0;\n            piVar16[1] = 0x3f36;\n            local_34 = 0;\n            uVar9 = 0;\n            do {\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar3 = *puVar8;\n              puVar8 = (uint *)((int)puVar8 + 1);\n              uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n              uVar9 = uVar9 + 8;\n              uVar13 = uVar13 - 1;\n              local_34 = uVar14;\n              local_30 = puVar8;\njoined_r0x00405541:\n            } while (uVar9 < 0x20);\n            if (piVar16[9] != 0) {\n              *(uint *)(piVar16[9] + 4) = uVar14;\n            }\n            if (((piVar16[5] & 0x200U) != 0) && ((*(byte *)(piVar16 + 3) & 4) != 0)) {\n              local_2c = (undefined2)uVar14;\n              local_2a = (undefined1)(uVar14 >> 0x10);\n              local_29 = (undefined1)(uVar14 >> 0x18);\n              puVar7 = FUN_00407060(piVar16[7],(uint *)&local_2c,4);\n              piVar16[7] = (int)puVar7;\n            }\n            uVar14 = 0;\n            piVar16[1] = 0x3f37;\n            local_34 = 0;\n            uVar9 = 0;\n            do {\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar3 = *puVar8;\n              puVar8 = (uint *)((int)puVar8 + 1);\n              uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n              uVar9 = uVar9 + 8;\n              uVar13 = uVar13 - 1;\n              local_34 = uVar14;\n              local_30 = puVar8;\njoined_r0x004055c5:\n            } while (uVar9 < 0x10);\n            if (piVar16[9] != 0) {\n              *(uint *)(piVar16[9] + 8) = uVar14 & 0xff;\n              *(uint *)(piVar16[9] + 0xc) = uVar14 >> 8;\n            }\n            if (((piVar16[5] & 0x200U) != 0) && ((*(byte *)(piVar16 + 3) & 4) != 0)) {\n              local_2c = (undefined2)uVar14;\n              puVar7 = FUN_00407060(piVar16[7],(uint *)&local_2c,2);\n              piVar16[7] = (int)puVar7;\n            }\n            uVar14 = 0;\n            piVar16[1] = 0x3f38;\n            local_34 = 0;\n            uVar9 = 0;\n            goto switchD_004052f0_caseD_405640;\n          }\n          param_1[6] = (int)\"unknown header flags set\";\n          piVar16[1] = 0x3f51;\n        }\n        else {\n          param_1[6] = (int)\"unknown compression method\";\n          piVar16[1] = 0x3f51;\n        }\n        break;\n      case (undefined *)0x40553e:\n        goto joined_r0x00405541;\n      case (undefined *)0x4055c2:\n        goto joined_r0x004055c5;\n      case (undefined *)0x405640:\nswitchD_004052f0_caseD_405640:\n        if ((piVar16[5] & 0x400U) == 0) {\n          if (piVar16[9] != 0) {\n            *(undefined4 *)(piVar16[9] + 0x10) = 0;\n          }\n        }\n        else {\n          for (; uVar9 < 0x10; uVar9 = uVar9 + 8) {\n            if (uVar13 == 0) goto LAB_00405805;\n            uVar3 = *puVar8;\n            puVar8 = (uint *)((int)puVar8 + 1);\n            uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n            uVar13 = uVar13 - 1;\n            local_34 = uVar14;\n            local_30 = puVar8;\n          }\n          piVar16[0x11] = uVar14;\n          if (piVar16[9] != 0) {\n            *(uint *)(piVar16[9] + 0x14) = uVar14;\n          }\n          if (((piVar16[5] & 0x200U) != 0) && ((*(byte *)(piVar16 + 3) & 4) != 0)) {\n            local_2c = (undefined2)uVar14;\n            puVar7 = FUN_00407060(piVar16[7],(uint *)&local_2c,2);\n            piVar16[7] = (int)puVar7;\n          }\n          uVar9 = 0;\n          local_34 = 0;\n        }\n        piVar16[1] = 0x3f39;\n      case (undefined *)0x4056ce:\n        if ((piVar16[5] & 0x400U) == 0) {\nLAB_00405765:\n          piVar16[0x11] = 0;\n          piVar16[1] = 0x3f3a;\nswitchD_004052f0_caseD_405773:\n          if ((piVar16[5] & 0x800U) == 0) {\n            if (piVar16[9] != 0) {\n              *(undefined4 *)(piVar16[9] + 0x1c) = 0;\n            }\nLAB_00405897:\n            piVar16[0x11] = 0;\n            piVar16[1] = 0x3f3b;\nswitchD_004052f0_caseD_4058a5:\n            if ((piVar16[5] & 0x1000U) == 0) {\n              if (piVar16[9] != 0) {\n                *(undefined4 *)(piVar16[9] + 0x24) = 0;\n              }\nLAB_00405947:\n              piVar16[1] = 0x3f3c;\n              uVar14 = local_34;\nswitchD_004052f0_caseD_405952:\n              if ((piVar16[5] & 0x200U) != 0) {\n                for (; uVar9 < 0x10; uVar9 = uVar9 + 8) {\n                  if (uVar13 == 0) goto LAB_00405805;\n                  uVar3 = *puVar8;\n                  puVar8 = (uint *)((int)puVar8 + 1);\n                  uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n                  uVar13 = uVar13 - 1;\n                  local_34 = uVar14;\n                  local_30 = puVar8;\n                }\n                if (((*(byte *)(piVar16 + 3) & 4) != 0) && (uVar14 != *(ushort *)(piVar16 + 7))) {\n                  param_1[6] = (int)\"header crc mismatch\";\n                  piVar16[1] = 0x3f51;\n                  break;\n                }\n                uVar9 = 0;\n                local_34 = 0;\n              }\n              if (piVar16[9] != 0) {\n                *(uint *)(piVar16[9] + 0x2c) = piVar16[5] >> 9 & 1;\n                *(undefined4 *)(piVar16[9] + 0x30) = 1;\n              }\n              puVar7 = FUN_00407060(0,(uint *)0x0,0);\n              piVar16[7] = (int)puVar7;\n              param_1[0xc] = (int)puVar7;\n              piVar16[1] = 0x3f3f;\n              uVar14 = local_34;\n              break;\n            }\n            if (uVar13 != 0) {\n              local_10 = 0;\n              do {\n                pbVar1 = (byte *)(local_10 + (int)puVar8);\n                local_14 = (uint)*pbVar1;\n                local_10 = local_10 + 1;\n                iVar4 = piVar16[9];\n                if (((iVar4 != 0) && (*(int *)(iVar4 + 0x24) != 0)) &&\n                   ((uint)piVar16[0x11] < *(uint *)(iVar4 + 0x28))) {\n                  *(byte *)(*(int *)(iVar4 + 0x24) + piVar16[0x11]) = *pbVar1;\n                  piVar16[0x11] = piVar16[0x11] + 1;\n                  puVar8 = local_30;\n                }\n              } while ((local_14 != 0) && (local_10 < uVar13));\n              if (((piVar16[5] & 0x200U) != 0) && ((*(byte *)(piVar16 + 3) & 4) != 0)) {\n                puVar7 = FUN_00407060(piVar16[7],puVar8,local_10);\n                piVar16[7] = (int)puVar7;\n              }\n              puVar8 = (uint *)((int)puVar8 + local_10);\n              uVar13 = uVar13 - local_10;\n              local_30 = puVar8;\n              if (local_14 == 0) goto LAB_00405947;\n            }\n          }\n          else if (uVar13 != 0) {\n            local_10 = 0;\n            do {\n              pbVar1 = (byte *)(local_10 + (int)puVar8);\n              local_14 = (uint)*pbVar1;\n              local_10 = local_10 + 1;\n              iVar4 = piVar16[9];\n              if (((iVar4 != 0) && (*(int *)(iVar4 + 0x1c) != 0)) &&\n                 ((uint)piVar16[0x11] < *(uint *)(iVar4 + 0x20))) {\n                *(byte *)(*(int *)(iVar4 + 0x1c) + piVar16[0x11]) = *pbVar1;\n                piVar16[0x11] = piVar16[0x11] + 1;\n                puVar8 = local_30;\n              }\n            } while ((local_14 != 0) && (local_10 < uVar13));\n            if (((piVar16[5] & 0x200U) != 0) && ((*(byte *)(piVar16 + 3) & 4) != 0)) {\n              puVar7 = FUN_00407060(piVar16[7],puVar8,local_10);\n              piVar16[7] = (int)puVar7;\n            }\n            puVar8 = (uint *)((int)puVar8 + local_10);\n            uVar13 = uVar13 - local_10;\n            local_30 = puVar8;\n            if (local_14 == 0) goto LAB_00405897;\n          }\n        }\n        else {\n          local_14 = piVar16[0x11];\n          if (uVar13 < (uint)piVar16[0x11]) {\n            local_14 = uVar13;\n          }\n          if (local_14 != 0) {\n            iVar4 = piVar16[9];\n            if ((iVar4 != 0) && (*(int *)(iVar4 + 0x10) != 0)) {\n              local_10 = *(int *)(iVar4 + 0x14) - piVar16[0x11];\n              uVar14 = local_14;\n              if (*(uint *)(iVar4 + 0x18) < local_10 + local_14) {\n                uVar14 = *(uint *)(iVar4 + 0x18) - local_10;\n              }\n              FUN_00408c90((uint *)(local_10 + *(int *)(iVar4 + 0x10)),puVar8,uVar14);\n            }\n            if (((piVar16[5] & 0x200U) != 0) && ((*(byte *)(piVar16 + 3) & 4) != 0)) {\n              puVar7 = FUN_00407060(piVar16[7],puVar8,local_14);\n              piVar16[7] = (int)puVar7;\n            }\n            puVar8 = (uint *)((int)puVar8 + local_14);\n            uVar13 = uVar13 - local_14;\n            piVar16[0x11] = piVar16[0x11] - local_14;\n            local_30 = puVar8;\n          }\n          if (piVar16[0x11] == 0) goto LAB_00405765;\n        }\nLAB_00405805:\n        uVar14 = local_1c;\n        piVar16 = local_20;\n        param_1[3] = (int)local_24;\n        param_1[4] = local_28;\n        param_1[1] = uVar13;\n        *param_1 = (int)local_30;\n        local_20[0xf] = local_34;\n        local_20[0x10] = uVar9;\n        if (((local_20[0xb] == 0) &&\n            (((local_1c == param_1[4] || (0x3f50 < local_20[1])) ||\n             ((0x3f4d < local_20[1] && (param_2 == 4)))))) ||\n           (iVar4 = FUN_00406cf0((int)param_1,param_1[3],local_1c - param_1[4]), iVar4 == 0)) {\n          local_c = local_c - param_1[1];\n          uVar14 = uVar14 - param_1[4];\n          param_1[2] = param_1[2] + local_c;\n          param_1[5] = param_1[5] + uVar14;\n          piVar16[8] = piVar16[8] + uVar14;\n          if (((*(byte *)(piVar16 + 3) & 4) != 0) && (uVar14 != 0)) {\n            if (piVar16[5] == 0) {\n              uVar9 = thunk_FUN_00406df0(piVar16[7],(byte *)(param_1[3] - uVar14),uVar14);\n              piVar16[7] = uVar9;\n              param_1[0xc] = uVar9;\n            }\n            else {\n              puVar8 = FUN_00407060(piVar16[7],(uint *)(param_1[3] - uVar14),uVar14);\n              piVar16[7] = (int)puVar8;\n              param_1[0xc] = (int)puVar8;\n            }\n          }\n          iVar4 = piVar16[1];\n          if ((iVar4 == 0x3f47) || (iVar4 == 0x3f42)) {\n            iVar15 = 0x100;\n          }\n          else {\n            iVar15 = 0;\n          }\n          iVar10 = 0;\n          if (iVar4 == 0x3f3f) {\n            iVar10 = 0x80;\n          }\n          param_1[0xb] = iVar10 + (-(uint)(piVar16[2] != 0) & 0x40) + iVar15 + piVar16[0x10];\n          if (((local_c != 0) || (uVar14 != 0)) && (param_2 != 4)) {\n            return local_18;\n          }\n          if (local_18 == 0) {\n            local_18 = -5;\n          }\n          return local_18;\n        }\n        piVar16[1] = 0x3f52;\nswitchD_004052f0_caseD_40587c:\n        return -4;\n      case (undefined *)0x405773:\n        goto switchD_004052f0_caseD_405773;\n      case (undefined *)0x40587c:\n        goto switchD_004052f0_caseD_40587c;\n      case (undefined *)0x4058a5:\n        goto switchD_004052f0_caseD_4058a5;\n      case (undefined *)0x405952:\n        goto switchD_004052f0_caseD_405952;\n      case (undefined *)0x4059f5:\n        for (; uVar9 < 0x20; uVar9 = uVar9 + 8) {\n          if (uVar13 == 0) goto LAB_00405805;\n          uVar3 = *puVar8;\n          puVar8 = (uint *)((int)puVar8 + 1);\n          uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n          uVar13 = uVar13 - 1;\n          local_34 = uVar14;\n          local_30 = puVar8;\n        }\n        iVar4 = (uVar14 >> 8 & 0xff00) + ((uVar14 & 0xff00) + uVar14 * 0x10000) * 0x100 +\n                (uVar14 >> 0x18);\n        uVar14 = 0;\n        piVar16[7] = iVar4;\n        local_34 = 0;\n        uVar9 = 0;\n        param_1[0xc] = iVar4;\n        piVar16[1] = 0x3f3e;\n      case (undefined *)0x405a5f:\n        if (piVar16[4] == 0) {\n          param_1[3] = (int)local_24;\n          param_1[4] = local_28;\n          *param_1 = (int)puVar8;\n          param_1[1] = uVar13;\n          piVar16[0x10] = uVar9;\n          piVar16[0xf] = uVar14;\n          return 2;\n        }\n        uVar14 = thunk_FUN_00406df0(0,(byte *)0x0,0);\n        piVar16[7] = uVar14;\n        param_1[0xc] = uVar14;\n        piVar16[1] = 0x3f3f;\n        uVar14 = local_34;\nswitchD_004052f0_caseD_405a8c:\n        if ((param_2 == 5) || (param_2 == 6)) goto LAB_00405805;\nswitchD_004052f0_caseD_405aa2:\n        if (piVar16[2] != 0) {\n          piVar16[1] = 0x3f4e;\n          local_34 = uVar14 >> (sbyte)(uVar9 & 7);\n          uVar9 = uVar9 - (uVar9 & 7);\n          uVar14 = local_34;\n          break;\n        }\n        for (; uVar9 < 3; uVar9 = uVar9 + 8) {\n          if (uVar13 == 0) goto LAB_00405805;\n          uVar3 = *puVar8;\n          puVar8 = (uint *)((int)puVar8 + 1);\n          uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n          uVar13 = uVar13 - 1;\n          local_34 = uVar14;\n          local_30 = puVar8;\n        }\n        piVar16[2] = uVar14 & 1;\n        switch(uVar14 >> 1 & 3) {\n        case 0:\n          piVar16[1] = 0x3f41;\n          goto LAB_00405b06;\n        case 1:\n          piVar16[0x14] = (int)&DAT_00423198;\n          piVar16[0x16] = 9;\n          piVar16[0x15] = (int)&DAT_00423998;\n          piVar16[0x17] = 5;\n          piVar16[1] = 0x3f47;\n          if (param_2 == 6) {\n            local_34 = uVar14 >> 3;\n            uVar9 = uVar9 - 3;\n            goto LAB_00405805;\n          }\nLAB_00405b06:\n          uVar14 = uVar14 >> 3;\n          uVar9 = uVar9 - 3;\n          local_34 = uVar14;\n          break;\n        case 2:\n          uVar14 = uVar14 >> 3;\n          uVar9 = uVar9 - 3;\n          piVar16[1] = 0x3f44;\n          local_34 = uVar14;\n          break;\n        case 3:\n          uVar14 = uVar14 >> 3;\n          uVar9 = uVar9 - 3;\n          param_1[6] = (int)\"invalid block type\";\n          piVar16[1] = 0x3f51;\n          local_34 = uVar14;\n        }\n        break;\n      case (undefined *)0x405a8c:\n        goto switchD_004052f0_caseD_405a8c;\n      case (undefined *)0x405aa2:\n        goto switchD_004052f0_caseD_405aa2;\n      case (undefined *)0x405b8d:\n        local_34 = uVar14 >> (sbyte)(uVar9 & 7);\n        for (uVar9 = uVar9 - (uVar9 & 7); uVar9 < 0x20; uVar9 = uVar9 + 8) {\n          if (uVar13 == 0) goto LAB_00405805;\n          uVar14 = *puVar8;\n          puVar8 = (uint *)((int)puVar8 + 1);\n          local_34 = local_34 + ((uint)(byte)uVar14 << ((byte)uVar9 & 0x1f));\n          uVar13 = uVar13 - 1;\n          local_30 = puVar8;\n        }\n        if ((local_34 & 0xffff) == ~local_34 >> 0x10) {\n          uVar14 = 0;\n          piVar16[0x11] = local_34 & 0xffff;\n          uVar9 = 0;\n          local_34 = 0;\n          piVar16[1] = 0x3f42;\n          if (param_2 != 6) goto switchD_004052f0_caseD_405c06;\n          local_34 = 0;\n          goto LAB_00405805;\n        }\n        param_1[6] = (int)\"invalid stored block lengths\";\n        piVar16[1] = 0x3f51;\n        uVar14 = local_34;\n        break;\n      case (undefined *)0x405c06:\nswitchD_004052f0_caseD_405c06:\n        piVar16[1] = 0x3f43;\n      case (undefined *)0x405c0d:\n        uVar3 = piVar16[0x11];\n        if (uVar3 == 0) {\n          piVar16[1] = 0x3f3f;\n          break;\n        }\n        if (uVar13 < uVar3) {\n          uVar3 = uVar13;\n        }\n        local_10 = uVar3;\n        if (local_28 < uVar3) {\n          local_10 = local_28;\n        }\n        if (local_10 != 0) {\n          FUN_00408c90(local_24,puVar8,local_10);\n          local_28 = local_28 - local_10;\n          puVar8 = (uint *)((int)puVar8 + local_10);\n          local_24 = (uint *)((int)local_24 + local_10);\n          uVar13 = uVar13 - local_10;\n          piVar16[0x11] = piVar16[0x11] - local_10;\n          uVar14 = local_34;\n          local_30 = puVar8;\n          break;\n        }\n        goto LAB_00405805;\n      case (undefined *)0x405c82:\n        for (; uVar9 < 0xe; uVar9 = uVar9 + 8) {\n          if (uVar13 == 0) goto LAB_00405805;\n          uVar3 = *puVar8;\n          puVar8 = (uint *)((int)puVar8 + 1);\n          uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n          uVar13 = uVar13 - 1;\n          local_34 = uVar14;\n          local_30 = puVar8;\n        }\n        uVar9 = uVar9 - 0xe;\n        piVar16[0x19] = (uVar14 & 0x1f) + 0x101;\n        uVar3 = uVar14 >> 10;\n        piVar16[0x1a] = (uVar14 >> 5 & 0x1f) + 1;\n        uVar14 = uVar14 >> 0xe;\n        piVar16[0x18] = (uVar3 & 0xf) + 4;\n        local_34 = uVar14;\n        if (((uint)piVar16[0x19] < 0x11f) && ((uint)piVar16[0x1a] < 0x1f)) {\n          piVar16[0x1b] = 0;\n          piVar16[1] = 0x3f45;\n          goto switchD_004052f0_caseD_405d04;\n        }\n        param_1[6] = (int)\"too many length or distance symbols\";\n        piVar16[1] = 0x3f51;\n        break;\n      case (undefined *)0x405d04:\nswitchD_004052f0_caseD_405d04:\n        if ((uint)piVar16[0x1b] < (uint)piVar16[0x18]) {\n          do {\n            for (; uVar9 < 3; uVar9 = uVar9 + 8) {\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar3 = *puVar8;\n              puVar8 = (uint *)((int)puVar8 + 1);\n              local_34 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n              uVar13 = uVar13 - 1;\n              uVar14 = local_34;\n              local_30 = puVar8;\n            }\n            local_34 = uVar14 >> 3;\n            uVar9 = uVar9 - 3;\n            *(ushort *)\n             ((int)piVar16 + (uint)*(ushort *)(&DAT_00423a18 + piVar16[0x1b] * 2) * 2 + 0x74) =\n                 (ushort)uVar14 & 7;\n            piVar16[0x1b] = piVar16[0x1b] + 1;\n            uVar14 = local_34;\n          } while ((uint)piVar16[0x1b] < (uint)piVar16[0x18]);\n        }\n        uVar14 = piVar16[0x1b];\n        while (uVar14 < 0x13) {\n          *(undefined2 *)\n           ((int)piVar16 + (uint)*(ushort *)(&DAT_00423a18 + piVar16[0x1b] * 2) * 2 + 0x74) = 0;\n          piVar16[0x1b] = piVar16[0x1b] + 1;\n          uVar14 = piVar16[0x1b];\n        }\n        piVar16[0x16] = 7;\n        piVar16[0x14] = (int)(piVar16 + 0x14d);\n        piVar16[0x1c] = (int)(piVar16 + 0x14d);\n        local_18 = FUN_00407350(0,(int)(piVar16 + 0x1d),0x13,piVar16 + 0x1c,(uint *)(piVar16 + 0x16)\n                                ,(ushort *)(piVar16 + 0xbd));\n        if (local_18 == 0) {\n          piVar16[0x1b] = 0;\n          piVar16[1] = 0x3f46;\n          goto switchD_004052f0_caseD_405e00;\n        }\n        param_1[6] = (int)\"invalid code lengths set\";\n        piVar16[1] = 0x3f51;\n        uVar14 = local_34;\n        break;\n      case (undefined *)0x405e00:\nswitchD_004052f0_caseD_405e00:\n        if ((uint)piVar16[0x1b] < (uint)(piVar16[0x1a] + piVar16[0x19])) {\n          do {\n            uVar14 = *(uint *)(local_20[0x14] + ((1 << ((byte)*local_8 & 0x1f)) - 1U & local_34) * 4\n                              );\n            local_10 = uVar14;\n            if (uVar9 < (uVar14 >> 8 & 0xff)) {\n              do {\n                if (uVar13 == 0) goto LAB_00405805;\n                local_34 = local_34 + ((uint)(byte)*puVar8 << ((byte)uVar9 & 0x1f));\n                puVar8 = (uint *)((int)puVar8 + 1);\n                uVar9 = uVar9 + 8;\n                uVar13 = uVar13 - 1;\n                uVar14 = *(uint *)(local_20[0x14] +\n                                  ((1 << ((byte)*local_8 & 0x1f)) - 1U & local_34) * 4);\n                local_30 = puVar8;\n                local_10 = uVar14;\n              } while (uVar9 < (uVar14 >> 8 & 0xff));\n            }\n            uVar12 = (ushort)(uVar14 >> 0x10);\n            bVar11 = (byte)(uVar14 >> 8);\n            piVar16 = local_20;\n            if (0xf < uVar12) {\n              if (uVar12 == 0x10) {\n                local_10 = (uVar14 >> 8 & 0xff) + 2;\n                for (; uVar9 < local_10; uVar9 = uVar9 + 8) {\n                  if (uVar13 == 0) goto LAB_00405805;\n                  uVar3 = *puVar8;\n                  puVar8 = (uint *)((int)puVar8 + 1);\n                  local_34 = local_34 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n                  uVar13 = uVar13 - 1;\n                  local_30 = puVar8;\n                }\n                local_34 = local_34 >> (bVar11 & 0x1f);\n                uVar9 = uVar9 - (uVar14 >> 8 & 0xff);\n                if (local_20[0x1b] != 0) {\n                  local_10 = (uint)*(ushort *)((int)local_20 + local_20[0x1b] * 2 + 0x72);\n                  local_14 = local_34 & 3;\n                  local_34 = local_34 >> 2;\n                  local_14 = local_14 + 3;\n                  uVar9 = uVar9 - 2;\n                  goto LAB_00405fec;\n                }\n              }\n              else {\n                local_10 = uVar14 >> 8 & 0xff;\n                if (uVar12 == 0x11) {\n                  for (; uVar9 < local_10 + 3; uVar9 = uVar9 + 8) {\n                    if (uVar13 == 0) goto LAB_00405805;\n                    uVar14 = *puVar8;\n                    puVar8 = (uint *)((int)puVar8 + 1);\n                    local_34 = local_34 + ((uint)(byte)uVar14 << ((byte)uVar9 & 0x1f));\n                    uVar13 = uVar13 - 1;\n                    local_30 = puVar8;\n                  }\n                  local_34 = local_34 >> (bVar11 & 0x1f);\n                  local_14 = (local_34 & 7) + 3;\n                  local_34 = local_34 >> 3;\n                  iVar4 = -3;\n                }\n                else {\n                  for (; uVar9 < local_10 + 7; uVar9 = uVar9 + 8) {\n                    if (uVar13 == 0) goto LAB_00405805;\n                    uVar14 = *puVar8;\n                    puVar8 = (uint *)((int)puVar8 + 1);\n                    local_34 = local_34 + ((uint)(byte)uVar14 << ((byte)uVar9 & 0x1f));\n                    uVar13 = uVar13 - 1;\n                    local_30 = puVar8;\n                  }\n                  local_34 = local_34 >> (bVar11 & 0x1f);\n                  local_14 = (local_34 & 0x7f) + 0xb;\n                  local_34 = local_34 >> 7;\n                  iVar4 = -7;\n                }\n                uVar9 = uVar9 + (iVar4 - local_10);\n                local_10 = 0;\nLAB_00405fec:\n                uVar3 = local_14;\n                if (local_20[0x1b] + local_14 <= (uint)(local_20[0x1a] + local_20[0x19])) {\n                  do {\n                    *(short *)((int)local_20 + local_20[0x1b] * 2 + 0x74) = (short)local_10;\n                    local_20[0x1b] = local_20[0x1b] + 1;\n                    uVar6 = local_20[0x1b];\n                    uVar3 = uVar3 - 1;\n                    uVar14 = uVar6;\n                  } while (uVar3 != 0);\n                  goto LAB_00406031;\n                }\n              }\n              param_1[6] = (int)\"invalid bit length repeat\";\n              local_20[1] = 0x3f51;\n              uVar14 = local_34;\n              goto LAB_00405c5b;\n            }\n            local_34 = local_34 >> (bVar11 & 0x1f);\n            uVar9 = uVar9 - (uVar14 >> 8 & 0xff);\n            *(ushort *)((int)local_20 + local_20[0x1b] * 2 + 0x74) = uVar12;\n            local_20[0x1b] = local_20[0x1b] + 1;\n            uVar6 = local_20[0x1b];\nLAB_00406031:\n            local_10 = uVar14;\n          } while (uVar6 < (uint)(local_20[0x1a] + local_20[0x19]));\n        }\n        uVar14 = local_34;\n        if (piVar16[1] != 0x3f51) {\n          if ((short)piVar16[0x9d] == 0) {\n            param_1[6] = (int)\"invalid code -- missing end-of-block\";\n            piVar16[1] = 0x3f51;\n          }\n          else {\n            piVar16[0x16] = 9;\n            piVar16[0x14] = (int)(piVar16 + 0x14d);\n            piVar16[0x1c] = (int)(piVar16 + 0x14d);\n            local_18 = FUN_00407350(1,(int)(piVar16 + 0x1d),piVar16[0x19],piVar16 + 0x1c,\n                                    (uint *)(piVar16 + 0x16),(ushort *)(piVar16 + 0xbd));\n            if (local_18 == 0) {\n              piVar16[0x15] = piVar16[0x1c];\n              piVar16[0x17] = 6;\n              local_18 = FUN_00407350(2,(int)piVar16 + (piVar16[0x19] + 0x3a) * 2,piVar16[0x1a],\n                                      piVar16 + 0x1c,(uint *)(piVar16 + 0x17),\n                                      (ushort *)(piVar16 + 0xbd));\n              if (local_18 == 0) {\n                piVar16[1] = 0x3f47;\n                if (param_2 != 6) goto switchD_004052f0_caseD_406152;\n                goto LAB_00405805;\n              }\n              param_1[6] = (int)\"invalid distances set\";\n              piVar16[1] = 0x3f51;\n            }\n            else {\n              param_1[6] = (int)\"invalid literal/lengths set\";\n              piVar16[1] = 0x3f51;\n            }\n          }\n        }\n        break;\n      case (undefined *)0x406152:\nswitchD_004052f0_caseD_406152:\n        piVar16[1] = 0x3f48;\n        uVar6 = uVar9;\n      case (undefined *)0x406159:\n        if ((5 < uVar13) && (0x101 < local_28)) {\n          param_1[3] = (int)local_24;\n          param_1[4] = local_28;\n          *param_1 = (int)puVar8;\n          param_1[1] = uVar13;\n          piVar16[0xf] = uVar14;\n          piVar16[0x10] = uVar6;\n          FUN_00407800(param_1,local_1c);\n          uVar14 = piVar16[0xf];\n          uVar9 = piVar16[0x10];\n          local_24 = (uint *)param_1[3];\n          puVar8 = (uint *)*param_1;\n          uVar13 = param_1[1];\n          local_28 = param_1[4];\n          local_34 = uVar14;\n          local_30 = puVar8;\n          if (piVar16[1] == 0x3f3f) {\n            piVar16[0x6f2] = -1;\n          }\n          break;\n        }\n        local_14 = piVar16[0x14];\n        piVar16[0x6f2] = 0;\n        uVar3 = *(uint *)(piVar16[0x14] + ((1 << ((byte)piVar16[0x16] & 0x1f)) - 1U & uVar14) * 4);\n        if (uVar6 < (uVar3 >> 8 & 0xff)) {\n          do {\n            uVar9 = uVar6;\n            if (uVar13 == 0) goto LAB_00405805;\n            uVar9 = *puVar8;\n            puVar8 = (uint *)((int)puVar8 + 1);\n            uVar14 = uVar14 + ((uint)(byte)uVar9 << ((byte)uVar6 & 0x1f));\n            uVar6 = uVar6 + 8;\n            uVar13 = uVar13 - 1;\n            uVar3 = *(uint *)(piVar16[0x14] +\n                             ((1 << ((byte)piVar16[0x16] & 0x1f)) - 1U & uVar14) * 4);\n            local_34 = uVar14;\n            local_30 = puVar8;\n          } while (uVar6 < (uVar3 >> 8 & 0xff));\n        }\n        cVar2 = (char)uVar3;\n        uVar5 = uVar3;\n        if ((cVar2 != '\\0') && ((uVar3 & 0xf0) == 0)) {\n          local_4 = uVar3 >> 8;\n          bVar11 = (byte)(uVar3 >> 8);\n          uVar5 = *(uint *)(local_14 +\n                           ((((1 << (cVar2 + bVar11 & 0x1f)) - 1U & local_34) >> (bVar11 & 0x1f)) +\n                           (uVar3 >> 0x10)) * 4);\n          uVar9 = uVar6;\n          local_10 = uVar3;\n          if (uVar6 < (uVar5 >> 8 & 0xff) + (local_4 & 0xff)) {\n            do {\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar6 = uVar9 + 8;\n              uVar13 = uVar13 - 1;\n              uVar14 = *local_30;\n              local_30 = (uint *)((int)local_30 + 1);\n              local_34 = local_34 + ((uint)(byte)uVar14 << ((byte)uVar9 & 0x1f));\n              uVar5 = *(uint *)(local_20[0x14] +\n                               ((((1 << (cVar2 + bVar11 & 0x1f)) - 1U & local_34) >> (bVar11 & 0x1f)\n                                ) + (uVar3 >> 0x10)) * 4);\n              uVar9 = uVar6;\n            } while (uVar6 < (uVar5 >> 8 & 0xff) + (uVar3 >> 8 & 0xff));\n          }\n          uVar9 = uVar3 >> 8 & 0xff;\n          uVar14 = local_34 >> (bVar11 & 0x1f);\n          uVar6 = uVar6 - uVar9;\n          local_20[0x6f2] = uVar9;\n          puVar8 = local_30;\n          piVar16 = local_20;\n        }\n        uVar9 = uVar5 >> 8 & 0xff;\n        piVar16[0x6f2] = piVar16[0x6f2] + uVar9;\n        uVar9 = uVar6 - uVar9;\n        uVar14 = uVar14 >> ((byte)(uVar5 >> 8) & 0x1f);\n        piVar16[0x11] = uVar5 >> 0x10;\n        local_34 = uVar14;\n        if ((char)uVar5 == '\\0') {\n          piVar16[1] = 0x3f4d;\n          break;\n        }\n        if ((uVar5 & 0x20) != 0) {\n          piVar16[0x6f2] = -1;\n          piVar16[1] = 0x3f3f;\n          break;\n        }\n        if ((uVar5 & 0x40) != 0) {\n          param_1[6] = (int)\"invalid literal/length code\";\n          piVar16[1] = 0x3f51;\n          break;\n        }\n        piVar16[1] = 0x3f49;\n        piVar16[0x13] = uVar5 & 0xf;\nswitchD_004052f0_caseD_406383:\n        uVar3 = piVar16[0x13];\n        if (uVar3 != 0) {\n          if (uVar9 < uVar3) {\n            do {\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar6 = *puVar8;\n              puVar8 = (uint *)((int)puVar8 + 1);\n              uVar3 = piVar16[0x13];\n              uVar14 = uVar14 + ((uint)(byte)uVar6 << ((byte)uVar9 & 0x1f));\n              uVar9 = uVar9 + 8;\n              uVar13 = uVar13 - 1;\n              local_34 = uVar14;\n              local_30 = puVar8;\n            } while (uVar9 < uVar3);\n          }\n          uVar9 = uVar9 - uVar3;\n          uVar6 = (1 << ((byte)uVar3 & 0x1f)) - 1U & uVar14;\n          uVar14 = uVar14 >> ((byte)uVar3 & 0x1f);\n          piVar16[0x11] = piVar16[0x11] + uVar6;\n          piVar16[0x6f2] = piVar16[0x6f2] + uVar3;\n          local_34 = uVar14;\n        }\n        piVar16[0x6f3] = piVar16[0x11];\n        piVar16[1] = 0x3f4a;\nswitchD_004052f0_caseD_4063e0:\n        local_4 = piVar16[0x15];\n        uVar3 = *(uint *)(piVar16[0x15] + ((1 << ((byte)piVar16[0x17] & 0x1f)) - 1U & uVar14) * 4);\n        if (uVar9 < (uVar3 >> 8 & 0xff)) {\n          do {\n            if (uVar13 == 0) goto LAB_00405805;\n            uVar3 = *puVar8;\n            puVar8 = (uint *)((int)puVar8 + 1);\n            uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n            uVar9 = uVar9 + 8;\n            uVar13 = uVar13 - 1;\n            uVar3 = *(uint *)(piVar16[0x15] +\n                             ((1 << ((byte)piVar16[0x17] & 0x1f)) - 1U & uVar14) * 4);\n            local_34 = uVar14;\n            local_30 = puVar8;\n          } while (uVar9 < (uVar3 >> 8 & 0xff));\n        }\n        uVar6 = uVar3;\n        if ((uVar3 & 0xf0) == 0) {\n          local_14 = uVar3 >> 8;\n          bVar11 = (byte)(uVar3 >> 8);\n          uVar6 = *(uint *)(local_4 +\n                           ((((1 << ((char)uVar3 + bVar11 & 0x1f)) - 1U & local_34) >>\n                            (bVar11 & 0x1f)) + (uVar3 >> 0x10)) * 4);\n          uVar14 = uVar9;\n          local_10 = uVar3;\n          if (uVar9 < (uVar6 >> 8 & 0xff) + (local_14 & 0xff)) {\n            do {\n              uVar9 = uVar14;\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar9 = uVar14 + 8;\n              uVar13 = uVar13 - 1;\n              uVar6 = *local_30;\n              local_30 = (uint *)((int)local_30 + 1);\n              local_34 = local_34 + ((uint)(byte)uVar6 << ((byte)uVar14 & 0x1f));\n              uVar6 = *(uint *)(local_20[0x15] +\n                               ((((1 << ((char)uVar3 + bVar11 & 0x1f)) - 1U & local_34) >>\n                                (bVar11 & 0x1f)) + (uVar3 >> 0x10)) * 4);\n              uVar14 = uVar9;\n            } while (uVar9 < (uVar6 >> 8 & 0xff) + (uVar3 >> 8 & 0xff));\n          }\n          uVar3 = uVar3 >> 8 & 0xff;\n          uVar9 = uVar9 - uVar3;\n          uVar14 = local_34 >> (bVar11 & 0x1f);\n          local_20[0x6f2] = local_20[0x6f2] + uVar3;\n          piVar16 = local_20;\n        }\n        uVar3 = uVar6 >> 8 & 0xff;\n        piVar16[0x6f2] = piVar16[0x6f2] + uVar3;\n        uVar9 = uVar9 - uVar3;\n        uVar14 = uVar14 >> ((byte)(uVar6 >> 8) & 0x1f);\n        puVar8 = local_30;\n        local_34 = uVar14;\n        if ((uVar6 & 0x40) != 0) {\n          param_1[6] = (int)\"invalid distance code\";\n          piVar16[1] = 0x3f51;\n          break;\n        }\n        piVar16[1] = 0x3f4b;\n        piVar16[0x12] = uVar6 >> 0x10;\n        piVar16[0x13] = uVar6 & 0xf;\nswitchD_004052f0_caseD_406559:\n        uVar3 = piVar16[0x13];\n        if (uVar3 != 0) {\n          if (uVar9 < uVar3) {\n            do {\n              if (uVar13 == 0) goto LAB_00405805;\n              uVar6 = *puVar8;\n              puVar8 = (uint *)((int)puVar8 + 1);\n              uVar3 = piVar16[0x13];\n              uVar14 = uVar14 + ((uint)(byte)uVar6 << ((byte)uVar9 & 0x1f));\n              uVar9 = uVar9 + 8;\n              uVar13 = uVar13 - 1;\n              local_34 = uVar14;\n              local_30 = puVar8;\n            } while (uVar9 < uVar3);\n          }\n          uVar9 = uVar9 - uVar3;\n          uVar6 = (1 << ((byte)uVar3 & 0x1f)) - 1U & uVar14;\n          uVar14 = uVar14 >> ((byte)uVar3 & 0x1f);\n          piVar16[0x12] = piVar16[0x12] + uVar6;\n          piVar16[0x6f2] = piVar16[0x6f2] + uVar3;\n          local_34 = uVar14;\n        }\n        piVar16[1] = 0x3f4c;\nswitchD_004052f0_caseD_4065ab:\n        if (local_28 != 0) {\n          uVar3 = piVar16[0x12];\n          if (local_1c - local_28 < uVar3) {\n            uVar3 = uVar3 - (local_1c - local_28);\n            if (((uint)piVar16[0xc] < uVar3) && (piVar16[0x6f1] != 0)) {\n              param_1[6] = (int)\"invalid distance too far back\";\n              piVar16[1] = 0x3f51;\n              break;\n            }\n            if ((uint)piVar16[0xd] < uVar3) {\n              uVar3 = uVar3 - piVar16[0xd];\n              local_10 = (piVar16[0xe] + piVar16[0xb]) - uVar3;\n            }\n            else {\n              local_10 = (piVar16[0xe] - uVar3) + piVar16[0xd];\n            }\n            uVar6 = piVar16[0x11];\n            if (uVar6 < uVar3) goto LAB_00406620;\n          }\n          else {\n            local_10 = (int)local_24 - uVar3;\n            uVar6 = piVar16[0x11];\nLAB_00406620:\n            uVar3 = uVar6;\n          }\n          if (local_28 < uVar3) {\n            uVar3 = local_28;\n          }\n          local_28 = local_28 - uVar3;\n          piVar16[0x11] = uVar6 - uVar3;\n          iVar4 = local_10 - (int)local_24;\n          do {\n            *(undefined1 *)local_24 = *(undefined1 *)(iVar4 + (int)local_24);\n            local_24 = (uint *)((int)local_24 + 1);\n            uVar3 = uVar3 - 1;\n          } while (uVar3 != 0);\n          puVar8 = local_30;\n          piVar16 = local_20;\n          if (local_20[0x11] == 0) {\n            local_20[1] = 0x3f48;\n          }\n          break;\n        }\n        goto LAB_00405805;\n      case (undefined *)0x406383:\n        goto switchD_004052f0_caseD_406383;\n      case (undefined *)0x4063e0:\n        goto switchD_004052f0_caseD_4063e0;\n      case (undefined *)0x406559:\n        goto switchD_004052f0_caseD_406559;\n      case (undefined *)0x4065ab:\n        goto switchD_004052f0_caseD_4065ab;\n      case (undefined *)0x40666c:\n        if (local_28 == 0) goto LAB_00405805;\n        local_28 = local_28 - 1;\n        *(char *)local_24 = (char)piVar16[0x11];\n        piVar16[1] = 0x3f48;\n        puVar8 = local_30;\n        local_24 = (uint *)((int)local_24 + 1);\n        break;\n      case (undefined *)0x406698:\n        if (piVar16[3] != 0) {\n          for (; uVar9 < 0x20; uVar9 = uVar9 + 8) {\n            if (uVar13 == 0) goto LAB_00405805;\n            uVar3 = *puVar8;\n            puVar8 = (uint *)((int)puVar8 + 1);\n            uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n            uVar13 = uVar13 - 1;\n            local_34 = uVar14;\n            local_30 = puVar8;\n          }\n          local_1c = local_1c - local_28;\n          param_1[5] = param_1[5] + local_1c;\n          piVar16[8] = piVar16[8] + local_1c;\n          if (((*(byte *)(piVar16 + 3) & 4) != 0) && (local_1c != 0)) {\n            if (piVar16[5] == 0) {\n              puVar7 = (uint *)thunk_FUN_00406df0(piVar16[7],(byte *)((int)local_24 - local_1c),\n                                                  local_1c);\n            }\n            else {\n              puVar7 = FUN_00407060(piVar16[7],(uint *)((int)local_24 - local_1c),local_1c);\n            }\n            piVar16[7] = (int)puVar7;\n            param_1[0xc] = (int)puVar7;\n            uVar14 = local_34;\n          }\n          local_1c = local_28;\n          if ((*(byte *)(piVar16 + 3) & 4) != 0) {\n            uVar3 = uVar14;\n            if (piVar16[5] == 0) {\n              uVar3 = ((uVar14 & 0xff00) + uVar14 * 0x10000) * 0x100 + (uVar14 >> 8 & 0xff00) +\n                      (uVar14 >> 0x18);\n            }\n            if (uVar3 != piVar16[7]) {\n              param_1[6] = (int)\"incorrect data check\";\n              piVar16[1] = 0x3f51;\n              break;\n            }\n          }\n          uVar14 = 0;\n          uVar9 = 0;\n          local_34 = 0;\n        }\n        piVar16[1] = 0x3f4f;\n      case (undefined *)0x40677e:\n        if ((piVar16[3] != 0) && (piVar16[5] != 0)) {\n          for (; uVar9 < 0x20; uVar9 = uVar9 + 8) {\n            if (uVar13 == 0) goto LAB_00405805;\n            uVar3 = *puVar8;\n            puVar8 = (uint *)((int)puVar8 + 1);\n            uVar14 = uVar14 + ((uint)(byte)uVar3 << ((byte)uVar9 & 0x1f));\n            uVar13 = uVar13 - 1;\n            local_34 = uVar14;\n            local_30 = puVar8;\n          }\n          if (uVar14 != piVar16[8]) {\n            param_1[6] = (int)\"incorrect length check\";\n            piVar16[1] = 0x3f51;\n            break;\n          }\n          uVar9 = 0;\n          local_34 = 0;\n        }\n        piVar16[1] = 0x3f50;\nswitchD_004052f0_caseD_406804:\n        local_18 = 1;\n        goto LAB_00405805;\n      case (undefined *)0x406804:\n        goto switchD_004052f0_caseD_406804;\n      case (undefined *)0x406811:\n        local_18 = -3;\n        goto LAB_00405805;\n      }\nLAB_00405c5b:\n      uVar3 = piVar16[1] - 0x3f34;\n    } while (uVar3 < 0x1f);\n  }\n  return -2;\n}\n\n"
    },
    {
      "name": "FUN_004069b0",
      "entry": "004069b0",
      "c": "\nundefined4 __cdecl FUN_004069b0(int param_1)\n\n{\n  int *piVar1;\n  \n  if ((((param_1 != 0) && (*(int *)(param_1 + 0x20) != 0)) &&\n      (*(code **)(param_1 + 0x24) != (code *)0x0)) &&\n     (((piVar1 = *(int **)(param_1 + 0x1c), piVar1 != (int *)0x0 && (*piVar1 == param_1)) &&\n      ((0x3f33 < piVar1[1] && (piVar1[1] < 0x3f54)))))) {\n    if (piVar1[0xe] != 0) {\n      (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),piVar1[0xe]);\n    }\n    (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),*(undefined4 *)(param_1 + 0x1c));\n    *(undefined4 *)(param_1 + 0x1c) = 0;\n    return 0;\n  }\n  return 0xfffffffe;\n}\n\n"
    },
    {
      "name": "FUN_00406a20",
      "entry": "00406a20",
      "c": "\nint __cdecl FUN_00406a20(int param_1,uint param_2,char *param_3,int param_4)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if (((param_3 == (char *)0x0) || (*param_3 != '1')) || (param_4 != 0x38)) {\n    return -6;\n  }\n  if (param_1 == 0) {\n    return -2;\n  }\n  *(undefined4 *)(param_1 + 0x18) = 0;\n  if (*(int *)(param_1 + 0x20) == 0) {\n    *(code **)(param_1 + 0x20) = FUN_00407320;\n    *(undefined4 *)(param_1 + 0x28) = 0;\n  }\n  if (*(int *)(param_1 + 0x24) == 0) {\n    *(code **)(param_1 + 0x24) = FUN_00407340;\n  }\n  piVar1 = (int *)(**(code **)(param_1 + 0x20))(*(undefined4 *)(param_1 + 0x28),1,0x1bd0);\n  if (piVar1 == (int *)0x0) {\n    return -4;\n  }\n  *(int **)(param_1 + 0x1c) = piVar1;\n  *piVar1 = param_1;\n  piVar1[0xe] = 0;\n  piVar1[1] = 0x3f34;\n  iVar2 = FUN_00406b60(param_1,param_2);\n  if (iVar2 != 0) {\n    (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),piVar1);\n    *(undefined4 *)(param_1 + 0x1c) = 0;\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "FUN_00406ae0",
      "entry": "00406ae0",
      "c": "\nvoid __cdecl FUN_00406ae0(int param_1,char *param_2,int param_3)\n\n{\n  FUN_00406a20(param_1,0xf,param_2,param_3);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00406b00",
      "entry": "00406b00",
      "c": "\nundefined4 __cdecl FUN_00406b00(int param_1)\n\n{\n  int *piVar1;\n  undefined4 uVar2;\n  \n  if ((((param_1 != 0) && (*(int *)(param_1 + 0x20) != 0)) && (*(int *)(param_1 + 0x24) != 0)) &&\n     (((piVar1 = *(int **)(param_1 + 0x1c), piVar1 != (int *)0x0 && (*piVar1 == param_1)) &&\n      ((0x3f33 < piVar1[1] && (piVar1[1] < 0x3f54)))))) {\n    piVar1[0xb] = 0;\n    piVar1[0xc] = 0;\n    piVar1[0xd] = 0;\n    uVar2 = FUN_00406c10(param_1);\n    return uVar2;\n  }\n  return 0xfffffffe;\n}\n\n"
    },
    {
      "name": "FUN_00406b60",
      "entry": "00406b60",
      "c": "\nundefined4 __cdecl FUN_00406b60(int param_1,uint param_2)\n\n{\n  int *piVar1;\n  undefined4 uVar2;\n  int iVar3;\n  \n  if (((((param_1 == 0) || (*(int *)(param_1 + 0x20) == 0)) ||\n       (*(code **)(param_1 + 0x24) == (code *)0x0)) ||\n      ((piVar1 = *(int **)(param_1 + 0x1c), piVar1 == (int *)0x0 || (*piVar1 != param_1)))) ||\n     ((piVar1[1] < 0x3f34 || (0x3f53 < piVar1[1])))) {\n    return 0xfffffffe;\n  }\n  if ((int)param_2 < 0) {\n    iVar3 = 0;\n    param_2 = -param_2;\n  }\n  else {\n    iVar3 = ((int)param_2 >> 4) + 5;\n    if ((int)param_2 < 0x30) {\n      param_2 = param_2 & 0xf;\n    }\n  }\n  if ((param_2 != 0) && (((int)param_2 < 8 || (0xf < (int)param_2)))) {\n    return 0xfffffffe;\n  }\n  if ((piVar1[0xe] != 0) && (piVar1[10] != param_2)) {\n    (**(code **)(param_1 + 0x24))(*(undefined4 *)(param_1 + 0x28),piVar1[0xe]);\n    piVar1[0xe] = 0;\n  }\n  piVar1[3] = iVar3;\n  piVar1[10] = param_2;\n  uVar2 = FUN_00406b00(param_1);\n  return uVar2;\n}\n\n"
    },
    {
      "name": "FUN_00406c10",
      "entry": "00406c10",
      "c": "\nundefined4 __cdecl FUN_00406c10(int param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  \n  if ((((param_1 != 0) && (*(int *)(param_1 + 0x20) != 0)) && (*(int *)(param_1 + 0x24) != 0)) &&\n     (((piVar2 = *(int **)(param_1 + 0x1c), piVar2 != (int *)0x0 && (*piVar2 == param_1)) &&\n      ((0x3f33 < piVar2[1] && (piVar2[1] < 0x3f54)))))) {\n    piVar2[8] = 0;\n    *(undefined4 *)(param_1 + 0x14) = 0;\n    *(undefined4 *)(param_1 + 8) = 0;\n    *(undefined4 *)(param_1 + 0x18) = 0;\n    if (piVar2[3] != 0) {\n      *(uint *)(param_1 + 0x30) = piVar2[3] & 1;\n    }\n    piVar1 = piVar2 + 0x14d;\n    piVar2[1] = 0x3f34;\n    piVar2[0x1c] = (int)piVar1;\n    piVar2[0x15] = (int)piVar1;\n    piVar2[0x14] = (int)piVar1;\n    piVar2[2] = 0;\n    piVar2[4] = 0;\n    piVar2[6] = 0x8000;\n    piVar2[9] = 0;\n    piVar2[0xf] = 0;\n    piVar2[0x10] = 0;\n    piVar2[0x6f1] = 1;\n    piVar2[0x6f2] = -1;\n    return 0;\n  }\n  return 0xfffffffe;\n}\n\n"
    },
    {
      "name": "FUN_00406cf0",
      "entry": "00406cf0",
      "c": "\nundefined4 __cdecl FUN_00406cf0(int param_1,int param_2,uint param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  iVar1 = *(int *)(param_1 + 0x1c);\n  if (*(int *)(iVar1 + 0x38) == 0) {\n    iVar2 = (**(code **)(param_1 + 0x20))\n                      (*(undefined4 *)(param_1 + 0x28),\n                       1 << ((byte)*(undefined4 *)(iVar1 + 0x28) & 0x1f),1);\n    *(int *)(iVar1 + 0x38) = iVar2;\n    if (iVar2 == 0) {\n      return 1;\n    }\n  }\n  if (*(int *)(iVar1 + 0x2c) == 0) {\n    *(int *)(iVar1 + 0x2c) = 1 << ((byte)*(undefined4 *)(iVar1 + 0x28) & 0x1f);\n    *(undefined4 *)(iVar1 + 0x34) = 0;\n    *(undefined4 *)(iVar1 + 0x30) = 0;\n  }\n  uVar4 = *(uint *)(iVar1 + 0x2c);\n  if (uVar4 <= param_3) {\n    FUN_00408c90(*(uint **)(iVar1 + 0x38),(uint *)(param_2 - uVar4),uVar4);\n    *(undefined4 *)(iVar1 + 0x30) = *(undefined4 *)(iVar1 + 0x2c);\n    *(undefined4 *)(iVar1 + 0x34) = 0;\n    return 0;\n  }\n  uVar4 = uVar4 - *(int *)(iVar1 + 0x34);\n  if (param_3 < uVar4) {\n    uVar4 = param_3;\n  }\n  FUN_00408c90((uint *)(*(int *)(iVar1 + 0x38) + *(int *)(iVar1 + 0x34)),(uint *)(param_2 - param_3)\n               ,uVar4);\n  uVar3 = param_3 - uVar4;\n  if (uVar3 != 0) {\n    FUN_00408c90(*(uint **)(iVar1 + 0x38),(uint *)(param_2 - uVar3),uVar3);\n    *(uint *)(iVar1 + 0x34) = uVar3;\n    *(undefined4 *)(iVar1 + 0x30) = *(undefined4 *)(iVar1 + 0x2c);\n    return 0;\n  }\n  *(int *)(iVar1 + 0x34) = *(int *)(iVar1 + 0x34) + uVar4;\n  if (*(uint *)(iVar1 + 0x34) == *(uint *)(iVar1 + 0x2c)) {\n    *(undefined4 *)(iVar1 + 0x34) = 0;\n  }\n  if (*(uint *)(iVar1 + 0x30) < *(uint *)(iVar1 + 0x2c)) {\n    *(uint *)(iVar1 + 0x30) = *(uint *)(iVar1 + 0x30) + uVar4;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "thunk_FUN_00406df0",
      "entry": "00406de0",
      "c": "\nuint __cdecl thunk_FUN_00406df0(uint param_1,byte *param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  int iVar12;\n  int iVar13;\n  int iVar14;\n  int iVar15;\n  int iVar16;\n  int iVar17;\n  int iVar18;\n  int iVar19;\n  uint uVar20;\n  uint uVar21;\n  \n  uVar3 = param_1 & 0xffff;\n  uVar21 = param_1 >> 0x10;\n  if (param_3 == 1) {\n    uVar3 = uVar3 + *param_2;\n    uVar20 = uVar3 - 0xfff1;\n    if (uVar3 < 0xfff1) {\n      uVar20 = uVar3;\n    }\n    uVar21 = uVar21 + uVar20;\n    uVar3 = uVar21 - 0xfff1;\n    if (uVar21 < 0xfff1) {\n      uVar3 = uVar21;\n    }\n    return uVar3 << 0x10 | uVar20;\n  }\n  if (param_2 == (byte *)0x0) {\n    return 1;\n  }\n  if (param_3 < 0x10) {\n    if (param_3 != 0) {\n      do {\n        bVar2 = *param_2;\n        param_2 = param_2 + 1;\n        uVar3 = uVar3 + bVar2;\n        uVar21 = uVar21 + uVar3;\n        param_3 = param_3 - 1;\n      } while (param_3 != 0);\n    }\n    uVar20 = uVar3 - 0xfff1;\n    if (uVar3 < 0xfff1) {\n      uVar20 = uVar3;\n    }\n    return ((uVar21 / 0xfff1) * 0xf + uVar21) * 0x10000 | uVar20;\n  }\n  if (0x15af < param_3) {\n    uVar20 = param_3 / 0x15b0;\n    do {\n      param_3 = param_3 - 0x15b0;\n      iVar19 = 0x15b;\n      do {\n        iVar4 = uVar3 + *param_2;\n        iVar5 = iVar4 + (uint)param_2[1];\n        iVar6 = iVar5 + (uint)param_2[2];\n        iVar7 = iVar6 + (uint)param_2[3];\n        iVar8 = iVar7 + (uint)param_2[4];\n        iVar9 = iVar8 + (uint)param_2[5];\n        iVar10 = iVar9 + (uint)param_2[6];\n        iVar11 = iVar10 + (uint)param_2[7];\n        iVar12 = iVar11 + (uint)param_2[8];\n        iVar13 = iVar12 + (uint)param_2[9];\n        iVar14 = iVar13 + (uint)param_2[10];\n        iVar15 = iVar14 + (uint)param_2[0xb];\n        iVar16 = iVar15 + (uint)param_2[0xc];\n        iVar17 = iVar16 + (uint)param_2[0xd];\n        iVar18 = iVar17 + (uint)param_2[0xe];\n        pbVar1 = param_2 + 0xf;\n        param_2 = param_2 + 0x10;\n        uVar3 = iVar18 + (uint)*pbVar1;\n        uVar21 = uVar21 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 + iVar12 +\n                 iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + uVar3;\n        iVar19 = iVar19 + -1;\n      } while (iVar19 != 0);\n      uVar3 = uVar3 % 0xfff1;\n      uVar21 = uVar21 % 0xfff1;\n      uVar20 = uVar20 - 1;\n    } while (uVar20 != 0);\n  }\n  if (param_3 != 0) {\n    if (0xf < param_3) {\n      uVar20 = param_3 >> 4;\n      do {\n        param_3 = param_3 - 0x10;\n        iVar19 = uVar3 + *param_2;\n        iVar4 = iVar19 + (uint)param_2[1];\n        iVar5 = iVar4 + (uint)param_2[2];\n        iVar6 = iVar5 + (uint)param_2[3];\n        iVar7 = iVar6 + (uint)param_2[4];\n        iVar8 = iVar7 + (uint)param_2[5];\n        iVar9 = iVar8 + (uint)param_2[6];\n        iVar10 = iVar9 + (uint)param_2[7];\n        iVar11 = iVar10 + (uint)param_2[8];\n        iVar12 = iVar11 + (uint)param_2[9];\n        iVar13 = iVar12 + (uint)param_2[10];\n        iVar14 = iVar13 + (uint)param_2[0xb];\n        iVar15 = iVar14 + (uint)param_2[0xc];\n        iVar16 = iVar15 + (uint)param_2[0xd];\n        iVar17 = iVar16 + (uint)param_2[0xe];\n        pbVar1 = param_2 + 0xf;\n        param_2 = param_2 + 0x10;\n        uVar3 = iVar17 + (uint)*pbVar1;\n        uVar21 = uVar21 + iVar19 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 +\n                 iVar12 + iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + uVar3;\n        uVar20 = uVar20 - 1;\n      } while (uVar20 != 0);\n    }\n    for (; param_3 != 0; param_3 = param_3 - 1) {\n      bVar2 = *param_2;\n      param_2 = param_2 + 1;\n      uVar3 = uVar3 + bVar2;\n      uVar21 = uVar21 + uVar3;\n    }\n    uVar3 = uVar3 % 0xfff1;\n    uVar21 = uVar21 % 0xfff1;\n  }\n  return uVar21 << 0x10 | uVar3;\n}\n\n"
    },
    {
      "name": "FUN_00406df0",
      "entry": "00406df0",
      "c": "\nuint __cdecl FUN_00406df0(uint param_1,byte *param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  int iVar12;\n  int iVar13;\n  int iVar14;\n  int iVar15;\n  int iVar16;\n  int iVar17;\n  int iVar18;\n  int iVar19;\n  uint uVar20;\n  uint uVar21;\n  \n  uVar3 = param_1 & 0xffff;\n  uVar21 = param_1 >> 0x10;\n  if (param_3 == 1) {\n    uVar3 = uVar3 + *param_2;\n    uVar20 = uVar3 - 0xfff1;\n    if (uVar3 < 0xfff1) {\n      uVar20 = uVar3;\n    }\n    uVar21 = uVar21 + uVar20;\n    uVar3 = uVar21 - 0xfff1;\n    if (uVar21 < 0xfff1) {\n      uVar3 = uVar21;\n    }\n    return uVar3 << 0x10 | uVar20;\n  }\n  if (param_2 == (byte *)0x0) {\n    return 1;\n  }\n  if (param_3 < 0x10) {\n    if (param_3 != 0) {\n      do {\n        bVar2 = *param_2;\n        param_2 = param_2 + 1;\n        uVar3 = uVar3 + bVar2;\n        uVar21 = uVar21 + uVar3;\n        param_3 = param_3 - 1;\n      } while (param_3 != 0);\n    }\n    uVar20 = uVar3 - 0xfff1;\n    if (uVar3 < 0xfff1) {\n      uVar20 = uVar3;\n    }\n    return ((uVar21 / 0xfff1) * 0xf + uVar21) * 0x10000 | uVar20;\n  }\n  if (0x15af < param_3) {\n    uVar20 = param_3 / 0x15b0;\n    do {\n      param_3 = param_3 - 0x15b0;\n      iVar19 = 0x15b;\n      do {\n        iVar4 = uVar3 + *param_2;\n        iVar5 = iVar4 + (uint)param_2[1];\n        iVar6 = iVar5 + (uint)param_2[2];\n        iVar7 = iVar6 + (uint)param_2[3];\n        iVar8 = iVar7 + (uint)param_2[4];\n        iVar9 = iVar8 + (uint)param_2[5];\n        iVar10 = iVar9 + (uint)param_2[6];\n        iVar11 = iVar10 + (uint)param_2[7];\n        iVar12 = iVar11 + (uint)param_2[8];\n        iVar13 = iVar12 + (uint)param_2[9];\n        iVar14 = iVar13 + (uint)param_2[10];\n        iVar15 = iVar14 + (uint)param_2[0xb];\n        iVar16 = iVar15 + (uint)param_2[0xc];\n        iVar17 = iVar16 + (uint)param_2[0xd];\n        iVar18 = iVar17 + (uint)param_2[0xe];\n        pbVar1 = param_2 + 0xf;\n        param_2 = param_2 + 0x10;\n        uVar3 = iVar18 + (uint)*pbVar1;\n        uVar21 = uVar21 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 + iVar12 +\n                 iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + uVar3;\n        iVar19 = iVar19 + -1;\n      } while (iVar19 != 0);\n      uVar3 = uVar3 % 0xfff1;\n      uVar21 = uVar21 % 0xfff1;\n      uVar20 = uVar20 - 1;\n    } while (uVar20 != 0);\n  }\n  if (param_3 != 0) {\n    if (0xf < param_3) {\n      uVar20 = param_3 >> 4;\n      do {\n        param_3 = param_3 - 0x10;\n        iVar19 = uVar3 + *param_2;\n        iVar4 = iVar19 + (uint)param_2[1];\n        iVar5 = iVar4 + (uint)param_2[2];\n        iVar6 = iVar5 + (uint)param_2[3];\n        iVar7 = iVar6 + (uint)param_2[4];\n        iVar8 = iVar7 + (uint)param_2[5];\n        iVar9 = iVar8 + (uint)param_2[6];\n        iVar10 = iVar9 + (uint)param_2[7];\n        iVar11 = iVar10 + (uint)param_2[8];\n        iVar12 = iVar11 + (uint)param_2[9];\n        iVar13 = iVar12 + (uint)param_2[10];\n        iVar14 = iVar13 + (uint)param_2[0xb];\n        iVar15 = iVar14 + (uint)param_2[0xc];\n        iVar16 = iVar15 + (uint)param_2[0xd];\n        iVar17 = iVar16 + (uint)param_2[0xe];\n        pbVar1 = param_2 + 0xf;\n        param_2 = param_2 + 0x10;\n        uVar3 = iVar17 + (uint)*pbVar1;\n        uVar21 = uVar21 + iVar19 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 +\n                 iVar12 + iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + uVar3;\n        uVar20 = uVar20 - 1;\n      } while (uVar20 != 0);\n    }\n    for (; param_3 != 0; param_3 = param_3 - 1) {\n      bVar2 = *param_2;\n      param_2 = param_2 + 1;\n      uVar3 = uVar3 + bVar2;\n      uVar21 = uVar21 + uVar3;\n    }\n    uVar3 = uVar3 % 0xfff1;\n    uVar21 = uVar21 % 0xfff1;\n  }\n  return uVar21 << 0x10 | uVar3;\n}\n\n"
    },
    {
      "name": "FUN_00407060",
      "entry": "00407060",
      "c": "\nuint * __cdecl FUN_00407060(uint param_1,uint *param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_2 == (uint *)0x0) {\n    return param_2;\n  }\n  uVar1 = ~param_1;\n  if (param_3 != 0) {\n    do {\n      if (((uint)param_2 & 3) == 0) break;\n      uVar2 = *param_2;\n      param_2 = (uint *)((int)param_2 + 1);\n      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_00423c28 + (((byte)uVar2 ^ uVar1) & 0xff) * 4);\n      param_3 = param_3 - 1;\n    } while (param_3 != 0);\n  }\n  if (0x1f < param_3) {\n    uVar2 = param_3 >> 5;\n    do {\n      uVar1 = uVar1 ^ *param_2;\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4) ^ param_2[1];\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4) ^ param_2[2];\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4) ^ param_2[3];\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4) ^ param_2[4];\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4) ^ param_2[5];\n      param_3 = param_3 - 0x20;\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4) ^ param_2[6];\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4) ^ param_2[7];\n      param_2 = param_2 + 8;\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4);\n      uVar2 = uVar2 - 1;\n    } while (uVar2 != 0);\n  }\n  if (3 < param_3) {\n    uVar2 = param_3 >> 2;\n    do {\n      uVar1 = uVar1 ^ *param_2;\n      param_3 = param_3 - 4;\n      param_2 = param_2 + 1;\n      uVar1 = *(uint *)(&DAT_00424028 + (uVar1 >> 0x10 & 0xff) * 4) ^\n              *(uint *)(&DAT_00424428 + (uVar1 >> 8 & 0xff) * 4) ^\n              *(uint *)(&DAT_00423c28 + (uVar1 >> 0x18) * 4) ^\n              *(uint *)(&DAT_00424828 + (uVar1 & 0xff) * 4);\n      uVar2 = uVar2 - 1;\n    } while (uVar2 != 0);\n  }\n  for (; param_3 != 0; param_3 = param_3 - 1) {\n    uVar2 = *param_2;\n    param_2 = (uint *)((int)param_2 + 1);\n    uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_00423c28 + (((byte)uVar2 ^ uVar1) & 0xff) * 4);\n  }\n  return (uint *)~uVar1;\n}\n\n"
    },
    {
      "name": "FUN_00407320",
      "entry": "00407320",
      "c": "\nvoid __cdecl FUN_00407320(undefined4 param_1,int param_2,int param_3)\n\n{\n  FUN_00409dbb(param_2 * param_3);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00407340",
      "entry": "00407340",
      "c": "\nvoid __cdecl FUN_00407340(undefined4 param_1,void *param_2)\n\n{\n  FID_conflict__free(param_2);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00407350",
      "entry": "00407350",
      "c": "\nvoid __cdecl\nFUN_00407350(int param_1,int param_2,uint param_3,int *param_4,uint *param_5,ushort *param_6)\n\n{\n  code *pcVar1;\n  byte bVar2;\n  ushort uVar3;\n  uint uVar4;\n  ushort *puVar5;\n  uint uVar6;\n  uint *puVar7;\n  byte bVar8;\n  int iVar9;\n  uint uVar10;\n  char cVar11;\n  uint uVar12;\n  int iVar13;\n  bool bVar14;\n  bool bVar15;\n  undefined4 local_90;\n  uint local_8c;\n  int local_88;\n  uint local_84;\n  uint local_80;\n  uint local_7c;\n  uint local_78;\n  ushort *local_74;\n  ushort *local_70;\n  ushort *local_6c;\n  uint local_68;\n  uint local_64;\n  int *local_60;\n  int local_5c;\n  uint local_58;\n  uint *local_54;\n  uint local_50;\n  uint local_4c;\n  uint local_48;\n  ushort local_44 [16];\n  ushort auStack_24 [16];\n  uint local_4;\n  \n  local_4 = DAT_0042d008 ^ (uint)&local_90;\n  uVar4 = 0;\n  local_5c = param_2;\n  local_60 = param_4;\n  local_54 = param_5;\n  local_6c = param_6;\n  do {\n    if (0x1f < uVar4) {\n      ___report_rangecheckfailure();\n      pcVar1 = (code *)swi(3);\n      (*pcVar1)();\n      return;\n    }\n    uVar6 = 0;\n    *(undefined2 *)((int)local_44 + uVar4) = 0;\n    uVar4 = uVar4 + 2;\n  } while (uVar4 < 0x1f);\n  if (param_3 != 0) {\n    do {\n      iVar9 = uVar6 * 2;\n      uVar6 = uVar6 + 1;\n      local_44[*(ushort *)(param_2 + iVar9)] = local_44[*(ushort *)(param_2 + iVar9)] + 1;\n    } while (uVar6 < param_3);\n  }\n  puVar5 = local_44 + 0xd;\n  uVar4 = 0xf;\n  do {\n    if (puVar5[2] != 0) break;\n    if (puVar5[1] != 0) {\n      uVar4 = uVar4 - 1;\n      break;\n    }\n    if (*puVar5 != 0) {\n      uVar4 = uVar4 - 2;\n      break;\n    }\n    if (puVar5[-1] != 0) {\n      uVar4 = uVar4 - 3;\n      break;\n    }\n    if (puVar5[-2] != 0) {\n      uVar4 = uVar4 - 4;\n      break;\n    }\n    uVar4 = uVar4 - 5;\n    puVar5 = puVar5 + -5;\n  } while (uVar4 != 0);\n  uVar6 = *param_5;\n  if (uVar4 < *param_5) {\n    uVar6 = uVar4;\n  }\n  uVar10 = local_68;\n  if (uVar4 == 0) {\n    local_90 = 0x140;\n    *(undefined4 *)*param_4 = 0x140;\n    *param_4 = *param_4 + 4;\n    *(undefined4 *)*param_4 = 0x140;\n    *param_4 = *param_4 + 4;\n    *param_5 = 1;\n  }\n  else {\n    uVar12 = 1;\n    local_80 = 1;\n    if (1 < uVar4) {\n      do {\n        local_80 = uVar12;\n        if (local_44[uVar12] != 0) break;\n        uVar12 = uVar12 + 1;\n        local_80 = uVar12;\n      } while (uVar12 < uVar4);\n    }\n    iVar9 = 1;\n    local_7c = uVar6;\n    if (uVar6 < local_80) {\n      local_7c = local_80;\n    }\n    uVar6 = 1;\n    do {\n      iVar9 = iVar9 * 2 - (uint)local_44[uVar6];\n      if (iVar9 < 0) goto LAB_0040744e;\n      uVar6 = uVar6 + 1;\n    } while (uVar6 < 0x10);\n    if ((iVar9 < 1) || ((param_1 != 0 && (uVar4 == 1)))) {\n      uVar6 = 2;\n      auStack_24[1] = 0;\n      do {\n        *(short *)((int)auStack_24 + uVar6 + 2) =\n             *(short *)((int)auStack_24 + uVar6) + *(short *)((int)local_44 + uVar6);\n        uVar6 = uVar6 + 2;\n      } while (uVar6 < 0x1e);\n      uVar6 = 0;\n      if (param_3 != 0) {\n        do {\n          uVar3 = *(ushort *)(param_2 + uVar6 * 2);\n          if (uVar3 != 0) {\n            param_6[auStack_24[uVar3]] = (ushort)uVar6;\n            auStack_24[*(ushort *)(param_2 + uVar6 * 2)] =\n                 auStack_24[*(ushort *)(param_2 + uVar6 * 2)] + 1;\n          }\n          uVar6 = uVar6 + 1;\n        } while (uVar6 < param_3);\n      }\n      if (param_1 == 0) {\n        local_74 = param_6;\n        local_70 = param_6;\n        local_78 = 0x14;\n      }\n      else if (param_1 == 1) {\n        local_70 = (ushort *)&DAT_00425d00;\n        local_74 = (ushort *)&DAT_00425d40;\n        local_78 = 0x101;\n      }\n      else {\n        local_70 = (ushort *)&DAT_00425d80;\n        local_74 = (ushort *)&DAT_00425dc0;\n        local_78 = 0;\n      }\n      local_84 = 0;\n      local_8c = 0;\n      local_58 = 0xffffffff;\n      local_88 = *param_4;\n      local_68 = 1 << ((byte)local_7c & 0x1f);\n      local_50 = local_68 - 1;\n      uVar6 = local_80;\n      uVar10 = local_68;\n      local_64 = local_68;\n      if (param_1 == 1) {\n        if (local_68 < 0x355) {\nLAB_004075e4:\n          cVar11 = (char)uVar6;\n          bVar8 = (byte)local_8c;\n          bVar2 = cVar11 - bVar8;\n          uVar10 = (uint)*local_6c;\n          if (uVar10 + 1 < local_78) {\n            local_90 = (uint)CONCAT21(*local_6c,bVar2) << 8;\n          }\n          else {\n            if (uVar10 < local_78) {\n              local_90 = CONCAT31((uint3)bVar2,0x60);\n              uVar3 = 0;\n            }\n            else {\n              local_90._0_2_ = CONCAT11(bVar2,(char)local_74[uVar10 - local_78]);\n              uVar3 = local_70[uVar10 - local_78];\n            }\n            local_90 = CONCAT22(uVar3,(ushort)local_90);\n          }\n          iVar9 = 1 << (cVar11 - bVar8 & 0x1f);\n          puVar7 = (uint *)(local_88 + ((local_84 >> (bVar8 & 0x1f)) + local_68) * 4);\n          uVar10 = local_68;\n          do {\n            puVar7 = puVar7 + -iVar9;\n            *puVar7 = local_90;\n            uVar10 = uVar10 - iVar9;\n          } while (uVar10 != 0);\n          for (uVar10 = 1 << (cVar11 - 1U & 0x1f); (local_84 & uVar10) != 0; uVar10 = uVar10 >> 1) {\n          }\n          if (uVar10 == 0) {\n            local_84 = 0;\n          }\n          else {\n            local_84 = (uVar10 - 1 & local_84) + uVar10;\n          }\n          local_6c = local_6c + 1;\n          puVar5 = local_44 + uVar6;\n          *puVar5 = *puVar5 - 1;\n          local_4c = local_68;\n          if (*puVar5 == 0) {\n            if (uVar6 == uVar4) {\n              if (local_84 != 0) {\n                local_90._0_2_ = CONCAT11(cVar11 - bVar8,0x40);\n                local_90 = (uint)(ushort)local_90;\n                *(uint *)(local_88 + local_84 * 4) = local_90;\n              }\n              *param_4 = *param_4 + local_64 * 4;\n              *param_5 = local_7c;\n              uVar10 = local_68;\n              goto LAB_0040744e;\n            }\n            uVar6 = (uint)*(ushort *)(param_2 + (uint)*local_6c * 2);\n            local_80 = uVar6;\n          }\n          if ((local_7c < uVar6) && (local_48 = local_50 & local_84, local_48 != local_58)) {\n            if (local_8c == 0) {\n              local_8c = local_7c;\n            }\n            iVar13 = uVar6 - local_8c;\n            uVar6 = local_8c + iVar13;\n            local_88 = local_88 + local_68 * 4;\n            iVar9 = 1 << ((byte)iVar13 & 0x1f);\n            if (uVar6 < uVar4) {\n              puVar5 = local_44 + uVar6;\n              do {\n                uVar3 = *puVar5;\n                if ((int)(iVar9 - (uint)uVar3) < 1) break;\n                uVar6 = uVar6 + 1;\n                iVar13 = iVar13 + 1;\n                puVar5 = puVar5 + 1;\n                iVar9 = (iVar9 - (uint)uVar3) * 2;\n              } while (uVar6 < uVar4);\n            }\n            uVar10 = 1 << ((byte)iVar13 & 0x1f);\n            local_64 = local_64 + uVar10;\n            if (param_1 == 1) {\n              bVar14 = local_64 < 0x354;\n              bVar15 = local_64 == 0x354;\nLAB_00407771:\n              if (!bVar14 && !bVar15) goto LAB_0040744e;\n            }\n            else if (param_1 == 2) {\n              bVar14 = local_64 < 0x250;\n              bVar15 = local_64 == 0x250;\n              goto LAB_00407771;\n            }\n            *(byte *)(*param_4 + local_48 * 4) = (byte)iVar13;\n            *(byte *)(*param_4 + 1 + local_48 * 4) = (byte)local_7c;\n            *(short *)(*param_4 + 2 + local_48 * 4) = (short)(local_88 - *param_4 >> 2);\n            uVar6 = local_80;\n            local_68 = uVar10;\n            local_58 = local_48;\n          }\n          goto LAB_004075e4;\n        }\n      }\n      else if ((param_1 != 2) || (local_68 < 0x251)) goto LAB_004075e4;\n    }\n  }\nLAB_0040744e:\n  local_68 = uVar10;\n  __security_check_cookie(local_4 ^ (uint)&local_90);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00407800",
      "entry": "00407800",
      "c": "\nvoid __cdecl FUN_00407800(int *param_1,int param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  undefined1 uVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  undefined1 *puVar9;\n  int iVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  byte *pbVar13;\n  uint uVar14;\n  uint uVar15;\n  uint uVar16;\n  int iVar17;\n  int iVar18;\n  char cVar19;\n  uint uVar20;\n  uint uVar21;\n  int iVar22;\n  undefined1 *puVar23;\n  undefined1 *puVar24;\n  undefined1 *puVar25;\n  uint uVar26;\n  undefined1 *puVar27;\n  byte *local_38;\n  \n  iVar4 = param_1[7];\n  local_38 = (byte *)*param_1;\n  puVar5 = (undefined1 *)param_1[3];\n  pbVar13 = local_38 + param_1[1] + -5;\n  iVar6 = param_1[4];\n  uVar21 = *(uint *)(iVar4 + 0x40);\n  iVar18 = *(int *)(iVar4 + 0x2c);\n  uVar7 = *(uint *)(iVar4 + 0x30);\n  uVar8 = *(uint *)(iVar4 + 0x34);\n  puVar9 = *(undefined1 **)(iVar4 + 0x38);\n  iVar22 = *(int *)(iVar4 + 0x50);\n  iVar10 = *(int *)(iVar4 + 0x54);\n  uVar11 = *(undefined4 *)(iVar4 + 0x58);\n  uVar12 = *(undefined4 *)(iVar4 + 0x5c);\n  uVar26 = *(uint *)(iVar4 + 0x3c);\n  puVar23 = puVar5;\nLAB_00407890:\n  if (uVar21 < 0xf) {\n    bVar2 = *local_38;\n    pbVar1 = local_38 + 1;\n    local_38 = local_38 + 2;\n    uVar26 = uVar26 + ((uint)bVar2 << ((byte)uVar21 & 0x1f)) +\n             ((uint)*pbVar1 << ((byte)uVar21 + 8 & 0x1f));\n    uVar21 = uVar21 + 0x10;\n  }\n  uVar15 = *(uint *)(iVar22 + ((1 << ((byte)uVar11 & 0x1f)) - 1U & uVar26) * 4);\n  uVar26 = uVar26 >> ((byte)(uVar15 >> 8) & 0x1f);\n  uVar21 = uVar21 - (uVar15 >> 8 & 0xff);\n  cVar19 = (char)uVar15;\n  while (cVar19 != '\\0') {\n    puVar24 = puVar23;\n    if ((uVar15 & 0x10) != 0) {\n      uVar20 = uVar15 >> 0x10;\n      uVar15 = uVar15 & 0xf;\n      if (uVar15 != 0) {\n        if (uVar21 < uVar15) {\n          uVar26 = uVar26 + ((uint)*local_38 << ((byte)uVar21 & 0x1f));\n          uVar21 = uVar21 + 8;\n          local_38 = local_38 + 1;\n        }\n        uVar14 = (1 << (sbyte)uVar15) - 1U & uVar26;\n        uVar26 = uVar26 >> (sbyte)uVar15;\n        uVar20 = uVar20 + uVar14;\n        uVar21 = uVar21 - uVar15;\n      }\n      if (uVar21 < 0xf) {\n        bVar2 = *local_38;\n        pbVar1 = local_38 + 1;\n        local_38 = local_38 + 2;\n        uVar26 = uVar26 + ((uint)bVar2 << ((byte)uVar21 & 0x1f)) +\n                 ((uint)*pbVar1 << ((byte)uVar21 + 8 & 0x1f));\n        uVar21 = uVar21 + 0x10;\n      }\n      uVar15 = *(uint *)(iVar10 + ((1 << ((byte)uVar12 & 0x1f)) - 1U & uVar26) * 4);\n      uVar21 = uVar21 - (uVar15 >> 8 & 0xff);\n      uVar26 = uVar26 >> ((byte)(uVar15 >> 8) & 0x1f);\n      goto joined_r0x00407993;\n    }\n    if ((uVar15 & 0x40) != 0) {\n      if ((uVar15 & 0x20) == 0) {\n        param_1[6] = (int)\"invalid literal/length code\";\n        goto LAB_00407bc6;\n      }\n      *(undefined4 *)(iVar4 + 4) = 0x3f3f;\n      goto LAB_00407bcd;\n    }\n    uVar15 = *(uint *)(iVar22 + (((1 << ((byte)uVar15 & 0x1f)) - 1U & uVar26) + (uVar15 >> 0x10)) *\n                                4);\n    uVar26 = uVar26 >> ((byte)(uVar15 >> 8) & 0x1f);\n    uVar21 = uVar21 - (uVar15 >> 8 & 0xff);\n    cVar19 = (char)uVar15;\n  }\n  *puVar23 = (char)(uVar15 >> 0x10);\n  puVar24 = puVar23 + 1;\n  goto LAB_00407b21;\njoined_r0x00407993:\n  if ((uVar15 & 0x10) != 0) goto LAB_004079d2;\n  if ((uVar15 & 0x40) != 0) {\n    param_1[6] = (int)\"invalid distance code\";\n    goto LAB_00407bc6;\n  }\n  uVar15 = *(uint *)(iVar10 + (((1 << ((byte)uVar15 & 0x1f)) - 1U & uVar26) + (uVar15 >> 0x10)) * 4)\n  ;\n  uVar21 = uVar21 - (uVar15 >> 8 & 0xff);\n  uVar26 = uVar26 >> ((byte)(uVar15 >> 8) & 0x1f);\n  goto joined_r0x00407993;\nLAB_004079d2:\n  uVar16 = uVar15 & 0xf;\n  uVar14 = uVar21;\n  pbVar1 = local_38;\n  if (uVar21 < uVar16) {\n    uVar14 = uVar21 + 8;\n    uVar26 = uVar26 + ((uint)*local_38 << ((byte)uVar21 & 0x1f));\n    pbVar1 = local_38 + 1;\n    if (uVar14 < uVar16) {\n      uVar26 = uVar26 + ((uint)local_38[1] << ((byte)uVar14 & 0x1f));\n      uVar14 = uVar21 + 0x10;\n      pbVar1 = local_38 + 2;\n    }\n  }\n  local_38 = pbVar1;\n  uVar21 = uVar14 - uVar16;\n  uVar14 = (1 << (sbyte)uVar16) - 1U & uVar26;\n  uVar26 = uVar26 >> (sbyte)uVar16;\n  uVar14 = (uVar15 >> 0x10) + uVar14;\n  if (uVar14 <= (uint)((int)puVar23 - (int)(puVar5 + (iVar6 - param_2)))) {\n    puVar24 = puVar23 + -uVar14;\n    do {\n      puVar25 = puVar23;\n      puVar27 = puVar24;\n      *puVar25 = *puVar27;\n      uVar20 = uVar20 - 3;\n      puVar25[1] = puVar27[1];\n      puVar25[2] = puVar27[2];\n      puVar23 = puVar25 + 3;\n      puVar24 = puVar27 + 3;\n    } while (2 < uVar20);\n    puVar24 = puVar23;\n    if (uVar20 != 0) {\n      *puVar23 = puVar27[3];\n      puVar24 = puVar25 + 4;\n      if (1 < uVar20) {\n        puVar25[4] = puVar27[4];\n        puVar24 = puVar25 + 5;\n      }\n    }\n    goto LAB_00407b21;\n  }\n  uVar15 = uVar14 - ((int)puVar23 - (int)(puVar5 + (iVar6 - param_2)));\n  if ((uVar7 < uVar15) && (*(int *)(iVar4 + 0x1bc4) != 0)) {\n    param_1[6] = (int)\"invalid distance too far back\";\nLAB_00407bc6:\n    *(undefined4 *)(iVar4 + 4) = 0x3f51;\nLAB_00407bcd:\n    iVar18 = (int)local_38 - (uVar21 >> 3);\n    iVar22 = uVar21 + (uVar21 >> 3) * -8;\n    param_1[1] = (int)(pbVar13 + (5 - iVar18));\n    param_1[3] = (int)puVar24;\n    *param_1 = iVar18;\n    param_1[4] = (int)(puVar5 + iVar6 + -0x101 + (0x101 - (int)puVar24));\n    *(uint *)(iVar4 + 0x3c) = uVar26 & (1 << ((byte)iVar22 & 0x1f)) - 1U;\n    *(int *)(iVar4 + 0x40) = iVar22;\n    return;\n  }\n  if (uVar8 == 0) {\n    puVar27 = puVar9 + (iVar18 - uVar15);\n    if (uVar15 < uVar20) {\n      uVar20 = uVar20 - uVar15;\n      do {\n        uVar3 = *puVar27;\n        puVar27 = puVar27 + 1;\n        *puVar23 = uVar3;\n        puVar23 = puVar23 + 1;\n        uVar15 = uVar15 - 1;\n      } while (uVar15 != 0);\nLAB_00407ad2:\n      puVar27 = puVar23 + -uVar14;\n    }\n  }\n  else {\n    puVar27 = puVar9 + (uVar8 - uVar15);\n    if (uVar8 < uVar15) {\n      puVar27 = puVar27 + iVar18;\n      uVar15 = uVar15 - uVar8;\n      if (uVar15 < uVar20) {\n        uVar20 = uVar20 - uVar15;\n        iVar17 = (int)puVar27 - (int)puVar23;\n        do {\n          *puVar23 = puVar23[iVar17];\n          puVar23 = puVar23 + 1;\n          uVar15 = uVar15 - 1;\n        } while (uVar15 != 0);\n        puVar27 = puVar9;\n        if (uVar8 < uVar20) {\n          uVar20 = uVar20 - uVar8;\n          uVar15 = uVar8;\n          puVar24 = puVar9;\n          do {\n            uVar3 = *puVar24;\n            puVar24 = puVar24 + 1;\n            *puVar23 = uVar3;\n            puVar23 = puVar23 + 1;\n            uVar15 = uVar15 - 1;\n          } while (uVar15 != 0);\n          goto LAB_00407ad2;\n        }\n      }\n    }\n    else if (uVar15 < uVar20) {\n      uVar20 = uVar20 - uVar15;\n      do {\n        uVar3 = *puVar27;\n        puVar27 = puVar27 + 1;\n        *puVar23 = uVar3;\n        puVar23 = puVar23 + 1;\n        uVar15 = uVar15 - 1;\n      } while (uVar15 != 0);\n      goto LAB_00407ad2;\n    }\n  }\n  if (2 < uVar20) {\n    iVar17 = (uVar20 - 3) / 3 + 1;\n    do {\n      uVar20 = uVar20 - 3;\n      *puVar23 = *puVar27;\n      puVar23[1] = puVar27[1];\n      puVar24 = puVar27 + 2;\n      puVar27 = puVar27 + 3;\n      puVar23[2] = *puVar24;\n      puVar23 = puVar23 + 3;\n      iVar17 = iVar17 + -1;\n    } while (iVar17 != 0);\n  }\n  puVar24 = puVar23;\n  if (uVar20 != 0) {\n    *puVar23 = *puVar27;\n    puVar24 = puVar23 + 1;\n    if (1 < uVar20) {\n      *puVar24 = puVar27[1];\n      puVar24 = puVar23 + 2;\n    }\n  }\nLAB_00407b21:\n  if ((pbVar13 <= local_38) || (puVar23 = puVar24, puVar5 + iVar6 + -0x101 <= puVar24))\n  goto LAB_00407bcd;\n  goto LAB_00407890;\n}\n\n"
    },
    {
      "name": "ConvertStringSecurityDescriptorToSecurityDescriptorW",
      "entry": "00407c18",
      "c": "\nvoid ConvertStringSecurityDescriptorToSecurityDescriptorW(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00407c18. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  ConvertStringSecurityDescriptorToSecurityDescriptorW();\n  return;\n}\n\n"
    },
    {
      "name": "Ordinal_14",
      "entry": "00407c1e",
      "c": "\nvoid Ordinal_14(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00407c1e. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  Ordinal_14();\n  return;\n}\n\n"
    },
    {
      "name": "__security_check_cookie",
      "entry": "00407c24",
      "c": "\n/* Library Function - Single Match\n    @__security_check_cookie@4\n   \n   Library: Visual Studio 2015 Release\n   __fastcall __security_check_cookie,4 */\n\nvoid __fastcall __security_check_cookie(int param_1)\n\n{\n  if (param_1 == DAT_0042d008) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  ___report_gsfailure();\n}\n\n"
    },
    {
      "name": "__alloca_probe",
      "entry": "00407c40",
      "c": "\n/* WARNING: This is an inlined function */\n/* Library Function - Single Match\n    __alloca_probe\n   \n   Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */\n\nvoid __alloca_probe(void)\n\n{\n  undefined1 *in_EAX;\n  undefined4 *puVar1;\n  undefined4 *puVar2;\n  undefined4 unaff_retaddr;\n  undefined1 auStack_4 [4];\n  \n  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))\n  ;\n  for (puVar1 = (undefined4 *)((uint)auStack_4 & 0xfffff000); puVar2 < puVar1;\n      puVar1 = puVar1 + -0x400) {\n  }\n  *puVar2 = unaff_retaddr;\n  return;\n}\n\n"
    },
    {
      "name": "__scrt_common_main_seh",
      "entry": "00407d2b",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    int __cdecl __scrt_common_main_seh(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __scrt_common_main_seh(void)\n\n{\n  code *pcVar1;\n  bool bVar2;\n  undefined4 uVar3;\n  int iVar4;\n  int *piVar5;\n  uint *puVar6;\n  undefined4 *puVar7;\n  uint uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  \n  uVar3 = ___scrt_initialize_crt(1);\n  if ((char)uVar3 != '\\0') goto LAB_00407d4a;\n  do {\n    ___scrt_fastfail();\nLAB_00407d4a:\n    bVar2 = false;\n    uVar3 = ___scrt_acquire_startup_lock();\n  } while (DAT_0043ad84 == 1);\n  if (DAT_0043ad84 == 0) {\n    DAT_0043ad84 = 1;\n    iVar4 = __initterm_e((undefined4 *)&DAT_0042119c,(undefined4 *)&DAT_004211b8);\n    if (iVar4 != 0) {\n      return 0xff;\n    }\n    __initterm((undefined4 *)&DAT_00421190,(undefined4 *)&DAT_00421198);\n    DAT_0043ad84 = 2;\n  }\n  else {\n    bVar2 = true;\n  }\n  ___scrt_release_startup_lock((char)uVar3);\n  piVar5 = (int *)FUN_004084c9();\n  if ((*piVar5 != 0) &&\n     (uVar3 = ___scrt_is_nonwritable_in_current_image((int)piVar5), (char)uVar3 != '\\0')) {\n    uVar10 = 0;\n    uVar9 = 2;\n    uVar3 = 0;\n    pcVar1 = (code *)*piVar5;\n    guard_check_icall();\n    (*pcVar1)(uVar3,uVar9,uVar10);\n  }\n  puVar6 = (uint *)FUN_004084cf();\n  if ((*puVar6 != 0) &&\n     (uVar3 = ___scrt_is_nonwritable_in_current_image((int)puVar6), (char)uVar3 != '\\0')) {\n    __register_thread_local_exe_atexit_callback(*puVar6);\n  }\n  puVar7 = FUN_00409a59();\n  puVar6 = (uint *)FUN_00409a53();\n  iVar4 = FID_conflict___get_initial_narrow_environment();\n  iVar4 = FUN_00401000(*puVar6,*puVar7,iVar4);\n  uVar8 = ___scrt_is_managed_app();\n  if ((char)uVar8 != '\\0') {\n    if (!bVar2) {\n      __cexit();\n    }\n    ___scrt_uninitialize_crt('\\x01','\\0');\n    return iVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  _exit(iVar4);\n}\n\n"
    },
    {
      "name": "entry",
      "entry": "00407e9a",
      "c": "\nvoid entry(void)\n\n{\n  ___security_init_cookie();\n  __scrt_common_main_seh();\n  return;\n}\n\n"
    },
    {
      "name": "__alldiv",
      "entry": "00407eb0",
      "c": "\n/* Library Function - Single Match\n    __alldiv\n   \n   Library: Visual Studio 2015 Release */\n\nundefined8 __alldiv(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  bool bVar10;\n  char cVar11;\n  uint uVar9;\n  \n  cVar11 = (int)param_2 < 0;\n  if ((bool)cVar11) {\n    bVar10 = param_1 != 0;\n    param_1 = -param_1;\n    param_2 = -(uint)bVar10 - param_2;\n  }\n  if ((int)param_4 < 0) {\n    cVar11 = cVar11 + '\\x01';\n    bVar10 = param_3 != 0;\n    param_3 = -param_3;\n    param_4 = -(uint)bVar10 - param_4;\n  }\n  uVar3 = param_1;\n  uVar5 = param_3;\n  uVar6 = param_2;\n  uVar9 = param_4;\n  if (param_4 == 0) {\n    uVar3 = param_2 / param_3;\n    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /\n                 (ulonglong)param_3);\n  }\n  else {\n    do {\n      uVar8 = uVar9 >> 1;\n      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;\n      uVar7 = uVar6 >> 1;\n      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;\n      uVar6 = uVar7;\n      uVar9 = uVar8;\n    } while (uVar8 != 0);\n    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;\n    iVar4 = (int)uVar1;\n    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);\n    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);\n    uVar5 = uVar3 + iVar4 * param_4;\n    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||\n       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {\n      iVar4 = iVar4 + -1;\n    }\n    uVar3 = 0;\n  }\n  if (cVar11 == '\\x01') {\n    bVar10 = iVar4 != 0;\n    iVar4 = -iVar4;\n    uVar3 = -(uint)bVar10 - uVar3;\n  }\n  return CONCAT44(uVar3,iVar4);\n}\n\n"
    },
    {
      "name": "___raise_securityfailure",
      "entry": "00407f5a",
      "c": "\n/* Library Function - Single Match\n    ___raise_securityfailure\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___raise_securityfailure(_EXCEPTION_POINTERS *param_1)\n\n{\n  HANDLE hProcess;\n  UINT uExitCode;\n  \n  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n  UnhandledExceptionFilter(param_1);\n  uExitCode = 0xc0000409;\n  hProcess = GetCurrentProcess();\n  TerminateProcess(hProcess,uExitCode);\n  return;\n}\n\n"
    },
    {
      "name": "___report_gsfailure",
      "entry": "00407f82",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___report_gsfailure\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___report_gsfailure(void)\n\n{\n  code *pcVar1;\n  uint uVar2;\n  undefined4 extraout_ECX;\n  undefined4 extraout_ECX_00;\n  undefined4 uVar3;\n  undefined4 extraout_EDX;\n  undefined4 unaff_EBX;\n  undefined4 unaff_EBP;\n  undefined4 unaff_ESI;\n  undefined4 unaff_EDI;\n  undefined2 in_ES;\n  undefined2 in_CS;\n  undefined2 in_SS;\n  undefined2 in_DS;\n  undefined2 in_FS;\n  undefined2 in_GS;\n  byte bVar4;\n  byte bVar5;\n  byte in_AF;\n  byte bVar6;\n  byte bVar7;\n  byte in_TF;\n  byte in_IF;\n  byte bVar8;\n  byte in_NT;\n  byte in_AC;\n  byte in_VIF;\n  byte in_VIP;\n  byte in_ID;\n  undefined8 uVar9;\n  undefined4 unaff_retaddr;\n  \n  uVar2 = IsProcessorFeaturePresent(0x17);\n  uVar9 = CONCAT44(extraout_EDX,uVar2);\n  bVar4 = 0;\n  bVar8 = 0;\n  bVar7 = (int)uVar2 < 0;\n  bVar6 = uVar2 == 0;\n  bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n  uVar3 = extraout_ECX;\n  if (!(bool)bVar6) {\n    pcVar1 = (code *)swi(0x29);\n    uVar9 = (*pcVar1)();\n    uVar3 = extraout_ECX_00;\n  }\n  _DAT_0043ab60 = (undefined4)((ulonglong)uVar9 >> 0x20);\n  _DAT_0043ab68 = (undefined4)uVar9;\n  _DAT_0043ab78 =\n       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar8 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |\n       (uint)(in_TF & 1) * 0x100 | (uint)(bVar7 & 1) * 0x80 | (uint)(bVar6 & 1) * 0x40 |\n       (uint)(in_AF & 1) * 0x10 | (uint)(bVar5 & 1) * 4 | (uint)(bVar4 & 1) |\n       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |\n       (uint)(in_AC & 1) * 0x40000;\n  _DAT_0043ab7c = &stack0x00000004;\n  _DAT_0043aab8 = 0x10001;\n  _DAT_0043aa68 = 0xc0000409;\n  _DAT_0043aa6c = 1;\n  _DAT_0043aa78 = 1;\n  DAT_0043aa7c = 2;\n  _DAT_0043aa74 = unaff_retaddr;\n  _DAT_0043ab44 = in_GS;\n  _DAT_0043ab48 = in_FS;\n  _DAT_0043ab4c = in_ES;\n  _DAT_0043ab50 = in_DS;\n  _DAT_0043ab54 = unaff_EDI;\n  _DAT_0043ab58 = unaff_ESI;\n  _DAT_0043ab5c = unaff_EBX;\n  _DAT_0043ab64 = uVar3;\n  _DAT_0043ab6c = unaff_EBP;\n  DAT_0043ab70 = unaff_retaddr;\n  _DAT_0043ab74 = in_CS;\n  _DAT_0043ab80 = in_SS;\n  ___raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_00425e00);\n  return;\n}\n\n"
    },
    {
      "name": "___report_rangecheckfailure",
      "entry": "0040807d",
      "c": "\n/* Library Function - Single Match\n    ___report_rangecheckfailure\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___report_rangecheckfailure(void)\n\n{\n  ___report_securityfailure(8);\n  return;\n}\n\n"
    },
    {
      "name": "___report_securityfailure",
      "entry": "00408089",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___report_securityfailure\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___report_securityfailure(undefined4 param_1)\n\n{\n  code *pcVar1;\n  uint uVar2;\n  undefined4 extraout_ECX;\n  undefined4 extraout_ECX_00;\n  undefined4 uVar3;\n  undefined4 extraout_EDX;\n  undefined4 unaff_EBX;\n  undefined4 unaff_EBP;\n  undefined4 unaff_ESI;\n  undefined4 unaff_EDI;\n  undefined2 in_ES;\n  undefined2 in_CS;\n  undefined2 in_SS;\n  undefined2 in_DS;\n  undefined2 in_FS;\n  undefined2 in_GS;\n  byte bVar4;\n  byte bVar5;\n  byte in_AF;\n  byte bVar6;\n  byte bVar7;\n  byte in_TF;\n  byte in_IF;\n  byte bVar8;\n  byte in_NT;\n  byte in_AC;\n  byte in_VIF;\n  byte in_VIP;\n  byte in_ID;\n  undefined8 uVar9;\n  undefined4 unaff_retaddr;\n  \n  uVar2 = IsProcessorFeaturePresent(0x17);\n  uVar9 = CONCAT44(extraout_EDX,uVar2);\n  bVar4 = 0;\n  bVar8 = 0;\n  bVar7 = (int)uVar2 < 0;\n  bVar6 = uVar2 == 0;\n  bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n  uVar3 = extraout_ECX;\n  if (!(bool)bVar6) {\n    pcVar1 = (code *)swi(0x29);\n    uVar9 = (*pcVar1)();\n    uVar3 = extraout_ECX_00;\n  }\n  _DAT_0043ab60 = (undefined4)((ulonglong)uVar9 >> 0x20);\n  _DAT_0043ab68 = (undefined4)uVar9;\n  _DAT_0043ab78 =\n       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar8 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |\n       (uint)(in_TF & 1) * 0x100 | (uint)(bVar7 & 1) * 0x80 | (uint)(bVar6 & 1) * 0x40 |\n       (uint)(in_AF & 1) * 0x10 | (uint)(bVar5 & 1) * 4 | (uint)(bVar4 & 1) |\n       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |\n       (uint)(in_AC & 1) * 0x40000;\n  _DAT_0043ab7c = &param_1;\n  _DAT_0043aa68 = 0xc0000409;\n  _DAT_0043aa6c = 1;\n  _DAT_0043aa78 = 1;\n  DAT_0043aa7c = param_1;\n  _DAT_0043aa74 = unaff_retaddr;\n  _DAT_0043ab44 = in_GS;\n  _DAT_0043ab48 = in_FS;\n  _DAT_0043ab4c = in_ES;\n  _DAT_0043ab50 = in_DS;\n  _DAT_0043ab54 = unaff_EDI;\n  _DAT_0043ab58 = unaff_ESI;\n  _DAT_0043ab5c = unaff_EBX;\n  _DAT_0043ab64 = uVar3;\n  _DAT_0043ab6c = unaff_EBP;\n  DAT_0043ab70 = unaff_retaddr;\n  _DAT_0043ab74 = in_CS;\n  _DAT_0043ab80 = in_SS;\n  ___raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_00425e00);\n  return;\n}\n\n"
    },
    {
      "name": "find_pe_section",
      "entry": "00408159",
      "c": "\n/* Library Function - Single Match\n    struct _IMAGE_SECTION_HEADER * __cdecl find_pe_section(unsigned char * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\n_IMAGE_SECTION_HEADER * __cdecl find_pe_section(uchar *param_1,uint param_2)\n\n{\n  int iVar1;\n  _IMAGE_SECTION_HEADER *p_Var2;\n  _IMAGE_SECTION_HEADER *p_Var3;\n  \n  iVar1 = *(int *)(param_1 + 0x3c);\n  p_Var2 = (_IMAGE_SECTION_HEADER *)\n           (param_1 + (uint)*(ushort *)(param_1 + iVar1 + 0x14) + iVar1 + 0x18);\n  p_Var3 = p_Var2 + *(ushort *)(param_1 + iVar1 + 6);\n  while( true ) {\n    if (p_Var2 == p_Var3) {\n      return (_IMAGE_SECTION_HEADER *)0x0;\n    }\n    if ((p_Var2->VirtualAddress <= param_2) &&\n       (param_2 < (p_Var2->Misc).PhysicalAddress + p_Var2->VirtualAddress)) break;\n    p_Var2 = p_Var2 + 1;\n  }\n  return p_Var2;\n}\n\n"
    },
    {
      "name": "___scrt_acquire_startup_lock",
      "entry": "0040819d",
      "c": "\n/* Library Function - Single Match\n    ___scrt_acquire_startup_lock\n   \n   Library: Visual Studio 2015 Release */\n\nint ___scrt_acquire_startup_lock(void)\n\n{\n  int iVar1;\n  bool bVar2;\n  uint3 extraout_var;\n  int iVar3;\n  uint3 uVar4;\n  \n  bVar2 = ___scrt_is_ucrt_dll_in_use();\n  if (CONCAT31(extraout_var,bVar2) == 0) {\n    return (uint)extraout_var << 8;\n  }\n  while( true ) {\n    iVar3 = 0;\n    LOCK();\n    iVar1 = *(int *)((int)Self + 4);\n    if (DAT_0043ad88 != 0) {\n      iVar3 = DAT_0043ad88;\n      iVar1 = DAT_0043ad88;\n    }\n    DAT_0043ad88 = iVar1;\n    UNLOCK();\n    uVar4 = (uint3)((uint)iVar3 >> 8);\n    if (iVar3 == 0) break;\n    if (*(int *)((int)Self + 4) == iVar3) {\n      return CONCAT31(uVar4,1);\n    }\n  }\n  return (uint)uVar4 << 8;\n}\n\n"
    },
    {
      "name": "___scrt_initialize_crt",
      "entry": "004081d2",
      "c": "\n/* Library Function - Single Match\n    ___scrt_initialize_crt\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___scrt_initialize_crt(int param_1)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  \n  if (param_1 == 0) {\n    DAT_0043ada4 = 1;\n  }\n  ___isa_available_init();\n  uVar1 = ___vcrt_initialize();\n  if ((char)uVar1 != '\\0') {\n    uVar2 = ___acrt_initialize();\n    if ((char)uVar2 != '\\0') {\n      return CONCAT31((int3)((uint)uVar2 >> 8),1);\n    }\n    uVar1 = ___vcrt_uninitialize('\\0');\n  }\n  return uVar1 & 0xffffff00;\n}\n\n"
    },
    {
      "name": "___scrt_initialize_onexit_tables",
      "entry": "0040820b",
      "c": "\n/* Library Function - Single Match\n    ___scrt_initialize_onexit_tables\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___scrt_initialize_onexit_tables(int param_1)\n\n{\n  code *pcVar1;\n  byte bVar2;\n  bool bVar3;\n  undefined3 extraout_var;\n  uint uVar4;\n  int iVar5;\n  \n  if ((param_1 != 0) && (param_1 != 1)) {\n    ___scrt_fastfail();\n    pcVar1 = (code *)swi(3);\n    uVar4 = (*pcVar1)();\n    return uVar4;\n  }\n  bVar3 = ___scrt_is_ucrt_dll_in_use();\n  if ((CONCAT31(extraout_var,bVar3) == 0) || (param_1 != 0)) {\n    bVar2 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n    DAT_0043ad8c = (0xffffffffU >> bVar2 | -1 << 0x20 - bVar2) ^ DAT_0042d008;\n    uVar4 = CONCAT31((int3)(DAT_0043ad8c >> 8),1);\n    DAT_0043ad90 = DAT_0043ad8c;\n    DAT_0043ad94 = DAT_0043ad8c;\n    DAT_0043ad98 = DAT_0043ad8c;\n    DAT_0043ad9c = DAT_0043ad8c;\n    DAT_0043ada0 = DAT_0043ad8c;\n  }\n  else {\n    uVar4 = __initialize_onexit_table(&DAT_0043ad8c);\n    if (uVar4 == 0) {\n      iVar5 = __initialize_onexit_table(&DAT_0043ad98);\n      uVar4 = CONCAT31((int3)((uint)-iVar5 >> 8),'\\x01' - (iVar5 != 0));\n    }\n    else {\n      uVar4 = uVar4 & 0xffffff00;\n    }\n  }\n  return uVar4;\n}\n\n"
    },
    {
      "name": "___scrt_is_nonwritable_in_current_image",
      "entry": "004082a2",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    ___scrt_is_nonwritable_in_current_image\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___scrt_is_nonwritable_in_current_image(int param_1)\n\n{\n  _IMAGE_SECTION_HEADER *p_Var1;\n  \n  p_Var1 = (_IMAGE_SECTION_HEADER *)0x5a4d;\n  if ((((IMAGE_DOS_HEADER_00400000.e_magic == (char  [2])0x5a4d) &&\n       (p_Var1 = (_IMAGE_SECTION_HEADER *)IMAGE_DOS_HEADER_00400000.e_lfanew,\n       *(int *)(IMAGE_DOS_HEADER_00400000.e_lfanew + 0x400000) == 0x4550)) &&\n      (*(short *)((int)IMAGE_DOS_HEADER_00400000.e_res_4_ + (IMAGE_DOS_HEADER_00400000.e_lfanew - 4)\n                 ) == 0x10b)) &&\n     ((p_Var1 = find_pe_section((uchar *)&IMAGE_DOS_HEADER_00400000,param_1 - 0x400000),\n      p_Var1 != (_IMAGE_SECTION_HEADER *)0x0 && (-1 < (int)p_Var1->Characteristics)))) {\n    return CONCAT31((int3)((uint)p_Var1 >> 8),1);\n  }\n  return (uint)p_Var1 & 0xffffff00;\n}\n\n"
    },
    {
      "name": "___scrt_release_startup_lock",
      "entry": "0040832c",
      "c": "\n/* Library Function - Single Match\n    ___scrt_release_startup_lock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl ___scrt_release_startup_lock(char param_1)\n\n{\n  int iVar1;\n  bool bVar2;\n  undefined3 extraout_var;\n  int iVar3;\n  \n  bVar2 = ___scrt_is_ucrt_dll_in_use();\n  iVar1 = DAT_0043ad88;\n  iVar3 = CONCAT31(extraout_var,bVar2);\n  if ((iVar3 != 0) && (param_1 == '\\0')) {\n    LOCK();\n    DAT_0043ad88 = 0;\n    UNLOCK();\n    iVar3 = iVar1;\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "___scrt_uninitialize_crt",
      "entry": "00408349",
      "c": "\n/* Library Function - Single Match\n    ___scrt_uninitialize_crt\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl ___scrt_uninitialize_crt(char param_1,char param_2)\n\n{\n  undefined4 in_EAX;\n  \n  if ((DAT_0043ada4 == '\\0') || (param_2 == '\\0')) {\n    ___acrt_uninitialize();\n    in_EAX = ___vcrt_uninitialize(param_1);\n  }\n  return CONCAT31((int3)((uint)in_EAX >> 8),1);\n}\n\n"
    },
    {
      "name": "__onexit",
      "entry": "00408371",
      "c": "\n/* Library Function - Single Match\n    __onexit\n   \n   Library: Visual Studio 2015 Release */\n\n_onexit_t __cdecl __onexit(_onexit_t _Func)\n\n{\n  int iVar1;\n  byte bVar2;\n  \n  bVar2 = (byte)DAT_0042d008 & 0x1f;\n  if (((DAT_0042d008 ^ DAT_0043ad8c) >> bVar2 | (DAT_0042d008 ^ DAT_0043ad8c) << 0x20 - bVar2) ==\n      0xffffffff) {\n    iVar1 = __crt_atexit();\n  }\n  else {\n    iVar1 = __register_onexit_function();\n  }\n  return (_onexit_t)(~-(uint)(iVar1 != 0) & (uint)_Func);\n}\n\n"
    },
    {
      "name": "_atexit",
      "entry": "004083ac",
      "c": "\n/* Library Function - Single Match\n    _atexit\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nint __cdecl _atexit(_func_4879 *param_1)\n\n{\n  _onexit_t p_Var1;\n  \n  p_Var1 = __onexit((_onexit_t)param_1);\n  return (p_Var1 != (_onexit_t)0x0) - 1;\n}\n\n"
    },
    {
      "name": "___security_init_cookie",
      "entry": "004083c1",
      "c": "\n/* Library Function - Single Match\n    ___security_init_cookie\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___security_init_cookie(void)\n\n{\n  DWORD DVar1;\n  LARGE_INTEGER local_18;\n  _FILETIME local_10;\n  uint local_8;\n  \n  local_10.dwLowDateTime = 0;\n  local_10.dwHighDateTime = 0;\n  if ((DAT_0042d008 == 0xbb40e64e) || ((DAT_0042d008 & 0xffff0000) == 0)) {\n    GetSystemTimeAsFileTime(&local_10);\n    local_8 = local_10.dwHighDateTime ^ local_10.dwLowDateTime;\n    DVar1 = GetCurrentThreadId();\n    local_8 = local_8 ^ DVar1;\n    DVar1 = GetCurrentProcessId();\n    local_8 = local_8 ^ DVar1;\n    QueryPerformanceCounter(&local_18);\n    DAT_0042d008 = local_18.s.HighPart ^ local_18.s.LowPart ^ local_8 ^ (uint)&local_8;\n    if (DAT_0042d008 == 0xbb40e64e) {\n      DAT_0042d008 = 0xbb40e64f;\n    }\n    else if ((DAT_0042d008 & 0xffff0000) == 0) {\n      DAT_0042d008 = DAT_0042d008 | (DAT_0042d008 | 0x4711) << 0x10;\n    }\n    DAT_0042d004 = ~DAT_0042d008;\n  }\n  else {\n    DAT_0042d004 = ~DAT_0042d008;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00408460",
      "entry": "00408460",
      "c": "\nundefined4 FUN_00408460(void)\n\n{\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_00408463",
      "entry": "00408463",
      "c": "\nundefined4 FUN_00408463(void)\n\n{\n  return 1;\n}\n\n"
    },
    {
      "name": "FUN_00408467",
      "entry": "00408467",
      "c": "\nundefined4 FUN_00408467(void)\n\n{\n  return 0x4000;\n}\n\n"
    },
    {
      "name": "FUN_0040846d",
      "entry": "0040846d",
      "c": "\nvoid FUN_0040846d(void)\n\n{\n  InitializeSListHead((PSLIST_HEADER)&DAT_0043ada8);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00408479",
      "entry": "00408479",
      "c": "\nvoid FUN_00408479(void)\n\n{\n  code *pcVar1;\n  errno_t eVar2;\n  \n  eVar2 = __controlfp_s((uint *)0x0,0x10000,0x30000);\n  if (eVar2 == 0) {\n    return;\n  }\n  ___scrt_fastfail();\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040849a",
      "entry": "0040849a",
      "c": "\nundefined * FUN_0040849a(void)\n\n{\n  return &DAT_0043adb0;\n}\n\n"
    },
    {
      "name": "FUN_004084a0",
      "entry": "004084a0",
      "c": "\nvoid FUN_004084a0(void)\n\n{\n  uint *puVar1;\n  \n  puVar1 = (uint *)FUN_00401840();\n  *puVar1 = *puVar1 | 4;\n  puVar1[1] = puVar1[1];\n  puVar1 = (uint *)FUN_0040849a();\n  *puVar1 = *puVar1 | 2;\n  puVar1[1] = puVar1[1];\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004084bd",
      "entry": "004084bd",
      "c": "\nbool FUN_004084bd(void)\n\n{\n  return DAT_0042d014 == 0;\n}\n\n"
    },
    {
      "name": "FUN_004084c9",
      "entry": "004084c9",
      "c": "\nundefined * FUN_004084c9(void)\n\n{\n  return &DAT_0043b670;\n}\n\n"
    },
    {
      "name": "FUN_004084cf",
      "entry": "004084cf",
      "c": "\nundefined * FUN_004084cf(void)\n\n{\n  return &DAT_0043b66c;\n}\n\n"
    },
    {
      "name": "___scrt_fastfail",
      "entry": "004084d5",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___scrt_fastfail\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___scrt_fastfail(void)\n\n{\n  code *pcVar1;\n  BOOL BVar2;\n  LONG LVar3;\n  undefined4 local_328 [39];\n  EXCEPTION_RECORD local_5c;\n  _EXCEPTION_POINTERS local_c;\n  \n  BVar2 = IsProcessorFeaturePresent(0x17);\n  if (BVar2 != 0) {\n    pcVar1 = (code *)swi(0x29);\n    (*pcVar1)();\n  }\n  _DAT_0043adb8 = 0;\n  _memset(local_328,0,0x2cc);\n  local_328[0] = 0x10001;\n  _memset(&local_5c,0,0x50);\n  local_5c.ExceptionCode = 0x40000015;\n  local_5c.ExceptionFlags = 1;\n  BVar2 = IsDebuggerPresent();\n  local_c.ExceptionRecord = &local_5c;\n  local_c.ContextRecord = (PCONTEXT)local_328;\n  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n  LVar3 = UnhandledExceptionFilter(&local_c);\n  if (LVar3 == 0) {\n    _DAT_0043adb8 = _DAT_0043adb8 & -(uint)(BVar2 == 1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___scrt_unhandled_exception_filter@4",
      "entry": "004085fc",
      "c": "\n/* Library Function - Single Match\n    ___scrt_unhandled_exception_filter@4\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nundefined4 ___scrt_unhandled_exception_filter_4(int *param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  code *pcVar3;\n  undefined4 uVar4;\n  \n  piVar1 = (int *)*param_1;\n  if (((*piVar1 == -0x1f928c9d) && (piVar1[4] == 3)) &&\n     ((iVar2 = piVar1[5], iVar2 == 0x19930520 ||\n      (((iVar2 == 0x19930521 || (iVar2 == 0x19930522)) || (iVar2 == 0x1994000)))))) {\n    terminate();\n    pcVar3 = (code *)swi(3);\n    uVar4 = (*pcVar3)();\n    return uVar4;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_0040863d",
      "entry": "0040863d",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0040863d(void)\n\n{\n  _DAT_0043adb8 = 0;\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00408645",
      "entry": "00408645",
      "c": "\n/* WARNING: Removing unreachable block (ram,0x00408655) */\n/* WARNING: Removing unreachable block (ram,0x00408656) */\n/* WARNING: Removing unreachable block (ram,0x0040865c) */\n/* WARNING: Removing unreachable block (ram,0x00408665) */\n/* WARNING: Removing unreachable block (ram,0x0040866c) */\n\nvoid FUN_00408645(void)\n\n{\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00408670",
      "entry": "00408670",
      "c": "\n/* WARNING: Removing unreachable block (ram,0x00408680) */\n/* WARNING: Removing unreachable block (ram,0x00408681) */\n/* WARNING: Removing unreachable block (ram,0x00408687) */\n/* WARNING: Removing unreachable block (ram,0x00408690) */\n/* WARNING: Removing unreachable block (ram,0x00408697) */\n\nvoid FUN_00408670(void)\n\n{\n  return;\n}\n\n"
    },
    {
      "name": "guard_check_icall",
      "entry": "0040869b",
      "c": "\n/* WARNING: Switch with 1 destination removed at 0x0040869b */\n\nvoid __cdecl guard_check_icall(void)\n\n{\n  return;\n}\n\n"
    },
    {
      "name": "__SEH_prolog4",
      "entry": "004086b0",
      "c": "\n/* WARNING: This is an inlined function */\n/* WARNING: Unable to track spacebase fully for stack */\n/* WARNING: Variable defined which should be unmapped: param_2 */\n/* Library Function - Single Match\n    __SEH_prolog4\n   \n   Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */\n\nvoid __cdecl __SEH_prolog4(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 unaff_EBX;\n  undefined4 unaff_ESI;\n  undefined4 unaff_EDI;\n  undefined4 unaff_retaddr;\n  uint auStack_1c [5];\n  undefined1 local_8 [8];\n  \n  iVar1 = -param_2;\n  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;\n  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;\n  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;\n  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_0042d008 ^ (uint)&param_2;\n  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;\n  ExceptionList = local_8;\n  return;\n}\n\n"
    },
    {
      "name": "__SEH_epilog4",
      "entry": "004086f6",
      "c": "\n/* WARNING: This is an inlined function */\n/* Library Function - Single Match\n    __SEH_epilog4\n   \n   Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */\n\nvoid __SEH_epilog4(void)\n\n{\n  undefined4 *unaff_EBP;\n  undefined4 unaff_retaddr;\n  \n  ExceptionList = (void *)unaff_EBP[-4];\n  *unaff_EBP = unaff_retaddr;\n  return;\n}\n\n"
    },
    {
      "name": "___isa_available_init",
      "entry": "0040870b",
      "c": "\n/* WARNING: Removing unreachable block (ram,0x0040874c) */\n/* WARNING: Removing unreachable block (ram,0x004087fc) */\n/* WARNING: Removing unreachable block (ram,0x00408786) */\n/* Library Function - Single Match\n    ___isa_available_init\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 ___isa_available_init(void)\n\n{\n  int *piVar1;\n  uint *puVar2;\n  int iVar3;\n  uint uVar4;\n  BOOL BVar5;\n  uint uVar6;\n  uint uVar7;\n  uint in_XCR0;\n  uint local_14;\n  \n  DAT_0043adbc = 0;\n  DAT_0042d020 = DAT_0042d020 | 1;\n  BVar5 = IsProcessorFeaturePresent(10);\n  uVar4 = DAT_0042d020;\n  if (BVar5 != 0) {\n    local_14 = 0;\n    DAT_0042d020 = DAT_0042d020 | 2;\n    DAT_0043adbc = 1;\n    piVar1 = (int *)cpuid_basic_info(0);\n    puVar2 = (uint *)cpuid_Version_info(1);\n    uVar7 = puVar2[3];\n    if (((piVar1[2] == 0x49656e69 && piVar1[3] == 0x6c65746e) && piVar1[1] == 0x756e6547) &&\n       (((((uVar6 = *puVar2 & 0xfff3ff0, uVar6 == 0x106c0 || (uVar6 == 0x20660)) ||\n          (uVar6 == 0x20670)) || ((uVar6 == 0x30650 || (uVar6 == 0x30660)))) || (uVar6 == 0x30670)))\n       ) {\n      DAT_0043adc0 = DAT_0043adc0 | 1;\n    }\n    if (6 < *piVar1) {\n      iVar3 = cpuid_Extended_Feature_Enumeration_info(7);\n      local_14 = *(uint *)(iVar3 + 4);\n      if ((local_14 & 0x200) != 0) {\n        DAT_0043adc0 = DAT_0043adc0 | 2;\n      }\n    }\n    if ((uVar7 & 0x100000) != 0) {\n      DAT_0042d020 = uVar4 | 6;\n      DAT_0043adbc = 2;\n      if ((((uVar7 & 0x8000000) != 0) && ((uVar7 & 0x10000000) != 0)) && ((in_XCR0 & 6) == 6)) {\n        DAT_0042d020 = uVar4 | 0xe;\n        DAT_0043adbc = 3;\n        if ((local_14 & 0x20) != 0) {\n          DAT_0042d020 = uVar4 | 0x2e;\n          DAT_0043adbc = 5;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "___scrt_is_ucrt_dll_in_use",
      "entry": "004088a5",
      "c": "\n/* Library Function - Single Match\n    ___scrt_is_ucrt_dll_in_use\n   \n   Library: Visual Studio 2015 Release */\n\nbool ___scrt_is_ucrt_dll_in_use(void)\n\n{\n  return DAT_0043b668 != 0;\n}\n\n"
    },
    {
      "name": "_memset",
      "entry": "004088c0",
      "c": "\n/* Library Function - Single Match\n    _memset\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nvoid * __cdecl _memset(void *_Dst,int _Val,size_t _Size)\n\n{\n  int iVar1;\n  undefined1 *puVar2;\n  int *piVar3;\n  \n  if (_Size == 0) {\n    return _Dst;\n  }\n  iVar1 = (_Val & 0xffU) * 0x1010101;\n  piVar3 = (int *)_Dst;\n  if (0x20 < (int)_Size) {\n    if (0x7f < (int)_Size) {\n      puVar2 = (undefined1 *)_Dst;\n      if ((DAT_0043adc0 >> 1 & 1) != 0) {\n        for (; _Size != 0; _Size = _Size - 1) {\n          *puVar2 = (char)iVar1;\n          puVar2 = puVar2 + 1;\n        }\n        return _Dst;\n      }\n      if ((DAT_0042d020 >> 1 & 1) == 0) goto joined_r0x004089cb;\n      *(int *)_Dst = iVar1;\n      *(int *)((int)_Dst + 4) = iVar1;\n      *(int *)((int)_Dst + 8) = iVar1;\n      *(int *)((int)_Dst + 0xc) = iVar1;\n      piVar3 = (int *)((int)_Dst + 0x10U & 0xfffffff0);\n      _Size = (int)_Dst + (_Size - (int)piVar3);\n      if (0x80 < (int)_Size) {\n        do {\n          *piVar3 = iVar1;\n          piVar3[1] = iVar1;\n          piVar3[2] = iVar1;\n          piVar3[3] = iVar1;\n          piVar3[4] = iVar1;\n          piVar3[5] = iVar1;\n          piVar3[6] = iVar1;\n          piVar3[7] = iVar1;\n          piVar3[8] = iVar1;\n          piVar3[9] = iVar1;\n          piVar3[10] = iVar1;\n          piVar3[0xb] = iVar1;\n          piVar3[0xc] = iVar1;\n          piVar3[0xd] = iVar1;\n          piVar3[0xe] = iVar1;\n          piVar3[0xf] = iVar1;\n          piVar3[0x10] = iVar1;\n          piVar3[0x11] = iVar1;\n          piVar3[0x12] = iVar1;\n          piVar3[0x13] = iVar1;\n          piVar3[0x14] = iVar1;\n          piVar3[0x15] = iVar1;\n          piVar3[0x16] = iVar1;\n          piVar3[0x17] = iVar1;\n          piVar3[0x18] = iVar1;\n          piVar3[0x19] = iVar1;\n          piVar3[0x1a] = iVar1;\n          piVar3[0x1b] = iVar1;\n          piVar3[0x1c] = iVar1;\n          piVar3[0x1d] = iVar1;\n          piVar3[0x1e] = iVar1;\n          piVar3[0x1f] = iVar1;\n          piVar3 = piVar3 + 0x20;\n          _Size = _Size - 0x80;\n        } while ((_Size & 0xffffff00) != 0);\n        goto LAB_00408990;\n      }\n    }\n    if ((DAT_0042d020 >> 1 & 1) != 0) {\nLAB_00408990:\n      if (0x1f < _Size) {\n        do {\n          *piVar3 = iVar1;\n          piVar3[1] = iVar1;\n          piVar3[2] = iVar1;\n          piVar3[3] = iVar1;\n          piVar3[4] = iVar1;\n          piVar3[5] = iVar1;\n          piVar3[6] = iVar1;\n          piVar3[7] = iVar1;\n          piVar3 = piVar3 + 8;\n          _Size = _Size - 0x20;\n        } while (0x1f < _Size);\n        if ((_Size & 0x1f) == 0) {\n          return _Dst;\n        }\n      }\n      piVar3 = (int *)((_Size - 0x20) + (int)piVar3);\n      *piVar3 = iVar1;\n      piVar3[1] = iVar1;\n      piVar3[2] = iVar1;\n      piVar3[3] = iVar1;\n      piVar3[4] = iVar1;\n      piVar3[5] = iVar1;\n      piVar3[6] = iVar1;\n      piVar3[7] = iVar1;\n      return _Dst;\n    }\n  }\njoined_r0x004089cb:\n  for (; (_Size & 3) != 0; _Size = _Size - 1) {\n    *(char *)piVar3 = (char)iVar1;\n    piVar3 = (int *)((int)piVar3 + 1);\n  }\n  if ((_Size & 4) != 0) {\n    *piVar3 = iVar1;\n    piVar3 = piVar3 + 1;\n    _Size = _Size - 4;\n  }\n  for (; (_Size & 0xfffffff8) != 0; _Size = _Size - 8) {\n    *piVar3 = iVar1;\n    piVar3[1] = iVar1;\n    piVar3 = piVar3 + 2;\n  }\n  return _Dst;\n}\n\n"
    },
    {
      "name": "FUN_00408a20",
      "entry": "00408a20",
      "c": "\nuint * __cdecl FUN_00408a20(uint *param_1,char param_2)\n\n{\n  int iVar1;\n  char cVar2;\n  uint uVar3;\n  uint *puVar4;\n  uint uVar5;\n  uint uVar6;\n  char *pcVar7;\n  undefined1 auVar8 [16];\n  undefined1 auVar9 [16];\n  undefined1 auVar10 [16];\n  \n  if (DAT_0043adbc != 0) {\n    auVar10 = pshuflw(ZEXT216(CONCAT11(param_2,param_2)),ZEXT216(CONCAT11(param_2,param_2)),0);\n    uVar3 = -1 << (sbyte)((uint)param_1 & 0xf);\n    pcVar7 = (char *)((int)param_1 - ((uint)param_1 & 0xf));\n    while( true ) {\n      auVar9[0] = -(*pcVar7 == '\\0');\n      auVar9[1] = -(pcVar7[1] == '\\0');\n      auVar9[2] = -(pcVar7[2] == '\\0');\n      auVar9[3] = -(pcVar7[3] == '\\0');\n      auVar9[4] = -(pcVar7[4] == '\\0');\n      auVar9[5] = -(pcVar7[5] == '\\0');\n      auVar9[6] = -(pcVar7[6] == '\\0');\n      auVar9[7] = -(pcVar7[7] == '\\0');\n      auVar9[8] = -(pcVar7[8] == '\\0');\n      auVar9[9] = -(pcVar7[9] == '\\0');\n      auVar9[10] = -(pcVar7[10] == '\\0');\n      auVar9[0xb] = -(pcVar7[0xb] == '\\0');\n      auVar9[0xc] = -(pcVar7[0xc] == '\\0');\n      auVar9[0xd] = -(pcVar7[0xd] == '\\0');\n      auVar9[0xe] = -(pcVar7[0xe] == '\\0');\n      auVar9[0xf] = -(pcVar7[0xf] == '\\0');\n      cVar2 = auVar10[0];\n      auVar8[0] = -(*pcVar7 == cVar2);\n      auVar8[1] = -(pcVar7[1] == auVar10[1]);\n      auVar8[2] = -(pcVar7[2] == auVar10[2]);\n      auVar8[3] = -(pcVar7[3] == auVar10[3]);\n      auVar8[4] = -(pcVar7[4] == auVar10[4]);\n      auVar8[5] = -(pcVar7[5] == auVar10[5]);\n      auVar8[6] = -(pcVar7[6] == auVar10[6]);\n      auVar8[7] = -(pcVar7[7] == auVar10[7]);\n      auVar8[8] = -(pcVar7[8] == cVar2);\n      auVar8[9] = -(pcVar7[9] == auVar10[1]);\n      auVar8[10] = -(pcVar7[10] == auVar10[2]);\n      auVar8[0xb] = -(pcVar7[0xb] == auVar10[3]);\n      auVar8[0xc] = -(pcVar7[0xc] == auVar10[4]);\n      auVar8[0xd] = -(pcVar7[0xd] == auVar10[5]);\n      auVar8[0xe] = -(pcVar7[0xe] == auVar10[6]);\n      auVar8[0xf] = -(pcVar7[0xf] == auVar10[7]);\n      auVar9 = auVar9 | auVar8;\n      uVar3 = (ushort)((ushort)(SUB161(auVar9 >> 7,0) & 1) |\n                       (ushort)(SUB161(auVar9 >> 0xf,0) & 1) << 1 |\n                       (ushort)(SUB161(auVar9 >> 0x17,0) & 1) << 2 |\n                       (ushort)(SUB161(auVar9 >> 0x1f,0) & 1) << 3 |\n                       (ushort)(SUB161(auVar9 >> 0x27,0) & 1) << 4 |\n                       (ushort)(SUB161(auVar9 >> 0x2f,0) & 1) << 5 |\n                       (ushort)(SUB161(auVar9 >> 0x37,0) & 1) << 6 |\n                       (ushort)(SUB161(auVar9 >> 0x3f,0) & 1) << 7 |\n                       (ushort)(SUB161(auVar9 >> 0x47,0) & 1) << 8 |\n                       (ushort)(SUB161(auVar9 >> 0x4f,0) & 1) << 9 |\n                       (ushort)(SUB161(auVar9 >> 0x57,0) & 1) << 10 |\n                       (ushort)(SUB161(auVar9 >> 0x5f,0) & 1) << 0xb |\n                       (ushort)(SUB161(auVar9 >> 0x67,0) & 1) << 0xc |\n                       (ushort)(SUB161(auVar9 >> 0x6f,0) & 1) << 0xd |\n                       (ushort)(SUB161(auVar9 >> 0x77,0) & 1) << 0xe |\n                      (ushort)(byte)(auVar9[0xf] >> 7) << 0xf) & uVar3;\n      if (uVar3 != 0) break;\n      uVar3 = 0xffffffff;\n      pcVar7 = pcVar7 + 0x10;\n    }\n    iVar1 = 0;\n    if (uVar3 != 0) {\n      for (; (uVar3 >> iVar1 & 1) == 0; iVar1 = iVar1 + 1) {\n      }\n    }\n    puVar4 = (uint *)(pcVar7 + iVar1);\n    if (cVar2 != (char)*puVar4) {\n      puVar4 = (uint *)0x0;\n    }\n    return puVar4;\n  }\n  uVar3 = (uint)param_1 & 3;\n  while (uVar3 != 0) {\n    if ((char)*param_1 == param_2) {\n      return param_1;\n    }\n    if ((char)*param_1 == '\\0') {\n      return (uint *)0x0;\n    }\n    uVar3 = (uint)((int)param_1 + 1) & 3;\n    param_1 = (uint *)((int)param_1 + 1);\n  }\n  while( true ) {\n    while( true ) {\n      uVar3 = *param_1;\n      uVar6 = uVar3 ^ CONCAT22(CONCAT11(param_2,param_2),CONCAT11(param_2,param_2));\n      uVar5 = uVar3 ^ 0xffffffff ^ uVar3 + 0x7efefeff;\n      puVar4 = param_1 + 1;\n      if (((uVar6 ^ 0xffffffff ^ uVar6 + 0x7efefeff) & 0x81010100) != 0) break;\n      param_1 = puVar4;\n      if ((uVar5 & 0x81010100) != 0) {\n        if ((uVar5 & 0x1010100) != 0) {\n          return (uint *)0x0;\n        }\n        if ((uVar3 + 0x7efefeff & 0x80000000) == 0) {\n          return (uint *)0x0;\n        }\n      }\n    }\n    uVar3 = *param_1;\n    if ((char)uVar3 == param_2) {\n      return param_1;\n    }\n    if ((char)uVar3 == '\\0') {\n      return (uint *)0x0;\n    }\n    cVar2 = (char)(uVar3 >> 8);\n    if (cVar2 == param_2) {\n      return (uint *)((int)param_1 + 1);\n    }\n    if (cVar2 == '\\0') break;\n    cVar2 = (char)(uVar3 >> 0x10);\n    if (cVar2 == param_2) {\n      return (uint *)((int)param_1 + 2);\n    }\n    if (cVar2 == '\\0') {\n      return (uint *)0x0;\n    }\n    cVar2 = (char)(uVar3 >> 0x18);\n    if (cVar2 == param_2) {\n      return (uint *)((int)param_1 + 3);\n    }\n    param_1 = puVar4;\n    if (cVar2 == '\\0') {\n      return (uint *)0x0;\n    }\n  }\n  return (uint *)0x0;\n}\n\n"
    },
    {
      "name": "FUN_00408b50",
      "entry": "00408b50",
      "c": "\nundefined1 (*) [16] __cdecl FUN_00408b50(undefined1 (*param_1) [16],byte param_2)\n\n{\n  byte bVar1;\n  undefined1 *puVar2;\n  uint uVar3;\n  undefined1 (*pauVar4) [16];\n  uint uVar5;\n  int iVar6;\n  undefined1 (*pauVar7) [16];\n  char *pcVar8;\n  byte *pbVar9;\n  undefined1 auVar11 [16];\n  undefined1 auVar12 [16];\n  undefined1 auVar13 [16];\n  undefined1 auVar14 [16];\n  byte *pbVar10;\n  \n  if (DAT_0043adbc != 0) {\n    if (DAT_0043adbc < 2) {\n      auVar14 = pshuflw(ZEXT216(CONCAT11(param_2,param_2)),ZEXT216(CONCAT11(param_2,param_2)),0);\n      uVar3 = -1 << (sbyte)((uint)param_1 & 0xf);\n      pcVar8 = (char *)((int)param_1 - ((uint)param_1 & 0xf));\n      pauVar7 = (undefined1 (*) [16])0x0;\n      while( true ) {\n        auVar13[0] = -(*pcVar8 == '\\0');\n        auVar13[1] = -(pcVar8[1] == '\\0');\n        auVar13[2] = -(pcVar8[2] == '\\0');\n        auVar13[3] = -(pcVar8[3] == '\\0');\n        auVar13[4] = -(pcVar8[4] == '\\0');\n        auVar13[5] = -(pcVar8[5] == '\\0');\n        auVar13[6] = -(pcVar8[6] == '\\0');\n        auVar13[7] = -(pcVar8[7] == '\\0');\n        auVar13[8] = -(pcVar8[8] == '\\0');\n        auVar13[9] = -(pcVar8[9] == '\\0');\n        auVar13[10] = -(pcVar8[10] == '\\0');\n        auVar13[0xb] = -(pcVar8[0xb] == '\\0');\n        auVar13[0xc] = -(pcVar8[0xc] == '\\0');\n        auVar13[0xd] = -(pcVar8[0xd] == '\\0');\n        auVar13[0xe] = -(pcVar8[0xe] == '\\0');\n        auVar13[0xf] = -(pcVar8[0xf] == '\\0');\n        auVar12[0] = -(*pcVar8 == auVar14[0]);\n        auVar12[1] = -(pcVar8[1] == auVar14[1]);\n        auVar12[2] = -(pcVar8[2] == auVar14[2]);\n        auVar12[3] = -(pcVar8[3] == auVar14[3]);\n        auVar12[4] = -(pcVar8[4] == auVar14[4]);\n        auVar12[5] = -(pcVar8[5] == auVar14[5]);\n        auVar12[6] = -(pcVar8[6] == auVar14[6]);\n        auVar12[7] = -(pcVar8[7] == auVar14[7]);\n        auVar12[8] = -(pcVar8[8] == auVar14[0]);\n        auVar12[9] = -(pcVar8[9] == auVar14[1]);\n        auVar12[10] = -(pcVar8[10] == auVar14[2]);\n        auVar12[0xb] = -(pcVar8[0xb] == auVar14[3]);\n        auVar12[0xc] = -(pcVar8[0xc] == auVar14[4]);\n        auVar12[0xd] = -(pcVar8[0xd] == auVar14[5]);\n        auVar12[0xe] = -(pcVar8[0xe] == auVar14[6]);\n        auVar12[0xf] = -(pcVar8[0xf] == auVar14[7]);\n        uVar5 = (ushort)((ushort)(SUB161(auVar13 >> 7,0) & 1) |\n                         (ushort)(SUB161(auVar13 >> 0xf,0) & 1) << 1 |\n                         (ushort)(SUB161(auVar13 >> 0x17,0) & 1) << 2 |\n                         (ushort)(SUB161(auVar13 >> 0x1f,0) & 1) << 3 |\n                         (ushort)(SUB161(auVar13 >> 0x27,0) & 1) << 4 |\n                         (ushort)(SUB161(auVar13 >> 0x2f,0) & 1) << 5 |\n                         (ushort)(SUB161(auVar13 >> 0x37,0) & 1) << 6 |\n                         (ushort)(SUB161(auVar13 >> 0x3f,0) & 1) << 7 |\n                         (ushort)(SUB161(auVar13 >> 0x47,0) & 1) << 8 |\n                         (ushort)(SUB161(auVar13 >> 0x4f,0) & 1) << 9 |\n                         (ushort)(SUB161(auVar13 >> 0x57,0) & 1) << 10 |\n                         (ushort)(SUB161(auVar13 >> 0x5f,0) & 1) << 0xb |\n                         (ushort)(SUB161(auVar13 >> 0x67,0) & 1) << 0xc |\n                         (ushort)(SUB161(auVar13 >> 0x6f,0) & 1) << 0xd |\n                         (ushort)(SUB161(auVar13 >> 0x77,0) & 1) << 0xe |\n                        (ushort)(auVar13[0xf] >> 7) << 0xf) & uVar3;\n        if (uVar5 != 0) break;\n        uVar3 = (ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |\n                         (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |\n                         (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |\n                         (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |\n                         (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |\n                         (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |\n                         (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |\n                         (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |\n                         (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |\n                         (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |\n                         (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |\n                         (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |\n                         (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |\n                         (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |\n                         (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |\n                        (ushort)(auVar12[0xf] >> 7) << 0xf) & uVar3;\n        iVar6 = 0x1f;\n        if (uVar3 != 0) {\n          for (; uVar3 >> iVar6 == 0; iVar6 = iVar6 + -1) {\n          }\n        }\n        if (uVar3 != 0) {\n          pauVar7 = (undefined1 (*) [16])(pcVar8 + iVar6);\n        }\n        uVar3 = 0xffffffff;\n        pcVar8 = pcVar8 + 0x10;\n      }\n      uVar3 = (uVar5 * 2 & uVar5 * -2) - 1 &\n              (ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |\n                       (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |\n                       (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |\n                       (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |\n                       (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |\n                       (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |\n                       (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |\n                       (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |\n                       (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |\n                       (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |\n                       (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |\n                       (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |\n                       (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |\n                       (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |\n                       (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |\n                      (ushort)(auVar12[0xf] >> 7) << 0xf) & uVar3;\n      iVar6 = 0x1f;\n      if (uVar3 != 0) {\n        for (; uVar3 >> iVar6 == 0; iVar6 = iVar6 + -1) {\n        }\n      }\n      pauVar4 = (undefined1 (*) [16])(pcVar8 + iVar6);\n      if (uVar3 == 0) {\n        pauVar4 = pauVar7;\n      }\n      return pauVar4;\n    }\n    uVar3 = (uint)param_2;\n    if (uVar3 == 0) {\n      pcVar8 = (char *)((uint)param_1 & 0xfffffff0);\n      auVar14[0] = -(*pcVar8 == '\\0');\n      auVar14[1] = -(pcVar8[1] == '\\0');\n      auVar14[2] = -(pcVar8[2] == '\\0');\n      auVar14[3] = -(pcVar8[3] == '\\0');\n      auVar14[4] = -(pcVar8[4] == '\\0');\n      auVar14[5] = -(pcVar8[5] == '\\0');\n      auVar14[6] = -(pcVar8[6] == '\\0');\n      auVar14[7] = -(pcVar8[7] == '\\0');\n      auVar14[8] = -(pcVar8[8] == '\\0');\n      auVar14[9] = -(pcVar8[9] == '\\0');\n      auVar14[10] = -(pcVar8[10] == '\\0');\n      auVar14[0xb] = -(pcVar8[0xb] == '\\0');\n      auVar14[0xc] = -(pcVar8[0xc] == '\\0');\n      auVar14[0xd] = -(pcVar8[0xd] == '\\0');\n      auVar14[0xe] = -(pcVar8[0xe] == '\\0');\n      auVar14[0xf] = -(pcVar8[0xf] == '\\0');\n      uVar3 = (uint)(ushort)((ushort)(SUB161(auVar14 >> 7,0) & 1) |\n                             (ushort)(SUB161(auVar14 >> 0xf,0) & 1) << 1 |\n                             (ushort)(SUB161(auVar14 >> 0x17,0) & 1) << 2 |\n                             (ushort)(SUB161(auVar14 >> 0x1f,0) & 1) << 3 |\n                             (ushort)(SUB161(auVar14 >> 0x27,0) & 1) << 4 |\n                             (ushort)(SUB161(auVar14 >> 0x2f,0) & 1) << 5 |\n                             (ushort)(SUB161(auVar14 >> 0x37,0) & 1) << 6 |\n                             (ushort)(SUB161(auVar14 >> 0x3f,0) & 1) << 7 |\n                             (ushort)(SUB161(auVar14 >> 0x47,0) & 1) << 8 |\n                             (ushort)(SUB161(auVar14 >> 0x4f,0) & 1) << 9 |\n                             (ushort)(SUB161(auVar14 >> 0x57,0) & 1) << 10 |\n                             (ushort)(SUB161(auVar14 >> 0x5f,0) & 1) << 0xb |\n                             (ushort)(SUB161(auVar14 >> 0x67,0) & 1) << 0xc |\n                             (ushort)(SUB161(auVar14 >> 0x6f,0) & 1) << 0xd |\n                             (ushort)(SUB161(auVar14 >> 0x77,0) & 1) << 0xe |\n                            (ushort)(auVar14[0xf] >> 7) << 0xf) & -1 << ((byte)param_1 & 0xf);\n      while (uVar3 == 0) {\n        auVar11[0] = -(pcVar8[0x10] == '\\0');\n        auVar11[1] = -(pcVar8[0x11] == '\\0');\n        auVar11[2] = -(pcVar8[0x12] == '\\0');\n        auVar11[3] = -(pcVar8[0x13] == '\\0');\n        auVar11[4] = -(pcVar8[0x14] == '\\0');\n        auVar11[5] = -(pcVar8[0x15] == '\\0');\n        auVar11[6] = -(pcVar8[0x16] == '\\0');\n        auVar11[7] = -(pcVar8[0x17] == '\\0');\n        auVar11[8] = -(pcVar8[0x18] == '\\0');\n        auVar11[9] = -(pcVar8[0x19] == '\\0');\n        auVar11[10] = -(pcVar8[0x1a] == '\\0');\n        auVar11[0xb] = -(pcVar8[0x1b] == '\\0');\n        auVar11[0xc] = -(pcVar8[0x1c] == '\\0');\n        auVar11[0xd] = -(pcVar8[0x1d] == '\\0');\n        auVar11[0xe] = -(pcVar8[0x1e] == '\\0');\n        auVar11[0xf] = -(pcVar8[0x1f] == '\\0');\n        pcVar8 = pcVar8 + 0x10;\n        uVar3 = (uint)(ushort)((ushort)(SUB161(auVar11 >> 7,0) & 1) |\n                               (ushort)(SUB161(auVar11 >> 0xf,0) & 1) << 1 |\n                               (ushort)(SUB161(auVar11 >> 0x17,0) & 1) << 2 |\n                               (ushort)(SUB161(auVar11 >> 0x1f,0) & 1) << 3 |\n                               (ushort)(SUB161(auVar11 >> 0x27,0) & 1) << 4 |\n                               (ushort)(SUB161(auVar11 >> 0x2f,0) & 1) << 5 |\n                               (ushort)(SUB161(auVar11 >> 0x37,0) & 1) << 6 |\n                               (ushort)(SUB161(auVar11 >> 0x3f,0) & 1) << 7 |\n                               (ushort)(SUB161(auVar11 >> 0x47,0) & 1) << 8 |\n                               (ushort)(SUB161(auVar11 >> 0x4f,0) & 1) << 9 |\n                               (ushort)(SUB161(auVar11 >> 0x57,0) & 1) << 10 |\n                               (ushort)(SUB161(auVar11 >> 0x5f,0) & 1) << 0xb |\n                               (ushort)(SUB161(auVar11 >> 0x67,0) & 1) << 0xc |\n                               (ushort)(SUB161(auVar11 >> 0x6f,0) & 1) << 0xd |\n                               (ushort)(SUB161(auVar11 >> 0x77,0) & 1) << 0xe |\n                              (ushort)(auVar11[0xf] >> 7) << 0xf);\n      }\n      iVar6 = 0;\n      if (uVar3 != 0) {\n        for (; (uVar3 >> iVar6 & 1) == 0; iVar6 = iVar6 + 1) {\n        }\n      }\n      pauVar7 = (undefined1 (*) [16])(pcVar8 + iVar6);\n    }\n    else {\n      pauVar7 = (undefined1 (*) [16])0x0;\n      uVar5 = (uint)param_1 & 0xf;\n      while (uVar5 != 0) {\n        if ((byte)(*param_1)[0] == uVar3) {\n          pauVar7 = param_1;\n        }\n        if ((byte)(*param_1)[0] == 0) {\n          return pauVar7;\n        }\n        param_1 = (undefined1 (*) [16])(*param_1 + 1);\n        uVar5 = (uint)param_1 & 0xf;\n      }\n      do {\n        pauVar4 = param_1 + 1;\n        iVar6 = pcmpistri(ZEXT416(uVar3),*param_1,0x40);\n        if ((undefined1 (*) [16])0xffffffef < param_1) {\n          pauVar7 = (undefined1 (*) [16])(*param_1 + iVar6);\n        }\n        param_1 = pauVar4;\n      } while (pauVar4 != (undefined1 (*) [16])0x0);\n    }\n    return pauVar7;\n  }\n  iVar6 = -1;\n  do {\n    pauVar7 = param_1;\n    if (iVar6 == 0) break;\n    iVar6 = iVar6 + -1;\n    pauVar7 = (undefined1 (*) [16])(*param_1 + 1);\n    puVar2 = *param_1;\n    param_1 = pauVar7;\n  } while (*puVar2 != '\\0');\n  iVar6 = -(iVar6 + 1);\n  pbVar10 = pauVar7[-1] + 0xf;\n  do {\n    pbVar9 = pbVar10;\n    if (iVar6 == 0) break;\n    iVar6 = iVar6 + -1;\n    pbVar9 = pbVar10 + -1;\n    bVar1 = *pbVar10;\n    pbVar10 = pbVar9;\n  } while (param_2 != bVar1);\n  pauVar7 = (undefined1 (*) [16])(pbVar9 + 1);\n  if ((*pauVar7)[0] != param_2) {\n    pauVar7 = (undefined1 (*) [16])0x0;\n  }\n  return pauVar7;\n}\n\n"
    },
    {
      "name": "FUN_00408c90",
      "entry": "00408c90",
      "c": "\nulonglong __cdecl FUN_00408c90(uint *param_1,uint *param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined4 uVar18;\n  undefined4 uVar19;\n  undefined4 uVar20;\n  undefined4 uVar21;\n  undefined4 uVar22;\n  undefined4 uVar23;\n  undefined4 uVar24;\n  undefined4 uVar25;\n  undefined4 uVar26;\n  undefined4 uVar27;\n  undefined4 uVar28;\n  undefined4 uVar29;\n  undefined4 uVar30;\n  undefined4 uVar31;\n  undefined4 uVar32;\n  undefined4 uVar33;\n  uint uVar34;\n  uint uVar35;\n  uint uVar36;\n  uint uVar37;\n  uint uVar38;\n  uint uVar39;\n  uint uVar40;\n  uint uVar41;\n  uint uVar42;\n  uint uVar43;\n  uint uVar44;\n  uint uVar45;\n  uint uVar46;\n  uint uVar47;\n  uint *puVar48;\n  undefined4 *puVar49;\n  undefined4 *puVar50;\n  uint *puVar51;\n  undefined4 *puVar52;\n  undefined4 *puVar53;\n  uint uVar54;\n  ulonglong uVar55;\n  \n  if ((param_2 < param_1) && (param_1 < (uint *)(param_3 + (int)param_2))) {\n    puVar49 = (undefined4 *)(param_3 + (int)param_2);\n    puVar52 = (undefined4 *)(param_3 + (int)param_1);\n    uVar46 = param_3;\n    uVar47 = param_3;\n    if (0x1f < param_3) {\n      if ((DAT_0042d020 >> 1 & 1) == 0) {\n        if (((uint)puVar52 & 3) != 0) {\n          uVar47 = (uint)puVar52 & 3;\n          param_3 = param_3 - uVar47;\n          do {\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            puVar49 = (undefined4 *)((int)puVar49 + -1);\n            puVar52 = (undefined4 *)((int)puVar52 - 1);\n            uVar47 = uVar47 - 1;\n          } while (uVar47 != 0);\n        }\n        uVar46 = param_3;\n        if (0x1f < param_3) {\n          uVar46 = param_3 >> 2;\n          while( true ) {\n            if (uVar46 == 0) break;\n            uVar46 = uVar46 - 1;\n            puVar52[-1] = puVar49[-1];\n            puVar49 = puVar49 + -1;\n            puVar52 = puVar52 + -1;\n          }\n          switch(param_3 & 3) {\n          case 0:\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          case 1:\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          case 2:\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            *(undefined1 *)((int)puVar52 - 2) = *(undefined1 *)((int)puVar49 + -2);\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          case 3:\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            *(undefined1 *)((int)puVar52 - 2) = *(undefined1 *)((int)puVar49 + -2);\n            *(undefined1 *)((int)puVar52 - 3) = *(undefined1 *)((int)puVar49 + -3);\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          }\n        }\n      }\n      else {\n        while (puVar50 = puVar49, puVar53 = puVar52, ((uint)puVar52 & 0xf) != 0) {\n          puVar49 = (undefined4 *)((int)puVar49 + -1);\n          puVar52 = (undefined4 *)((int)puVar52 + -1);\n          *(undefined1 *)puVar52 = *(undefined1 *)puVar49;\n          uVar46 = uVar46 - 1;\n        }\n        do {\n          puVar49 = puVar50;\n          puVar52 = puVar53;\n          if (uVar46 < 0x80) break;\n          puVar49 = puVar50 + -0x20;\n          puVar52 = puVar53 + -0x20;\n          uVar3 = puVar50[-0x1f];\n          uVar4 = puVar50[-0x1e];\n          uVar5 = puVar50[-0x1d];\n          uVar6 = puVar50[-0x1c];\n          uVar7 = puVar50[-0x1b];\n          uVar8 = puVar50[-0x1a];\n          uVar9 = puVar50[-0x19];\n          uVar10 = puVar50[-0x18];\n          uVar11 = puVar50[-0x17];\n          uVar12 = puVar50[-0x16];\n          uVar13 = puVar50[-0x15];\n          uVar14 = puVar50[-0x14];\n          uVar15 = puVar50[-0x13];\n          uVar16 = puVar50[-0x12];\n          uVar17 = puVar50[-0x11];\n          uVar18 = puVar50[-0x10];\n          uVar19 = puVar50[-0xf];\n          uVar20 = puVar50[-0xe];\n          uVar21 = puVar50[-0xd];\n          uVar22 = puVar50[-0xc];\n          uVar23 = puVar50[-0xb];\n          uVar24 = puVar50[-10];\n          uVar25 = puVar50[-9];\n          uVar26 = puVar50[-8];\n          uVar27 = puVar50[-7];\n          uVar28 = puVar50[-6];\n          uVar29 = puVar50[-5];\n          uVar30 = puVar50[-4];\n          uVar31 = puVar50[-3];\n          uVar32 = puVar50[-2];\n          uVar33 = puVar50[-1];\n          *puVar52 = *puVar49;\n          puVar53[-0x1f] = uVar3;\n          puVar53[-0x1e] = uVar4;\n          puVar53[-0x1d] = uVar5;\n          puVar53[-0x1c] = uVar6;\n          puVar53[-0x1b] = uVar7;\n          puVar53[-0x1a] = uVar8;\n          puVar53[-0x19] = uVar9;\n          puVar53[-0x18] = uVar10;\n          puVar53[-0x17] = uVar11;\n          puVar53[-0x16] = uVar12;\n          puVar53[-0x15] = uVar13;\n          puVar53[-0x14] = uVar14;\n          puVar53[-0x13] = uVar15;\n          puVar53[-0x12] = uVar16;\n          puVar53[-0x11] = uVar17;\n          puVar53[-0x10] = uVar18;\n          puVar53[-0xf] = uVar19;\n          puVar53[-0xe] = uVar20;\n          puVar53[-0xd] = uVar21;\n          puVar53[-0xc] = uVar22;\n          puVar53[-0xb] = uVar23;\n          puVar53[-10] = uVar24;\n          puVar53[-9] = uVar25;\n          puVar53[-8] = uVar26;\n          puVar53[-7] = uVar27;\n          puVar53[-6] = uVar28;\n          puVar53[-5] = uVar29;\n          puVar53[-4] = uVar30;\n          puVar53[-3] = uVar31;\n          puVar53[-2] = uVar32;\n          puVar53[-1] = uVar33;\n          uVar46 = uVar46 - 0x80;\n          puVar50 = puVar49;\n          puVar53 = puVar52;\n        } while ((uVar46 & 0xffffff80) != 0);\n        puVar50 = puVar49;\n        puVar53 = puVar52;\n        if (0x1f < uVar46) {\n          do {\n            puVar49 = puVar50 + -8;\n            puVar52 = puVar53 + -8;\n            uVar3 = puVar50[-7];\n            uVar4 = puVar50[-6];\n            uVar5 = puVar50[-5];\n            uVar6 = puVar50[-4];\n            uVar7 = puVar50[-3];\n            uVar8 = puVar50[-2];\n            uVar9 = puVar50[-1];\n            *puVar52 = *puVar49;\n            puVar53[-7] = uVar3;\n            puVar53[-6] = uVar4;\n            puVar53[-5] = uVar5;\n            puVar53[-4] = uVar6;\n            puVar53[-3] = uVar7;\n            puVar53[-2] = uVar8;\n            puVar53[-1] = uVar9;\n            uVar46 = uVar46 - 0x20;\n            puVar50 = puVar49;\n            puVar53 = puVar52;\n          } while ((uVar46 & 0xffffffe0) != 0);\n        }\n      }\n    }\n    for (; (uVar46 & 0xfffffffc) != 0; uVar46 = uVar46 - 4) {\n      puVar52 = puVar52 + -1;\n      puVar49 = puVar49 + -1;\n      *puVar52 = *puVar49;\n    }\n    for (; uVar46 != 0; uVar46 = uVar46 - 1) {\n      puVar52 = (undefined4 *)((int)puVar52 - 1);\n      puVar49 = (undefined4 *)((int)puVar49 + -1);\n      *(undefined1 *)puVar52 = *(undefined1 *)puVar49;\n    }\n    return CONCAT44(uVar47,param_1);\n  }\n  uVar46 = param_3;\n  puVar51 = param_1;\n  if (0x1f < param_3) {\n    if (param_3 < 0x80) {\n      if ((DAT_0042d020 >> 1 & 1) != 0) {\nLAB_0040915d:\n        if (uVar46 == 0) goto LAB_004091c0;\n        for (param_3 = uVar46 >> 5; param_3 != 0; param_3 = param_3 - 1) {\n          uVar47 = param_2[1];\n          uVar54 = param_2[2];\n          uVar2 = param_2[3];\n          uVar34 = param_2[4];\n          uVar35 = param_2[5];\n          uVar36 = param_2[6];\n          uVar37 = param_2[7];\n          *puVar51 = *param_2;\n          puVar51[1] = uVar47;\n          puVar51[2] = uVar54;\n          puVar51[3] = uVar2;\n          puVar51[4] = uVar34;\n          puVar51[5] = uVar35;\n          puVar51[6] = uVar36;\n          puVar51[7] = uVar37;\n          param_2 = param_2 + 8;\n          puVar51 = puVar51 + 8;\n        }\n        goto LAB_0040918b;\n      }\nLAB_00408eb7:\n      uVar46 = (uint)param_1 & 3;\n      while (uVar46 != 0) {\n        *(char *)puVar51 = (char)*param_2;\n        param_3 = param_3 - 1;\n        param_2 = (uint *)((int)param_2 + 1);\n        puVar51 = (uint *)((int)puVar51 + 1);\n        uVar46 = (uint)puVar51 & 3;\n      }\n    }\n    else {\n      if ((DAT_0043adc0 >> 1 & 1) != 0) {\n        for (; uVar46 != 0; uVar46 = uVar46 - 1) {\n          *(char *)puVar51 = (char)*param_2;\n          param_2 = (uint *)((int)param_2 + 1);\n          puVar51 = (uint *)((int)puVar51 + 1);\n        }\n        return CONCAT44(param_3,param_1);\n      }\n      if (((((uint)param_1 ^ (uint)param_2) & 0xf) == 0) && ((DAT_0042d020 >> 1 & 1) != 0)) {\n        if (((uint)param_2 & 0xf) != 0) {\n          uVar47 = 0x10 - ((uint)param_2 & 0xf);\n          param_3 = param_3 - uVar47;\n          for (uVar46 = uVar47 & 3; uVar46 != 0; uVar46 = uVar46 - 1) {\n            *(char *)puVar51 = (char)*param_2;\n            param_2 = (uint *)((int)param_2 + 1);\n            puVar51 = (uint *)((int)puVar51 + 1);\n          }\n          for (uVar47 = uVar47 >> 2; uVar47 != 0; uVar47 = uVar47 - 1) {\n            *puVar51 = *param_2;\n            param_2 = param_2 + 1;\n            puVar51 = puVar51 + 1;\n          }\n        }\n        uVar46 = param_3 & 0x7f;\n        for (param_3 = param_3 >> 7; param_3 != 0; param_3 = param_3 - 1) {\n          uVar47 = param_2[1];\n          uVar54 = param_2[2];\n          uVar2 = param_2[3];\n          uVar34 = param_2[4];\n          uVar35 = param_2[5];\n          uVar36 = param_2[6];\n          uVar37 = param_2[7];\n          uVar38 = param_2[8];\n          uVar39 = param_2[9];\n          uVar40 = param_2[10];\n          uVar41 = param_2[0xb];\n          uVar42 = param_2[0xc];\n          uVar43 = param_2[0xd];\n          uVar44 = param_2[0xe];\n          uVar45 = param_2[0xf];\n          *puVar51 = *param_2;\n          puVar51[1] = uVar47;\n          puVar51[2] = uVar54;\n          puVar51[3] = uVar2;\n          puVar51[4] = uVar34;\n          puVar51[5] = uVar35;\n          puVar51[6] = uVar36;\n          puVar51[7] = uVar37;\n          puVar51[8] = uVar38;\n          puVar51[9] = uVar39;\n          puVar51[10] = uVar40;\n          puVar51[0xb] = uVar41;\n          puVar51[0xc] = uVar42;\n          puVar51[0xd] = uVar43;\n          puVar51[0xe] = uVar44;\n          puVar51[0xf] = uVar45;\n          uVar47 = param_2[0x11];\n          uVar54 = param_2[0x12];\n          uVar2 = param_2[0x13];\n          uVar34 = param_2[0x14];\n          uVar35 = param_2[0x15];\n          uVar36 = param_2[0x16];\n          uVar37 = param_2[0x17];\n          uVar38 = param_2[0x18];\n          uVar39 = param_2[0x19];\n          uVar40 = param_2[0x1a];\n          uVar41 = param_2[0x1b];\n          uVar42 = param_2[0x1c];\n          uVar43 = param_2[0x1d];\n          uVar44 = param_2[0x1e];\n          uVar45 = param_2[0x1f];\n          puVar51[0x10] = param_2[0x10];\n          puVar51[0x11] = uVar47;\n          puVar51[0x12] = uVar54;\n          puVar51[0x13] = uVar2;\n          puVar51[0x14] = uVar34;\n          puVar51[0x15] = uVar35;\n          puVar51[0x16] = uVar36;\n          puVar51[0x17] = uVar37;\n          puVar51[0x18] = uVar38;\n          puVar51[0x19] = uVar39;\n          puVar51[0x1a] = uVar40;\n          puVar51[0x1b] = uVar41;\n          puVar51[0x1c] = uVar42;\n          puVar51[0x1d] = uVar43;\n          puVar51[0x1e] = uVar44;\n          puVar51[0x1f] = uVar45;\n          param_2 = param_2 + 0x20;\n          puVar51 = puVar51 + 0x20;\n        }\n        goto LAB_0040915d;\n      }\n      if (((DAT_0043adc0 & 1) == 0) || (((uint)param_1 & 3) != 0)) goto LAB_00408eb7;\n      if (((uint)param_2 & 3) == 0) {\n        if (((uint)param_1 >> 2 & 1) != 0) {\n          uVar46 = *param_2;\n          param_3 = param_3 - 4;\n          param_2 = param_2 + 1;\n          *param_1 = uVar46;\n          param_1 = param_1 + 1;\n        }\n        if (((uint)param_1 >> 3 & 1) != 0) {\n          uVar1 = *(undefined8 *)param_2;\n          param_3 = param_3 - 8;\n          param_2 = param_2 + 2;\n          *(undefined8 *)param_1 = uVar1;\n          param_1 = param_1 + 2;\n        }\n        if (((uint)param_2 & 7) == 0) {\n          puVar51 = param_2 + -2;\n          uVar46 = *param_2;\n          uVar47 = param_2[1];\n          do {\n            puVar48 = puVar51;\n            uVar34 = puVar48[8];\n            uVar35 = puVar48[9];\n            param_3 = param_3 - 0x30;\n            uVar36 = puVar48[6];\n            uVar37 = puVar48[7];\n            uVar38 = puVar48[8];\n            uVar39 = puVar48[9];\n            uVar54 = puVar48[0xe];\n            uVar2 = puVar48[0xf];\n            uVar40 = puVar48[10];\n            uVar41 = puVar48[0xb];\n            uVar42 = puVar48[0xc];\n            uVar43 = puVar48[0xd];\n            param_1[2] = uVar46;\n            param_1[3] = uVar47;\n            param_1[4] = uVar34;\n            param_1[5] = uVar35;\n            param_1[6] = uVar36;\n            param_1[7] = uVar37;\n            param_1[8] = uVar38;\n            param_1[9] = uVar39;\n            param_1[10] = uVar40;\n            param_1[0xb] = uVar41;\n            param_1[0xc] = uVar42;\n            param_1[0xd] = uVar43;\n            param_1 = param_1 + 0xc;\n            puVar51 = puVar48 + 0xc;\n            uVar46 = uVar54;\n            uVar47 = uVar2;\n          } while (0x2f < (int)param_3);\n          puVar48 = puVar48 + 0xe;\n        }\n        else if (((uint)param_2 >> 3 & 1) == 0) {\n          puVar51 = param_2 + -1;\n          uVar46 = *param_2;\n          uVar47 = param_2[1];\n          uVar54 = param_2[2];\n          do {\n            puVar48 = puVar51;\n            uVar36 = puVar48[8];\n            param_3 = param_3 - 0x30;\n            uVar37 = puVar48[5];\n            uVar38 = puVar48[6];\n            uVar39 = puVar48[7];\n            uVar40 = puVar48[8];\n            uVar2 = puVar48[0xd];\n            uVar34 = puVar48[0xe];\n            uVar35 = puVar48[0xf];\n            uVar41 = puVar48[9];\n            uVar42 = puVar48[10];\n            uVar43 = puVar48[0xb];\n            uVar44 = puVar48[0xc];\n            param_1[1] = uVar46;\n            param_1[2] = uVar47;\n            param_1[3] = uVar54;\n            param_1[4] = uVar36;\n            param_1[5] = uVar37;\n            param_1[6] = uVar38;\n            param_1[7] = uVar39;\n            param_1[8] = uVar40;\n            param_1[9] = uVar41;\n            param_1[10] = uVar42;\n            param_1[0xb] = uVar43;\n            param_1[0xc] = uVar44;\n            param_1 = param_1 + 0xc;\n            puVar51 = puVar48 + 0xc;\n            uVar46 = uVar2;\n            uVar47 = uVar34;\n            uVar54 = uVar35;\n          } while (0x2f < (int)param_3);\n          puVar48 = puVar48 + 0xd;\n        }\n        else {\n          puVar51 = param_2 + -3;\n          uVar46 = *param_2;\n          do {\n            puVar48 = puVar51;\n            uVar54 = puVar48[8];\n            uVar2 = puVar48[9];\n            uVar34 = puVar48[10];\n            param_3 = param_3 - 0x30;\n            uVar35 = puVar48[7];\n            uVar36 = puVar48[8];\n            uVar37 = puVar48[9];\n            uVar38 = puVar48[10];\n            uVar47 = puVar48[0xf];\n            uVar39 = puVar48[0xb];\n            uVar40 = puVar48[0xc];\n            uVar41 = puVar48[0xd];\n            uVar42 = puVar48[0xe];\n            param_1[3] = uVar46;\n            param_1[4] = uVar54;\n            param_1[5] = uVar2;\n            param_1[6] = uVar34;\n            param_1[7] = uVar35;\n            param_1[8] = uVar36;\n            param_1[9] = uVar37;\n            param_1[10] = uVar38;\n            param_1[0xb] = uVar39;\n            param_1[0xc] = uVar40;\n            param_1[0xd] = uVar41;\n            param_1[0xe] = uVar42;\n            param_1 = param_1 + 0xc;\n            puVar51 = puVar48 + 0xc;\n            uVar46 = uVar47;\n          } while (0x2f < (int)param_3);\n          puVar48 = puVar48 + 0xf;\n        }\n        for (; 0xf < (int)param_3; param_3 = param_3 - 0x10) {\n          uVar46 = *puVar48;\n          uVar47 = puVar48[1];\n          uVar54 = puVar48[2];\n          uVar2 = puVar48[3];\n          puVar48 = puVar48 + 4;\n          *param_1 = uVar46;\n          param_1[1] = uVar47;\n          param_1[2] = uVar54;\n          param_1[3] = uVar2;\n          param_1 = param_1 + 4;\n        }\n        if ((param_3 >> 2 & 1) != 0) {\n          uVar46 = *puVar48;\n          param_3 = param_3 - 4;\n          puVar48 = puVar48 + 1;\n          *param_1 = uVar46;\n          param_1 = param_1 + 1;\n        }\n        if ((param_3 >> 3 & 1) != 0) {\n          param_3 = param_3 - 8;\n          *(undefined8 *)param_1 = *(undefined8 *)puVar48;\n        }\n                    /* WARNING: Could not recover jumptable at 0x00408eb5. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        uVar55 = (*(code *)(&switchD_00408ee5::switchdataD_00408ef4)[param_3])();\n        return uVar55;\n      }\n    }\n    uVar46 = param_3;\n    if (0x1f < param_3) {\n      for (uVar46 = param_3 >> 2; uVar46 != 0; uVar46 = uVar46 - 1) {\n        *puVar51 = *param_2;\n        param_2 = param_2 + 1;\n        puVar51 = puVar51 + 1;\n      }\n      switch(param_3 & 3) {\n      case 0:\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      case 1:\n        *(char *)puVar51 = (char)*param_2;\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      case 2:\n        *(char *)puVar51 = (char)*param_2;\n        *(undefined1 *)((int)puVar51 + 1) = *(undefined1 *)((int)param_2 + 1);\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      case 3:\n        *(char *)puVar51 = (char)*param_2;\n        *(undefined1 *)((int)puVar51 + 1) = *(undefined1 *)((int)param_2 + 1);\n        *(undefined1 *)((int)puVar51 + 2) = *(undefined1 *)((int)param_2 + 2);\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      }\n    }\n  }\nLAB_0040918b:\n  if ((uVar46 & 0x1f) != 0) {\n    for (uVar47 = (uVar46 & 0x1f) >> 2; uVar47 != 0; uVar47 = uVar47 - 1) {\n      param_3 = *param_2;\n      *puVar51 = param_3;\n      puVar51 = puVar51 + 1;\n      param_2 = param_2 + 1;\n    }\n    for (uVar46 = uVar46 & 3; uVar46 != 0; uVar46 = uVar46 - 1) {\n      *(char *)puVar51 = (char)*param_2;\n      param_2 = (uint *)((int)param_2 + 1);\n      puVar51 = (uint *)((int)puVar51 + 1);\n    }\n  }\nLAB_004091c0:\n  return CONCAT44(param_3,param_1);\n}\n\n"
    },
    {
      "name": "_ValidateLocalCookies",
      "entry": "00409210",
      "c": "\n/* Library Function - Single Match\n    _ValidateLocalCookies\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl _ValidateLocalCookies(int *param_1,int param_2)\n\n{\n  if (*param_1 != -2) {\n    __security_check_cookie(param_1[1] + param_2 ^ *(uint *)(*param_1 + param_2));\n  }\n  __security_check_cookie(param_1[3] + param_2 ^ *(uint *)(param_1[2] + param_2));\n  return;\n}\n\n"
    },
    {
      "name": "__except_handler4",
      "entry": "00409250",
      "c": "\n/* Library Function - Single Match\n    __except_handler4\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl __except_handler4(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  int iVar3;\n  BOOL BVar4;\n  int *piVar5;\n  uint uVar6;\n  PEXCEPTION_RECORD pEVar7;\n  undefined4 uVar8;\n  PEXCEPTION_RECORD local_20;\n  undefined4 local_1c;\n  int local_18;\n  uint *local_14;\n  undefined4 local_10;\n  int *local_c;\n  char local_5;\n  \n  local_5 = '\\0';\n  local_10 = 1;\n  local_18 = (int)param_2 + 0x10;\n  piVar5 = (int *)(*(uint *)((int)param_2 + 8) ^ DAT_0042d008);\n  local_c = piVar5;\n  _ValidateLocalCookies(piVar5,local_18);\n  guard_check_icall();\n  if ((param_1->ExceptionFlags & 0x66) == 0) {\n    local_20 = param_1;\n    local_1c = param_3;\n    *(PEXCEPTION_RECORD **)((int)param_2 + -4) = &local_20;\n    uVar6 = *(uint *)((int)param_2 + 0xc);\n    if (*(uint *)((int)param_2 + 0xc) == 0xfffffffe) {\n      return local_10;\n    }\n    do {\n      local_14 = (uint *)(piVar5 + uVar6 * 3 + 4);\n      uVar1 = *local_14;\n      if ((undefined *)piVar5[uVar6 * 3 + 5] != (undefined *)0x0) {\n        iVar3 = _EH4_CallFilterFunc((undefined *)piVar5[uVar6 * 3 + 5]);\n        local_5 = '\\x01';\n        if (iVar3 < 0) {\n          local_10 = 0;\n          piVar5 = local_c;\n          goto LAB_0040936e;\n        }\n        if (0 < iVar3) {\n          if (((param_1->ExceptionCode == 0xe06d7363) && (DAT_0043b674 != (code *)0x0)) &&\n             (BVar4 = __IsNonwritableInCurrentImage((PBYTE)&DAT_0043b674), pcVar2 = DAT_0043b674,\n             BVar4 != 0)) {\n            uVar8 = 1;\n            pEVar7 = param_1;\n            guard_check_icall();\n            (*pcVar2)(pEVar7,uVar8);\n          }\n          _EH4_GlobalUnwind2(param_2,param_1);\n          if (*(uint *)((int)param_2 + 0xc) != uVar6) {\n            _EH4_LocalUnwind((int)param_2,uVar6,(int)param_2 + 0x10,&DAT_0042d008);\n          }\n          *(uint *)((int)param_2 + 0xc) = uVar1;\n          _ValidateLocalCookies(local_c,(int)param_2 + 0x10);\n          _EH4_TransferToHandler((undefined *)local_14[2]);\n          pcVar2 = (code *)swi(3);\n          uVar8 = (*pcVar2)();\n          return uVar8;\n        }\n      }\n      piVar5 = local_c;\n      uVar6 = uVar1;\n    } while (uVar1 != 0xfffffffe);\n    if (local_5 == '\\0') {\n      return local_10;\n    }\n  }\n  else {\n    if (*(int *)((int)param_2 + 0xc) == -2) {\n      return local_10;\n    }\n    _EH4_LocalUnwind((int)param_2,0xfffffffe,(int)param_2 + 0x10,&DAT_0042d008);\n  }\nLAB_0040936e:\n  _ValidateLocalCookies(piVar5,local_18);\n  return local_10;\n}\n\n"
    },
    {
      "name": "___vcrt_initialize",
      "entry": "004093b6",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_initialize\n   \n   Library: Visual Studio 2015 Release */\n\nuint ___vcrt_initialize(void)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  \n  ___vcrt_initialize_pure_virtual_call_handler();\n  ___vcrt_initialize_winapi_thunks();\n  uVar1 = ___vcrt_initialize_locks();\n  if ((char)uVar1 != '\\0') {\n    uVar2 = ___vcrt_initialize_ptd();\n    if ((char)uVar2 != '\\0') {\n      return CONCAT31((int3)((uint)uVar2 >> 8),1);\n    }\n    uVar1 = ___vcrt_uninitialize_locks();\n  }\n  return uVar1 & 0xffffff00;\n}\n\n"
    },
    {
      "name": "___vcrt_uninitialize",
      "entry": "004093df",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_uninitialize\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nundefined4 __cdecl ___vcrt_uninitialize(char param_1)\n\n{\n  undefined4 in_EAX;\n  \n  if (param_1 == '\\0') {\n    ___vcrt_uninitialize_ptd();\n    ___vcrt_uninitialize_locks();\n    in_EAX = ___vcrt_uninitialize_winapi_thunks('\\0');\n  }\n  return CONCAT31((int3)((uint)in_EAX >> 8),1);\n}\n\n"
    },
    {
      "name": "__local_unwind4",
      "entry": "00409400",
      "c": "\n/* Library Function - Single Match\n    __local_unwind4\n   \n   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual\n   Studio 2019 Release */\n\nvoid __cdecl __local_unwind4(uint *param_1,int param_2,uint param_3)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  void *pvStack_28;\n  undefined1 *puStack_24;\n  uint local_20;\n  uint uStack_1c;\n  int iStack_18;\n  uint *puStack_14;\n  \n  puStack_14 = param_1;\n  iStack_18 = param_2;\n  uStack_1c = param_3;\n  puStack_24 = &LAB_00409490;\n  pvStack_28 = ExceptionList;\n  local_20 = DAT_0042d008 ^ (uint)&pvStack_28;\n  ExceptionList = &pvStack_28;\n  while( true ) {\n    uVar2 = *(uint *)(param_2 + 0xc);\n    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;\n    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);\n    *(undefined4 *)(param_2 + 0xc) = *puVar1;\n    if (puVar1[1] == 0) {\n      __NLG_Notify(0x101);\n      FUN_00409a34();\n    }\n  }\n  ExceptionList = pvStack_28;\n  return;\n}\n\n"
    },
    {
      "name": "_EH4_CallFilterFunc",
      "entry": "004094fe",
      "c": "\n/* Library Function - Single Match\n    @_EH4_CallFilterFunc@8\n   \n   Library: Visual Studio 2015 Release\n   __fastcall _EH4_CallFilterFunc,8 */\n\nvoid __fastcall _EH4_CallFilterFunc(undefined *param_1)\n\n{\n  (*(code *)param_1)();\n  return;\n}\n\n"
    },
    {
      "name": "_EH4_TransferToHandler",
      "entry": "00409515",
      "c": "\n/* Library Function - Single Match\n    @_EH4_TransferToHandler@8\n   \n   Library: Visual Studio 2015 Release\n   __fastcall _EH4_TransferToHandler,8 */\n\nvoid __fastcall _EH4_TransferToHandler(undefined *UNRECOVERED_JUMPTABLE)\n\n{\n  __NLG_Notify(1);\n                    /* WARNING: Could not recover jumptable at 0x0040952c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n"
    },
    {
      "name": "_EH4_GlobalUnwind2",
      "entry": "0040952e",
      "c": "\n/* Library Function - Single Match\n    @_EH4_GlobalUnwind2@8\n   \n   Library: Visual Studio 2015 Release\n   __fastcall _EH4_GlobalUnwind2,8 */\n\nvoid __fastcall _EH4_GlobalUnwind2(PVOID param_1,PEXCEPTION_RECORD param_2)\n\n{\n  RtlUnwind(param_1,(PVOID)0x409542,param_2,(PVOID)0x0);\n  return;\n}\n\n"
    },
    {
      "name": "_EH4_LocalUnwind",
      "entry": "00409547",
      "c": "\n/* Library Function - Single Match\n    @_EH4_LocalUnwind@16\n   \n   Library: Visual Studio 2015 Release\n   __fastcall _EH4_LocalUnwind,16 */\n\nvoid __fastcall _EH4_LocalUnwind(int param_1,uint param_2,undefined4 param_3,uint *param_4)\n\n{\n  __local_unwind4(param_4,param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040955e",
      "entry": "0040955e",
      "c": "\nvoid FUN_0040955e(undefined *param_1)\n\n{\n  if ((param_1 != (undefined *)0x0) && (param_1 != &DAT_0043adc4)) {\n    FID_conflict__free(param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___vcrt_initialize_ptd",
      "entry": "0040957a",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_initialize_ptd\n   \n   Library: Visual Studio 2015 Release */\n\nuint ___vcrt_initialize_ptd(void)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 = ___vcrt_FlsAlloc(FUN_0040955e);\n  DAT_0042d030 = uVar1;\n  if (uVar1 != 0xffffffff) {\n    iVar2 = ___vcrt_FlsSetValue(uVar1,&DAT_0043adc4);\n    if (iVar2 != 0) {\n      return CONCAT31((int3)((uint)iVar2 >> 8),1);\n    }\n    uVar1 = ___vcrt_uninitialize_ptd();\n  }\n  return uVar1 & 0xffffff00;\n}\n\n"
    },
    {
      "name": "___vcrt_uninitialize_ptd",
      "entry": "004095ad",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_uninitialize_ptd\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 ___vcrt_uninitialize_ptd(void)\n\n{\n  DWORD DVar1;\n  \n  DVar1 = DAT_0042d030;\n  if (DAT_0042d030 != 0xffffffff) {\n    DVar1 = ___vcrt_FlsFree(DAT_0042d030);\n    DAT_0042d030 = 0xffffffff;\n  }\n  return CONCAT31((int3)(DVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "___vcrt_initialize_locks",
      "entry": "004095c8",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_initialize_locks\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 ___vcrt_initialize_locks(void)\n\n{\n  int iVar1;\n  uint uVar2;\n  LPCRITICAL_SECTION p_Var3;\n  \n  p_Var3 = (LPCRITICAL_SECTION)&DAT_0043adec;\n  uVar2 = 0;\n  do {\n    iVar1 = ___vcrt_InitializeCriticalSectionEx(p_Var3,4000,0);\n    if (iVar1 == 0) {\n      uVar2 = ___vcrt_uninitialize_locks();\n      return uVar2 & 0xffffff00;\n    }\n    DAT_0043ae04 = DAT_0043ae04 + 1;\n    uVar2 = uVar2 + 0x18;\n    p_Var3 = p_Var3 + 1;\n  } while (uVar2 < 0x18);\n  return CONCAT31((int3)((uint)iVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "___vcrt_uninitialize_locks",
      "entry": "00409604",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_uninitialize_locks\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nundefined4 ___vcrt_uninitialize_locks(void)\n\n{\n  undefined4 in_EAX;\n  undefined4 extraout_EAX;\n  int iVar1;\n  LPCRITICAL_SECTION lpCriticalSection;\n  \n  if (DAT_0043ae04 != 0) {\n    lpCriticalSection = (LPCRITICAL_SECTION)(&DAT_0043add4 + DAT_0043ae04 * 0x18);\n    iVar1 = DAT_0043ae04;\n    do {\n      DeleteCriticalSection(lpCriticalSection);\n      DAT_0043ae04 = DAT_0043ae04 + -1;\n      lpCriticalSection = lpCriticalSection + -1;\n      iVar1 = iVar1 + -1;\n      in_EAX = extraout_EAX;\n    } while (iVar1 != 0);\n  }\n  return CONCAT31((int3)((uint)in_EAX >> 8),1);\n}\n\n"
    },
    {
      "name": "__crt_fast_encode_pointer<void*>",
      "entry": "00409633",
      "c": "\n/* Library Function - Single Match\n    void * __cdecl __crt_fast_encode_pointer<void *>(void * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid * __cdecl __crt_fast_encode_pointer<void*>(void *param_1)\n\n{\n  byte bVar1;\n  \n  bVar1 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n  return (void *)(((uint)param_1 >> bVar1 | (int)param_1 << 0x20 - bVar1) ^ DAT_0042d008);\n}\n\n"
    },
    {
      "name": "try_get_function",
      "entry": "00409650",
      "c": "\n/* Library Function - Single Match\n    void * __cdecl try_get_function(enum `anonymous namespace'::function_id,char const * const,enum\n   A0x89697e75::module_id const * const,enum A0x89697e75::module_id const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid * __cdecl\ntry_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  HMODULE hModule;\n  FARPROC pFVar3;\n  byte bVar4;\n  void *pvVar5;\n  \n  puVar1 = &DAT_0043ae18 + param_1;\n  LOCK();\n  uVar2 = *puVar1;\n  if (uVar2 == 0) {\n    *puVar1 = 0;\n    uVar2 = 0;\n  }\n  UNLOCK();\n  bVar4 = (byte)DAT_0042d008 & 0x1f;\n  pvVar5 = (void *)((DAT_0042d008 ^ uVar2) >> bVar4 | (DAT_0042d008 ^ uVar2) << 0x20 - bVar4);\n  if (pvVar5 != (void *)0xffffffff) {\n    if (pvVar5 != (void *)0x0) {\n      return pvVar5;\n    }\n    if (param_3 != param_4) {\n      do {\n        hModule = try_get_module(*param_3);\n        if (hModule != (HINSTANCE__ *)0x0) goto LAB_004096ac;\n        param_3 = param_3 + 1;\n      } while (param_3 != param_4);\n    }\n    hModule = (HMODULE)0x0;\nLAB_004096ac:\n    if ((hModule != (HMODULE)0x0) &&\n       (pFVar3 = GetProcAddress(hModule,param_2), pFVar3 != (FARPROC)0x0)) {\n      pvVar5 = __crt_fast_encode_pointer<void*>(pFVar3);\n      LOCK();\n      *puVar1 = (uint)pvVar5;\n      UNLOCK();\n      return pFVar3;\n    }\n    bVar4 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n    LOCK();\n    *puVar1 = (0xffffffffU >> bVar4 | -1 << 0x20 - bVar4) ^ DAT_0042d008;\n    UNLOCK();\n  }\n  return (void *)0x0;\n}\n\n"
    },
    {
      "name": "try_get_module",
      "entry": "004096f0",
      "c": "\n/* Library Function - Single Match\n    struct HINSTANCE__ * __cdecl try_get_module(enum `anonymous namespace'::module_id)\n   \n   Library: Visual Studio 2015 Release */\n\nHINSTANCE__ * __cdecl try_get_module(module_id param_1)\n\n{\n  uint *puVar1;\n  LPCWSTR lpLibFileName;\n  uint uVar2;\n  HINSTANCE__ *hLibModule;\n  DWORD DVar3;\n  \n  puVar1 = &DAT_0043ae08 + param_1;\n  LOCK();\n  uVar2 = *puVar1;\n  if (uVar2 == 0) {\n    *puVar1 = 0;\n    uVar2 = 0;\n  }\n  UNLOCK();\n  if (uVar2 == 0) {\n    lpLibFileName = (LPCWSTR)(&PTR_u_advapi32_00425e08)[param_1];\n    hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0x800);\n    if (hLibModule == (HMODULE)0x0) {\n      DVar3 = GetLastError();\n      if (DVar3 == 0x57) {\n        hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0);\n      }\n      else {\n        hLibModule = (HMODULE)0x0;\n      }\n      if (hLibModule == (HMODULE)0x0) {\n        LOCK();\n        *puVar1 = 0xffffffff;\n        UNLOCK();\n        return (HINSTANCE__ *)0x0;\n      }\n    }\n    LOCK();\n    uVar2 = *puVar1;\n    *puVar1 = (uint)hLibModule;\n    UNLOCK();\n    if (uVar2 != 0) {\n      FreeLibrary(hLibModule);\n    }\n  }\n  else {\n    hLibModule = (HINSTANCE__ *)(-(uint)(uVar2 != 0xffffffff) & uVar2);\n  }\n  return hLibModule;\n}\n\n"
    },
    {
      "name": "___vcrt_FlsAlloc",
      "entry": "00409771",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_FlsAlloc\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___vcrt_FlsAlloc(undefined4 param_1)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)try_get_function(4,\"FlsAlloc\",(module_id *)&DAT_00425eb8,(module_id *)\"FlsAlloc\")\n  ;\n  if (pcVar1 != (code *)0x0) {\n    guard_check_icall();\n    (*pcVar1)(param_1);\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x004097a5. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  TlsAlloc();\n  return;\n}\n\n"
    },
    {
      "name": "___vcrt_FlsFree",
      "entry": "004097ab",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_FlsFree\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___vcrt_FlsFree(DWORD param_1)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)try_get_function(5,\"FlsFree\",(module_id *)&DAT_00425ecc,(module_id *)\"FlsFree\");\n  if (pcVar1 == (code *)0x0) {\n    TlsFree(param_1);\n  }\n  else {\n    guard_check_icall();\n    (*pcVar1)();\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___vcrt_FlsSetValue",
      "entry": "004097e5",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_FlsSetValue\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___vcrt_FlsSetValue(DWORD param_1,LPVOID param_2)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)try_get_function(7,\"FlsSetValue\",(module_id *)&DAT_00425ee8,\n                                    (module_id *)\"FlsSetValue\");\n  if (pcVar1 == (code *)0x0) {\n    TlsSetValue(param_1,param_2);\n  }\n  else {\n    guard_check_icall();\n    (*pcVar1)();\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___vcrt_InitializeCriticalSectionEx",
      "entry": "00409822",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_InitializeCriticalSectionEx\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___vcrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)try_get_function(8,\"InitializeCriticalSectionEx\",(module_id *)&DAT_00425efc,\n                                    (module_id *)\"InitializeCriticalSectionEx\");\n  if (pcVar1 == (code *)0x0) {\n    InitializeCriticalSectionAndSpinCount(param_1,param_2);\n  }\n  else {\n    guard_check_icall();\n    (*pcVar1)(param_1,param_2,param_3);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___vcrt_initialize_winapi_thunks",
      "entry": "00409868",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_initialize_winapi_thunks\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___vcrt_initialize_winapi_thunks(void)\n\n{\n  byte bVar1;\n  uint *puVar2;\n  int iVar3;\n  uint uVar4;\n  \n  puVar2 = &DAT_0043ae18;\n  bVar1 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n  iVar3 = 0;\n  uVar4 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0042d008;\n  do {\n    iVar3 = iVar3 + 1;\n    *puVar2 = uVar4;\n    puVar2 = puVar2 + 1;\n  } while (iVar3 != 9);\n  return;\n}\n\n"
    },
    {
      "name": "___vcrt_uninitialize_winapi_thunks",
      "entry": "004098a2",
      "c": "\n/* Library Function - Single Match\n    ___vcrt_uninitialize_winapi_thunks\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl ___vcrt_uninitialize_winapi_thunks(char param_1)\n\n{\n  int *piVar1;\n  \n  if (param_1 == '\\0') {\n    piVar1 = &DAT_0043ae08;\n    do {\n      if (*piVar1 != 0) {\n        if (*piVar1 != -1) {\n          FreeLibrary((HMODULE)*piVar1);\n        }\n        *piVar1 = 0;\n      }\n      piVar1 = piVar1 + 1;\n    } while (piVar1 != &DAT_0043ae18);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___vcrt_initialize_pure_virtual_call_handler",
      "entry": "004098d4",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___vcrt_initialize_pure_virtual_call_handler\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___vcrt_initialize_pure_virtual_call_handler(void)\n\n{\n  byte bVar1;\n  \n  bVar1 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n  _DAT_0043ae3c = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0042d008;\n  return;\n}\n\n"
    },
    {
      "name": "__global_unwind2",
      "entry": "00409900",
      "c": "\n/* Library Function - Single Match\n    __global_unwind2\n   \n   Library: Visual Studio */\n\nvoid __cdecl __global_unwind2(PVOID param_1)\n\n{\n  RtlUnwind(param_1,(PVOID)0x409918,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);\n  return;\n}\n\n"
    },
    {
      "name": "__local_unwind2",
      "entry": "00409965",
      "c": "\n/* Library Function - Single Match\n    __local_unwind2\n   \n   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual\n   Studio 2019 Release */\n\nvoid __cdecl __local_unwind2(int param_1,uint param_2)\n\n{\n  uint uVar1;\n  void *local_20;\n  undefined1 *puStack_1c;\n  undefined4 local_18;\n  int iStack_14;\n  \n  iStack_14 = param_1;\n  puStack_1c = &LAB_00409920;\n  local_20 = ExceptionList;\n  ExceptionList = &local_20;\n  while( true ) {\n    uVar1 = *(uint *)(param_1 + 0xc);\n    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;\n    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);\n    *(undefined4 *)(param_1 + 0xc) = local_18;\n    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {\n      __NLG_Notify(0x101);\n      FUN_00409a34();\n    }\n  }\n  ExceptionList = local_20;\n  return;\n}\n\n"
    },
    {
      "name": "__NLG_Notify",
      "entry": "00409a15",
      "c": "\n/* Library Function - Single Match\n    __NLG_Notify\n   \n   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual\n   Studio 2019 Release */\n\nvoid __NLG_Notify(ulong param_1)\n\n{\n  undefined4 in_EAX;\n  undefined4 unaff_EBP;\n  \n  DAT_0042d048 = param_1;\n  DAT_0042d044 = in_EAX;\n  DAT_0042d04c = unaff_EBP;\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00409a34",
      "entry": "00409a34",
      "c": "\nvoid FUN_00409a34(void)\n\n{\n  code *in_EAX;\n  \n  (*in_EAX)();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00409a50",
      "entry": "00409a50",
      "c": "\nundefined1 FUN_00409a50(void)\n\n{\n  return 1;\n}\n\n"
    },
    {
      "name": "FUN_00409a53",
      "entry": "00409a53",
      "c": "\nundefined * FUN_00409a53(void)\n\n{\n  return &DAT_0043ae7c;\n}\n\n"
    },
    {
      "name": "FUN_00409a59",
      "entry": "00409a59",
      "c": "\nundefined4 * FUN_00409a59(void)\n\n{\n  return &DAT_0043ae84;\n}\n\n"
    },
    {
      "name": "_strncmp",
      "entry": "00409a60",
      "c": "\n/* Library Function - Single Match\n    _strncmp\n   \n   Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */\n\nint __cdecl _strncmp(char *_Str1,char *_Str2,size_t _MaxCount)\n\n{\n  byte bVar1;\n  uint uVar2;\n  int iVar3;\n  bool bVar4;\n  \n  if (_MaxCount != 0) {\n    iVar3 = (int)_Str1 - (int)_Str2;\n    uVar2 = (uint)_Str2 & 3;\n    while( true ) {\n      if (uVar2 == 0) {\n        while ((((uint)((int)_Str2 + iVar3) & 0xfff) < 0xffd &&\n               (uVar2 = *(uint *)((int)_Str2 + iVar3), uVar2 == *(uint *)_Str2))) {\n          bVar4 = _MaxCount < 4;\n          _MaxCount = _MaxCount - 4;\n          if (bVar4 || _MaxCount == 0) {\n            return 0;\n          }\n          _Str2 = (char *)((int)_Str2 + 4);\n          if ((~uVar2 & uVar2 + 0xfefefeff & 0x80808080) != 0) {\n            return 0;\n          }\n        }\n      }\n      bVar1 = *(byte *)((int)_Str2 + iVar3);\n      if (bVar1 != (byte)*(uint *)_Str2) {\n        return -(uint)(bVar1 < (byte)*(uint *)_Str2) | 1;\n      }\n      if (bVar1 == 0) break;\n      _Str2 = (char *)((int)_Str2 + 1);\n      bVar4 = _MaxCount == 0;\n      _MaxCount = _MaxCount - 1;\n      if (bVar4 || _MaxCount == 0) {\n        return 0;\n      }\n      uVar2 = (uint)_Str2 & 3;\n    }\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_00409ad8",
      "entry": "00409ad8",
      "c": "\nuint __cdecl FUN_00409ad8(char *param_1,uint param_2)\n\n{\n  bool bVar1;\n  undefined1 auVar2 [32];\n  char *pcVar3;\n  uint uVar4;\n  undefined1 (*pauVar5) [32];\n  uint uVar6;\n  undefined1 (*pauVar7) [32];\n  char *pcVar8;\n  undefined1 auVar9 [16];\n  undefined1 in_ZMM1 [64];\n  undefined1 auVar10 [64];\n  \n  if (DAT_0043adbc < 5) {\n    if (DAT_0043adbc < 1) {\n      pcVar3 = param_1;\n      if (param_1 != param_1 + param_2) {\n        do {\n          if (*pcVar3 == '\\0') break;\n          pcVar3 = pcVar3 + 1;\n        } while (pcVar3 != param_1 + param_2);\n      }\n      uVar4 = (int)pcVar3 - (int)param_1;\n    }\n    else {\n      uVar6 = -(uint)(((uint)param_1 & 0xf) != 0) & 0x10 - ((uint)param_1 & 0xf);\n      if (param_2 < uVar6) {\n        uVar6 = param_2;\n      }\n      pcVar3 = param_1;\n      if (param_1 != param_1 + uVar6) {\n        do {\n          if (*pcVar3 == '\\0') break;\n          pcVar3 = pcVar3 + 1;\n        } while (pcVar3 != param_1 + uVar6);\n      }\n      uVar4 = (int)pcVar3 - (int)param_1;\n      if (uVar4 == uVar6) {\n        pcVar3 = param_1 + uVar4;\n        auVar10 = ZEXT4864(in_ZMM1._16_48_) << 0x80;\n        pcVar8 = pcVar3 + ((param_2 - uVar6) - (param_2 - uVar6 & 0xf));\n        for (; pcVar3 != pcVar8; pcVar3 = pcVar3 + 0x10) {\n          auVar9[0] = -(*pcVar3 == '\\0');\n          auVar9[1] = -(pcVar3[1] == '\\0');\n          auVar9[2] = -(pcVar3[2] == '\\0');\n          auVar9[3] = -(pcVar3[3] == '\\0');\n          auVar9[4] = -(pcVar3[4] == '\\0');\n          auVar9[5] = -(pcVar3[5] == '\\0');\n          auVar9[6] = -(pcVar3[6] == '\\0');\n          auVar9[7] = -(pcVar3[7] == '\\0');\n          auVar9[8] = -(pcVar3[8] == auVar10[8]);\n          auVar9[9] = -(pcVar3[9] == auVar10[9]);\n          auVar9[10] = -(pcVar3[10] == auVar10[10]);\n          auVar9[0xb] = -(pcVar3[0xb] == auVar10[0xb]);\n          auVar9[0xc] = -(pcVar3[0xc] == auVar10[0xc]);\n          auVar9[0xd] = -(pcVar3[0xd] == auVar10[0xd]);\n          auVar9[0xe] = -(pcVar3[0xe] == auVar10[0xe]);\n          bVar1 = pcVar3[0xf] == auVar10[0xf];\n          auVar9[0xf] = -bVar1;\n          if ((((((((((((((((auVar9 >> 7 & (undefined1  [16])0x1) != (undefined1  [16])0x0 ||\n                           (auVar9 >> 0xf & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                          (auVar9 >> 0x17 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                         (auVar9 >> 0x1f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                        (auVar9 >> 0x27 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                       (auVar9 >> 0x2f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                      (auVar9 >> 0x37 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                     (auVar9 >> 0x3f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                    (auVar9 >> 0x47 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                   (auVar9 >> 0x4f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                  (auVar9 >> 0x57 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                 (auVar9 >> 0x5f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                (auVar9 >> 0x67 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n               (auVar9 >> 0x6f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n              (auVar9 >> 0x77 & (undefined1  [16])0x1) != (undefined1  [16])0x0) || bVar1) break;\n        }\n        for (; (pcVar3 != param_1 + param_2 && (*pcVar3 != '\\0')); pcVar3 = pcVar3 + 1) {\n        }\n        uVar4 = (int)pcVar3 - (int)param_1;\n      }\n    }\n  }\n  else {\n    uVar6 = -(uint)(((uint)param_1 & 0x1f) != 0) & 0x20 - ((uint)param_1 & 0x1f);\n    if (param_2 < uVar6) {\n      uVar6 = param_2;\n    }\n    pcVar3 = param_1;\n    if (param_1 != param_1 + uVar6) {\n      do {\n        if (*pcVar3 == '\\0') break;\n        pcVar3 = pcVar3 + 1;\n      } while (pcVar3 != param_1 + uVar6);\n    }\n    uVar4 = (int)pcVar3 - (int)param_1;\n    if (uVar4 == uVar6) {\n      pauVar5 = (undefined1 (*) [32])(param_1 + uVar4);\n      pauVar7 = (undefined1 (*) [32])(((param_2 - uVar6) - (param_2 - uVar6 & 0x1f)) + (int)pauVar5)\n      ;\n      while ((pauVar5 != pauVar7 &&\n             (auVar2 = vpcmpeqb_avx2(ZEXT832(0) << 0x40,*pauVar5),\n             (((((((((((((((((((((((((((((((auVar2 >> 7 & (undefined1  [32])0x1) ==\n                                           (undefined1  [32])0x0 &&\n                                          (auVar2 >> 0xf & (undefined1  [32])0x1) ==\n                                          (undefined1  [32])0x0) &&\n                                         (auVar2 >> 0x17 & (undefined1  [32])0x1) ==\n                                         (undefined1  [32])0x0) &&\n                                        (auVar2 >> 0x1f & (undefined1  [32])0x1) ==\n                                        (undefined1  [32])0x0) &&\n                                       (auVar2 >> 0x27 & (undefined1  [32])0x1) ==\n                                       (undefined1  [32])0x0) &&\n                                      (auVar2 >> 0x2f & (undefined1  [32])0x1) ==\n                                      (undefined1  [32])0x0) &&\n                                     (auVar2 >> 0x37 & (undefined1  [32])0x1) ==\n                                     (undefined1  [32])0x0) &&\n                                    (auVar2 >> 0x3f & (undefined1  [32])0x1) ==\n                                    (undefined1  [32])0x0) &&\n                                   (auVar2 >> 0x47 & (undefined1  [32])0x1) == (undefined1  [32])0x0\n                                   ) && (auVar2 >> 0x4f & (undefined1  [32])0x1) ==\n                                        (undefined1  [32])0x0) &&\n                                 (auVar2 >> 0x57 & (undefined1  [32])0x1) == (undefined1  [32])0x0)\n                                && (auVar2 >> 0x5f & (undefined1  [32])0x1) == (undefined1  [32])0x0\n                                ) && (auVar2 >> 0x67 & (undefined1  [32])0x1) ==\n                                     (undefined1  [32])0x0) &&\n                              (auVar2 >> 0x6f & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                             (auVar2 >> 0x77 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                            SUB321(auVar2 >> 0x7f,0) == '\\0') &&\n                           (auVar2 >> 0x87 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                          (auVar2 >> 0x8f & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                         (auVar2 >> 0x97 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                        (auVar2 >> 0x9f & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                       (auVar2 >> 0xa7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                      (auVar2 >> 0xaf & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                     (auVar2 >> 0xb7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                    SUB321(auVar2 >> 0xbf,0) == '\\0') &&\n                   (auVar2 >> 199 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                  (auVar2 >> 0xcf & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                 (auVar2 >> 0xd7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                (auVar2 >> 0xdf & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n               (auVar2 >> 0xe7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n              (auVar2 >> 0xef & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n             (auVar2 >> 0xf7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) && -1 < auVar2[0x1f]\n             ))) {\n        pauVar5 = pauVar5 + 1;\n      }\n      for (; (pauVar5 != (undefined1 (*) [32])(param_1 + param_2) && ((*pauVar5)[0] != '\\0'));\n          pauVar5 = (undefined1 (*) [32])(*pauVar5 + 1)) {\n      }\n      uVar4 = (int)pauVar5 - (int)param_1;\n    }\n  }\n  return uVar4;\n}\n\n"
    },
    {
      "name": "FUN_00409bff",
      "entry": "00409bff",
      "c": "\nuint __cdecl FUN_00409bff(short *param_1,uint param_2)\n\n{\n  undefined1 (*pauVar1) [32];\n  short *psVar2;\n  undefined1 auVar3 [32];\n  uint uVar4;\n  undefined1 (*pauVar5) [32];\n  short *psVar6;\n  int iVar7;\n  uint uVar8;\n  undefined1 auVar9 [16];\n  undefined1 in_ZMM1 [64];\n  undefined1 auVar10 [64];\n  \n  psVar6 = param_1;\n  if (DAT_0043adbc < 5) {\n    if (DAT_0043adbc < 1) {\n      if (param_1 != param_1 + param_2) {\n        do {\n          if (*psVar6 == 0) break;\n          psVar6 = psVar6 + 1;\n        } while (psVar6 != param_1 + param_2);\n      }\n    }\n    else {\n      if (((uint)param_1 & 1) == 0) {\n        uVar8 = (-(uint)(((uint)param_1 & 0xf) != 0) & 0x10 - ((uint)param_1 & 0xf)) >> 1;\n        if (param_2 < uVar8) {\n          uVar8 = param_2;\n        }\n        if (param_1 != param_1 + uVar8) {\n          do {\n            if (*psVar6 == 0) break;\n            psVar6 = psVar6 + 1;\n          } while (psVar6 != param_1 + uVar8);\n        }\n        uVar4 = (int)psVar6 - (int)param_1 >> 1;\n        if (uVar4 != uVar8) {\n          return uVar4;\n        }\n        psVar6 = param_1 + uVar4;\n        auVar10 = ZEXT4864(in_ZMM1._16_48_) << 0x80;\n        psVar2 = psVar6 + ((param_2 - uVar8) - (param_2 - uVar8 & 0xf));\n        for (; psVar6 != psVar2; psVar6 = psVar6 + 8) {\n          auVar9._0_2_ = -(ushort)(*psVar6 == 0);\n          auVar9._2_2_ = -(ushort)(psVar6[1] == 0);\n          auVar9._4_2_ = -(ushort)(psVar6[2] == 0);\n          auVar9._6_2_ = -(ushort)(psVar6[3] == 0);\n          auVar9._8_2_ = -(ushort)(psVar6[4] == auVar10._8_2_);\n          auVar9._10_2_ = -(ushort)(psVar6[5] == auVar10._10_2_);\n          auVar9._12_2_ = -(ushort)(psVar6[6] == auVar10._12_2_);\n          auVar9._14_2_ = -(ushort)(psVar6[7] == auVar10._14_2_);\n          if ((((((((((((((((auVar9 >> 7 & (undefined1  [16])0x1) != (undefined1  [16])0x0 ||\n                           (auVar9 >> 0xf & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                          (auVar9 >> 0x17 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                         (auVar9 >> 0x1f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                        (auVar9 >> 0x27 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                       (auVar9 >> 0x2f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                      (auVar9 >> 0x37 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                     (auVar9 >> 0x3f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                    (auVar9 >> 0x47 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                   (auVar9 >> 0x4f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                  (auVar9 >> 0x57 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                 (auVar9 >> 0x5f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n                (auVar9 >> 0x67 & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n               (auVar9 >> 0x6f & (undefined1  [16])0x1) != (undefined1  [16])0x0) ||\n              (auVar9._14_2_ >> 7 & 1) != 0) || (auVar9._14_2_ & 0x8000) != 0) break;\n        }\n        for (; (psVar6 != param_1 + param_2 && (*psVar6 != 0)); psVar6 = psVar6 + 1) {\n        }\n        iVar7 = (int)psVar6 - (int)param_1;\n        goto LAB_00409dac;\n      }\n      if (param_1 != param_1 + param_2) {\n        do {\n          if (*psVar6 == 0) break;\n          psVar6 = psVar6 + 1;\n        } while (psVar6 != param_1 + param_2);\n      }\n    }\n  }\n  else {\n    if (((uint)param_1 & 1) == 0) {\n      uVar8 = (-(uint)(((uint)param_1 & 0x1f) != 0) & 0x20 - ((uint)param_1 & 0x1f)) >> 1;\n      if (param_2 < uVar8) {\n        uVar8 = param_2;\n      }\n      if (param_1 != param_1 + uVar8) {\n        do {\n          if (*psVar6 == 0) break;\n          psVar6 = psVar6 + 1;\n        } while (psVar6 != param_1 + uVar8);\n      }\n      uVar4 = (int)psVar6 - (int)param_1 >> 1;\n      if (uVar4 != uVar8) {\n        return uVar4;\n      }\n      pauVar5 = (undefined1 (*) [32])(param_1 + uVar4);\n      pauVar1 = (undefined1 (*) [32])\n                ((int)pauVar5 + ((param_2 - uVar8) - (param_2 - uVar8 & 0x1f)) * 2);\n      while ((pauVar5 != pauVar1 &&\n             (auVar3 = vpcmpeqw_avx2(ZEXT832(0) << 0x40,*pauVar5),\n             (((((((((((((((((((((((((((((((auVar3 >> 7 & (undefined1  [32])0x1) ==\n                                           (undefined1  [32])0x0 &&\n                                          (auVar3 >> 0xf & (undefined1  [32])0x1) ==\n                                          (undefined1  [32])0x0) &&\n                                         (auVar3 >> 0x17 & (undefined1  [32])0x1) ==\n                                         (undefined1  [32])0x0) &&\n                                        (auVar3 >> 0x1f & (undefined1  [32])0x1) ==\n                                        (undefined1  [32])0x0) &&\n                                       (auVar3 >> 0x27 & (undefined1  [32])0x1) ==\n                                       (undefined1  [32])0x0) &&\n                                      (auVar3 >> 0x2f & (undefined1  [32])0x1) ==\n                                      (undefined1  [32])0x0) &&\n                                     (auVar3 >> 0x37 & (undefined1  [32])0x1) ==\n                                     (undefined1  [32])0x0) &&\n                                    (auVar3 >> 0x3f & (undefined1  [32])0x1) ==\n                                    (undefined1  [32])0x0) &&\n                                   (auVar3 >> 0x47 & (undefined1  [32])0x1) == (undefined1  [32])0x0\n                                   ) && (auVar3 >> 0x4f & (undefined1  [32])0x1) ==\n                                        (undefined1  [32])0x0) &&\n                                 (auVar3 >> 0x57 & (undefined1  [32])0x1) == (undefined1  [32])0x0)\n                                && (auVar3 >> 0x5f & (undefined1  [32])0x1) == (undefined1  [32])0x0\n                                ) && (auVar3 >> 0x67 & (undefined1  [32])0x1) ==\n                                     (undefined1  [32])0x0) &&\n                              (auVar3 >> 0x6f & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                             (auVar3 >> 0x77 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                            SUB321(auVar3 >> 0x7f,0) == '\\0') &&\n                           (auVar3 >> 0x87 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                          (auVar3 >> 0x8f & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                         (auVar3 >> 0x97 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                        (auVar3 >> 0x9f & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                       (auVar3 >> 0xa7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                      (auVar3 >> 0xaf & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                     (auVar3 >> 0xb7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                    SUB321(auVar3 >> 0xbf,0) == '\\0') &&\n                   (auVar3 >> 199 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                  (auVar3 >> 0xcf & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                 (auVar3 >> 0xd7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n                (auVar3 >> 0xdf & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n               (auVar3 >> 0xe7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n              (auVar3 >> 0xef & (undefined1  [32])0x1) == (undefined1  [32])0x0) &&\n             (auVar3 >> 0xf7 & (undefined1  [32])0x1) == (undefined1  [32])0x0) && -1 < auVar3[0x1f]\n             ))) {\n        pauVar5 = pauVar5 + 1;\n      }\n      for (; (pauVar5 != (undefined1 (*) [32])(param_1 + param_2) && (*(short *)*pauVar5 != 0));\n          pauVar5 = (undefined1 (*) [32])(*pauVar5 + 2)) {\n      }\n      return (int)pauVar5 - (int)param_1 >> 1;\n    }\n    if (param_1 != param_1 + param_2) {\n      do {\n        if (*psVar6 == 0) break;\n        psVar6 = psVar6 + 1;\n      } while (psVar6 != param_1 + param_2);\n    }\n  }\n  iVar7 = (int)psVar6 - (int)param_1;\nLAB_00409dac:\n  return iVar7 >> 1;\n}\n\n"
    },
    {
      "name": "FID_conflict:_free",
      "entry": "00409db6",
      "c": "\nvoid __cdecl FID_conflict__free(void *_Memory)\n\n{\n  BOOL BVar1;\n  int *piVar2;\n  DWORD DVar3;\n  int iVar4;\n  \n  if (_Memory != (void *)0x0) {\n    BVar1 = HeapFree(DAT_0043b564,0,_Memory);\n    if (BVar1 == 0) {\n      piVar2 = __errno();\n      DVar3 = GetLastError();\n      iVar4 = FID_conflict____acrt_errno_from_os_error(DVar3);\n      *piVar2 = iVar4;\n    }\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00409dbb",
      "entry": "00409dbb",
      "c": "\nvoid FUN_00409dbb(size_t param_1)\n\n{\n  __malloc_base(param_1);\n  return;\n}\n\n"
    },
    {
      "name": "__fclose_nolock",
      "entry": "00409dc6",
      "c": "\n/* Library Function - Single Match\n    __fclose_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __fclose_nolock(FILE *_File)\n\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  \n  if (_File == (FILE *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    iVar2 = -1;\n  }\n  else {\n    iVar2 = -1;\n    if (((uint)_File->_flag >> 0xd & 1) != 0) {\n      iVar2 = ___acrt_stdio_flush_nolock(_File);\n      ___acrt_stdio_free_buffer_nolock(&_File->_ptr);\n      iVar3 = __fileno(_File);\n      iVar3 = __close(iVar3);\n      if (iVar3 < 0) {\n        iVar2 = -1;\n      }\n      else if (_File->_tmpfname != (char *)0x0) {\n        FID_conflict__free(_File->_tmpfname);\n        _File->_tmpfname = (char *)0x0;\n      }\n    }\n    __acrt_stdio_free_stream(_File);\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "_fclose",
      "entry": "00409e3c",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    _fclose\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _fclose(FILE *_File)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if (_File == (FILE *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    if (((uint)_File->_flag >> 0xc & 1) == 0) {\n      __lock_file(_File);\n      iVar2 = __fclose_nolock(_File);\n      FUN_00409eb2();\n      return iVar2;\n    }\n    __acrt_stdio_free_stream();\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "FUN_00409eb2",
      "entry": "00409eb2",
      "c": "\nvoid FUN_00409eb2(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file(*(FILE **)(unaff_EBP + -0x20));\n  return;\n}\n\n"
    },
    {
      "name": "_feof",
      "entry": "00409ebc",
      "c": "\n/* Library Function - Single Match\n    _feof\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _feof(FILE *_File)\n\n{\n  int *piVar1;\n  \n  if (_File == (FILE *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0;\n  }\n  return (uint)_File->_flag >> 3 & 1;\n}\n\n"
    },
    {
      "name": "_ferror",
      "entry": "00409ee7",
      "c": "\n/* Library Function - Single Match\n    _ferror\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _ferror(FILE *_File)\n\n{\n  int *piVar1;\n  \n  if (_File == (FILE *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0;\n  }\n  return (uint)_File->_flag >> 4 & 1;\n}\n\n"
    },
    {
      "name": "__fread_nolock_s",
      "entry": "00409f12",
      "c": "\n/* Library Function - Single Match\n    __fread_nolock_s\n   \n   Library: Visual Studio 2015 Release */\n\nsize_t __cdecl\n__fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File)\n\n{\n  int *piVar1;\n  char *_MaxCount;\n  int iVar2;\n  char *_DstSize_00;\n  char *pcVar3;\n  undefined1 *_DstBuf_00;\n  uint uVar4;\n  char *local_18;\n  char *local_10;\n  undefined1 *local_8;\n  \n  if ((_ElementSize != 0) && (_Count != 0)) {\n    if (_DstBuf != (void *)0x0) {\n      if ((_File != (FILE *)0x0) && (_Count <= (uint)(0xffffffff / (ulonglong)_ElementSize))) {\nLAB_00409f84:\n        piVar1 = &_File->_flag;\n        if ((*piVar1 & 0x4c0U) == 0) {\n          local_10 = (char *)0x1000;\n        }\n        else {\n          local_10 = (char *)_File->_bufsiz;\n        }\n        local_8 = (undefined1 *)_DstBuf;\n        _DstSize_00 = (char *)_DstSize;\n        pcVar3 = (char *)(_ElementSize * _Count);\n        do {\n          while( true ) {\n            if (pcVar3 == (char *)0x0) {\n              return _Count;\n            }\n            if ((_File->_flag & 0x4c0U) != 0) break;\nLAB_0040a008:\n            if (pcVar3 < local_10) {\n              iVar2 = FUN_004132c2();\n              if (iVar2 == -1) goto LAB_0040a0cc;\n              if (_DstSize_00 == (char *)0x0) goto LAB_0040a0a0;\n              *local_8 = (char)iVar2;\n              local_8 = local_8 + 1;\n              pcVar3 = pcVar3 + -1;\n              _DstSize_00 = _DstSize_00 + -1;\n              local_10 = (char *)_File->_bufsiz;\n            }\n            else {\n              local_18 = pcVar3;\n              if ((char *)0x7fffffff < pcVar3) {\n                local_18 = (char *)0x7fffffff;\n              }\n              if (local_10 != (char *)0x0) {\n                local_18 = local_18 + -((uint)local_18 % (uint)local_10);\n              }\n              if (_DstSize_00 < local_18) goto LAB_0040a0a0;\n              _DstBuf_00 = local_8;\n              iVar2 = __fileno(_File);\n              iVar2 = __read_nolock(iVar2,_DstBuf_00,(uint)local_18);\n              if (iVar2 == 0) {\n                uVar4 = 8;\n                goto LAB_0040a0c5;\n              }\n              if (iVar2 < 0) goto LAB_0040a0c3;\n              pcVar3 = pcVar3 + -iVar2;\n              local_8 = local_8 + iVar2;\n              _DstSize_00 = _DstSize_00 + -iVar2;\n            }\n          }\n          _MaxCount = _File->_base;\n          if (_MaxCount == (char *)0x0) goto LAB_0040a008;\n          if ((int)_MaxCount < 0) {\nLAB_0040a0c3:\n            uVar4 = 0x10;\nLAB_0040a0c5:\n            LOCK();\n            *piVar1 = *piVar1 | uVar4;\n            UNLOCK();\nLAB_0040a0cc:\n            return (uint)((int)(_ElementSize * _Count) - (int)pcVar3) / _ElementSize;\n          }\n          if (pcVar3 < _MaxCount) {\n            _MaxCount = pcVar3;\n          }\n          if (_DstSize_00 < _MaxCount) {\nLAB_0040a0a0:\n            if (_DstSize != 0xffffffff) {\n              _memset(_DstBuf,0,_DstSize);\n            }\n            piVar1 = __errno();\n            *piVar1 = 0x22;\n            goto LAB_00409f3c;\n          }\n          _memcpy_s(local_8,(rsize_t)_DstSize_00,_File->_ptr,(rsize_t)_MaxCount);\n          pcVar3 = pcVar3 + -(int)_MaxCount;\n          local_8 = local_8 + (int)_MaxCount;\n          _File->_base = _File->_base + -(int)_MaxCount;\n          _File->_ptr = _MaxCount + (int)_File->_ptr;\n          _DstSize_00 = _DstSize_00 + -(int)_MaxCount;\n        } while( true );\n      }\n      if (_DstSize != 0xffffffff) {\n        _memset(_DstBuf,0,_DstSize);\n      }\n      if ((_File != (FILE *)0x0) && (_Count <= (uint)(0xffffffff / (ulonglong)_ElementSize)))\n      goto LAB_00409f84;\n    }\n    piVar1 = __errno();\n    *piVar1 = 0x16;\nLAB_00409f3c:\n    FUN_00412362();\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "_fread",
      "entry": "0040a0de",
      "c": "\n/* Library Function - Single Match\n    _fread\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nsize_t __cdecl _fread(void *_DstBuf,size_t _ElementSize,size_t _Count,FILE *_File)\n\n{\n  size_t sVar1;\n  \n  sVar1 = _fread_s(_DstBuf,0xffffffff,_ElementSize,_Count,_File);\n  return sVar1;\n}\n\n"
    },
    {
      "name": "_fread_s",
      "entry": "0040a0fb",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    _fread_s\n   \n   Library: Visual Studio 2015 Release */\n\nsize_t __cdecl _fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File)\n\n{\n  int *piVar1;\n  size_t sVar2;\n  \n  if ((_ElementSize != 0) && (_Count != 0)) {\n    if (_File != (FILE *)0x0) {\n      __lock_file(_File);\n      sVar2 = __fread_nolock_s(_DstBuf,_DstSize,_ElementSize,_Count,_File);\n      FUN_0040a186();\n      return sVar2;\n    }\n    if (_DstSize != 0xffffffff) {\n      _memset(_DstBuf,0,_DstSize);\n    }\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_0040a186",
      "entry": "0040a186",
      "c": "\nvoid FUN_0040a186(void)\n\n{\n  FILE *unaff_ESI;\n  \n  __unlock_file(unaff_ESI);\n  return;\n}\n\n"
    },
    {
      "name": "LongLongSub",
      "entry": "0040a18e",
      "c": "\n/* Library Function - Single Match\n    long __cdecl LongLongSub(__int64,__int64,__int64 *)\n   \n   Library: Visual Studio 2015 Release */\n\nlong __cdecl LongLongSub(__int64 param_1,__int64 param_2,__int64 *param_3)\n\n{\n  longlong lVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  \n  lVar1 = param_1 - param_2;\n  iVar2 = 1;\n  if ((0xffffffff < param_1) || (iVar4 = iVar2, -1 < param_1)) {\n    iVar4 = 0;\n  }\n  if ((0xffffffff < param_2) || (iVar3 = iVar2, -1 < param_2)) {\n    iVar3 = 0;\n  }\n  if (iVar4 != iVar3) {\n    if ((0xffffffff < param_1) || (iVar4 = iVar2, -1 < param_1)) {\n      iVar4 = 0;\n    }\n    if ((0 < (int)((ulonglong)lVar1 >> 0x20)) || (-1 < lVar1)) {\n      iVar2 = 0;\n    }\n    if (iVar4 != iVar2) {\n      *(undefined4 *)param_3 = 0xffffffff;\n      *(undefined4 *)((int)param_3 + 4) = 0xffffffff;\n      return -0x7ff8fdea;\n    }\n  }\n  *param_3 = lVar1;\n  return 0;\n}\n\n"
    },
    {
      "name": "common_fseek",
      "entry": "0040a20f",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    int __cdecl common_fseek(class __crt_stdio_stream,__int64,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_fseek(FILE *param_1,undefined4 param_2,undefined4 param_3,int param_4)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if ((param_1 == (FILE *)0x0) || (((param_4 != 0 && (param_4 != 1)) && (param_4 != 2)))) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    iVar2 = -1;\n  }\n  else {\n    __lock_file(param_1);\n    iVar2 = common_fseek_nolock(param_1,param_2,param_3,param_4);\n    FUN_0040a28c();\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "FUN_0040a28c",
      "entry": "0040a28c",
      "c": "\nvoid FUN_0040a28c(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file(*(FILE **)(unaff_EBP + 8));\n  return;\n}\n\n"
    },
    {
      "name": "common_fseek_binary_mode_read_only_fast_track_nolock",
      "entry": "0040a296",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl common_fseek_binary_mode_read_only_fast_track_nolock(class\n   __crt_stdio_stream,__int64,int)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl\ncommon_fseek_binary_mode_read_only_fast_track_nolock\n          (int *param_1,uint param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  uint uVar3;\n  int unaff_ESI;\n  longlong lVar4;\n  \n  if (((param_4 == 2) || ((param_1[3] & 0x4c0U) == 0)) || ((param_1[3] & 6U) != 0)) {\n    return false;\n  }\n  if (-1 < param_1[2]) {\n    uVar3 = param_1[4];\n    iVar1 = (uVar3 & 0x3f) * 0x30;\n    if (((*(byte *)((&DAT_0043b110)[(int)uVar3 >> 6] + 0x28 + iVar1) & 0x80) == 0) &&\n       (*(char *)((&DAT_0043b110)[(int)uVar3 >> 6] + 0x29 + iVar1) == '\\0')) {\n      if (param_4 == 0) {\n        lVar4 = __lseeki64_nolock(uVar3,0x100000000,unaff_ESI);\n        if ((lVar4 < 0x100000000) && (lVar4 < 0)) {\n          return false;\n        }\n        lVar2 = LongLongSub(CONCAT44(param_3,param_2),lVar4 - param_1[2],(__int64 *)&param_2);\n        if (lVar2 < 0) {\n          return false;\n        }\n      }\n      uVar3 = param_1[1] - *param_1;\n      iVar1 = (int)uVar3 >> 0x1f;\n      if ((iVar1 <= param_3) && ((iVar1 < param_3 || (uVar3 <= param_2)))) {\n        iVar1 = param_1[2] >> 0x1f;\n        if ((param_3 <= iVar1) && ((param_3 < iVar1 || (param_2 <= (uint)param_1[2])))) {\n          *param_1 = *param_1 + param_2;\n          param_1[2] = param_1[2] - param_2;\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n"
    },
    {
      "name": "common_fseek_nolock",
      "entry": "0040a36f",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_fseek_nolock(class __crt_stdio_stream,__int64,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_fseek_nolock(FILE *param_1,undefined4 param_2,undefined4 param_3,int param_4)\n\n{\n  bool bVar1;\n  int *piVar2;\n  int unaff_EDI;\n  __int64 _Var3;\n  longlong lVar4;\n  \n  if (((uint)param_1->_flag >> 0xd & 1) == 0) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    return -1;\n  }\n  LOCK();\n  param_1->_flag = param_1->_flag & 0xfffffff7;\n  UNLOCK();\n  lVar4 = CONCAT44(param_3,param_2);\n  bVar1 = common_fseek_binary_mode_read_only_fast_track_nolock(param_1,param_2,param_3,param_4);\n  if (!bVar1) {\n    if (param_4 == 1) {\n      _Var3 = FUN_0040a9af();\n      lVar4 = _Var3 + lVar4;\n      param_4 = 0;\n    }\n    ___acrt_stdio_flush_nolock(param_1);\n    param_1->_base = (char *)0x0;\n    param_1->_ptr = (char *)param_1->_cnt;\n    if (((uint)param_1->_flag >> 2 & 1) == 0) {\n      if ((((byte)param_1->_flag & 0x41) == 0x41) && (((uint)param_1->_flag >> 8 & 1) == 0)) {\n        param_1->_bufsiz = 0x200;\n      }\n    }\n    else {\n      LOCK();\n      param_1->_flag = param_1->_flag & 0xfffffffc;\n      UNLOCK();\n    }\n    lVar4 = __lseeki64_nolock(param_1->_file,CONCAT44(param_4,(int)((ulonglong)lVar4 >> 0x20)),\n                              unaff_EDI);\n    if (lVar4 == -1) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "_fseek",
      "entry": "0040a448",
      "c": "\n/* Library Function - Single Match\n    _fseek\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _fseek(FILE *_File,long _Offset,int _Origin)\n\n{\n  int iVar1;\n  \n  iVar1 = common_fseek(_File,_Offset,_Offset >> 0x1f,_Origin);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "common_ftell<long>",
      "entry": "0040a463",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    long __cdecl common_ftell<long>(class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\nlong __cdecl common_ftell<long>(FILE *param_1)\n\n{\n  int *piVar1;\n  long lVar2;\n  \n  if (param_1 == (FILE *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    lVar2 = -1;\n  }\n  else {\n    __lock_file(param_1);\n    lVar2 = common_ftell_nolock<long>(param_1);\n    FUN_0040a4c6();\n  }\n  return lVar2;\n}\n\n"
    },
    {
      "name": "FUN_0040a4c6",
      "entry": "0040a4c6",
      "c": "\nvoid FUN_0040a4c6(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file(*(FILE **)(unaff_EBP + 8));\n  return;\n}\n\n"
    },
    {
      "name": "common_ftell_nolock<long>",
      "entry": "0040a4d0",
      "c": "\n/* Library Function - Single Match\n    long __cdecl common_ftell_nolock<long>(class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\nlong __cdecl common_ftell_nolock<long>(undefined4 param_1)\n\n{\n  int *piVar1;\n  uint uVar2;\n  __int64 _Var3;\n  \n  _Var3 = common_ftell_nolock<__int64>(param_1);\n  uVar2 = (uint)_Var3;\n  if ((-1 < _Var3) && (((int)((ulonglong)_Var3 >> 0x20) != 0 && -1 < _Var3 || (0x7fffffff < uVar2)))\n     ) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n\n"
    },
    {
      "name": "common_ftell_nolock<__int64>",
      "entry": "0040a4fb",
      "c": "\n/* Library Function - Single Match\n    __int64 __cdecl common_ftell_nolock<__int64>(class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl common_ftell_nolock<__int64>(FILE *param_1)\n\n{\n  char cVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  char *pcVar6;\n  uint uVar7;\n  int unaff_EDI;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  longlong lVar11;\n  __int64 _Var12;\n  longlong lVar13;\n  \n  if (param_1 == (FILE *)0x0) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    return -1;\n  }\n  uVar3 = __fileno(param_1);\n  if ((int)param_1->_base < 0) {\n    param_1->_base = (char *)0x0;\n  }\n  lVar11 = __lseeki64(uVar3,0x100000000,unaff_EDI);\n  if (((int)((ulonglong)lVar11 >> 0x20) != 0 && -1 < lVar11) || (-1 < lVar11)) {\n    if ((param_1->_flag & 0xc0U) == 0) {\n      return lVar11 - (int)param_1->_base;\n    }\n    iVar4 = (int)uVar3 >> 6;\n    iVar5 = (uVar3 & 0x3f) * 0x30;\n    cVar1 = *(char *)(iVar5 + 0x29 + (&DAT_0043b110)[iVar4]);\n    uVar3 = (int)param_1->_ptr - param_1->_cnt;\n    uVar7 = (int)uVar3 >> 0x1f;\n    if ((param_1->_flag & 3U) == 0) {\n      if (((uint)param_1->_flag >> 2 & 1) == 0) {\n        piVar2 = __errno();\n        *piVar2 = 0x16;\n        goto LAB_0040a648;\n      }\n    }\n    else {\n      if ((cVar1 == '\\x01') && ((*(byte *)(iVar5 + 0x2d + (&DAT_0043b110)[iVar4]) & 2) != 0)) {\n        _Var12 = common_ftell_translated_utf8_nolock(param_1,lVar11);\n        return _Var12;\n      }\n      if (((*(byte *)(iVar5 + 0x28 + (&DAT_0043b110)[iVar4]) & 0x80) != 0) &&\n         (uVar8 = ~-(uint)(param_1->_ptr < (char *)param_1->_cnt) &\n                  (int)param_1->_ptr - param_1->_cnt, uVar8 != 0)) {\n        pcVar6 = (char *)param_1->_cnt;\n        uVar9 = 0;\n        do {\n          if (*pcVar6 == '\\n') {\n            bVar10 = 0xfffffffe < uVar3;\n            uVar3 = uVar3 + 1;\n            uVar7 = uVar7 + bVar10;\n          }\n          pcVar6 = pcVar6 + 1;\n          uVar9 = uVar9 + 1;\n        } while (uVar9 != uVar8);\n      }\n    }\n    lVar13 = CONCAT44(uVar7,uVar3);\n    if (lVar11 != 0) {\n      if ((param_1->_flag & 1U) == 0) {\n        if (cVar1 == '\\x01') {\n          lVar13 = __alldiv(uVar3,uVar7,2,0);\n        }\n        lVar13 = lVar13 + lVar11;\n      }\n      else {\n        lVar13 = common_ftell_read_mode_nolock(param_1,lVar11,uVar3,uVar7);\n      }\n    }\n  }\n  else {\nLAB_0040a648:\n    lVar13 = -1;\n  }\n  return lVar13;\n}\n\n"
    },
    {
      "name": "common_ftell_read_mode_nolock",
      "entry": "0040a690",
      "c": "\n/* Library Function - Single Match\n    __int64 __cdecl common_ftell_read_mode_nolock(class __crt_stdio_stream,__int64,__int64)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl\ncommon_ftell_read_mode_nolock\n          (FILE *param_1,undefined4 param_2,uint param_3,uint param_4,uint param_5)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  char *pcVar5;\n  int unaff_ESI;\n  char *pcVar6;\n  bool bVar7;\n  longlong lVar8;\n  longlong lVar9;\n  uint local_10;\n  uint local_c;\n  \n  lVar1 = CONCAT44(param_3,param_2);\n  uVar2 = __fileno(param_1);\n  local_c = 2;\n  iVar3 = (uVar2 & 0x3f) * 0x30;\n  if (*(char *)((&DAT_0043b110)[(int)uVar2 >> 6] + 0x29 + iVar3) != '\\x01') {\n    local_c = 1;\n  }\n  pcVar5 = param_1->_base;\n  if (pcVar5 != (char *)0x0) {\n    uVar4 = (int)param_1->_ptr - param_1->_cnt;\n    pcVar6 = pcVar5 + uVar4;\n    uVar4 = ((int)uVar4 >> 0x1f) + ((int)pcVar5 >> 0x1f) + (uint)CARRY4(uVar4,(uint)pcVar5);\n    if ((*(byte *)((&DAT_0043b110)[(int)uVar2 >> 6] + 0x28 + iVar3) & 0x80) != 0) {\n      lVar8 = __lseeki64(uVar2,0x200000000,unaff_ESI);\n      if (lVar8 == lVar1) {\n        local_10 = 0;\n        uVar2 = ~-(uint)(pcVar6 + param_1->_cnt < (char *)param_1->_cnt) &\n                (int)(pcVar6 + param_1->_cnt) - param_1->_cnt;\n        if (uVar2 != 0) {\n          pcVar5 = (char *)param_1->_cnt;\n          do {\n            if (*pcVar5 == '\\n') {\n              bVar7 = (char *)0xfffffffe < pcVar6;\n              pcVar6 = pcVar6 + 1;\n              uVar4 = uVar4 + bVar7;\n            }\n            pcVar5 = pcVar5 + 1;\n            local_10 = local_10 + 1;\n          } while (local_10 != uVar2);\n        }\n        bVar7 = ((uint)param_1->_flag >> 5 & 1) == 0;\n      }\n      else {\n        lVar8 = __lseeki64(uVar2,(ulonglong)param_3,unaff_ESI);\n        if (lVar8 == -1) {\n          return -1;\n        }\n        if ((((int)uVar4 < 1) &&\n            ((((int)uVar4 < 0 || (pcVar6 < (char *)0x201)) && (((uint)param_1->_flag >> 6 & 1) != 0)\n             ))) && (((uint)param_1->_flag >> 8 & 1) == 0)) {\n          pcVar6 = (char *)0x200;\n          uVar4 = 0;\n        }\n        else {\n          pcVar6 = (char *)param_1->_bufsiz;\n          uVar4 = (int)pcVar6 >> 0x1f;\n        }\n        bVar7 = (*(byte *)((&DAT_0043b110)[(int)uVar2 >> 6] + 0x28 + iVar3) & 4) == 0;\n      }\n      if (!bVar7) {\n        bVar7 = (char *)0xfffffffe < pcVar6;\n        pcVar6 = pcVar6 + 1;\n        uVar4 = uVar4 + bVar7;\n      }\n    }\n    lVar8 = __alldiv((uint)pcVar6,uVar4,local_c,0);\n    lVar9 = __alldiv(param_4,param_5,local_c,0);\n    lVar1 = (lVar9 - lVar8) + lVar1;\n  }\n  return lVar1;\n}\n\n"
    },
    {
      "name": "common_ftell_translated_utf8_nolock",
      "entry": "0040a814",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    __int64 __cdecl common_ftell_translated_utf8_nolock(class __crt_stdio_stream,__int64)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl common_ftell_translated_utf8_nolock(FILE *param_1,undefined4 param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  BOOL BVar3;\n  byte *pbVar4;\n  int iVar5;\n  int iVar6;\n  int unaff_EDI;\n  int iVar7;\n  bool bVar8;\n  longlong lVar9;\n  longlong lVar10;\n  __int64 _Var11;\n  uint local_1014;\n  int local_1010;\n  undefined4 local_100c;\n  byte local_1008 [4096];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  uVar1 = __fileno(param_1);\n  if (param_1->_base != (char *)0x0) {\n    uVar2 = (int)param_1->_ptr - param_1->_cnt;\n    lVar9 = __alldiv(uVar2,(int)uVar2 >> 0x1f,2,0);\n    iVar5 = (int)((ulonglong)lVar9 >> 0x20);\n    local_100c = (uint)lVar9;\n    iVar7 = (uVar1 & 0x3f) * 0x30;\n    lVar10 = __lseeki64(uVar1,(ulonglong)*(uint *)((&DAT_0043b110)[(int)uVar1 >> 6] + 0x24 + iVar7),\n                        unaff_EDI);\n    local_1010 = (int)lVar10;\n    iVar6 = (&DAT_0043b110)[(int)uVar1 >> 6];\n    if (((local_1010 == *(int *)(iVar6 + 0x20 + iVar7)) &&\n        ((int)((ulonglong)lVar10 >> 0x20) == *(int *)(iVar6 + 0x24 + iVar7))) &&\n       (BVar3 = ReadFile(*(HANDLE *)(iVar6 + 0x18 + iVar7),local_1008,0x1000,&local_1014,\n                         (LPOVERLAPPED)0x0), BVar3 != 0)) {\n      lVar10 = __lseeki64(uVar1,(ulonglong)param_3,unaff_EDI);\n      if ((((int)((ulonglong)lVar10 >> 0x20) != 0 && -1 < lVar10) || (-1 < lVar10)) &&\n         ((lVar9 < 0 || ((lVar9 < 0x100000000 && (local_100c <= local_1014)))))) {\n        iVar6 = 0;\n        pbVar4 = local_1008;\n        uVar1 = 0;\n        if ((local_100c != 0) || (iVar5 != 0)) {\n          do {\n            if (local_1008 + local_1014 <= pbVar4) break;\n            if (*pbVar4 == 0xd) {\n              if ((pbVar4 < local_1008 + (local_1014 - 1)) && (pbVar4[1] == 10)) {\n                pbVar4 = pbVar4 + 1;\n              }\n            }\n            else {\n              pbVar4 = pbVar4 + (char)(&DAT_0042d110)[*pbVar4];\n            }\n            bVar8 = 0xfffffffe < uVar1;\n            uVar1 = uVar1 + 1;\n            iVar6 = iVar6 + (uint)bVar8;\n            pbVar4 = pbVar4 + 1;\n          } while ((uVar1 != local_100c) || (iVar6 != iVar5));\n        }\n      }\n    }\n  }\n  _Var11 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return _Var11;\n}\n\n"
    },
    {
      "name": "FUN_0040a9af",
      "entry": "0040a9af",
      "c": "\n__int64 FUN_0040a9af(void)\n\n{\n  __int64 _Var1;\n  \n  _Var1 = common_ftell_nolock<__int64>();\n  return _Var1;\n}\n\n"
    },
    {
      "name": "FUN_0040a9ba",
      "entry": "0040a9ba",
      "c": "\nvoid FUN_0040a9ba(void)\n\n{\n  common_ftell<long>();\n  return;\n}\n\n"
    },
    {
      "name": "operator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>",
      "entry": "0040a9c5",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    public: unsigned int __thiscall __crt_seh_guarded_call<unsigned int>::operator()<class\n   <lambda_11b4f7b0d3157825a5656a18eba1ae27>,class <lambda_b51c0495177f500e782686251704ae76> &,class\n   <lambda_cf89b47920b5017557bfe891e78aca36> >(class <lambda_11b4f7b0d3157825a5656a18eba1ae27>\n   &&,class <lambda_b51c0495177f500e782686251704ae76> &,class\n   <lambda_cf89b47920b5017557bfe891e78aca36> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __thiscall\n__crt_seh_guarded_call<unsigned_int>::\noperator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>\n          (__crt_seh_guarded_call<unsigned_int> *this,\n          <lambda_11b4f7b0d3157825a5656a18eba1ae27> *param_1,\n          <lambda_b51c0495177f500e782686251704ae76> *param_2,\n          <lambda_cf89b47920b5017557bfe891e78aca36> *param_3)\n\n{\n  uint uVar1;\n  \n  __lock_file(*(FILE **)param_1);\n  uVar1 = <lambda_b51c0495177f500e782686251704ae76>::operator()(param_2);\n  FUN_0040aa0a();\n  return uVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040aa0a",
      "entry": "0040aa0a",
      "c": "\nvoid FUN_0040aa0a(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file((FILE *)**(undefined4 **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>",
      "entry": "0040aa16",
      "c": "\n/* Library Function - Single Match\n    unsigned int __cdecl __acrt_lock_stream_and_call<class <lambda_b51c0495177f500e782686251704ae76>\n   >(struct _iobuf * const,class <lambda_b51c0495177f500e782686251704ae76> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl\n__acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>\n          (_iobuf *param_1,<lambda_b51c0495177f500e782686251704ae76> *param_2)\n\n{\n  uint uVar1;\n  _iobuf *local_10;\n  _iobuf *local_c;\n  __crt_seh_guarded_call<unsigned_int> local_5;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  uVar1 = __crt_seh_guarded_call<unsigned_int>::\n          operator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>\n                    (&local_5,(<lambda_11b4f7b0d3157825a5656a18eba1ae27> *)&local_10,param_2,\n                     (<lambda_cf89b47920b5017557bfe891e78aca36> *)&local_c);\n  return uVar1;\n}\n\n"
    },
    {
      "name": "operator()",
      "entry": "0040aa3e",
      "c": "\n/* Library Function - Single Match\n    public: unsigned int __thiscall <lambda_b51c0495177f500e782686251704ae76>::operator()(void)const\n   \n   \n   Library: Visual Studio 2015 Release */\n\nuint __thiscall\n<lambda_b51c0495177f500e782686251704ae76>::operator()\n          (<lambda_b51c0495177f500e782686251704ae76> *this)\n\n{\n  FILE *pFVar1;\n  uint uVar2;\n  size_t sVar3;\n  \n  pFVar1 = (FILE *)**(undefined4 **)this;\n  uVar2 = ___acrt_stdio_begin_temporary_buffering_nolock(pFVar1);\n  sVar3 = __fwrite_nolock((void *)**(undefined4 **)(this + 4),**(size_t **)(this + 8),\n                          **(size_t **)(this + 0xc),(FILE *)**(undefined4 **)this);\n  ___acrt_stdio_end_temporary_buffering_nolock((char)uVar2,pFVar1);\n  return sVar3;\n}\n\n"
    },
    {
      "name": "__fwrite_nolock",
      "entry": "0040aa84",
      "c": "\n/* Library Function - Single Match\n    __fwrite_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nsize_t __cdecl __fwrite_nolock(void *_DstBuf,size_t _Size,size_t _Count,FILE *_File)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  int iVar3;\n  char *pcVar4;\n  char *pcVar5;\n  uint *_Buf;\n  char *local_c;\n  char *local_8;\n  \n  if ((_Size != 0) && (_Count != 0)) {\n    if ((_File != (FILE *)0x0) &&\n       ((_DstBuf != (void *)0x0 && (_Count <= (uint)(0xffffffff / (ulonglong)_Size))))) {\n      piVar1 = &_File->_flag;\n      if ((*piVar1 & 0x4c0U) == 0) {\n        local_8 = (char *)0x1000;\n      }\n      else {\n        local_8 = (char *)_File->_bufsiz;\n      }\n      pcVar5 = (char *)(_Size * _Count);\n      do {\n        while( true ) {\n          if (pcVar5 == (char *)0x0) {\n            return _Count;\n          }\n          if ((_File->_flag & 0xc0U) != 0) break;\nLAB_0040ab38:\n          if (local_8 <= pcVar5) {\n            if (((_File->_flag & 0xc0U) != 0) &&\n               (iVar3 = ___acrt_stdio_flush_nolock(_File), iVar3 != 0)) goto LAB_0040abef;\n            local_c = pcVar5;\n            if (local_8 != (char *)0x0) {\n              local_c = pcVar5 + -((uint)pcVar5 % (uint)local_8);\n            }\n            if (local_c == (char *)0xffffffff) {\n              local_c = (char *)0xffffffff;\n            }\n            _Buf = (uint *)_DstBuf;\n            pcVar2 = local_c;\n            iVar3 = __fileno(_File);\n            pcVar4 = (char *)__write(iVar3,_Buf,(uint)pcVar2);\n            if (pcVar4 != (char *)0xffffffff) {\n              pcVar2 = local_c;\n              if (pcVar4 <= local_c) {\n                pcVar2 = pcVar4;\n              }\n              pcVar5 = pcVar5 + -(int)pcVar2;\n              if (local_c <= pcVar4) goto LAB_0040aba8;\n            }\n            goto LAB_0040abe6;\n          }\n          iVar3 = FUN_004140d8();\n          if (iVar3 == -1) goto LAB_0040abef;\n          local_8 = (char *)_File->_bufsiz;\n          _DstBuf = (void *)((int)_DstBuf + 1);\n          pcVar5 = pcVar5 + -1;\n          if ((int)local_8 < 1) {\n            local_8 = (char *)0x1;\n          }\n        }\n        pcVar2 = _File->_base;\n        if (pcVar2 == (char *)0x0) goto LAB_0040ab38;\n        if ((int)pcVar2 < 0) {\nLAB_0040abe6:\n          LOCK();\n          *piVar1 = *piVar1 | 0x10;\n          UNLOCK();\nLAB_0040abef:\n          return (uint)((int)(_Size * _Count) - (int)pcVar5) / _Size;\n        }\n        if (pcVar5 < pcVar2) {\n          pcVar2 = pcVar5;\n        }\n        FUN_00408c90((uint *)_File->_ptr,(uint *)_DstBuf,(uint)pcVar2);\n        _File->_base = _File->_base + -(int)pcVar2;\n        pcVar5 = pcVar5 + -(int)pcVar2;\n        _File->_ptr = pcVar2 + (int)_File->_ptr;\nLAB_0040aba8:\n        _DstBuf = (void *)((int)_DstBuf + (int)pcVar2);\n      } while( true );\n    }\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "_fwrite",
      "entry": "0040abfd",
      "c": "\n/* Library Function - Single Match\n    _fwrite\n   \n   Library: Visual Studio 2015 Release */\n\nsize_t __cdecl _fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)\n\n{\n  int *piVar1;\n  uint uVar2;\n  FILE **local_14;\n  void **local_10;\n  size_t *local_c;\n  size_t *local_8;\n  \n  if ((_Size != 0) && (_Count != 0)) {\n    if (_File != (FILE *)0x0) {\n      local_14 = &_File;\n      local_10 = &_Str;\n      local_c = &_Size;\n      local_8 = &_Count;\n      uVar2 = __acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>\n                        (_File,(<lambda_b51c0495177f500e782686251704ae76> *)&local_14);\n      return uVar2;\n    }\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "___acrt_iob_func",
      "entry": "0040ad1d",
      "c": "\n/* Library Function - Single Match\n    ___acrt_iob_func\n   \n   Library: Visual Studio 2015 Release */\n\nundefined * __cdecl ___acrt_iob_func(int param_1)\n\n{\n  return &DAT_0042d050 + param_1 * 0x38;\n}\n\n"
    },
    {
      "name": "__lock_file",
      "entry": "0040ad79",
      "c": "\n/* Library Function - Single Match\n    __lock_file\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __lock_file(FILE *_File)\n\n{\n  EnterCriticalSection((LPCRITICAL_SECTION)(_File + 1));\n  return;\n}\n\n"
    },
    {
      "name": "__unlock_file",
      "entry": "0040ad8d",
      "c": "\n/* Library Function - Single Match\n    __unlock_file\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl __unlock_file(FILE *_File)\n\n{\n  LeaveCriticalSection((LPCRITICAL_SECTION)(_File + 1));\n  return;\n}\n\n"
    },
    {
      "name": "__get_sys_err_msg",
      "entry": "0040ada1",
      "c": "\n/* Library Function - Single Match\n    __get_sys_err_msg\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nchar * __cdecl __get_sys_err_msg(int m)\n\n{\n  uint *puVar1;\n  int *piVar2;\n  undefined **ppuVar3;\n  \n  puVar1 = (uint *)FUN_00414851();\n  if (*puVar1 <= (uint)m) {\n    piVar2 = (int *)FUN_00414851();\n    m = *piVar2;\n  }\n  ppuVar3 = FUN_0041484b();\n  return ppuVar3[m];\n}\n\n"
    },
    {
      "name": "_perror",
      "entry": "0040adc5",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    _perror\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl _perror(char *_ErrMsg)\n\n{\n  char cVar1;\n  int *piVar2;\n  char *_Buf;\n  char *pcVar3;\n  \n  ___acrt_lowio_lock_fh(2);\n  if ((_ErrMsg != (char *)0x0) && (*_ErrMsg != '\\0')) {\n    pcVar3 = _ErrMsg;\n    do {\n      cVar1 = *pcVar3;\n      pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    __write_nolock(2,_ErrMsg,(int)pcVar3 - (int)(_ErrMsg + 1));\n    __write_nolock(2,&DAT_00426680,2);\n  }\n  piVar2 = __errno();\n  _Buf = __get_sys_err_msg(*piVar2);\n  pcVar3 = _Buf;\n  do {\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar3 + 1;\n  } while (cVar1 != '\\0');\n  __write_nolock(2,_Buf,(int)pcVar3 - (int)(_Buf + 1));\n  __write_nolock(2,&DAT_00426684,1);\n  FUN_0040ae58();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040ae58",
      "entry": "0040ae58",
      "c": "\nvoid FUN_0040ae58(void)\n\n{\n  ___acrt_lowio_unlock_fh(2);\n  return;\n}\n\n"
    },
    {
      "name": "operator()<>",
      "entry": "0040ae61",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Multiple Matches With Same Base Name\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_5be909dfbae0a631386585770cd7b676>,class <lambda_e516058a9c289d98c8ca9fea99247804> &,class\n   <lambda_afe2e0cdc5e0ecf6f0d6f5e2f8985e38> >(class <lambda_5be909dfbae0a631386585770cd7b676>\n   &&,class <lambda_e516058a9c289d98c8ca9fea99247804> &,class\n   <lambda_afe2e0cdc5e0ecf6f0d6f5e2f8985e38> &&)\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_823d65812123d985753d53e2a8c25d20>,class <lambda_0a97c9e57da7be065955385c79108ff2> &,class\n   <lambda_4d2973f3ad2d226f00468307185dca1b> >(class <lambda_823d65812123d985753d53e2a8c25d20>\n   &&,class <lambda_0a97c9e57da7be065955385c79108ff2> &,class\n   <lambda_4d2973f3ad2d226f00468307185dca1b> &&)\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_ab9923ffb5d694ec0d78876dd103e44f>,class <lambda_481dd5778c961fbcd3b60b650e9b9dc4> &,class\n   <lambda_7923d86c9e3f319b415918ec4b39749c> >(class <lambda_ab9923ffb5d694ec0d78876dd103e44f>\n   &&,class <lambda_481dd5778c961fbcd3b60b650e9b9dc4> &,class\n   <lambda_7923d86c9e3f319b415918ec4b39749c> &&)\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_db08b09ef7aa9d4f8620ce68402612bc>,class <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> &,class\n   <lambda_3ae262bc35d4ba6a3825c4f6bcaaf95c> >(class <lambda_db08b09ef7aa9d4f8620ce68402612bc>\n   &&,class <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> &,class\n   <lambda_3ae262bc35d4ba6a3825c4f6bcaaf95c> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint operator()<>(undefined4 *param_1,<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> *param_2)\n\n{\n  int iVar1;\n  \n  __lock_file((FILE *)*param_1);\n  iVar1 = <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>::operator()(param_2);\n  FUN_0040aea6();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040aea6",
      "entry": "0040aea6",
      "c": "\nvoid FUN_0040aea6(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file((FILE *)**(undefined4 **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_stream_and_call<>",
      "entry": "0040aeb2",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    int __cdecl __acrt_lock_stream_and_call<class <lambda_0a97c9e57da7be065955385c79108ff2> >(struct\n   _iobuf * const,class <lambda_0a97c9e57da7be065955385c79108ff2> &&)\n    int __cdecl __acrt_lock_stream_and_call<class <lambda_2565fc715a641e539f44ad02d6823606> >(struct\n   _iobuf * const,class <lambda_2565fc715a641e539f44ad02d6823606> &&)\n    int __cdecl __acrt_lock_stream_and_call<class <lambda_481dd5778c961fbcd3b60b650e9b9dc4> >(struct\n   _iobuf * const,class <lambda_481dd5778c961fbcd3b60b650e9b9dc4> &&)\n    int __cdecl __acrt_lock_stream_and_call<class <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> >(struct\n   _iobuf * const,class <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> &&)\n     8 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__acrt_lock_stream_and_call<>(undefined4 param_1,<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> *param_2)\n\n{\n  undefined4 local_10;\n  undefined4 local_c;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  operator()<>(&local_10,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "common_vsprintf<class___crt_stdio_output::standard_base,char>",
      "entry": "0040aeda",
      "c": "\n/* WARNING: Type propagation algorithm not settling */\n/* Library Function - Single Match\n    int __cdecl common_vsprintf<class __crt_stdio_output::standard_base,char>(unsigned __int64,char\n   * const,unsigned int,char const * const,struct __crt_locale_pointers * const,char * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_vsprintf<class___crt_stdio_output::standard_base,char>\n          (__uint64 param_1,char *param_2,uint param_3,char *param_4,__crt_locale_pointers *param_5,\n          char *param_6)\n\n{\n  char *******pppppppcVar1;\n  int *piVar2;\n  int iVar3;\n  int local_488;\n  undefined1 local_484 [8];\n  char local_47c;\n  uint local_478;\n  char *******local_474;\n  uint local_470;\n  uint local_46c;\n  undefined4 local_468;\n  char *******local_464;\n  output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n  local_460 [64];\n  formatting_buffer local_420 [1048];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_464 = (char *******)param_2;\n  if ((param_4 == (char *)0x0) || ((param_3 != 0 && (param_2 == (char *)0x0)))) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    goto LAB_0040b02b;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_488,param_5);\n  pppppppcVar1 = local_464;\n  local_478 = (uint)param_1 & 2;\n  local_474 = local_464;\n  local_470 = param_3;\n  local_46c = 0;\n  if (((param_1 & 2) != 0) || (local_468 = 0, local_464 == (char *******)0x0)) {\n    local_468 = 1;\n  }\n  local_464 = (char *******)&local_474;\n  output_processor<>(local_460,&local_464,(uint)param_1,param_1._4_4_,param_4,local_484,param_6);\n  iVar3 = __crt_stdio_output::\n          output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n          ::process(local_460);\n  if (pppppppcVar1 != (char *******)0x0) {\n    if ((param_1 & 1) == 0) {\n      if (local_478 == 0) {\n        if (param_3 != 0) {\n          if (local_46c != param_3) goto LAB_0040b003;\nLAB_0040b050:\n          *(undefined1 *)((int)pppppppcVar1 + (param_3 - 1)) = 0;\n        }\n      }\n      else if (param_3 != 0) {\n        if (-1 < iVar3) {\n          if (local_46c == param_3) goto LAB_0040b050;\n          goto LAB_0040b003;\n        }\n        *(undefined1 *)pppppppcVar1 = 0;\n      }\n    }\n    else if (((param_3 != 0) || (iVar3 == 0)) && (local_46c != param_3)) {\nLAB_0040b003:\n      *(undefined1 *)((int)pppppppcVar1 + local_46c) = 0;\n    }\n  }\n  __crt_stdio_output::formatting_buffer::~formatting_buffer(local_420);\n  if (local_47c != '\\0') {\n    *(uint *)(local_488 + 0x350) = *(uint *)(local_488 + 0x350) & 0xfffffffd;\n  }\nLAB_0040b02b:\n  iVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "common_vsprintf<class___crt_stdio_output::standard_base,wchar_t>",
      "entry": "0040b056",
      "c": "\n/* WARNING: Type propagation algorithm not settling */\n/* Library Function - Single Match\n    int __cdecl common_vsprintf<class __crt_stdio_output::standard_base,wchar_t>(unsigned\n   __int64,wchar_t * const,unsigned int,wchar_t const * const,struct __crt_locale_pointers *\n   const,char * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_vsprintf<class___crt_stdio_output::standard_base,wchar_t>\n          (__uint64 param_1,wchar_t *param_2,uint param_3,wchar_t *param_4,\n          __crt_locale_pointers *param_5,char *param_6)\n\n{\n  wchar_t *******pppppppwVar1;\n  int *piVar2;\n  int iVar3;\n  int local_488;\n  undefined1 local_484 [8];\n  char local_47c;\n  uint local_478;\n  wchar_t *******local_474;\n  uint local_470;\n  uint local_46c;\n  undefined4 local_468;\n  wchar_t *******local_464;\n  output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n  local_460 [64];\n  formatting_buffer local_420 [1048];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_464 = (wchar_t *******)param_2;\n  if ((param_4 == (wchar_t *)0x0) || ((param_3 != 0 && (param_2 == (wchar_t *)0x0)))) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    goto LAB_0040b1ad;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_488,param_5);\n  pppppppwVar1 = local_464;\n  local_478 = (uint)param_1 & 2;\n  local_474 = local_464;\n  local_470 = param_3;\n  local_46c = 0;\n  if (((param_1 & 2) != 0) || (local_468 = 0, local_464 == (wchar_t *******)0x0)) {\n    local_468 = 1;\n  }\n  local_464 = (wchar_t *******)&local_474;\n  output_processor<>(local_460,&local_464,(uint)param_1,param_1._4_4_,param_4,local_484,param_6);\n  iVar3 = __crt_stdio_output::\n          output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n          ::process(local_460);\n  if (pppppppwVar1 != (wchar_t *******)0x0) {\n    if ((param_1 & 1) == 0) {\n      if (local_478 == 0) {\n        if (param_3 != 0) {\n          if (local_46c != param_3) goto LAB_0040b182;\nLAB_0040b1d2:\n          *(undefined2 *)((int)pppppppwVar1 + (param_3 - 1) * 2) = 0;\n        }\n      }\n      else if (param_3 != 0) {\n        if (-1 < iVar3) {\n          if (local_46c == param_3) goto LAB_0040b1d2;\n          goto LAB_0040b182;\n        }\n        *(undefined2 *)pppppppwVar1 = 0;\n      }\n    }\n    else if (((param_3 != 0) || (iVar3 == 0)) && (local_46c != param_3)) {\nLAB_0040b182:\n      *(undefined2 *)((int)pppppppwVar1 + local_46c * 2) = 0;\n    }\n  }\n  __crt_stdio_output::formatting_buffer::~formatting_buffer(local_420);\n  if (local_47c != '\\0') {\n    *(uint *)(local_488 + 0x350) = *(uint *)(local_488 + 0x350) & 0xfffffffd;\n  }\nLAB_0040b1ad:\n  iVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "count<char>",
      "entry": "0040b1db",
      "c": "\n/* Library Function - Single Match\n    public: unsigned int __thiscall __crt_stdio_output::formatting_buffer::count<char>(void)const \n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nuint __thiscall __crt_stdio_output::formatting_buffer::count<char>(formatting_buffer *this)\n\n{\n  if (*(int *)(this + 0x404) == 0) {\n    return 0x200;\n  }\n  return *(uint *)(this + 0x400) >> 1;\n}\n\n"
    },
    {
      "name": "ensure_buffer_is_big_enough<char>",
      "entry": "0040b1f3",
      "c": "\n/* Library Function - Single Match\n    public: bool __thiscall\n   __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>\n          (formatting_buffer *this,uint param_1)\n\n{\n  uint uVar1;\n  int *piVar2;\n  bool bVar3;\n  formatting_buffer *local_8;\n  \n  local_8 = this;\n  if (((uint)(0xffffffff / (ulonglong)param_1) & 0xfffffffe) < 2) {\n    piVar2 = __errno();\n    *piVar2 = 0xc;\n    bVar3 = false;\n  }\n  else {\n    uVar1 = param_1 * 2;\n    if (((*(int *)(this + 0x404) == 0) && (uVar1 < 0x401)) || (uVar1 <= *(uint *)(this + 0x400))) {\n      bVar3 = true;\n    }\n    else {\n      local_8 = (formatting_buffer *)__malloc_base(uVar1);\n      bVar3 = local_8 != (formatting_buffer *)0x0;\n      if (bVar3) {\n        __crt_unique_heap_ptr<char,struct___crt_internal_free_policy>::operator=\n                  ((__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *)(this + 0x404),\n                   (__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *)&local_8);\n        *(uint *)(this + 0x400) = uVar1;\n      }\n      FID_conflict__free(local_8);\n    }\n  }\n  return bVar3;\n}\n\n"
    },
    {
      "name": "is_wide_character_specifier<char>",
      "entry": "0040b279",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __crt_stdio_output::is_wide_character_specifier<char>(unsigned __int64,char,enum\n   __crt_stdio_output::length_modifier)\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nbool __cdecl\n__crt_stdio_output::is_wide_character_specifier<char>\n          (__uint64 param_1,char param_2,length_modifier param_3)\n\n{\n  bool bVar1;\n  \n  if (param_3 != 2) {\n    if ((param_3 == 3) || (param_3 == 0xc)) {\n      return true;\n    }\n    if (param_3 != 0xd) {\n      if ((param_2 == 'c') || (param_2 == 's')) {\n        bVar1 = true;\n      }\n      else {\n        bVar1 = false;\n      }\n      return !bVar1;\n    }\n  }\n  return false;\n}\n\n"
    },
    {
      "name": "is_wide_character_specifier<wchar_t>",
      "entry": "0040b2b9",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __crt_stdio_output::is_wide_character_specifier<wchar_t>(unsigned\n   __int64,wchar_t,enum __crt_stdio_output::length_modifier)\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nbool __cdecl\n__crt_stdio_output::is_wide_character_specifier<wchar_t>\n          (__uint64 param_1,wchar_t param_2,length_modifier param_3)\n\n{\n  bool bVar1;\n  \n  if (param_3 == 2) {\n    return false;\n  }\n  if (((param_3 != 3) && (param_3 != 0xc)) && (param_3 != 0xd)) {\n    bVar1 = false;\n    if ((param_2 == L'c') || (param_2 == L's')) {\n      bVar1 = true;\n    }\n    return ((param_1 & 4) != 0) == bVar1;\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "scratch_data<char>",
      "entry": "0040b308",
      "c": "\n/* Library Function - Single Match\n    public: char * __thiscall __crt_stdio_output::formatting_buffer::scratch_data<char>(void)\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nchar * __thiscall __crt_stdio_output::formatting_buffer::scratch_data<char>(formatting_buffer *this)\n\n{\n  int iVar1;\n  uint uVar2;\n  formatting_buffer *pfVar3;\n  \n  iVar1 = *(int *)(this + 0x404);\n  uVar2 = count<char>(this);\n  if (iVar1 == 0) {\n    pfVar3 = this + uVar2;\n  }\n  else {\n    pfVar3 = (formatting_buffer *)(uVar2 + iVar1);\n  }\n  return (char *)pfVar3;\n}\n\n"
    },
    {
      "name": "type_case_integer_parse_into_buffer<>",
      "entry": "0040b326",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_integer_parse_into_buffer<unsigned int>(unsigned int,unsigned int,bool)\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_integer_parse_into_buffer<unsigned int>(unsigned int,unsigned int,bool)\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::type_case_integer_parse_into_buffer<unsigned\n   int>(unsigned int,unsigned int,bool)\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::type_case_integer_parse_into_buffer<unsigned int>(unsigned int,unsigned int,bool)\n     12 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\ntype_case_integer_parse_into_buffer<>(void *this,uint param_1,uint param_2,char param_3)\n\n{\n  uint uVar1;\n  char cVar2;\n  formatting_buffer *pfVar3;\n  \n  pfVar3 = *(formatting_buffer **)((int)this + 0x444);\n  if (*(formatting_buffer **)((int)this + 0x444) == (formatting_buffer *)0x0) {\n    pfVar3 = (formatting_buffer *)((int)this + 0x40);\n  }\n  uVar1 = __crt_stdio_output::formatting_buffer::count<char>\n                    ((formatting_buffer *)((int)this + 0x40));\n  *(formatting_buffer **)((int)this + 0x34) = pfVar3 + (uVar1 - 1);\n  while ((0 < *(int *)((int)this + 0x28) || (param_1 != 0))) {\n    cVar2 = (char)(param_1 % param_2) + '0';\n    *(int *)((int)this + 0x28) = *(int *)((int)this + 0x28) + -1;\n    if ('9' < cVar2) {\n      cVar2 = cVar2 + ((param_3 == '\\0') - 1U & 0xe0) + 0x27;\n    }\n    **(char **)((int)this + 0x34) = cVar2;\n    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + -1;\n    param_1 = param_1 / param_2;\n  }\n  *(int *)((int)this + 0x38) = (int)(pfVar3 + (uVar1 - 1)) - *(int *)((int)this + 0x34);\n  *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + 1;\n  return;\n}\n\n"
    },
    {
      "name": "type_case_integer_parse_into_buffer<>",
      "entry": "0040b39b",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_integer_parse_into_buffer<unsigned __int64>(unsigned __int64,unsigned int,bool)\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_integer_parse_into_buffer<unsigned __int64>(unsigned __int64,unsigned int,bool)\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::type_case_integer_parse_into_buffer<unsigned\n   __int64>(unsigned __int64,unsigned int,bool)\n    private: void __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::type_case_integer_parse_into_buffer<unsigned __int64>(unsigned __int64,unsigned int,bool)\n     12 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\ntype_case_integer_parse_into_buffer<>(void *this,longlong param_1,uint param_2,char param_3)\n\n{\n  uint uVar1;\n  char extraout_CL;\n  char cVar2;\n  formatting_buffer *pfVar3;\n  \n  pfVar3 = *(formatting_buffer **)((int)this + 0x444);\n  if (*(formatting_buffer **)((int)this + 0x444) == (formatting_buffer *)0x0) {\n    pfVar3 = (formatting_buffer *)((int)this + 0x40);\n  }\n  uVar1 = __crt_stdio_output::formatting_buffer::count<char>\n                    ((formatting_buffer *)((int)this + 0x40));\n  *(formatting_buffer **)((int)this + 0x34) = pfVar3 + (uVar1 - 1);\n  while( true ) {\n    if ((*(int *)((int)this + 0x28) < 1) && (param_1 == 0)) break;\n    *(int *)((int)this + 0x28) = *(int *)((int)this + 0x28) + -1;\n    param_1 = __aulldvrm((uint)param_1,(uint)((ulonglong)param_1 >> 0x20),param_2,0);\n    cVar2 = extraout_CL + '0';\n    if ('9' < cVar2) {\n      cVar2 = cVar2 + ((param_3 == '\\0') - 1U & 0xe0) + 0x27;\n    }\n    **(char **)((int)this + 0x34) = cVar2;\n    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + -1;\n  }\n  *(int *)((int)this + 0x38) = (int)(pfVar3 + (uVar1 - 1)) - *(int *)((int)this + 0x34);\n  *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + 1;\n  return;\n}\n\n"
    },
    {
      "name": "write_multiple_characters<class___crt_stdio_output::stream_output_adapter<char>,char>",
      "entry": "0040b423",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __crt_stdio_output::write_multiple_characters<class\n   __crt_stdio_output::stream_output_adapter<char>,char>(class\n   __crt_stdio_output::stream_output_adapter<char> const &,char,int,int * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__crt_stdio_output::\nwrite_multiple_characters<class___crt_stdio_output::stream_output_adapter<char>,char>\n          (stream_output_adapter<char> *param_1,char param_2,int param_3,int *param_4)\n\n{\n  int iVar1;\n  \n  iVar1 = 0;\n  if (0 < param_3) {\n    do {\n      stream_output_adapter<char>::write_character(param_1,param_2,param_4);\n      if (*param_4 == -1) {\n        return;\n      }\n      iVar1 = iVar1 + 1;\n    } while (iVar1 < param_3);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>",
      "entry": "0040b44f",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __crt_stdio_output::write_multiple_characters<class\n   __crt_stdio_output::string_output_adapter<char>,char>(class\n   __crt_stdio_output::string_output_adapter<char> const &,char,int,int * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__crt_stdio_output::\nwrite_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>\n          (string_output_adapter<char> *param_1,char param_2,int param_3,int *param_4)\n\n{\n  int iVar1;\n  \n  iVar1 = 0;\n  if (0 < param_3) {\n    do {\n      string_output_adapter<char>::write_character(param_1,param_2,param_4);\n      if (*param_4 == -1) {\n        return;\n      }\n      iVar1 = iVar1 + 1;\n    } while (iVar1 < param_3);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>",
      "entry": "0040b47b",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __crt_stdio_output::write_multiple_characters<class\n   __crt_stdio_output::string_output_adapter<wchar_t>,char>(class\n   __crt_stdio_output::string_output_adapter<wchar_t> const &,char,int,int * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__crt_stdio_output::\nwrite_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n          (string_output_adapter<wchar_t> *param_1,char param_2,int param_3,int *param_4)\n\n{\n  int iVar1;\n  \n  iVar1 = 0;\n  if (0 < param_3) {\n    do {\n      string_output_adapter<wchar_t>::write_character(param_1,(short)param_2,param_4);\n      if (*param_4 == -1) {\n        return;\n      }\n      iVar1 = iVar1 + 1;\n    } while (iVar1 < param_3);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "common_data<char>",
      "entry": "0040b4ac",
      "c": "\n/* Library Function - Single Match\n    protected: __thiscall __crt_stdio_output::common_data<char>::common_data<char>(void)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\ncommon_data<char> * __thiscall\n__crt_stdio_output::common_data<char>::common_data<char>(common_data<char> *this)\n\n{\n  *(undefined4 *)this = 0;\n  *(undefined4 *)(this + 4) = 0;\n  *(undefined4 *)(this + 8) = 0;\n  *(undefined4 *)(this + 0xc) = 0;\n  *(undefined4 *)(this + 0x10) = 0;\n  *(undefined4 *)(this + 0x14) = 0;\n  *(undefined4 *)(this + 0x18) = 0;\n  *(undefined4 *)(this + 0x1c) = 0;\n  *(undefined4 *)(this + 0x20) = 0;\n  *(undefined4 *)(this + 0x24) = 0;\n  *(undefined4 *)(this + 0x28) = 0;\n  *(undefined2 *)(this + 0x30) = 0;\n  *(undefined4 *)(this + 0x38) = 0;\n  this[0x3c] = (common_data<char>)0x0;\n  *(undefined4 *)(this + 0x440) = 0;\n  *(undefined4 *)(this + 0x444) = 0;\n  return this;\n}\n\n"
    },
    {
      "name": "common_data<wchar_t>",
      "entry": "0040b4f3",
      "c": "\n/* Library Function - Single Match\n    protected: __thiscall __crt_stdio_output::common_data<wchar_t>::common_data<wchar_t>(void)\n   \n   Library: Visual Studio 2015 Release */\n\ncommon_data<wchar_t> * __thiscall\n__crt_stdio_output::common_data<wchar_t>::common_data<wchar_t>(common_data<wchar_t> *this)\n\n{\n  *(undefined4 *)this = 0;\n  *(undefined2 *)(this + 0x32) = 0;\n  *(undefined4 *)(this + 4) = 0;\n  *(undefined4 *)(this + 8) = 0;\n  *(undefined4 *)(this + 0xc) = 0;\n  *(undefined4 *)(this + 0x10) = 0;\n  *(undefined4 *)(this + 0x14) = 0;\n  *(undefined4 *)(this + 0x18) = 0;\n  *(undefined4 *)(this + 0x1c) = 0;\n  *(undefined4 *)(this + 0x20) = 0;\n  *(undefined4 *)(this + 0x24) = 0;\n  *(undefined4 *)(this + 0x28) = 0;\n  this[0x30] = (common_data<wchar_t>)0x0;\n  *(undefined4 *)(this + 0x38) = 0;\n  this[0x3c] = (common_data<wchar_t>)0x0;\n  *(undefined4 *)(this + 0x440) = 0;\n  *(undefined4 *)(this + 0x444) = 0;\n  return this;\n}\n\n"
    },
    {
      "name": "output_adapter_data<>",
      "entry": "0040b53f",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    protected: __thiscall __crt_stdio_output::output_adapter_data<char,class\n   __crt_stdio_output::stream_output_adapter<char> >::output_adapter_data<char,class\n   __crt_stdio_output::stream_output_adapter<char> >(class\n   __crt_stdio_output::stream_output_adapter<char> const &,unsigned __int64,char const *\n   const,struct __crt_locale_pointers * const,char * const)\n    protected: __thiscall __crt_stdio_output::output_adapter_data<char,class\n   __crt_stdio_output::string_output_adapter<char> >::output_adapter_data<char,class\n   __crt_stdio_output::string_output_adapter<char> >(class\n   __crt_stdio_output::string_output_adapter<char> const &,unsigned __int64,char const *\n   const,struct __crt_locale_pointers * const,char * const)\n   \n   Library: Visual Studio 2015 Release */\n\ncommon_data<char> * __thiscall\noutput_adapter_data<>\n          (void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n          undefined4 param_5,undefined4 param_6)\n\n{\n  __crt_stdio_output::common_data<char>::common_data<char>((common_data<char> *)this);\n  *(undefined4 *)((int)this + 0x448) = *param_1;\n  *(undefined4 *)this = param_2;\n  *(undefined4 *)((int)this + 4) = param_3;\n  *(undefined4 *)((int)this + 8) = param_5;\n  *(undefined4 *)((int)this + 0x10) = param_4;\n  *(undefined4 *)((int)this + 0x14) = param_6;\n  return (common_data<char> *)this;\n}\n\n"
    },
    {
      "name": "output_adapter_data<>",
      "entry": "0040b57b",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    protected: __thiscall __crt_stdio_output::output_adapter_data<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> >::output_adapter_data<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> >(class\n   __crt_stdio_output::stream_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *\n   const,struct __crt_locale_pointers * const,char * const)\n    protected: __thiscall __crt_stdio_output::output_adapter_data<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> >::output_adapter_data<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> >(class\n   __crt_stdio_output::string_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *\n   const,struct __crt_locale_pointers * const,char * const)\n   \n   Library: Visual Studio 2015 Release */\n\ncommon_data<wchar_t> * __thiscall\noutput_adapter_data<>\n          (void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n          undefined4 param_5,undefined4 param_6)\n\n{\n  __crt_stdio_output::common_data<wchar_t>::common_data<wchar_t>((common_data<wchar_t> *)this);\n  *(undefined4 *)((int)this + 0x448) = *param_1;\n  *(undefined4 *)this = param_2;\n  *(undefined4 *)((int)this + 4) = param_3;\n  *(undefined4 *)((int)this + 8) = param_5;\n  *(undefined4 *)((int)this + 0x10) = param_4;\n  *(undefined4 *)((int)this + 0x14) = param_6;\n  return (common_data<wchar_t> *)this;\n}\n\n"
    },
    {
      "name": "output_processor<>",
      "entry": "0040b5b7",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    public: __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::string_output_adapter<char> > >::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::string_output_adapter<char> > >(class\n   __crt_stdio_output::string_output_adapter<char> const &,unsigned __int64,char const *\n   const,struct __crt_locale_pointers * const,char * const)\n    public: __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::output_processor<char,class __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >(class __crt_stdio_output::string_output_adapter<char> const &,unsigned __int64,char const *\n   const,struct __crt_locale_pointers * const,char * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid * __thiscall\noutput_processor<>(void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,\n                  undefined4 param_4,undefined4 param_5,undefined4 param_6)\n\n{\n  int *piVar1;\n  \n  output_adapter_data<>(this,param_1,param_2,param_3,param_4,param_5,param_6);\n  *(undefined4 *)((int)this + 0x450) = 0;\n  piVar1 = __errno();\n  *(int **)((int)this + 0xc) = piVar1;\n  return this;\n}\n\n"
    },
    {
      "name": "output_processor<>",
      "entry": "0040b5ec",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    public: __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >(class\n   __crt_stdio_output::string_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *\n   const,struct __crt_locale_pointers * const,char * const)\n    public: __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >(class\n   __crt_stdio_output::string_output_adapter<wchar_t> const &,unsigned __int64,wchar_t const *\n   const,struct __crt_locale_pointers * const,char * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid * __thiscall\noutput_processor<>(void *this,undefined4 *param_1,undefined4 param_2,undefined4 param_3,\n                  undefined4 param_4,undefined4 param_5,undefined4 param_6)\n\n{\n  int *piVar1;\n  \n  output_adapter_data<>(this,param_1,param_2,param_3,param_4,param_5,param_6);\n  *(undefined4 *)((int)this + 0x450) = 0;\n  piVar1 = __errno();\n  *(int **)((int)this + 0xc) = piVar1;\n  return this;\n}\n\n"
    },
    {
      "name": "_LocaleUpdate",
      "entry": "0040b621",
      "c": "\n/* Library Function - Single Match\n    public: __thiscall _LocaleUpdate::_LocaleUpdate(struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\n_LocaleUpdate * __thiscall\n_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this,__crt_locale_pointers *param_1)\n\n{\n  uint uVar1;\n  undefined *puVar2;\n  __acrt_ptd *p_Var3;\n  \n  this[0xc] = (_LocaleUpdate)0x0;\n  if (param_1 == (__crt_locale_pointers *)0x0) {\n    if (DAT_0043b0e8 != 0) {\n      p_Var3 = ___acrt_getptd();\n      *(__acrt_ptd **)this = p_Var3;\n      *(int *)(this + 4) = *(int *)(p_Var3 + 0x4c);\n      *(int *)(this + 8) = *(int *)(p_Var3 + 0x48);\n      ___acrt_update_locale_info((int)p_Var3,(int *)(this + 4));\n      ___acrt_update_multibyte_info(*(int *)this,(int *)(this + 8));\n      uVar1 = *(uint *)(*(int *)this + 0x350);\n      if ((uVar1 & 2) != 0) {\n        return this;\n      }\n      *(uint *)(*(int *)this + 0x350) = uVar1 | 2;\n      this[0xc] = (_LocaleUpdate)0x1;\n      return this;\n    }\n    *(undefined **)(this + 4) = PTR_PTR_0042d300;\n    puVar2 = PTR_DAT_0042d304;\n  }\n  else {\n    *(undefined4 *)(this + 4) = *(undefined4 *)param_1;\n    puVar2 = *(undefined **)(param_1 + 4);\n  }\n  *(undefined **)(this + 8) = puVar2;\n  return this;\n}\n\n"
    },
    {
      "name": "~formatting_buffer",
      "entry": "0040b6a4",
      "c": "\n/* Library Function - Single Match\n    public: __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(void)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(formatting_buffer *this)\n\n{\n  FID_conflict__free(*(void **)(this + 0x404));\n  *(undefined4 *)(this + 0x404) = 0;\n  return;\n}\n\n"
    },
    {
      "name": "operator=",
      "entry": "0040b6be",
      "c": "\n/* Library Function - Single Match\n    public: class __crt_unique_heap_ptr<char,struct __crt_internal_free_policy> & __thiscall\n   __crt_unique_heap_ptr<char,struct __crt_internal_free_policy>::operator=(class\n   __crt_unique_heap_ptr<char,struct __crt_internal_free_policy> &&)\n   \n   Library: Visual Studio 2015 Release */\n\n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> * __thiscall\n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy>::operator=\n          (__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *this,\n          __crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *param_1)\n\n{\n  FID_conflict__free(*(void **)this);\n  *(undefined4 *)this = 0;\n  *(undefined4 *)this = *(undefined4 *)param_1;\n  *(undefined4 *)param_1 = 0;\n  return this;\n}\n\n"
    },
    {
      "name": "operator()",
      "entry": "0040b6e2",
      "c": "\n/* Library Function - Single Match\n    public: int __thiscall <lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>::operator()(void)const \n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b>::operator()\n          (<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> *this)\n\n{\n  FILE *pFVar1;\n  uint uVar2;\n  int iVar3;\n  int local_47c;\n  undefined1 local_478 [8];\n  char local_470;\n  undefined1 local_468;\n  undefined3 uStack_467;\n  undefined4 local_464;\n  output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n  local_460 [64];\n  formatting_buffer local_420 [1048];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pFVar1 = (FILE *)**(undefined4 **)this;\n  uVar2 = ___acrt_stdio_begin_temporary_buffering_nolock(pFVar1);\n  _local_468 = CONCAT31(uStack_467,(char)uVar2);\n  _LocaleUpdate::_LocaleUpdate\n            ((_LocaleUpdate *)&local_47c,(__crt_locale_pointers *)**(undefined4 **)(this + 4));\n  local_464 = **(undefined4 **)this;\n  output_processor<>(local_460,&local_464,**(undefined4 **)(this + 8),\n                     (*(undefined4 **)(this + 8))[1],**(undefined4 **)(this + 0xc),local_478,\n                     **(undefined4 **)(this + 0x10));\n  __crt_stdio_output::\n  output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n  ::process(local_460);\n  __crt_stdio_output::formatting_buffer::~formatting_buffer(local_420);\n  if (local_470 != '\\0') {\n    *(uint *)(local_47c + 0x350) = *(uint *)(local_47c + 0x350) & 0xfffffffd;\n  }\n  ___acrt_stdio_end_temporary_buffering_nolock((char)_local_468,pFVar1);\n  iVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "crop_zeroes",
      "entry": "0040b79f",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __crt_stdio_output::crop_zeroes(char *,struct __crt_locale_pointers * const)\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nvoid __cdecl __crt_stdio_output::crop_zeroes(char *param_1,__crt_locale_pointers *param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  for (; (*param_1 != '\\0' && (*param_1 != *(char *)**(undefined4 **)(*(int *)param_2 + 0x88)));\n      param_1 = param_1 + 1) {\n  }\n  if (*param_1 != '\\0') {\n    do {\n      param_1 = param_1 + 1;\n      cVar1 = *param_1;\n      pcVar2 = param_1;\n      if ((cVar1 == '\\0') || (cVar1 == 'e')) break;\n    } while (cVar1 != 'E');\n    do {\n      pcVar3 = pcVar2;\n      pcVar2 = pcVar3 + -1;\n    } while (*pcVar2 == '0');\n    if (*pcVar2 == *(char *)**(undefined4 **)(*(int *)param_2 + 0x88)) {\n      pcVar2 = pcVar3 + -2;\n    }\n    do {\n      cVar1 = *param_1;\n      pcVar2 = pcVar2 + 1;\n      param_1 = param_1 + 1;\n      *pcVar2 = cVar1;\n    } while (cVar1 != '\\0');\n  }\n  return;\n}\n\n"
    },
    {
      "name": "find_next_state",
      "entry": "0040b7f6",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: enum __crt_stdio_output::state __thiscall\n   __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::find_next_state(char,enum __crt_stdio_output::state)const \n    private: enum __crt_stdio_output::state __thiscall\n   __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::find_next_state(char,enum __crt_stdio_output::state)const \n   \n   Library: Visual Studio 2015 Release */\n\nbyte find_next_state(char param_1,int param_2)\n\n{\n  uint uVar1;\n  \n  if ((byte)(param_1 - 0x20U) < 0x5b) {\n    uVar1 = (byte)\" Complete Object Locator\\'\"[param_1 + 4] & 0xf;\n  }\n  else {\n    uVar1 = 0;\n  }\n  return (byte)(&DAT_00426688)[uVar1 * 8 + param_2] >> 4;\n}\n\n"
    },
    {
      "name": "find_next_state",
      "entry": "0040b828",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: enum __crt_stdio_output::state __thiscall\n   __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::find_next_state(wchar_t,enum\n   __crt_stdio_output::state)const \n    private: enum __crt_stdio_output::state __thiscall\n   __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::find_next_state(wchar_t,enum\n   __crt_stdio_output::state)const \n   \n   Library: Visual Studio 2015 Release */\n\nbyte find_next_state(ushort param_1,int param_2)\n\n{\n  uint uVar1;\n  \n  if ((ushort)(param_1 - 0x20) < 0x5b) {\n    uVar1 = (byte)\" Complete Object Locator\\'\"[param_1 + 4] & 0xf;\n  }\n  else {\n    uVar1 = 0;\n  }\n  return (byte)(&DAT_00426688)[uVar1 * 8 + param_2] >> 4;\n}\n\n"
    },
    {
      "name": "force_decimal_point",
      "entry": "0040b85c",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __crt_stdio_output::force_decimal_point(char *,struct __crt_locale_pointers *\n   const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __crt_stdio_output::force_decimal_point(char *param_1,__crt_locale_pointers *param_2)\n\n{\n  byte bVar1;\n  int iVar2;\n  byte bVar3;\n  bool bVar4;\n  \n  iVar2 = _tolower((int)*param_1);\n  bVar4 = iVar2 == 0x65;\n  while (!bVar4) {\n    param_1 = (char *)((byte *)param_1 + 1);\n    iVar2 = _isdigit((uint)(byte)*param_1);\n    bVar4 = iVar2 == 0;\n  }\n  iVar2 = _tolower((int)*param_1);\n  if (iVar2 == 0x78) {\n    param_1 = (char *)((byte *)param_1 + 2);\n  }\n  bVar3 = *param_1;\n  *param_1 = *(byte *)**(undefined4 **)(*(int *)param_2 + 0x88);\n  do {\n    param_1 = (char *)((byte *)param_1 + 1);\n    bVar1 = *param_1;\n    *param_1 = bVar3;\n    bVar3 = bVar1;\n  } while (*param_1 != 0);\n  return;\n}\n\n"
    },
    {
      "name": "parse_int_from_format_string",
      "entry": "0040b8b8",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::console_output_adapter<char> > >::parse_int_from_format_string(int * const)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::console_output_adapter<char> >\n   >::parse_int_from_format_string(int * const)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::parse_int_from_format_string(int * const)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::parse_int_from_format_string(int * const)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nuint __thiscall parse_int_from_format_string(void *this,long *param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  long lVar3;\n  uint uVar4;\n  int *piVar5;\n  int *local_8;\n  \n  piVar1 = *(int **)((int)this + 0xc);\n  iVar2 = *piVar1;\n  *piVar1 = 0;\n  local_8 = (int *)0x0;\n  lVar3 = _strtol((char *)(*(int *)((int)this + 0x10) + -1),(char **)&local_8,10);\n  *param_1 = lVar3;\n  piVar5 = *(int **)((int)this + 0xc);\n  if ((**(int **)((int)this + 0xc) == 0x22) ||\n     (piVar5 = local_8, local_8 < *(int **)((int)this + 0x10))) {\n    uVar4 = (uint)piVar5 & 0xffffff00;\n  }\n  else {\n    *(int **)((int)this + 0x10) = local_8;\n    uVar4 = CONCAT31((int3)((uint)local_8 >> 8),1);\n  }\n  if ((*piVar1 == 0) && (iVar2 != 0)) {\n    *piVar1 = iVar2;\n  }\n  return uVar4;\n}\n\n"
    },
    {
      "name": "parse_int_from_format_string",
      "entry": "0040b914",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::parse_int_from_format_string(int *\n   const)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::parse_int_from_format_string(int *\n   const)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::parse_int_from_format_string(int * const)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::parse_int_from_format_string(int * const)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nuint __thiscall parse_int_from_format_string(void *this,long *param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  long lVar3;\n  uint uVar4;\n  wchar_t *pwVar5;\n  wchar_t *local_8;\n  \n  piVar1 = *(int **)((int)this + 0xc);\n  iVar2 = *piVar1;\n  *piVar1 = 0;\n  local_8 = (wchar_t *)0x0;\n  lVar3 = _wcstol((wchar_t *)(*(int *)((int)this + 0x10) + -2),&local_8,10);\n  *param_1 = lVar3;\n  pwVar5 = *(wchar_t **)((int)this + 0xc);\n  if ((*(int *)*(wchar_t **)((int)this + 0xc) == 0x22) ||\n     (pwVar5 = local_8, local_8 < *(wchar_t **)((int)this + 0x10))) {\n    uVar4 = (uint)pwVar5 & 0xffffff00;\n  }\n  else {\n    *(wchar_t **)((int)this + 0x10) = local_8;\n    uVar4 = CONCAT31((int3)((uint)local_8 >> 8),1);\n  }\n  if ((*piVar1 == 0) && (iVar2 != 0)) {\n    *piVar1 = iVar2;\n  }\n  return uVar4;\n}\n\n"
    },
    {
      "name": "process",
      "entry": "0040b972",
      "c": "\n/* Library Function - Single Match\n    public: int __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::process(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_stdio_output::\noutput_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n::process(output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n          *this)\n\n{\n  output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n  oVar1;\n  bool bVar2;\n  byte bVar3;\n  char cVar4;\n  int *piVar5;\n  int iVar6;\n  undefined3 extraout_var;\n  undefined4 uVar7;\n  \n  bVar2 = stream_output_adapter<char>::validate((stream_output_adapter<char> *)(this + 0x448));\n  if (!bVar2) {\n    return -1;\n  }\n  if (*(int *)(this + 0x10) == 0) {\nLAB_0040b997:\n    piVar5 = __errno();\n    *piVar5 = 0x16;\n    FUN_00412362();\nswitchD_0040b9e2_default:\n    iVar6 = -1;\n  }\n  else {\nLAB_0040ba52:\n    *(int *)(this + 0x450) = *(int *)(this + 0x450) + 1;\n    if (*(int *)(this + 0x450) != 2) {\n      *(undefined4 *)(this + 0x38) = 0;\n      *(undefined4 *)(this + 0x1c) = 0;\nLAB_0040ba3f:\n      oVar1 = **(output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                 **)(this + 0x10);\n      this[0x31] = oVar1;\n      if (oVar1 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x0) {\n        *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;\n        if (*(int *)(this + 0x18) < 0) goto LAB_0040ba52;\n        bVar3 = find_next_state((char)this[0x31],*(int *)(this + 0x1c));\n        iVar6 = CONCAT31(extraout_var,bVar3);\n        *(int *)(this + 0x1c) = iVar6;\n        if (iVar6 == 8) goto LAB_0040b997;\n        switch(iVar6) {\n        case 0:\n          uVar7 = state_case_normal((int)this);\n          cVar4 = (char)uVar7;\n          break;\n        case 1:\n          *(undefined4 *)(this + 0x28) = 0xffffffff;\n          *(undefined4 *)(this + 0x24) = 0;\n          this[0x30] = (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                        )0x0;\n          *(undefined4 *)(this + 0x20) = 0;\n          *(undefined4 *)(this + 0x2c) = 0;\n          this[0x3c] = (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                        )0x0;\n          goto LAB_0040ba3f;\n        case 2:\n          uVar7 = state_case_flag((int)this);\n          cVar4 = (char)uVar7;\n          break;\n        case 3:\n          uVar7 = state_case_width(this);\n          cVar4 = (char)uVar7;\n          break;\n        case 4:\n          goto switchD_0040b9e2_caseD_4;\n        case 5:\n          uVar7 = state_case_precision(this);\n          cVar4 = (char)uVar7;\n          break;\n        case 6:\n          cVar4 = state_case_size(this);\n          break;\n        case 7:\n          cVar4 = state_case_type(this);\n          break;\n        default:\n          goto switchD_0040b9e2_default;\n        }\n        if (cVar4 == '\\0') goto switchD_0040b9e2_default;\n        goto LAB_0040ba3f;\n      }\n      *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;\n      goto LAB_0040ba52;\n    }\n    iVar6 = *(int *)(this + 0x18);\n  }\n  return iVar6;\nswitchD_0040b9e2_caseD_4:\n  *(undefined4 *)(this + 0x28) = 0;\n  goto LAB_0040ba3f;\n}\n\n"
    },
    {
      "name": "process",
      "entry": "0040ba8e",
      "c": "\n/* Library Function - Single Match\n    public: int __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::process(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_stdio_output::\noutput_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n::process(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n          *this)\n\n{\n  output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n  oVar1;\n  bool bVar2;\n  byte bVar3;\n  char cVar4;\n  int *piVar5;\n  int iVar6;\n  undefined3 extraout_var;\n  undefined4 uVar7;\n  \n  bVar2 = __crt_strtox::c_string_character_source<wchar_t>::validate\n                    ((c_string_character_source<wchar_t> *)(this + 0x448));\n  if (!bVar2) {\n    return -1;\n  }\n  if (*(int *)(this + 0x10) == 0) {\nLAB_0040bab3:\n    piVar5 = __errno();\n    *piVar5 = 0x16;\n    FUN_00412362();\nswitchD_0040bafe_default:\n    iVar6 = -1;\n  }\n  else {\nLAB_0040bb6e:\n    *(int *)(this + 0x450) = *(int *)(this + 0x450) + 1;\n    if (*(int *)(this + 0x450) != 2) {\n      *(undefined4 *)(this + 0x38) = 0;\n      *(undefined4 *)(this + 0x1c) = 0;\nLAB_0040bb5b:\n      oVar1 = **(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                 **)(this + 0x10);\n      this[0x31] = oVar1;\n      if (oVar1 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x0) {\n        *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;\n        if (*(int *)(this + 0x18) < 0) goto LAB_0040bb6e;\n        bVar3 = find_next_state((char)this[0x31],*(int *)(this + 0x1c));\n        iVar6 = CONCAT31(extraout_var,bVar3);\n        *(int *)(this + 0x1c) = iVar6;\n        if (iVar6 == 8) goto LAB_0040bab3;\n        switch(iVar6) {\n        case 0:\n          uVar7 = state_case_normal((int)this);\n          cVar4 = (char)uVar7;\n          break;\n        case 1:\n          *(undefined4 *)(this + 0x28) = 0xffffffff;\n          *(undefined4 *)(this + 0x24) = 0;\n          this[0x30] = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                        )0x0;\n          *(undefined4 *)(this + 0x20) = 0;\n          *(undefined4 *)(this + 0x2c) = 0;\n          this[0x3c] = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                        )0x0;\n          goto LAB_0040bb5b;\n        case 2:\n          uVar7 = state_case_flag((int)this);\n          cVar4 = (char)uVar7;\n          break;\n        case 3:\n          uVar7 = state_case_width(this);\n          cVar4 = (char)uVar7;\n          break;\n        case 4:\n          goto switchD_0040bafe_caseD_4;\n        case 5:\n          uVar7 = state_case_precision(this);\n          cVar4 = (char)uVar7;\n          break;\n        case 6:\n          cVar4 = state_case_size(this);\n          break;\n        case 7:\n          cVar4 = state_case_type(this);\n          break;\n        default:\n          goto switchD_0040bafe_default;\n        }\n        if (cVar4 == '\\0') goto switchD_0040bafe_default;\n        goto LAB_0040bb5b;\n      }\n      *(int *)(this + 0x10) = *(int *)(this + 0x10) + 1;\n      goto LAB_0040bb6e;\n    }\n    iVar6 = *(int *)(this + 0x18);\n  }\n  return iVar6;\nswitchD_0040bafe_caseD_4:\n  *(undefined4 *)(this + 0x28) = 0;\n  goto LAB_0040bb5b;\n}\n\n"
    },
    {
      "name": "process",
      "entry": "0040bbaa",
      "c": "\n/* Library Function - Single Match\n    public: int __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::process(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_stdio_output::\noutput_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n::process(output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n          *this)\n\n{\n  short sVar1;\n  bool bVar2;\n  byte bVar3;\n  char cVar4;\n  int *piVar5;\n  int iVar6;\n  undefined3 extraout_var;\n  undefined4 uVar7;\n  \n  bVar2 = __crt_strtox::c_string_character_source<wchar_t>::validate\n                    ((c_string_character_source<wchar_t> *)(this + 0x448));\n  if (!bVar2) {\n    return -1;\n  }\n  if (*(int *)(this + 0x10) == 0) {\nLAB_0040bbcf:\n    piVar5 = __errno();\n    *piVar5 = 0x16;\n    FUN_00412362();\nswitchD_0040bc1b_default:\n    iVar6 = -1;\n  }\n  else {\nLAB_0040bc8f:\n    *(int *)(this + 0x450) = *(int *)(this + 0x450) + 1;\n    if (*(int *)(this + 0x450) != 2) {\n      *(undefined4 *)(this + 0x38) = 0;\n      *(undefined4 *)(this + 0x1c) = 0;\nLAB_0040bc78:\n      sVar1 = **(short **)(this + 0x10);\n      *(short *)(this + 0x32) = sVar1;\n      if (sVar1 != 0) {\n        *(int *)(this + 0x10) = *(int *)(this + 0x10) + 2;\n        if (*(int *)(this + 0x18) < 0) goto LAB_0040bc8f;\n        bVar3 = find_next_state(*(ushort *)(this + 0x32),*(int *)(this + 0x1c));\n        iVar6 = CONCAT31(extraout_var,bVar3);\n        *(int *)(this + 0x1c) = iVar6;\n        if (iVar6 == 8) goto LAB_0040bbcf;\n        switch(iVar6) {\n        case 0:\n          uVar7 = state_case_normal((int)this);\n          cVar4 = (char)uVar7;\n          break;\n        case 1:\n          *(undefined4 *)(this + 0x28) = 0xffffffff;\n          *(undefined4 *)(this + 0x24) = 0;\n          this[0x30] = (output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n                        )0x0;\n          *(undefined4 *)(this + 0x20) = 0;\n          *(undefined4 *)(this + 0x2c) = 0;\n          this[0x3c] = (output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n                        )0x0;\n          goto LAB_0040bc78;\n        case 2:\n          uVar7 = state_case_flag((int)this);\n          cVar4 = (char)uVar7;\n          break;\n        case 3:\n          uVar7 = state_case_width(this);\n          cVar4 = (char)uVar7;\n          break;\n        case 4:\n          goto switchD_0040bc1b_caseD_4;\n        case 5:\n          uVar7 = state_case_precision(this);\n          cVar4 = (char)uVar7;\n          break;\n        case 6:\n          cVar4 = state_case_size(this);\n          break;\n        case 7:\n          cVar4 = state_case_type(this);\n          break;\n        default:\n          goto switchD_0040bc1b_default;\n        }\n        if (cVar4 == '\\0') goto switchD_0040bc1b_default;\n        goto LAB_0040bc78;\n      }\n      *(int *)(this + 0x10) = *(int *)(this + 0x10) + 2;\n      goto LAB_0040bc8f;\n    }\n    iVar6 = *(int *)(this + 0x18);\n  }\n  return iVar6;\nswitchD_0040bc1b_caseD_4:\n  *(undefined4 *)(this + 0x28) = 0;\n  goto LAB_0040bc78;\n}\n\n"
    },
    {
      "name": "state_case_flag",
      "entry": "0040bcca",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_flag(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_flag(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall state_case_flag(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = (int)*(char *)(param_1 + 0x31);\n  if (iVar1 == 0x20) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 2;\n    iVar1 = 0;\n  }\n  else if (iVar1 == 0x23) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 0x20;\n    iVar1 = 0;\n  }\n  else if (iVar1 == 0x2b) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 1;\n    iVar1 = 0;\n  }\n  else if (iVar1 == 0x2d) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 4;\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = iVar1 + -0x30;\n    if (iVar1 == 0) {\n      *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 8;\n    }\n  }\n  return CONCAT31((int3)((uint)iVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_flag",
      "entry": "0040bd07",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::state_case_flag(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_flag(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall state_case_flag(int param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 = (uint)*(ushort *)(param_1 + 0x32);\n  if (uVar1 == 0x20) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 2;\n    iVar2 = 0;\n  }\n  else if (uVar1 == 0x23) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 0x20;\n    iVar2 = 0;\n  }\n  else if (uVar1 == 0x2b) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 1;\n    iVar2 = 0;\n  }\n  else if (uVar1 == 0x2d) {\n    *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 4;\n    iVar2 = 0;\n  }\n  else {\n    iVar2 = uVar1 - 0x30;\n    if (iVar2 == 0) {\n      *(uint *)(param_1 + 0x20) = *(uint *)(param_1 + 0x20) | 8;\n    }\n  }\n  return CONCAT31((int3)((uint)iVar2 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_normal",
      "entry": "0040bd44",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_normal(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_normal(void)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall state_case_normal(int param_1)\n\n{\n  uint uVar1;\n  int *piVar2;\n  \n  uVar1 = state_case_normal_common(param_1);\n  if ((char)uVar1 == '\\0') {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    uVar1 = FUN_00412362();\n    return uVar1 & 0xffffff00;\n  }\n  return CONCAT31((int3)(uVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_normal",
      "entry": "0040bd63",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_normal(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_normal(void)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall state_case_normal(int param_1)\n\n{\n  uint uVar1;\n  int *piVar2;\n  \n  uVar1 = state_case_normal_common(param_1);\n  if ((char)uVar1 == '\\0') {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    uVar1 = FUN_00412362();\n    return uVar1 & 0xffffff00;\n  }\n  return CONCAT31((int3)(uVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_normal",
      "entry": "0040bd82",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::state_case_normal(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_normal(void)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall state_case_normal(int param_1)\n\n{\n  char cVar1;\n  undefined3 extraout_var;\n  int *piVar2;\n  uint uVar3;\n  \n  cVar1 = state_case_normal_common(param_1);\n  if (cVar1 == '\\0') {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    uVar3 = FUN_00412362();\n    return uVar3 & 0xffffff00;\n  }\n  return CONCAT31(extraout_var,1);\n}\n\n"
    },
    {
      "name": "state_case_normal_common",
      "entry": "0040bda1",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::state_case_normal_common(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_normal_common(void)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall state_case_normal_common(int param_1)\n\n{\n  uint uVar1;\n  undefined4 extraout_EAX;\n  \n  uVar1 = state_case_normal_tchar(param_1);\n  if ((char)uVar1 == '\\0') {\n    return uVar1;\n  }\n  __crt_stdio_output::stream_output_adapter<char>::write_character\n            ((stream_output_adapter<char> *)(param_1 + 0x448),*(char *)(param_1 + 0x31),\n             (int *)(param_1 + 0x18));\n  return CONCAT31((int3)((uint)extraout_EAX >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_normal_common",
      "entry": "0040bdcb",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::string_output_adapter<char> > >::state_case_normal_common(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_normal_common(void)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall state_case_normal_common(int param_1)\n\n{\n  uint uVar1;\n  undefined3 extraout_var;\n  \n  uVar1 = state_case_normal_tchar(param_1);\n  if ((char)uVar1 == '\\0') {\n    return uVar1;\n  }\n  __crt_stdio_output::string_output_adapter<char>::write_character\n            ((string_output_adapter<char> *)(param_1 + 0x448),*(char *)(param_1 + 0x31),\n             (int *)(param_1 + 0x18));\n  return CONCAT31(extraout_var,1);\n}\n\n"
    },
    {
      "name": "state_case_normal_common",
      "entry": "0040bdf5",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_normal_common(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_normal_common(void)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined1 __fastcall state_case_normal_common(int param_1)\n\n{\n  *(undefined1 *)(param_1 + 0x3c) = 1;\n  __crt_stdio_output::string_output_adapter<wchar_t>::write_character\n            ((string_output_adapter<wchar_t> *)(param_1 + 0x448),*(wchar_t *)(param_1 + 0x32),\n             (int *)(param_1 + 0x18));\n  return 1;\n}\n\n"
    },
    {
      "name": "state_case_normal_tchar",
      "entry": "0040be10",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::state_case_normal_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::positional_parameter_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::state_case_normal_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_normal_tchar(char)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall state_case_normal_tchar(int param_1)\n\n{\n  int *piVar1;\n  uint uVar2;\n  undefined1 *puVar3;\n  \n  *(undefined1 *)(param_1 + 0x3c) = 0;\n  puVar3 = *(undefined1 **)**(undefined4 **)(param_1 + 8);\n  if ((*(ushort *)(puVar3 + (uint)*(byte *)(param_1 + 0x31) * 2) & 0x8000) != 0) {\n    __crt_stdio_output::stream_output_adapter<char>::write_character\n              ((stream_output_adapter<char> *)(param_1 + 0x448),*(byte *)(param_1 + 0x31),\n               (int *)(param_1 + 0x18));\n    *(undefined1 *)(param_1 + 0x31) = **(undefined1 **)(param_1 + 0x10);\n    puVar3 = *(undefined1 **)(param_1 + 0x10) + 1;\n    *(undefined1 **)(param_1 + 0x10) = puVar3;\n    if (*(char *)(param_1 + 0x31) == '\\0') {\n      piVar1 = __errno();\n      *piVar1 = 0x16;\n      uVar2 = FUN_00412362();\n      return uVar2 & 0xffffff00;\n    }\n  }\n  return CONCAT31((int3)((uint)puVar3 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_normal_tchar",
      "entry": "0040be71",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::string_output_adapter<char> > >::state_case_normal_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::positional_parameter_base<char,class\n   __crt_stdio_output::string_output_adapter<char> > >::state_case_normal_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_normal_tchar(char)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall state_case_normal_tchar(int param_1)\n\n{\n  int *piVar1;\n  uint uVar2;\n  undefined1 *puVar3;\n  \n  *(undefined1 *)(param_1 + 0x3c) = 0;\n  puVar3 = *(undefined1 **)**(undefined4 **)(param_1 + 8);\n  if ((*(ushort *)(puVar3 + (uint)*(byte *)(param_1 + 0x31) * 2) & 0x8000) != 0) {\n    __crt_stdio_output::string_output_adapter<char>::write_character\n              ((string_output_adapter<char> *)(param_1 + 0x448),*(byte *)(param_1 + 0x31),\n               (int *)(param_1 + 0x18));\n    *(undefined1 *)(param_1 + 0x31) = **(undefined1 **)(param_1 + 0x10);\n    puVar3 = *(undefined1 **)(param_1 + 0x10) + 1;\n    *(undefined1 **)(param_1 + 0x10) = puVar3;\n    if (*(char *)(param_1 + 0x31) == '\\0') {\n      piVar1 = __errno();\n      *piVar1 = 0x16;\n      uVar2 = FUN_00412362();\n      return uVar2 & 0xffffff00;\n    }\n  }\n  return CONCAT31((int3)((uint)puVar3 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_precision",
      "entry": "0040bed2",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_precision(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_precision(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall state_case_precision(void *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (*(char *)((int)param_1 + 0x31) != '*') {\n    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x28));\n    return uVar2;\n  }\n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);\n  *(int *)((int)param_1 + 0x28) = iVar1;\n  if (iVar1 < 0) {\n    *(undefined4 *)((int)param_1 + 0x28) = 0xffffffff;\n  }\n  return CONCAT31((int3)((uint)iVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_precision",
      "entry": "0040befa",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::state_case_precision(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_precision(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall state_case_precision(void *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (*(short *)((int)param_1 + 0x32) != 0x2a) {\n    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x28));\n    return uVar2;\n  }\n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);\n  *(int *)((int)param_1 + 0x28) = iVar1;\n  if (iVar1 < 0) {\n    *(undefined4 *)((int)param_1 + 0x28) = 0xffffffff;\n  }\n  return CONCAT31((int3)((uint)iVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_size",
      "entry": "0040bf23",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_size(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_size(void)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __fastcall\nstate_case_size(output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                *param_1)\n\n{\n  output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n  oVar1;\n  char cVar2;\n  char *pcVar3;\n  bool bVar4;\n  int *piVar5;\n  \n  oVar1 = param_1[0x31];\n  if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                )0x46) {\n    if ((*(uint *)param_1 & 8) == 0) {\n      *(undefined4 *)(param_1 + 0x1c) = 7;\n      bVar4 = __crt_stdio_output::\n              output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n              ::state_case_type(param_1);\n      return bVar4;\n    }\n  }\n  else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                     )0x4e) {\n    if ((*(uint *)param_1 & 8) == 0) {\n      *(undefined4 *)(param_1 + 0x1c) = 8;\nLAB_0040bf5b:\n      piVar5 = __errno();\n      *piVar5 = 0x16;\n      FUN_00412362();\n      return false;\n    }\n  }\n  else {\n    if (*(int *)(param_1 + 0x2c) != 0) goto LAB_0040bf5b;\n    if ((char)oVar1 < 'k') {\n      if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x6a) {\n        *(undefined4 *)(param_1 + 0x2c) = 5;\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                         )0x49) {\n        pcVar3 = *(char **)(param_1 + 0x10);\n        cVar2 = *pcVar3;\n        if ((cVar2 == '3') && (pcVar3[1] == '2')) {\n          *(undefined4 *)(param_1 + 0x2c) = 10;\n          *(char **)(param_1 + 0x10) = pcVar3 + 2;\n        }\n        else if ((cVar2 == '6') && (pcVar3[1] == '4')) {\n          *(undefined4 *)(param_1 + 0x2c) = 0xb;\n          *(char **)(param_1 + 0x10) = pcVar3 + 2;\n        }\n        else if ((((cVar2 == 'd') || (cVar2 == 'i')) || (cVar2 == 'o')) ||\n                (((cVar2 == 'u' || (cVar2 == 'x')) || (cVar2 == 'X')))) {\n          *(undefined4 *)(param_1 + 0x2c) = 9;\n        }\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                         )0x4c) {\n        *(undefined4 *)(param_1 + 0x2c) = 8;\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                         )0x54) {\n        *(undefined4 *)(param_1 + 0x2c) = 0xd;\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                         )0x68) {\n        if (**(char **)(param_1 + 0x10) == 'h') {\n          *(undefined4 *)(param_1 + 0x2c) = 1;\n          *(char **)(param_1 + 0x10) = *(char **)(param_1 + 0x10) + 1;\n        }\n        else {\n          *(undefined4 *)(param_1 + 0x2c) = 2;\n        }\n      }\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                       )0x6c) {\n      if (**(char **)(param_1 + 0x10) == 'l') {\n        *(undefined4 *)(param_1 + 0x2c) = 4;\n        *(char **)(param_1 + 0x10) = *(char **)(param_1 + 0x10) + 1;\n      }\n      else {\n        *(undefined4 *)(param_1 + 0x2c) = 3;\n      }\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                       )0x74) {\n      *(undefined4 *)(param_1 + 0x2c) = 7;\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                       )0x77) {\n      *(undefined4 *)(param_1 + 0x2c) = 0xc;\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                       )0x7a) {\n      *(undefined4 *)(param_1 + 0x2c) = 6;\n    }\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "state_case_size",
      "entry": "0040c08c",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_size(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_size(void)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __fastcall\nstate_case_size(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                *param_1)\n\n{\n  output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n  oVar1;\n  char cVar2;\n  char *pcVar3;\n  bool bVar4;\n  int *piVar5;\n  \n  oVar1 = param_1[0x31];\n  if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                )0x46) {\n    if ((*(uint *)param_1 & 8) == 0) {\n      *(undefined4 *)(param_1 + 0x1c) = 7;\n      bVar4 = __crt_stdio_output::\n              output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n              ::state_case_type(param_1);\n      return bVar4;\n    }\n  }\n  else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                     )0x4e) {\n    if ((*(uint *)param_1 & 8) == 0) {\n      *(undefined4 *)(param_1 + 0x1c) = 8;\nLAB_0040c0c4:\n      piVar5 = __errno();\n      *piVar5 = 0x16;\n      FUN_00412362();\n      return false;\n    }\n  }\n  else {\n    if (*(int *)(param_1 + 0x2c) != 0) goto LAB_0040c0c4;\n    if ((char)oVar1 < 'k') {\n      if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x6a) {\n        *(undefined4 *)(param_1 + 0x2c) = 5;\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                         )0x49) {\n        pcVar3 = *(char **)(param_1 + 0x10);\n        cVar2 = *pcVar3;\n        if ((cVar2 == '3') && (pcVar3[1] == '2')) {\n          *(undefined4 *)(param_1 + 0x2c) = 10;\n          *(char **)(param_1 + 0x10) = pcVar3 + 2;\n        }\n        else if ((cVar2 == '6') && (pcVar3[1] == '4')) {\n          *(undefined4 *)(param_1 + 0x2c) = 0xb;\n          *(char **)(param_1 + 0x10) = pcVar3 + 2;\n        }\n        else if ((((cVar2 == 'd') || (cVar2 == 'i')) || (cVar2 == 'o')) ||\n                (((cVar2 == 'u' || (cVar2 == 'x')) || (cVar2 == 'X')))) {\n          *(undefined4 *)(param_1 + 0x2c) = 9;\n        }\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                         )0x4c) {\n        *(undefined4 *)(param_1 + 0x2c) = 8;\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                         )0x54) {\n        *(undefined4 *)(param_1 + 0x2c) = 0xd;\n      }\n      else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                         )0x68) {\n        if (**(char **)(param_1 + 0x10) == 'h') {\n          *(undefined4 *)(param_1 + 0x2c) = 1;\n          *(char **)(param_1 + 0x10) = *(char **)(param_1 + 0x10) + 1;\n        }\n        else {\n          *(undefined4 *)(param_1 + 0x2c) = 2;\n        }\n      }\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                       )0x6c) {\n      if (**(char **)(param_1 + 0x10) == 'l') {\n        *(undefined4 *)(param_1 + 0x2c) = 4;\n        *(char **)(param_1 + 0x10) = *(char **)(param_1 + 0x10) + 1;\n      }\n      else {\n        *(undefined4 *)(param_1 + 0x2c) = 3;\n      }\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                       )0x74) {\n      *(undefined4 *)(param_1 + 0x2c) = 7;\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                       )0x77) {\n      *(undefined4 *)(param_1 + 0x2c) = 0xc;\n    }\n    else if (oVar1 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                       )0x7a) {\n      *(undefined4 *)(param_1 + 0x2c) = 6;\n    }\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "state_case_size",
      "entry": "0040c1f5",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::state_case_size(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_size(void)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __fastcall\nstate_case_size(output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n                *param_1)\n\n{\n  ushort uVar1;\n  short sVar2;\n  short *psVar3;\n  bool bVar4;\n  int *piVar5;\n  \n  uVar1 = *(ushort *)(param_1 + 0x32);\n  if (uVar1 == 0x46) {\n    if ((*(uint *)param_1 & 8) == 0) {\n      *(undefined4 *)(param_1 + 0x1c) = 7;\n      bVar4 = __crt_stdio_output::\n              output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n              ::state_case_type(param_1);\n      return bVar4;\n    }\n  }\n  else if (uVar1 == 0x4e) {\n    if ((*(uint *)param_1 & 8) == 0) {\n      *(undefined4 *)(param_1 + 0x1c) = 8;\nLAB_0040c230:\n      piVar5 = __errno();\n      *piVar5 = 0x16;\n      FUN_00412362();\n      return false;\n    }\n  }\n  else {\n    if (*(int *)(param_1 + 0x2c) != 0) goto LAB_0040c230;\n    if (uVar1 < 0x6b) {\n      if (uVar1 == 0x6a) {\n        *(undefined4 *)(param_1 + 0x2c) = 5;\n      }\n      else if (uVar1 == 0x49) {\n        psVar3 = *(short **)(param_1 + 0x10);\n        sVar2 = *psVar3;\n        if ((sVar2 == 0x33) && (psVar3[1] == 0x32)) {\n          *(undefined4 *)(param_1 + 0x2c) = 10;\n          *(short **)(param_1 + 0x10) = psVar3 + 2;\n        }\n        else if ((sVar2 == 0x36) && (psVar3[1] == 0x34)) {\n          *(undefined4 *)(param_1 + 0x2c) = 0xb;\n          *(short **)(param_1 + 0x10) = psVar3 + 2;\n        }\n        else if ((((sVar2 == 100) || (sVar2 == 0x69)) || (sVar2 == 0x6f)) ||\n                (((sVar2 == 0x75 || (sVar2 == 0x78)) || (sVar2 == 0x58)))) {\n          *(undefined4 *)(param_1 + 0x2c) = 9;\n        }\n      }\n      else if (uVar1 == 0x4c) {\n        *(undefined4 *)(param_1 + 0x2c) = 8;\n      }\n      else if (uVar1 == 0x54) {\n        *(undefined4 *)(param_1 + 0x2c) = 0xd;\n      }\n      else if (uVar1 == 0x68) {\n        if (**(short **)(param_1 + 0x10) == 0x68) {\n          *(undefined4 *)(param_1 + 0x2c) = 1;\n          *(short **)(param_1 + 0x10) = *(short **)(param_1 + 0x10) + 1;\n        }\n        else {\n          *(undefined4 *)(param_1 + 0x2c) = 2;\n        }\n      }\n    }\n    else if (uVar1 == 0x6c) {\n      if (**(short **)(param_1 + 0x10) == 0x6c) {\n        *(undefined4 *)(param_1 + 0x2c) = 4;\n        *(short **)(param_1 + 0x10) = *(short **)(param_1 + 0x10) + 1;\n      }\n      else {\n        *(undefined4 *)(param_1 + 0x2c) = 3;\n      }\n    }\n    else if (uVar1 == 0x74) {\n      *(undefined4 *)(param_1 + 0x2c) = 7;\n    }\n    else if (uVar1 == 0x77) {\n      *(undefined4 *)(param_1 + 0x2c) = 0xc;\n    }\n    else if (uVar1 == 0x7a) {\n      *(undefined4 *)(param_1 + 0x2c) = 6;\n    }\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "state_case_type",
      "entry": "0040c371",
      "c": "\n/* Library Function - Single Match\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_type(void)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_stdio_output::\noutput_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n::state_case_type(output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                  *this)\n\n{\n  output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n  *poVar1;\n  output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n  oVar2;\n  bool bVar3;\n  char cVar4;\n  undefined4 uVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  undefined4 local_8;\n  \n  iVar6 = 1;\n  oVar2 = this[0x31];\n  local_8 = this;\n  if ((char)oVar2 < 'e') {\n    if (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                  )0x64) {\nLAB_0040c422:\n      *(uint *)(this + 0x20) = *(uint *)(this + 0x20) | 0x10;\n      goto LAB_0040c426;\n    }\n    if ('X' < (char)oVar2) {\n      if (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x5a) {\n        uVar5 = type_case_Z((__uint64 *)this);\n        cVar4 = (char)uVar5;\n        goto LAB_0040c3be;\n      }\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x61) {\n        if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                      )0x63) {\n          return false;\n        }\nLAB_0040c3e2:\n        uVar5 = type_case_c_tchar((__uint64 *)this);\n        cVar4 = (char)uVar5;\n        goto LAB_0040c3be;\n      }\nLAB_0040c432:\n      uVar5 = type_case_a((uint *)this);\n      cVar4 = (char)uVar5;\n      goto LAB_0040c3be;\n    }\n    if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                  )0x58) {\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x41) {\n        if (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                      )0x43) goto LAB_0040c3e2;\n        if ((char)oVar2 < 'E') {\n          return false;\n        }\n        if ('G' < (char)oVar2) {\n          if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                        )0x53) {\n            return false;\n          }\n          goto LAB_0040c3b7;\n        }\n      }\n      goto LAB_0040c432;\n    }\n    cVar4 = '\\x01';\nLAB_0040c3ce:\n    uVar8 = 0x10;\n  }\n  else {\n    if ((char)oVar2 < 'q') {\n      if (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x70) {\n        cVar4 = type_case_p(this);\n        goto LAB_0040c3be;\n      }\n      if ((char)oVar2 < 'h') goto LAB_0040c432;\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x69) {\n        if (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                      )0x6e) {\n          uVar8 = type_case_n((int)this);\n          cVar4 = (char)uVar8;\n        }\n        else {\n          if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                        )0x6f) {\n            return false;\n          }\n          cVar4 = type_case_o(this);\n        }\n        goto LAB_0040c3be;\n      }\n      goto LAB_0040c422;\n    }\n    if (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                  )0x73) {\nLAB_0040c3b7:\n      uVar5 = type_case_s((__uint64 *)this);\n      cVar4 = (char)uVar5;\n      goto LAB_0040c3be;\n    }\n    if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                  )0x75) {\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                    )0x78) {\n        return false;\n      }\n      cVar4 = '\\0';\n      goto LAB_0040c3ce;\n    }\nLAB_0040c426:\n    cVar4 = '\\0';\n    uVar8 = 10;\n  }\n  uVar8 = type_case_integer(this,uVar8,cVar4);\n  cVar4 = (char)uVar8;\nLAB_0040c3be:\n  if (cVar4 == '\\0') {\n    return false;\n  }\n  if (this[0x30] !=\n      (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n       )0x0) {\n    return true;\n  }\n  uVar8 = *(uint *)(this + 0x20);\n  local_8 = (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n             *)((uint)local_8 & 0xff000000);\n  iVar7 = 0;\n  if ((uVar8 >> 4 & 1) != 0) {\n    iVar7 = iVar6;\n    if ((uVar8 >> 6 & 1) == 0) {\n      if ((uVar8 & 1) == 0) {\n        iVar7 = 0;\n        if ((uVar8 >> 1 & 1) != 0) {\n          local_8 = (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                     *)CONCAT31(local_8._1_3_,0x20);\n          iVar7 = iVar6;\n        }\n      }\n      else {\n        local_8 = (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                   *)CONCAT31(local_8._1_3_,0x2b);\n      }\n    }\n    else {\n      local_8 = (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                 *)CONCAT31(local_8._1_3_,0x2d);\n    }\n  }\n  oVar2 = this[0x31];\n  if (((oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                  )0x78) &&\n      (oVar2 != (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                 )0x58)) || ((uVar8 >> 5 & 1) == 0)) {\n    iVar6 = 0;\n  }\n  if ((oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                 )0x61) ||\n     (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                )0x41)) {\n    bVar3 = true;\n  }\n  else {\n    bVar3 = false;\n  }\n  if (((char)iVar6 != '\\0') || (bVar3)) {\n    *(undefined1 *)((int)&local_8 + iVar7) = 0x30;\n    if ((oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                   )0x58) ||\n       (oVar2 == (output_processor<char,class___crt_stdio_output::stream_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::stream_output_adapter<char>_>_>\n                  )0x41)) {\n      bVar3 = true;\n    }\n    else {\n      bVar3 = false;\n    }\n    *(byte *)((int)&local_8 + iVar7 + 1) = (!bVar3 - 1U & 0xe0) + 0x78;\n    iVar7 = iVar7 + 2;\n  }\n  iVar6 = (*(int *)(this + 0x24) - *(int *)(this + 0x38)) - iVar7;\n  if ((uVar8 & 0xc) == 0) {\n    write_multiple_characters<class___crt_stdio_output::stream_output_adapter<char>,char>\n              ((stream_output_adapter<char> *)(this + 0x448),' ',iVar6,(int *)(this + 0x18));\n  }\n  stream_output_adapter<char>::write_string\n            ((stream_output_adapter<char> *)(this + 0x448),(char *)&local_8,iVar7,\n             (int *)(this + 0x18),*(int **)(this + 0xc));\n  poVar1 = this + 0x18;\n  if (((*(uint *)(this + 0x20) >> 3 & 1) != 0) && ((*(uint *)(this + 0x20) >> 2 & 1) == 0)) {\n    write_multiple_characters<class___crt_stdio_output::stream_output_adapter<char>,char>\n              ((stream_output_adapter<char> *)(this + 0x448),'0',iVar6,(int *)poVar1);\n  }\n  write_stored_string_tchar((int)this);\n  if ((-1 < *(int *)poVar1) && ((*(uint *)(this + 0x20) >> 2 & 1) != 0)) {\n    write_multiple_characters<class___crt_stdio_output::stream_output_adapter<char>,char>\n              ((stream_output_adapter<char> *)(this + 0x448),' ',iVar6,(int *)poVar1);\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "state_case_type",
      "entry": "0040c5a0",
      "c": "\n/* Library Function - Single Match\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_type(void)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_stdio_output::\noutput_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n::state_case_type(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                  *this)\n\n{\n  output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n  *poVar1;\n  output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n  oVar2;\n  bool bVar3;\n  char cVar4;\n  undefined4 uVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  undefined4 local_8;\n  \n  iVar6 = 1;\n  oVar2 = this[0x31];\n  local_8 = this;\n  if ((char)oVar2 < 'e') {\n    if (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                  )0x64) {\nLAB_0040c651:\n      *(uint *)(this + 0x20) = *(uint *)(this + 0x20) | 0x10;\n      goto LAB_0040c655;\n    }\n    if ('X' < (char)oVar2) {\n      if (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x5a) {\n        uVar5 = type_case_Z((__uint64 *)this);\n        cVar4 = (char)uVar5;\n        goto LAB_0040c5ed;\n      }\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x61) {\n        if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                      )0x63) {\n          return false;\n        }\nLAB_0040c611:\n        uVar5 = type_case_c_tchar((__uint64 *)this);\n        cVar4 = (char)uVar5;\n        goto LAB_0040c5ed;\n      }\nLAB_0040c661:\n      uVar5 = type_case_a((uint *)this);\n      cVar4 = (char)uVar5;\n      goto LAB_0040c5ed;\n    }\n    if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                  )0x58) {\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x41) {\n        if (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                      )0x43) goto LAB_0040c611;\n        if ((char)oVar2 < 'E') {\n          return false;\n        }\n        if ('G' < (char)oVar2) {\n          if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                        )0x53) {\n            return false;\n          }\n          goto LAB_0040c5e6;\n        }\n      }\n      goto LAB_0040c661;\n    }\n    cVar4 = '\\x01';\nLAB_0040c5fd:\n    uVar8 = 0x10;\n  }\n  else {\n    if ((char)oVar2 < 'q') {\n      if (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x70) {\n        cVar4 = type_case_p(this);\n        goto LAB_0040c5ed;\n      }\n      if ((char)oVar2 < 'h') goto LAB_0040c661;\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x69) {\n        if (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                      )0x6e) {\n          uVar8 = type_case_n((int)this);\n          cVar4 = (char)uVar8;\n        }\n        else {\n          if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                        )0x6f) {\n            return false;\n          }\n          cVar4 = type_case_o(this);\n        }\n        goto LAB_0040c5ed;\n      }\n      goto LAB_0040c651;\n    }\n    if (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                  )0x73) {\nLAB_0040c5e6:\n      uVar5 = type_case_s((__uint64 *)this);\n      cVar4 = (char)uVar5;\n      goto LAB_0040c5ed;\n    }\n    if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                  )0x75) {\n      if (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                    )0x78) {\n        return false;\n      }\n      cVar4 = '\\0';\n      goto LAB_0040c5fd;\n    }\nLAB_0040c655:\n    cVar4 = '\\0';\n    uVar8 = 10;\n  }\n  uVar8 = type_case_integer(this,uVar8,cVar4);\n  cVar4 = (char)uVar8;\nLAB_0040c5ed:\n  if (cVar4 == '\\0') {\n    return false;\n  }\n  if (this[0x30] !=\n      (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n       )0x0) {\n    return true;\n  }\n  uVar8 = *(uint *)(this + 0x20);\n  local_8 = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n             *)((uint)local_8 & 0xff000000);\n  iVar7 = 0;\n  if ((uVar8 >> 4 & 1) != 0) {\n    iVar7 = iVar6;\n    if ((uVar8 >> 6 & 1) == 0) {\n      if ((uVar8 & 1) == 0) {\n        iVar7 = 0;\n        if ((uVar8 >> 1 & 1) != 0) {\n          local_8 = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                     *)CONCAT31(local_8._1_3_,0x20);\n          iVar7 = iVar6;\n        }\n      }\n      else {\n        local_8 = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                   *)CONCAT31(local_8._1_3_,0x2b);\n      }\n    }\n    else {\n      local_8 = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                 *)CONCAT31(local_8._1_3_,0x2d);\n    }\n  }\n  oVar2 = this[0x31];\n  if (((oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                  )0x78) &&\n      (oVar2 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                 )0x58)) || ((uVar8 >> 5 & 1) == 0)) {\n    iVar6 = 0;\n  }\n  if ((oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                 )0x61) ||\n     (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                )0x41)) {\n    bVar3 = true;\n  }\n  else {\n    bVar3 = false;\n  }\n  if (((char)iVar6 != '\\0') || (bVar3)) {\n    *(undefined1 *)((int)&local_8 + iVar7) = 0x30;\n    if ((oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                   )0x58) ||\n       (oVar2 == (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::standard_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n                  )0x41)) {\n      bVar3 = true;\n    }\n    else {\n      bVar3 = false;\n    }\n    *(byte *)((int)&local_8 + iVar7 + 1) = (!bVar3 - 1U & 0xe0) + 0x78;\n    iVar7 = iVar7 + 2;\n  }\n  iVar6 = (*(int *)(this + 0x24) - *(int *)(this + 0x38)) - iVar7;\n  if ((uVar8 & 0xc) == 0) {\n    write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>\n              ((string_output_adapter<char> *)(this + 0x448),' ',iVar6,(int *)(this + 0x18));\n  }\n  string_output_adapter<char>::write_string\n            ((string_output_adapter<char> *)(this + 0x448),(char *)&local_8,iVar7,\n             (int *)(this + 0x18),*(int **)(this + 0xc));\n  poVar1 = this + 0x18;\n  if (((*(uint *)(this + 0x20) >> 3 & 1) != 0) && ((*(uint *)(this + 0x20) >> 2 & 1) == 0)) {\n    write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>\n              ((string_output_adapter<char> *)(this + 0x448),'0',iVar6,(int *)poVar1);\n  }\n  write_stored_string_tchar((int)this);\n  if ((-1 < *(int *)poVar1) && ((*(uint *)(this + 0x20) >> 2 & 1) != 0)) {\n    write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>\n              ((string_output_adapter<char> *)(this + 0x448),' ',iVar6,(int *)poVar1);\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "state_case_type",
      "entry": "0040c7cf",
      "c": "\n/* Library Function - Single Match\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_type(void)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_stdio_output::\noutput_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n::state_case_type(output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n                  *this)\n\n{\n  output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n  *poVar1;\n  short sVar2;\n  bool bVar3;\n  bool bVar4;\n  char cVar5;\n  undefined1 uVar6;\n  undefined4 uVar7;\n  int iVar8;\n  ushort uVar9;\n  int iVar10;\n  uint uVar11;\n  undefined4 local_10;\n  undefined2 local_c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  iVar8 = 0;\n  uVar9 = *(ushort *)(this + 0x32);\n  if (uVar9 < 0x65) {\n    if (uVar9 == 100) {\nLAB_0040c88e:\n      *(uint *)(this + 0x20) = *(uint *)(this + 0x20) | 0x10;\nLAB_0040c892:\n      cVar5 = '\\0';\n      uVar11 = 10;\nLAB_0040c895:\n      uVar11 = type_case_integer(this,uVar11,cVar5);\n      cVar5 = (char)uVar11;\n    }\n    else if (uVar9 < 0x59) {\n      if (uVar9 == 0x58) {\n        cVar5 = '\\x01';\nLAB_0040c83a:\n        uVar11 = 0x10;\n        goto LAB_0040c895;\n      }\n      if (uVar9 != 0x41) {\n        if (uVar9 == 0x43) goto LAB_0040c84e;\n        if (uVar9 < 0x45) goto LAB_0040ca1c;\n        if (0x47 < uVar9) {\n          if (uVar9 != 0x53) goto LAB_0040ca1c;\n          goto LAB_0040c822;\n        }\n      }\nLAB_0040c89e:\n      uVar7 = type_case_a((uint *)this);\n      cVar5 = (char)uVar7;\n    }\n    else if (uVar9 == 0x5a) {\n      uVar7 = type_case_Z((__uint64 *)this);\n      cVar5 = (char)uVar7;\n    }\n    else {\n      if (uVar9 == 0x61) goto LAB_0040c89e;\n      if (uVar9 != 99) goto LAB_0040ca1c;\nLAB_0040c84e:\n      uVar7 = type_case_c_tchar((__uint64 *)this);\n      cVar5 = (char)uVar7;\n    }\n  }\n  else if (uVar9 < 0x71) {\n    if (uVar9 == 0x70) {\n      cVar5 = type_case_p(this);\n    }\n    else {\n      if (uVar9 < 0x68) goto LAB_0040c89e;\n      if (uVar9 == 0x69) goto LAB_0040c88e;\n      if (uVar9 == 0x6e) {\n        uVar11 = type_case_n((int)this);\n        cVar5 = (char)uVar11;\n      }\n      else {\n        if (uVar9 != 0x6f) goto LAB_0040ca1c;\n        cVar5 = type_case_o(this);\n      }\n    }\n  }\n  else {\n    if (uVar9 != 0x73) {\n      if (uVar9 != 0x75) {\n        if (uVar9 != 0x78) goto LAB_0040ca1c;\n        cVar5 = '\\0';\n        goto LAB_0040c83a;\n      }\n      goto LAB_0040c892;\n    }\nLAB_0040c822:\n    uVar7 = type_case_s((__uint64 *)this);\n    cVar5 = (char)uVar7;\n  }\n  if ((cVar5 == '\\0') ||\n     (this[0x30] !=\n      (output_processor<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>,class___crt_stdio_output::standard_base<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>_>\n       )0x0)) goto LAB_0040ca1c;\n  uVar11 = *(uint *)(this + 0x20);\n  local_10 = 0;\n  local_c = 0;\n  if ((uVar11 >> 4 & 1) != 0) {\n    if ((uVar11 >> 6 & 1) == 0) {\n      if ((uVar11 & 1) == 0) {\n        if ((uVar11 >> 1 & 1) == 0) goto LAB_0040c91c;\n        uVar9 = 0x20;\n      }\n      else {\n        uVar9 = 0x2b;\n      }\n    }\n    else {\n      uVar9 = 0x2d;\n    }\n    local_10 = (uint)uVar9;\n    iVar8 = 1;\n  }\nLAB_0040c91c:\n  sVar2 = *(short *)(this + 0x32);\n  if (((sVar2 == 0x78) || (sVar2 == 0x58)) && ((uVar11 >> 5 & 1) != 0)) {\n    bVar3 = true;\n  }\n  else {\n    bVar3 = false;\n  }\n  if ((sVar2 == 0x61) || (sVar2 == 0x41)) {\n    bVar4 = true;\n  }\n  else {\n    bVar4 = false;\n  }\n  if ((bVar3) || (bVar4)) {\n    *(undefined2 *)((int)&local_10 + iVar8 * 2) = 0x30;\n    if ((sVar2 == 0x58) || (sVar2 == 0x41)) {\n      bVar3 = true;\n    }\n    else {\n      bVar3 = false;\n    }\n    *(short *)((int)&local_10 + iVar8 * 2 + 2) = (short)(char)((!bVar3 - 1U & 0xe0) + 0x78);\n    iVar8 = iVar8 + 2;\n  }\n  iVar10 = (*(int *)(this + 0x24) - *(int *)(this + 0x38)) - iVar8;\n  if ((uVar11 & 0xc) == 0) {\n    write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n              ((string_output_adapter<wchar_t> *)(this + 0x448),' ',iVar10,(int *)(this + 0x18));\n  }\n  string_output_adapter<wchar_t>::write_string\n            ((string_output_adapter<wchar_t> *)(this + 0x448),(wchar_t *)&local_10,iVar8,\n             (int *)(this + 0x18),*(int **)(this + 0xc));\n  poVar1 = this + 0x18;\n  if (((*(uint *)(this + 0x20) >> 3 & 1) != 0) && ((*(uint *)(this + 0x20) >> 2 & 1) == 0)) {\n    write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n              ((string_output_adapter<wchar_t> *)(this + 0x448),'0',iVar10,(int *)poVar1);\n  }\n  write_stored_string_tchar((uint)this);\n  if ((-1 < *(int *)poVar1) && ((*(uint *)(this + 0x20) >> 2 & 1) != 0)) {\n    write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n              ((string_output_adapter<wchar_t> *)(this + 0x448),' ',iVar10,(int *)poVar1);\n  }\nLAB_0040ca1c:\n  uVar6 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return (bool)uVar6;\n}\n\n"
    },
    {
      "name": "state_case_width",
      "entry": "0040ca2c",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::state_case_width(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::state_case_width(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall state_case_width(void *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (*(char *)((int)param_1 + 0x31) != '*') {\n    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x24));\n    return uVar2;\n  }\n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);\n  *(int *)((int)param_1 + 0x24) = iVar1;\n  if (iVar1 < 0) {\n    *(uint *)((int)param_1 + 0x20) = *(uint *)((int)param_1 + 0x20) | 4;\n    *(int *)((int)param_1 + 0x24) = -*(int *)((int)param_1 + 0x24);\n  }\n  return CONCAT31((int3)((uint)iVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "state_case_width",
      "entry": "0040ca57",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::state_case_width(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::state_case_width(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall state_case_width(void *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (*(short *)((int)param_1 + 0x32) != 0x2a) {\n    uVar2 = parse_int_from_format_string(param_1,(long *)((int)param_1 + 0x24));\n    return uVar2;\n  }\n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);\n  *(int *)((int)param_1 + 0x24) = iVar1;\n  if (iVar1 < 0) {\n    *(uint *)((int)param_1 + 0x20) = *(uint *)((int)param_1 + 0x20) | 4;\n    *(int *)((int)param_1 + 0x24) = -*(int *)((int)param_1 + 0x24);\n  }\n  return CONCAT31((int3)((uint)iVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "to_integer_size",
      "entry": "0040ca83",
      "c": "\n/* Library Function - Single Match\n    unsigned int __cdecl __crt_stdio_output::to_integer_size(enum\n   __crt_stdio_output::length_modifier)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl __crt_stdio_output::to_integer_size(length_modifier param_1)\n\n{\n  uint uStack_8;\n  \n  switch(param_1) {\n  case 0:\n  case 3:\n  case 6:\n  case 7:\n  case 9:\n  case 10:\n    uStack_8 = 4;\n    break;\n  case 1:\n    return 1;\n  case 2:\n    uStack_8 = 2;\n    break;\n  case 4:\n  case 5:\n  case 0xb:\n    uStack_8 = 8;\n    break;\n  default:\n    return 0;\n  }\n  return uStack_8;\n}\n\n"
    },
    {
      "name": "type_case_Z",
      "entry": "0040cadf",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::console_output_adapter<char> > >::type_case_Z(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_Z(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::type_case_Z(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::type_case_Z(void)\n     6 names - too many to list\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_Z(__uint64 *param_1)\n\n{\n  ushort *puVar1;\n  int iVar2;\n  bool bVar3;\n  uint uVar4;\n  \n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  uVar4 = *(uint *)((int)param_1 + 0x14);\n  puVar1 = *(ushort **)(uVar4 - 4);\n  if ((puVar1 == (ushort *)0x0) || (iVar2 = *(int *)(puVar1 + 2), iVar2 == 0)) {\n    *(char **)((int)param_1 + 0x34) = \"(null)\";\n    *(undefined4 *)(param_1 + 7) = 6;\n  }\n  else {\n    bVar3 = __crt_stdio_output::is_wide_character_specifier<char>\n                      (*param_1,*(char *)((int)param_1 + 0x31),\n                       *(length_modifier *)((int)param_1 + 0x2c));\n    *(int *)((int)param_1 + 0x34) = iVar2;\n    uVar4 = (uint)*puVar1;\n    if (bVar3) {\n      uVar4 = (uint)(*puVar1 >> 1);\n      *(uint *)(param_1 + 7) = uVar4;\n      *(undefined1 *)((int)param_1 + 0x3c) = 1;\n      goto LAB_0040cb3c;\n    }\n    *(uint *)(param_1 + 7) = uVar4;\n  }\n  *(undefined1 *)((int)param_1 + 0x3c) = 0;\nLAB_0040cb3c:\n  return CONCAT31((int3)(uVar4 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_Z",
      "entry": "0040cb42",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_Z(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_Z(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_Z(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_Z(void)\n     6 names - too many to list\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_Z(__uint64 *param_1)\n\n{\n  ushort *puVar1;\n  int iVar2;\n  bool bVar3;\n  uint uVar4;\n  \n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  uVar4 = *(uint *)((int)param_1 + 0x14);\n  puVar1 = *(ushort **)(uVar4 - 4);\n  if ((puVar1 == (ushort *)0x0) || (iVar2 = *(int *)(puVar1 + 2), iVar2 == 0)) {\n    *(char **)((int)param_1 + 0x34) = \"(null)\";\n    *(undefined4 *)(param_1 + 7) = 6;\n  }\n  else {\n    bVar3 = __crt_stdio_output::is_wide_character_specifier<wchar_t>\n                      (*param_1,*(wchar_t *)((int)param_1 + 0x32),\n                       *(length_modifier *)((int)param_1 + 0x2c));\n    *(int *)((int)param_1 + 0x34) = iVar2;\n    uVar4 = (uint)*puVar1;\n    if (bVar3) {\n      uVar4 = (uint)(*puVar1 >> 1);\n      *(uint *)(param_1 + 7) = uVar4;\n      *(undefined1 *)((int)param_1 + 0x3c) = 1;\n      goto LAB_0040cb9f;\n    }\n    *(uint *)(param_1 + 7) = uVar4;\n  }\n  *(undefined1 *)((int)param_1 + 0x3c) = 0;\nLAB_0040cb9f:\n  return CONCAT31((int3)(uVar4 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_a",
      "entry": "0040cba5",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::console_output_adapter<char> > >::type_case_a(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_a(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::type_case_a(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::type_case_a(void)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_a(uint *param_1)\n\n{\n  formatting_buffer *this;\n  char *pcVar1;\n  char cVar2;\n  bool bVar3;\n  uint uVar4;\n  formatting_buffer *pfVar5;\n  int iVar6;\n  char *pcVar7;\n  uint uVar8;\n  char *pcVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  __crt_locale_pointers *p_Var13;\n  uint *local_c;\n  uint *local_8;\n  \n  param_1[8] = param_1[8] | 0x10;\n  if ((int)param_1[10] < 0) {\n    if ((*(char *)((int)param_1 + 0x31) == 'a') || (*(char *)((int)param_1 + 0x31) == 'A')) {\n      param_1[10] = 0xd;\n    }\n    else {\n      param_1[10] = 6;\n    }\n  }\n  else if ((param_1[10] == 0) &&\n          ((*(char *)((int)param_1 + 0x31) == 'g' || (*(char *)((int)param_1 + 0x31) == 'G')))) {\n    param_1[10] = 1;\n  }\n  this = (formatting_buffer *)(param_1 + 0x10);\n  local_c = param_1;\n  local_8 = param_1;\n  bVar3 = __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>\n                    (this,param_1[10] + 0x15d);\n  if (!bVar3) {\n    uVar4 = __crt_stdio_output::formatting_buffer::count<char>(this);\n    param_1[10] = uVar4 - 0x15d;\n  }\n  pfVar5 = (formatting_buffer *)param_1[0x111];\n  if ((formatting_buffer *)param_1[0x111] == (formatting_buffer *)0x0) {\n    pfVar5 = this;\n  }\n  param_1[0xd] = (uint)pfVar5;\n  param_1[5] = param_1[5] + 8;\n  local_c = *(uint **)(param_1[5] - 8);\n  local_8 = *(uint **)(param_1[5] - 4);\n  uVar4 = __crt_stdio_output::formatting_buffer::count<char>(this);\n  pfVar5 = (formatting_buffer *)param_1[0x111];\n  if ((formatting_buffer *)param_1[0x111] == (formatting_buffer *)0x0) {\n    pfVar5 = this;\n  }\n  p_Var13 = (__crt_locale_pointers *)param_1[2];\n  iVar6 = (int)*(char *)((int)param_1 + 0x31);\n  uVar12 = param_1[1];\n  uVar11 = *param_1;\n  uVar10 = param_1[10];\n  pcVar7 = __crt_stdio_output::formatting_buffer::scratch_data<char>(this);\n  uVar8 = __crt_stdio_output::formatting_buffer::count<char>(this);\n  ___acrt_fp_format((double *)&local_c,(char *)pfVar5,uVar8,pcVar7,uVar4,iVar6,uVar10,uVar11,uVar12,\n                    p_Var13);\n  if (((param_1[8] >> 5 & 1) != 0) && (param_1[10] == 0)) {\n    __crt_stdio_output::force_decimal_point\n              ((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);\n  }\n  if (((*(char *)((int)param_1 + 0x31) == 'g') || (*(char *)((int)param_1 + 0x31) == 'G')) &&\n     ((param_1[8] >> 5 & 1) == 0)) {\n    __crt_stdio_output::crop_zeroes((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);\n  }\n  pcVar7 = (char *)param_1[0xd];\n  if (*pcVar7 == '-') {\n    param_1[8] = param_1[8] | 0x40;\n    pcVar7 = pcVar7 + 1;\n    param_1[0xd] = (uint)pcVar7;\n  }\n  pcVar9 = (char *)param_1[0xd];\n  cVar2 = *pcVar9;\n  if (((cVar2 == 'i') || (cVar2 == 'I')) || ((cVar2 == 'n' || (cVar2 == 'N')))) {\n    *(undefined1 *)((int)param_1 + 0x31) = 0x73;\n  }\n  pcVar1 = pcVar9 + 1;\n  do {\n    cVar2 = *pcVar9;\n    pcVar9 = pcVar9 + 1;\n  } while (cVar2 != '\\0');\n  param_1[0xe] = (int)pcVar9 - (int)pcVar1;\n  return CONCAT31((int3)((uint)pcVar7 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_a",
      "entry": "0040ccff",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_a(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_a(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_a(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_a(void)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_a(uint *param_1)\n\n{\n  formatting_buffer *this;\n  char cVar1;\n  bool bVar2;\n  uint uVar3;\n  formatting_buffer *pfVar4;\n  int iVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined3 uVar8;\n  char *pcVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  __crt_locale_pointers *p_Var13;\n  uint *local_c;\n  uint *local_8;\n  \n  param_1[8] = param_1[8] | 0x10;\n  if ((int)param_1[10] < 0) {\n    if ((*(short *)((int)param_1 + 0x32) == 0x61) || (*(short *)((int)param_1 + 0x32) == 0x41)) {\n      param_1[10] = 0xd;\n    }\n    else {\n      param_1[10] = 6;\n    }\n  }\n  else if ((param_1[10] == 0) &&\n          ((*(short *)((int)param_1 + 0x32) == 0x67 || (*(short *)((int)param_1 + 0x32) == 0x47))))\n  {\n    param_1[10] = 1;\n  }\n  this = (formatting_buffer *)(param_1 + 0x10);\n  local_c = param_1;\n  local_8 = param_1;\n  bVar2 = __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>\n                    (this,param_1[10] + 0x15d);\n  if (!bVar2) {\n    uVar3 = __crt_stdio_output::formatting_buffer::count<char>(this);\n    param_1[10] = uVar3 - 0x15d;\n  }\n  pfVar4 = (formatting_buffer *)param_1[0x111];\n  if ((formatting_buffer *)param_1[0x111] == (formatting_buffer *)0x0) {\n    pfVar4 = this;\n  }\n  param_1[0xd] = (uint)pfVar4;\n  param_1[5] = param_1[5] + 8;\n  local_c = *(uint **)(param_1[5] - 8);\n  local_8 = *(uint **)(param_1[5] - 4);\n  uVar3 = __crt_stdio_output::formatting_buffer::count<char>(this);\n  pfVar4 = (formatting_buffer *)param_1[0x111];\n  if ((formatting_buffer *)param_1[0x111] == (formatting_buffer *)0x0) {\n    pfVar4 = this;\n  }\n  p_Var13 = (__crt_locale_pointers *)param_1[2];\n  iVar5 = (int)*(char *)((int)param_1 + 0x32);\n  uVar12 = param_1[1];\n  uVar11 = *param_1;\n  uVar10 = param_1[10];\n  pcVar6 = __crt_stdio_output::formatting_buffer::scratch_data<char>(this);\n  uVar7 = __crt_stdio_output::formatting_buffer::count<char>(this);\n  ___acrt_fp_format((double *)&local_c,(char *)pfVar4,uVar7,pcVar6,uVar3,iVar5,uVar10,uVar11,uVar12,\n                    p_Var13);\n  if (((param_1[8] >> 5 & 1) != 0) && (param_1[10] == 0)) {\n    __crt_stdio_output::force_decimal_point\n              ((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);\n  }\n  if (((*(short *)((int)param_1 + 0x32) == 0x67) || (*(short *)((int)param_1 + 0x32) == 0x47)) &&\n     ((param_1[8] >> 5 & 1) == 0)) {\n    __crt_stdio_output::crop_zeroes((char *)param_1[0xd],(__crt_locale_pointers *)param_1[2]);\n  }\n  pcVar6 = (char *)param_1[0xd];\n  if (*pcVar6 == '-') {\n    param_1[8] = param_1[8] | 0x40;\n    pcVar6 = pcVar6 + 1;\n    param_1[0xd] = (uint)pcVar6;\n  }\n  pcVar9 = (char *)param_1[0xd];\n  cVar1 = *pcVar9;\n  uVar8 = (undefined3)((uint)pcVar6 >> 8);\n  if (((cVar1 == 'i') || (cVar1 == 'I')) || ((cVar1 == 'n' || (cVar1 == 'N')))) {\n    uVar8 = 0;\n    *(undefined2 *)((int)param_1 + 0x32) = 0x73;\n  }\n  pcVar6 = pcVar9 + 1;\n  do {\n    cVar1 = *pcVar9;\n    pcVar9 = pcVar9 + 1;\n  } while (cVar1 != '\\0');\n  param_1[0xe] = (int)pcVar9 - (int)pcVar6;\n  return CONCAT31(uVar8,1);\n}\n\n"
    },
    {
      "name": "type_case_c_tchar",
      "entry": "0040ce71",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::console_output_adapter<char> > >::type_case_c_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_c_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::type_case_c_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::type_case_c_tchar(char)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_c_tchar(__uint64 *param_1)\n\n{\n  bool bVar1;\n  uint _SizeInBytes;\n  errno_t eVar2;\n  formatting_buffer *pfVar3;\n  formatting_buffer *this;\n  wchar_t _WCh;\n  \n  bVar1 = __crt_stdio_output::is_wide_character_specifier<char>\n                    (*param_1,*(char *)((int)param_1 + 0x31),\n                     *(length_modifier *)((int)param_1 + 0x2c));\n  this = (formatting_buffer *)(param_1 + 8);\n  if (bVar1) {\n    *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n    _WCh = *(wchar_t *)(*(int *)((int)param_1 + 0x14) + -4);\n    pfVar3 = *(formatting_buffer **)((int)param_1 + 0x444);\n    if (*(formatting_buffer **)((int)param_1 + 0x444) == (formatting_buffer *)0x0) {\n      pfVar3 = this;\n    }\n    _SizeInBytes = __crt_stdio_output::formatting_buffer::count<char>(this);\n    eVar2 = _wctomb_s((int *)(param_1 + 7),(char *)pfVar3,_SizeInBytes,_WCh);\n    if (eVar2 != 0) {\n      *(undefined1 *)(param_1 + 6) = 1;\n    }\n  }\n  else {\n    pfVar3 = *(formatting_buffer **)((int)param_1 + 0x444);\n    if (*(formatting_buffer **)((int)param_1 + 0x444) == (formatting_buffer *)0x0) {\n      pfVar3 = this;\n    }\n    *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n    *pfVar3 = *(formatting_buffer *)(*(int *)((int)param_1 + 0x14) + -4);\n    *(undefined4 *)(param_1 + 7) = 1;\n  }\n  pfVar3 = *(formatting_buffer **)((int)param_1 + 0x444);\n  if (pfVar3 != (formatting_buffer *)0x0) {\n    this = pfVar3;\n  }\n  *(formatting_buffer **)((int)param_1 + 0x34) = this;\n  return CONCAT31((int3)((uint)pfVar3 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_c_tchar",
      "entry": "0040cf01",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_c_tchar(wchar_t)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_c_tchar(wchar_t)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_c_tchar(wchar_t)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_c_tchar(wchar_t)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_c_tchar(__uint64 *param_1)\n\n{\n  wchar_t wVar1;\n  bool bVar2;\n  int iVar3;\n  wchar_t *pwVar4;\n  wchar_t *pwVar5;\n  undefined4 local_8;\n  \n  *(undefined1 *)((int)param_1 + 0x3c) = 1;\n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  wVar1 = *(wchar_t *)(*(int *)((int)param_1 + 0x14) + -4);\n  local_8 = param_1;\n  bVar2 = __crt_stdio_output::is_wide_character_specifier<wchar_t>\n                    (*param_1,*(wchar_t *)((int)param_1 + 0x32),\n                     *(length_modifier *)((int)param_1 + 0x2c));\n  pwVar5 = (wchar_t *)(param_1 + 8);\n  if (bVar2) {\n    pwVar4 = *(wchar_t **)((int)param_1 + 0x444);\n    if (*(wchar_t **)((int)param_1 + 0x444) == (wchar_t *)0x0) {\n      pwVar4 = pwVar5;\n    }\n    *pwVar4 = wVar1;\n  }\n  else {\n    local_8._0_2_ = CONCAT11(bVar2,(char)wVar1);\n    pwVar4 = *(wchar_t **)((int)param_1 + 0x444);\n    if (*(wchar_t **)((int)param_1 + 0x444) == (wchar_t *)0x0) {\n      pwVar4 = pwVar5;\n    }\n    iVar3 = __mbtowc_l(pwVar4,(char *)&local_8,(*(_locale_t *)(param_1 + 1))->locinfo->lc_codepage,\n                       *(_locale_t *)(param_1 + 1));\n    if (iVar3 < 0) {\n      *(undefined1 *)(param_1 + 6) = 1;\n    }\n  }\n  pwVar4 = *(wchar_t **)((int)param_1 + 0x444);\n  if (pwVar4 != (wchar_t *)0x0) {\n    pwVar5 = pwVar4;\n  }\n  *(wchar_t **)((int)param_1 + 0x34) = pwVar5;\n  *(undefined4 *)(param_1 + 7) = 1;\n  return CONCAT31((int3)((uint)pwVar4 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_integer",
      "entry": "0040cf99",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_integer(unsigned int,bool)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_integer(unsigned int,bool)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_integer(unsigned int,bool)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_integer(unsigned int,bool)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nuint __thiscall type_case_integer(void *this,uint param_1,char param_2)\n\n{\n  uint uVar1;\n  int *piVar2;\n  char *pcVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  \n  uVar1 = __crt_stdio_output::to_integer_size(*(length_modifier *)((int)this + 0x2c));\n  if (uVar1 == 1) {\n    *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 4;\n    if ((*(uint *)((int)this + 0x20) >> 4 & 1) == 0) {\n      uVar4 = (uint)*(byte *)(*(int *)((int)this + 0x14) + -4);\n    }\n    else {\n      uVar4 = (uint)*(char *)(*(int *)((int)this + 0x14) + -4);\n    }\n  }\n  else if (uVar1 == 2) {\n    *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 4;\n    if ((*(uint *)((int)this + 0x20) >> 4 & 1) == 0) {\n      uVar4 = (uint)*(ushort *)(*(int *)((int)this + 0x14) + -4);\n    }\n    else {\n      uVar4 = (uint)*(short *)(*(int *)((int)this + 0x14) + -4);\n    }\n  }\n  else {\n    if (uVar1 != 4) {\n      if (uVar1 != 8) {\n        piVar2 = __errno();\n        *piVar2 = 0x16;\n        uVar1 = FUN_00412362();\n        return uVar1 & 0xffffff00;\n      }\n      *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 8;\n      uVar4 = *(uint *)(*(int *)((int)this + 0x14) + -8);\n      iVar5 = *(int *)(*(int *)((int)this + 0x14) + -4);\n      goto LAB_0040d04a;\n    }\n    *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 4;\n    if ((*(uint *)((int)this + 0x20) >> 4 & 1) == 0) {\n      uVar4 = *(uint *)(*(int *)((int)this + 0x14) + -4);\n      iVar5 = 0;\n      goto LAB_0040d04a;\n    }\n    uVar4 = *(uint *)(*(int *)((int)this + 0x14) + -4);\n  }\n  iVar5 = (int)uVar4 >> 0x1f;\nLAB_0040d04a:\n  if ((((*(uint *)((int)this + 0x20) >> 4 & 1) != 0) && (iVar5 < 1)) && (iVar5 < 0)) {\n    bVar6 = uVar4 != 0;\n    uVar4 = -uVar4;\n    iVar5 = -(iVar5 + (uint)bVar6);\n    *(uint *)((int)this + 0x20) = *(uint *)((int)this + 0x20) | 0x40;\n  }\n  if (*(int *)((int)this + 0x28) < 0) {\n    *(undefined4 *)((int)this + 0x28) = 1;\n  }\n  else {\n    *(uint *)((int)this + 0x20) = *(uint *)((int)this + 0x20) & 0xfffffff7;\n    if (0x200 < *(int *)((int)this + 0x28)) {\n      *(undefined4 *)((int)this + 0x28) = 0x200;\n    }\n  }\n  if (uVar4 == 0 && iVar5 == 0) {\n    *(uint *)((int)this + 0x20) = *(uint *)((int)this + 0x20) & 0xffffffdf;\n  }\n  if (uVar1 == 8) {\n    type_case_integer_parse_into_buffer<>(this,CONCAT44(iVar5,uVar4),param_1,param_2);\n  }\n  else {\n    type_case_integer_parse_into_buffer<>(this,uVar4,param_1,param_2);\n  }\n  pcVar3 = (char *)(*(uint *)((int)this + 0x20) >> 7);\n  if ((((uint)pcVar3 & 1) != 0) &&\n     ((*(int *)((int)this + 0x38) == 0 || (pcVar3 = *(char **)((int)this + 0x34), *pcVar3 != '0'))))\n  {\n    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + -1;\n    **(undefined1 **)((int)this + 0x34) = 0x30;\n    *(int *)((int)this + 0x38) = *(int *)((int)this + 0x38) + 1;\n  }\n  return CONCAT31((int3)((uint)pcVar3 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_n",
      "entry": "0040d0e3",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_n(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_n(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_n(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_n(void)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nuint __fastcall type_case_n(int param_1)\n\n{\n  uint *puVar1;\n  int iVar2;\n  int *piVar3;\n  uint uVar4;\n  \n  *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + 4;\n  puVar1 = *(uint **)(*(int *)(param_1 + 0x14) + -4);\n  iVar2 = __get_printf_count_output();\n  if (iVar2 == 0) {\nLAB_0040d0fc:\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    uVar4 = FUN_00412362();\n    uVar4 = uVar4 & 0xffffff00;\n  }\n  else {\n    uVar4 = __crt_stdio_output::to_integer_size(*(length_modifier *)(param_1 + 0x2c));\n    if (uVar4 == 1) {\n      uVar4 = 0;\n      *(undefined1 *)puVar1 = *(undefined1 *)(param_1 + 0x18);\n    }\n    else if (uVar4 == 2) {\n      uVar4 = (uint)*(ushort *)(param_1 + 0x18);\n      *(ushort *)puVar1 = *(ushort *)(param_1 + 0x18);\n    }\n    else if (uVar4 == 4) {\n      uVar4 = *(uint *)(param_1 + 0x18);\n      *puVar1 = uVar4;\n    }\n    else {\n      if (uVar4 != 8) goto LAB_0040d0fc;\n      uVar4 = *(uint *)(param_1 + 0x18);\n      *puVar1 = uVar4;\n      puVar1[1] = (int)uVar4 >> 0x1f;\n    }\n    *(undefined1 *)(param_1 + 0x30) = 1;\n    uVar4 = CONCAT31((int3)(uVar4 >> 8),1);\n  }\n  return uVar4;\n}\n\n"
    },
    {
      "name": "type_case_o",
      "entry": "0040d157",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_o(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_o(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_o(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_o(void)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __fastcall type_case_o(void *param_1)\n\n{\n  if ((*(uint *)((int)param_1 + 0x20) >> 5 & 1) != 0) {\n    *(uint *)((int)param_1 + 0x20) = *(uint *)((int)param_1 + 0x20) | 0x80;\n  }\n  type_case_integer(param_1,8,'\\0');\n  return;\n}\n\n"
    },
    {
      "name": "type_case_p",
      "entry": "0040d176",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_p(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_p(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_p(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_p(void)\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __fastcall type_case_p(void *param_1)\n\n{\n  *(undefined4 *)((int)param_1 + 0x28) = 8;\n  *(undefined4 *)((int)param_1 + 0x2c) = 10;\n  type_case_integer(param_1,0x10,'\\x01');\n  return;\n}\n\n"
    },
    {
      "name": "type_case_s",
      "entry": "0040d18e",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::console_output_adapter<char> > >::type_case_s(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::console_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::console_output_adapter<char> >\n   >::type_case_s(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::type_case_s(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::type_case_s(void)\n     6 names - too many to list\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_s(__uint64 *param_1)\n\n{\n  int iVar1;\n  bool bVar2;\n  uint uVar3;\n  \n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  uVar3 = (uint)param_1[5];\n  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);\n  *(int *)((int)param_1 + 0x34) = iVar1;\n  if (uVar3 == 0xffffffff) {\n    uVar3 = 0x7fffffff;\n  }\n  bVar2 = __crt_stdio_output::is_wide_character_specifier<char>\n                    (*param_1,*(char *)((int)param_1 + 0x31),\n                     *(length_modifier *)((int)param_1 + 0x2c));\n  if (bVar2) {\n    if (iVar1 == 0) {\n      *(wchar_t **)((int)param_1 + 0x34) = L\"(null)\";\n    }\n    *(undefined1 *)((int)param_1 + 0x3c) = 1;\n    uVar3 = FUN_00409bff(*(short **)((int)param_1 + 0x34),uVar3);\n  }\n  else {\n    if (iVar1 == 0) {\n      *(char **)((int)param_1 + 0x34) = \"(null)\";\n    }\n    uVar3 = FUN_00409ad8(*(char **)((int)param_1 + 0x34),uVar3);\n  }\n  *(uint *)(param_1 + 7) = uVar3;\n  return CONCAT31((int3)(uVar3 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_s",
      "entry": "0040d201",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_s(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> > >::type_case_s(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_s(void)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> > >::type_case_s(void)\n     6 names - too many to list\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nundefined4 __fastcall type_case_s(__uint64 *param_1)\n\n{\n  int iVar1;\n  bool bVar2;\n  uint uVar3;\n  \n  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 4;\n  uVar3 = (uint)param_1[5];\n  iVar1 = *(int *)(*(int *)((int)param_1 + 0x14) + -4);\n  *(int *)((int)param_1 + 0x34) = iVar1;\n  if (uVar3 == 0xffffffff) {\n    uVar3 = 0x7fffffff;\n  }\n  bVar2 = __crt_stdio_output::is_wide_character_specifier<wchar_t>\n                    (*param_1,*(wchar_t *)((int)param_1 + 0x32),\n                     *(length_modifier *)((int)param_1 + 0x2c));\n  if (bVar2) {\n    if (iVar1 == 0) {\n      *(wchar_t **)((int)param_1 + 0x34) = L\"(null)\";\n    }\n    *(undefined1 *)((int)param_1 + 0x3c) = 1;\n    uVar3 = FUN_00409bff(*(short **)((int)param_1 + 0x34),uVar3);\n  }\n  else {\n    if (iVar1 == 0) {\n      *(char **)((int)param_1 + 0x34) = \"(null)\";\n    }\n    uVar3 = type_case_s_compute_narrow_string_length(param_1,uVar3);\n  }\n  *(uint *)(param_1 + 7) = uVar3;\n  return CONCAT31((int3)(uVar3 >> 8),1);\n}\n\n"
    },
    {
      "name": "type_case_s_compute_narrow_string_length",
      "entry": "0040d275",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> >\n   >::type_case_s_compute_narrow_string_length(int,wchar_t)const \n    private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::console_output_adapter<wchar_t> >\n   >::type_case_s_compute_narrow_string_length(int,wchar_t)const \n    private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> >\n   >::type_case_s_compute_narrow_string_length(int,wchar_t)const \n    private: int __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::stream_output_adapter<wchar_t> >\n   >::type_case_s_compute_narrow_string_length(int,wchar_t)const \n     6 names - too many to list\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nint __thiscall type_case_s_compute_narrow_string_length(void *this,int param_1)\n\n{\n  byte *pbVar1;\n  int iVar2;\n  \n  iVar2 = 0;\n  pbVar1 = *(byte **)((int)this + 0x34);\n  if (0 < param_1) {\n    do {\n      if (*pbVar1 == 0) {\n        return iVar2;\n      }\n      if ((*(ushort *)(*(int *)**(undefined4 **)((int)this + 8) + (uint)*pbVar1 * 2) & 0x8000) != 0)\n      {\n        pbVar1 = pbVar1 + 1;\n      }\n      pbVar1 = pbVar1 + 1;\n      iVar2 = iVar2 + 1;\n    } while (iVar2 < param_1);\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "validate",
      "entry": "0040d2b5",
      "c": "\n/* Library Function - Single Match\n    public: bool __thiscall __crt_stdio_output::stream_output_adapter<char>::validate(void)const \n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_stdio_output::stream_output_adapter<char>::validate(stream_output_adapter<char> *this)\n\n{\n  bool bVar1;\n  int *piVar2;\n  \n  if (*(_iobuf **)this == (_iobuf *)0x0) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    return false;\n  }\n  bVar1 = __acrt_stdio_char_traits<char>::validate_stream_is_ansi_if_required(*(_iobuf **)this);\n  return bVar1;\n}\n\n"
    },
    {
      "name": "validate",
      "entry": "0040d2d6",
      "c": "\n/* Library Function - Single Match\n    public: bool __thiscall __crt_strtox::c_string_character_source<wchar_t>::validate(void)const \n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_strtox::c_string_character_source<wchar_t>::validate(c_string_character_source<wchar_t> *this)\n\n{\n  int *piVar1;\n  \n  if (*(int *)this == 0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return false;\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "validate_stream_is_ansi_if_required",
      "entry": "0040d2f1",
      "c": "\n/* Library Function - Single Match\n    public: static bool __cdecl\n   __acrt_stdio_char_traits<char>::validate_stream_is_ansi_if_required(struct _iobuf * const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __acrt_stdio_char_traits<char>::validate_stream_is_ansi_if_required(_iobuf *param_1)\n\n{\n  bool bVar1;\n  uint uVar2;\n  undefined *puVar3;\n  int *piVar4;\n  undefined *puVar5;\n  \n  if (((uint)param_1->_flag >> 0xc & 1) == 0) {\n    uVar2 = __fileno(param_1);\n    puVar5 = &DAT_0042d210;\n    if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {\n      puVar3 = &DAT_0042d210;\n    }\n    else {\n      puVar3 = (undefined *)((uVar2 & 0x3f) * 0x30 + (&DAT_0043b110)[(int)uVar2 >> 6]);\n    }\n    if (puVar3[0x29] == '\\0') {\n      if ((uVar2 != 0xffffffff) && (uVar2 != 0xfffffffe)) {\n        puVar5 = (undefined *)((uVar2 & 0x3f) * 0x30 + (&DAT_0043b110)[(int)uVar2 >> 6]);\n      }\n      if ((puVar5[0x2d] & 1) == 0) goto LAB_0040d36e;\n    }\n    piVar4 = __errno();\n    *piVar4 = 0x16;\n    FUN_00412362();\n    bVar1 = false;\n  }\n  else {\nLAB_0040d36e:\n    bVar1 = true;\n  }\n  return bVar1;\n}\n\n"
    },
    {
      "name": "write_character",
      "entry": "0040d373",
      "c": "\n/* Library Function - Single Match\n    public: void __thiscall\n   __crt_stdio_output::stream_output_adapter<char>::write_character(char,int * const)const \n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n__crt_stdio_output::stream_output_adapter<char>::write_character\n          (stream_output_adapter<char> *this,char param_1,int *param_2)\n\n{\n  uint uVar1;\n  \n  if ((((*(uint *)(*(int *)this + 0xc) >> 0xc & 1) == 0) || (*(int *)(*(int *)this + 4) != 0)) &&\n     (uVar1 = __fputc_nolock(param_1,*(int **)this), uVar1 == 0xffffffff)) {\n    *param_2 = -1;\n    return;\n  }\n  *param_2 = *param_2 + 1;\n  return;\n}\n\n"
    },
    {
      "name": "write_character",
      "entry": "0040d3b0",
      "c": "\n/* Library Function - Single Match\n    public: bool __thiscall\n   __crt_stdio_output::string_output_adapter<char>::write_character(char,int * const)const \n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_stdio_output::string_output_adapter<char>::write_character\n          (string_output_adapter<char> *this,char param_1,int *param_2)\n\n{\n  int iVar1;\n  undefined1 uVar2;\n  \n  iVar1 = *(int *)this;\n  if (*(int *)(iVar1 + 8) == *(int *)(iVar1 + 4)) {\n    if (*(char *)(iVar1 + 0xc) == '\\0') {\n      *param_2 = -1;\n    }\n    else {\n      *param_2 = *param_2 + 1;\n    }\n    uVar2 = *(undefined1 *)(*(int *)this + 0xc);\n  }\n  else {\n    *param_2 = *param_2 + 1;\n    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + 1;\n    *(char *)**(undefined4 **)this = param_1;\n    **(int **)this = **(int **)this + 1;\n    uVar2 = 1;\n  }\n  return (bool)uVar2;\n}\n\n"
    },
    {
      "name": "write_character",
      "entry": "0040d3f2",
      "c": "\n/* Library Function - Single Match\n    public: bool __thiscall\n   __crt_stdio_output::string_output_adapter<wchar_t>::write_character(wchar_t,int * const)const \n   \n   Library: Visual Studio 2015 Release */\n\nbool __thiscall\n__crt_stdio_output::string_output_adapter<wchar_t>::write_character\n          (string_output_adapter<wchar_t> *this,wchar_t param_1,int *param_2)\n\n{\n  int iVar1;\n  undefined1 uVar2;\n  \n  iVar1 = *(int *)this;\n  if (*(int *)(iVar1 + 8) == *(int *)(iVar1 + 4)) {\n    if (*(char *)(iVar1 + 0xc) == '\\0') {\n      *param_2 = -1;\n    }\n    else {\n      *param_2 = *param_2 + 1;\n    }\n    uVar2 = *(undefined1 *)(*(int *)this + 0xc);\n  }\n  else {\n    *param_2 = *param_2 + 1;\n    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + 1;\n    *(wchar_t *)**(undefined4 **)this = param_1;\n    **(int **)this = **(int **)this + 2;\n    uVar2 = 1;\n  }\n  return (bool)uVar2;\n}\n\n"
    },
    {
      "name": "write_stored_string_tchar",
      "entry": "0040d437",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::stream_output_adapter<char> > >::write_stored_string_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::stream_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::stream_output_adapter<char> >\n   >::write_stored_string_tchar(char)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __fastcall write_stored_string_tchar(int param_1)\n\n{\n  wchar_t _WCh;\n  errno_t eVar1;\n  int iVar2;\n  wchar_t *pwVar3;\n  int local_14;\n  char local_10 [8];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if ((*(char *)(param_1 + 0x3c) == '\\0') || (*(int *)(param_1 + 0x38) < 1)) {\n    __crt_stdio_output::stream_output_adapter<char>::write_string\n              ((stream_output_adapter<char> *)(param_1 + 0x448),*(char **)(param_1 + 0x34),\n               *(int *)(param_1 + 0x38),(int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));\n  }\n  else {\n    pwVar3 = *(wchar_t **)(param_1 + 0x34);\n    iVar2 = 0;\n    if (*(int *)(param_1 + 0x38) != 0) {\n      do {\n        _WCh = *pwVar3;\n        pwVar3 = pwVar3 + 1;\n        local_14 = 0;\n        eVar1 = _wctomb_s(&local_14,local_10,6,_WCh);\n        if ((eVar1 != 0) || (local_14 == 0)) {\n          *(undefined4 *)(param_1 + 0x18) = 0xffffffff;\n          break;\n        }\n        __crt_stdio_output::stream_output_adapter<char>::write_string\n                  ((stream_output_adapter<char> *)(param_1 + 0x448),local_10,local_14,\n                   (int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));\n        iVar2 = iVar2 + 1;\n      } while (iVar2 != *(int *)(param_1 + 0x38));\n    }\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "write_stored_string_tchar",
      "entry": "0040d4de",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::format_validation_base<char,class\n   __crt_stdio_output::string_output_adapter<char> > >::write_stored_string_tchar(char)\n    private: bool __thiscall __crt_stdio_output::output_processor<char,class\n   __crt_stdio_output::string_output_adapter<char>,class\n   __crt_stdio_output::standard_base<char,class __crt_stdio_output::string_output_adapter<char> >\n   >::write_stored_string_tchar(char)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __fastcall write_stored_string_tchar(int param_1)\n\n{\n  wchar_t _WCh;\n  errno_t eVar1;\n  int iVar2;\n  wchar_t *pwVar3;\n  int local_14;\n  char local_10 [8];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if ((*(char *)(param_1 + 0x3c) == '\\0') || (*(int *)(param_1 + 0x38) < 1)) {\n    __crt_stdio_output::string_output_adapter<char>::write_string\n              ((string_output_adapter<char> *)(param_1 + 0x448),*(char **)(param_1 + 0x34),\n               *(int *)(param_1 + 0x38),(int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));\n  }\n  else {\n    pwVar3 = *(wchar_t **)(param_1 + 0x34);\n    iVar2 = 0;\n    if (*(int *)(param_1 + 0x38) != 0) {\n      do {\n        _WCh = *pwVar3;\n        pwVar3 = pwVar3 + 1;\n        local_14 = 0;\n        eVar1 = _wctomb_s(&local_14,local_10,6,_WCh);\n        if ((eVar1 != 0) || (local_14 == 0)) {\n          *(undefined4 *)(param_1 + 0x18) = 0xffffffff;\n          break;\n        }\n        __crt_stdio_output::string_output_adapter<char>::write_string\n                  ((string_output_adapter<char> *)(param_1 + 0x448),local_10,local_14,\n                   (int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));\n        iVar2 = iVar2 + 1;\n      } while (iVar2 != *(int *)(param_1 + 0x38));\n    }\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "write_stored_string_tchar",
      "entry": "0040d585",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::format_validation_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::write_stored_string_tchar(wchar_t)\n    private: bool __thiscall __crt_stdio_output::output_processor<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t>,class\n   __crt_stdio_output::standard_base<wchar_t,class\n   __crt_stdio_output::string_output_adapter<wchar_t> > >::write_stored_string_tchar(wchar_t)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall write_stored_string_tchar(uint param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int extraout_EAX;\n  char *_SrcCh;\n  int iVar3;\n  uint local_8;\n  uint3 extraout_var;\n  \n  local_8 = param_1;\n  if ((*(char *)(param_1 + 0x3c) == '\\0') && (iVar2 = *(int *)(param_1 + 0x38), 0 < iVar2)) {\n    _SrcCh = *(char **)(param_1 + 0x34);\n    iVar3 = 0;\n    if (iVar2 != 0) {\n      do {\n        local_8 = local_8 & 0xffff0000;\n        iVar1 = __mbtowc_l((wchar_t *)&local_8,_SrcCh,\n                           (*(_locale_t *)(param_1 + 8))->locinfo->lc_codepage,\n                           *(_locale_t *)(param_1 + 8));\n        if (iVar1 < 1) {\n          *(undefined4 *)(param_1 + 0x18) = 0xffffffff;\n          iVar2 = iVar1;\n          break;\n        }\n        __crt_stdio_output::string_output_adapter<wchar_t>::write_character\n                  ((string_output_adapter<wchar_t> *)(param_1 + 0x448),(wchar_t)local_8,\n                   (int *)(param_1 + 0x18));\n        iVar2 = (uint)extraout_var << 8;\n        _SrcCh = _SrcCh + iVar1;\n        iVar3 = iVar3 + 1;\n      } while (iVar3 != *(int *)(param_1 + 0x38));\n    }\n  }\n  else {\n    __crt_stdio_output::string_output_adapter<wchar_t>::write_string\n              ((string_output_adapter<wchar_t> *)(param_1 + 0x448),*(wchar_t **)(param_1 + 0x34),\n               *(int *)(param_1 + 0x38),(int *)(param_1 + 0x18),*(int **)(param_1 + 0xc));\n    iVar2 = extraout_EAX;\n  }\n  return CONCAT31((int3)((uint)iVar2 >> 8),1);\n}\n\n"
    },
    {
      "name": "write_string",
      "entry": "0040d610",
      "c": "\n/* Library Function - Single Match\n    public: void __thiscall __crt_stdio_output::stream_output_adapter<char>::write_string(char const\n   * const,int,int * const,int * const)const \n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n__crt_stdio_output::stream_output_adapter<char>::write_string\n          (stream_output_adapter<char> *this,char *param_1,int param_2,int *param_3,int *param_4)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  if (((*(uint *)(*(int *)this + 0xc) >> 0xc & 1) == 0) || (*(int *)(*(int *)this + 4) != 0)) {\n    pcVar2 = param_1 + param_2;\n    iVar1 = *param_4;\n    *param_4 = 0;\n    if (param_1 != pcVar2) {\n      do {\n        write_character(this,*param_1,param_3);\n        if (*param_3 == -1) {\n          if (*param_4 != 0x2a) break;\n          write_character(this,'?',param_3);\n        }\n        param_1 = param_1 + 1;\n      } while (param_1 != pcVar2);\n    }\n    if ((*param_4 == 0) && (iVar1 != 0)) {\n      *param_4 = iVar1;\n    }\n  }\n  else {\n    *param_3 = *param_3 + param_2;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "write_string",
      "entry": "0040d69a",
      "c": "\n/* Library Function - Single Match\n    public: void __thiscall __crt_stdio_output::string_output_adapter<char>::write_string(char const\n   * const,int,int * const,int * const)const \n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n__crt_stdio_output::string_output_adapter<char>::write_string\n          (string_output_adapter<char> *this,char *param_1,int param_2,int *param_3,int *param_4)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  uint uVar3;\n  \n  iVar1 = *param_4;\n  *param_4 = 0;\n  puVar2 = *(undefined4 **)this;\n  if (puVar2[2] == puVar2[1]) {\n    if (*(char *)(puVar2 + 3) == '\\0') {\n      *param_3 = -1;\n    }\n    else {\n      *param_3 = *param_3 + param_2;\n    }\n  }\n  else {\n    uVar3 = puVar2[1] - puVar2[2];\n    if ((uint)param_2 <= uVar3) {\n      uVar3 = param_2;\n    }\n    FUN_00408c90((uint *)*puVar2,(uint *)param_1,uVar3);\n    **(int **)this = **(int **)this + uVar3;\n    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + uVar3;\n    if (*(char *)(*(int *)this + 0xc) == '\\0') {\n      if (uVar3 == param_2) {\n        *param_3 = *param_3 + uVar3;\n      }\n      else {\n        *param_3 = -1;\n      }\n    }\n    else {\n      *param_3 = *param_3 + param_2;\n    }\n  }\n  if ((*param_4 == 0) && (iVar1 != 0)) {\n    *param_4 = iVar1;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "write_string",
      "entry": "0040d72d",
      "c": "\n/* Library Function - Single Match\n    public: void __thiscall __crt_stdio_output::string_output_adapter<wchar_t>::write_string(wchar_t\n   const * const,int,int * const,int * const)const \n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n__crt_stdio_output::string_output_adapter<wchar_t>::write_string\n          (string_output_adapter<wchar_t> *this,wchar_t *param_1,int param_2,int *param_3,\n          int *param_4)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  uint uVar3;\n  \n  iVar1 = *param_4;\n  *param_4 = 0;\n  puVar2 = *(undefined4 **)this;\n  if (puVar2[2] == puVar2[1]) {\n    if (*(char *)(puVar2 + 3) == '\\0') {\n      *param_3 = -1;\n    }\n    else {\n      *param_3 = *param_3 + param_2;\n    }\n  }\n  else {\n    uVar3 = puVar2[1] - puVar2[2];\n    if ((uint)param_2 <= uVar3) {\n      uVar3 = param_2;\n    }\n    FUN_00408c90((uint *)*puVar2,(uint *)param_1,uVar3 * 2);\n    **(int **)this = **(int **)this + uVar3 * 2;\n    *(int *)(*(int *)this + 8) = *(int *)(*(int *)this + 8) + uVar3;\n    if (*(char *)(*(int *)this + 0xc) == '\\0') {\n      if (uVar3 == param_2) {\n        *param_3 = *param_3 + uVar3;\n      }\n      else {\n        *param_3 = -1;\n      }\n    }\n    else {\n      *param_3 = *param_3 + param_2;\n    }\n  }\n  if ((*param_4 == 0) && (iVar1 != 0)) {\n    *param_4 = iVar1;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FID_conflict:___stdio_common_vfprintf",
      "entry": "0040d7c7",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    ___stdio_common_vfprintf\n    ___stdio_common_vfprintf_p\n    ___stdio_common_vfprintf_s\n    ___stdio_common_vfwprintf\n     6 names - too many to list\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl\nFID_conflict____stdio_common_vfprintf\n          (undefined4 param_1,undefined4 param_2,int param_3,int param_4,undefined4 param_5,\n          undefined4 param_6)\n\n{\n  int *piVar1;\n  undefined4 uVar2;\n  int *local_30;\n  undefined4 *local_2c;\n  undefined4 *local_28;\n  int *local_24;\n  undefined4 *local_20;\n  undefined4 local_1c;\n  undefined4 local_18;\n  undefined4 local_14;\n  int local_10;\n  undefined4 local_c;\n  int local_8;\n  \n  local_14 = param_6;\n  local_c = param_5;\n  local_1c = param_1;\n  local_10 = param_4;\n  local_8 = param_3;\n  local_18 = param_2;\n  if ((param_3 == 0) || (param_4 == 0)) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    uVar2 = 0xffffffff;\n  }\n  else {\n    local_30 = &local_8;\n    local_2c = &local_c;\n    local_28 = &local_1c;\n    local_24 = &local_10;\n    local_20 = &local_14;\n    uVar2 = __acrt_lock_stream_and_call<>\n                      (param_3,(<lambda_4f2c1eaeead2a5fc776db5b62ea0fb9b> *)&local_30);\n  }\n  return uVar2;\n}\n\n"
    },
    {
      "name": "___stdio_common_vsprintf",
      "entry": "0040d83e",
      "c": "\n/* Library Function - Single Match\n    ___stdio_common_vsprintf\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___stdio_common_vsprintf\n          (undefined4 param_1,undefined4 param_2,char *param_3,uint param_4,char *param_5,\n          __crt_locale_pointers *param_6,char *param_7)\n\n{\n  common_vsprintf<class___crt_stdio_output::standard_base,char>\n            (CONCAT44(param_2,param_1),param_3,param_4,param_5,param_6,param_7);\n  return;\n}\n\n"
    },
    {
      "name": "___stdio_common_vswprintf",
      "entry": "0040d862",
      "c": "\n/* Library Function - Single Match\n    ___stdio_common_vswprintf\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___stdio_common_vswprintf\n          (undefined4 param_1,undefined4 param_2,wchar_t *param_3,uint param_4,wchar_t *param_5,\n          __crt_locale_pointers *param_6,char *param_7)\n\n{\n  common_vsprintf<class___crt_stdio_output::standard_base,wchar_t>\n            (CONCAT44(param_2,param_1),param_3,param_4,param_5,param_6,param_7);\n  return;\n}\n\n"
    },
    {
      "name": "GetCurrentProcessId",
      "entry": "0040d886",
      "c": "\nDWORD GetCurrentProcessId(void)\n\n{\n  DWORD DVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x0040d886. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  DVar1 = GetCurrentProcessId();\n  return DVar1;\n}\n\n"
    },
    {
      "name": "_strncpy",
      "entry": "0040d890",
      "c": "\n/* Library Function - Single Match\n    _strncpy\n   \n   Library: Visual Studio */\n\nchar * __cdecl _strncpy(char *_Dest,char *_Source,size_t _Count)\n\n{\n  uint uVar1;\n  uint uVar2;\n  char cVar3;\n  uint uVar4;\n  uint *puVar5;\n  \n  if (_Count == 0) {\n    return _Dest;\n  }\n  puVar5 = (uint *)_Dest;\n  if (((uint)_Source & 3) != 0) {\n    while( true ) {\n      uVar4 = *(uint *)_Source;\n      _Source = (char *)((int)_Source + 1);\n      *(char *)puVar5 = (char)uVar4;\n      puVar5 = (uint *)((int)puVar5 + 1);\n      _Count = _Count - 1;\n      if (_Count == 0) {\n        return _Dest;\n      }\n      if ((char)uVar4 == '\\0') break;\n      if (((uint)_Source & 3) == 0) {\n        uVar4 = _Count >> 2;\n        goto joined_r0x0040d8dc;\n      }\n    }\n    do {\n      if (((uint)puVar5 & 3) == 0) {\n        uVar4 = _Count >> 2;\n        cVar3 = '\\0';\n        if (uVar4 == 0) goto LAB_0040d923;\n        goto LAB_0040d999;\n      }\n      *(char *)puVar5 = '\\0';\n      puVar5 = (uint *)((int)puVar5 + 1);\n      _Count = _Count - 1;\n    } while (_Count != 0);\n    return _Dest;\n  }\n  uVar4 = _Count >> 2;\n  if (uVar4 != 0) {\n    do {\n      uVar1 = *(uint *)_Source;\n      uVar2 = *(uint *)_Source;\n      _Source = (char *)((int)_Source + 4);\n      if (((uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff) & 0x81010100) != 0) {\n        if ((char)uVar2 == '\\0') {\n          *puVar5 = 0;\njoined_r0x0040d995:\n          while( true ) {\n            uVar4 = uVar4 - 1;\n            puVar5 = puVar5 + 1;\n            if (uVar4 == 0) break;\nLAB_0040d999:\n            *puVar5 = 0;\n          }\n          cVar3 = '\\0';\n          _Count = _Count & 3;\n          if (_Count != 0) goto LAB_0040d923;\n          return _Dest;\n        }\n        if ((char)(uVar2 >> 8) == '\\0') {\n          *puVar5 = uVar2 & 0xff;\n          goto joined_r0x0040d995;\n        }\n        if ((uVar2 & 0xff0000) == 0) {\n          *puVar5 = uVar2 & 0xffff;\n          goto joined_r0x0040d995;\n        }\n        if ((uVar2 & 0xff000000) == 0) {\n          *puVar5 = uVar2;\n          goto joined_r0x0040d995;\n        }\n      }\n      *puVar5 = uVar2;\n      puVar5 = puVar5 + 1;\n      uVar4 = uVar4 - 1;\njoined_r0x0040d8dc:\n    } while (uVar4 != 0);\n    _Count = _Count & 3;\n    if (_Count == 0) {\n      return _Dest;\n    }\n  }\n  do {\n    cVar3 = (char)*(uint *)_Source;\n    _Source = (char *)((int)_Source + 1);\n    *(char *)puVar5 = cVar3;\n    puVar5 = (uint *)((int)puVar5 + 1);\n    if (cVar3 == '\\0') {\n      while (_Count = _Count - 1, _Count != 0) {\nLAB_0040d923:\n        *(char *)puVar5 = cVar3;\n        puVar5 = (uint *)((int)puVar5 + 1);\n      }\n      return _Dest;\n    }\n    _Count = _Count - 1;\n  } while (_Count != 0);\n  return _Dest;\n}\n\n"
    },
    {
      "name": "_strtok",
      "entry": "0040d9b4",
      "c": "\n/* Library Function - Single Match\n    _strtok\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl _strtok(char *_Str,char *_Delim)\n\n{\n  __acrt_ptd *p_Var1;\n  char *pcVar2;\n  \n  p_Var1 = ___acrt_getptd();\n  pcVar2 = (char *)___acrt_strtok_s_novalidation\n                             ((byte *)_Str,(byte *)_Delim,(undefined4 *)(p_Var1 + 0x1c));\n  return pcVar2;\n}\n\n"
    },
    {
      "name": "common_stat<struct__stat64i32>",
      "entry": "0040d9d2",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_stat<struct _stat64i32>(wchar_t const * const,struct _stat64i32 * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_stat<struct__stat64i32>(wchar_t *param_1,_stat64i32 *param_2)\n\n{\n  bool bVar1;\n  ulong *puVar2;\n  int *piVar3;\n  wchar_t *pwVar4;\n  HANDLE hObject;\n  int iVar5;\n  int iVar6;\n  undefined4 *puVar7;\n  _stat64i32 *p_Var8;\n  undefined4 local_38 [12];\n  HANDLE local_8;\n  \n  if (param_2 == (_stat64i32 *)0x0) {\n    puVar2 = ___doserrno();\n    *puVar2 = 0;\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    iVar6 = 0;\n    _memset(local_38,0,0x30);\n    puVar7 = local_38;\n    p_Var8 = param_2;\n    for (iVar5 = 0xc; iVar5 != 0; iVar5 = iVar5 + -1) {\n      *(undefined4 *)p_Var8 = *puVar7;\n      puVar7 = puVar7 + 1;\n      p_Var8 = p_Var8 + 4;\n    }\n    if (param_1 == (wchar_t *)0x0) {\n      puVar2 = ___doserrno();\n      *puVar2 = 0;\n      piVar3 = __errno();\n      *piVar3 = 0x16;\n      FUN_00412362();\n    }\n    else {\n      pwVar4 = _wcspbrk(param_1,L\"?*\");\n      if (pwVar4 == (wchar_t *)0x0) {\n        hObject = CreateFileW(param_1,0x80,7,(LPSECURITY_ATTRIBUTES)0x0,3,0x2000000,(HANDLE)0x0);\n        local_8 = hObject;\n        if (hObject == (HANDLE)0xffffffff) {\n          bVar1 = common_stat_handle_file_not_opened<struct__stat64i32>(param_1,param_2);\n        }\n        else {\n          bVar1 = common_stat_handle_file_opened<struct__stat64i32>(param_1,-1,hObject,param_2);\n        }\n        if (bVar1 == false) {\n          _memset(local_38,0,0x30);\n          iVar6 = -1;\n          puVar7 = local_38;\n          for (iVar5 = 0xc; hObject = local_8, iVar5 != 0; iVar5 = iVar5 + -1) {\n            *(undefined4 *)param_2 = *puVar7;\n            puVar7 = puVar7 + 1;\n            param_2 = param_2 + 4;\n          }\n        }\n        if (hObject != (HANDLE)0xffffffff) {\n          CloseHandle(hObject);\n          return iVar6;\n        }\n        return iVar6;\n      }\n      piVar3 = __errno();\n      *piVar3 = 2;\n      puVar2 = ___doserrno();\n      *puVar2 = 2;\n    }\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "common_stat_handle_file_not_opened<struct__stat64i32>",
      "entry": "0040dad9",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl common_stat_handle_file_not_opened<struct _stat64i32>(wchar_t const * const,struct\n   _stat64i32 &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl\ncommon_stat_handle_file_not_opened<struct__stat64i32>(wchar_t *param_1,_stat64i32 *param_2)\n\n{\n  bool bVar1;\n  ushort uVar2;\n  __int64 _Var3;\n  int local_8;\n  \n  bVar1 = is_usable_drive_or_unc_root(param_1);\n  if (bVar1) {\n    uVar2 = convert_to_stat_mode(0x10,param_1);\n    local_8 = 0;\n    *(ushort *)(param_2 + 6) = uVar2;\n    *(undefined2 *)(param_2 + 8) = 1;\n    bVar1 = get_drive_number_from_path(param_1,&local_8);\n    if (bVar1) {\n      *(int *)(param_2 + 0x10) = local_8 + -1;\n      *(int *)param_2 = local_8 + -1;\n      _Var3 = FUN_00416365(0x7bc,1,1,0,0,0,-1);\n      *(__int64 *)(param_2 + 0x20) = _Var3;\n      bVar1 = true;\n      *(__int64 *)(param_2 + 0x18) = _Var3;\n      *(__int64 *)(param_2 + 0x28) = _Var3;\n    }\n  }\n  else {\n    ___acrt_errno_map_os_error(2);\n    bVar1 = false;\n  }\n  return bVar1;\n}\n\n"
    },
    {
      "name": "common_stat_handle_file_opened<struct__stat64i32>",
      "entry": "0040db65",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl common_stat_handle_file_opened<struct _stat64i32>(wchar_t const * const,int,void *\n   const,struct _stat64i32 &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl\ncommon_stat_handle_file_opened<struct__stat64i32>\n          (wchar_t *param_1,int param_2,void *param_3,_stat64i32 *param_4)\n\n{\n  _LARGE_INTEGER _Var1;\n  _LARGE_INTEGER _Var2;\n  _LARGE_INTEGER _Var3;\n  bool bVar4;\n  undefined1 uVar5;\n  ushort uVar6;\n  DWORD DVar7;\n  int *piVar8;\n  BOOL BVar9;\n  uint uVar10;\n  int iVar11;\n  undefined4 *puVar12;\n  __int64 _Var13;\n  int local_54;\n  wchar_t *local_50;\n  void *local_4c;\n  undefined4 local_48 [2];\n  _LARGE_INTEGER local_40 [2];\n  undefined4 local_30 [4];\n  undefined4 local_20;\n  undefined4 local_1c;\n  int local_10;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_50 = param_1;\n  local_4c = param_3;\n  DVar7 = GetFileType(param_3);\n  uVar10 = DVar7 & 0xffff7fff;\n  if (uVar10 == 1) {\n    *(undefined2 *)(param_4 + 8) = 1;\n    if (local_50 != (wchar_t *)0x0) {\n      local_54 = 0;\n      bVar4 = get_drive_number_from_path(local_50,&local_54);\n      if (!bVar4) goto LAB_0040dd0c;\n      *(int *)(param_4 + 0x10) = local_54 + -1;\n      *(int *)param_4 = local_54 + -1;\n    }\n    puVar12 = local_30;\n    for (iVar11 = 10; iVar11 != 0; iVar11 = iVar11 + -1) {\n      *puVar12 = 0;\n      puVar12 = puVar12 + 1;\n    }\n    iVar11 = ___acrt_GetFileInformationByHandleEx_16(local_4c,0,local_30,0x28);\n    if (iVar11 != 0) {\n      uVar6 = convert_to_stat_mode(local_10,local_50);\n      *(ushort *)(param_4 + 6) = uVar6;\n      _Var1.s.HighPart = local_1c;\n      _Var1.s.LowPart = local_20;\n      _Var13 = convert_large_integer_time_to_time_t<__int64>(_Var1,0);\n      *(__int64 *)(param_4 + 0x20) = _Var13;\n      if (_Var13 == -1) goto LAB_0040dd0c;\n      _Var2.s.HighPart = local_30[3];\n      _Var2.s.LowPart = local_30[2];\n      _Var13 = convert_large_integer_time_to_time_t<__int64>\n                         (_Var2,CONCAT44((int)((ulonglong)_Var13 >> 0x20),\n                                         *(undefined4 *)(param_4 + 0x20)));\n      *(__int64 *)(param_4 + 0x18) = _Var13;\n      if (_Var13 == -1) goto LAB_0040dd0c;\n      _Var3.s.HighPart = local_30[1];\n      _Var3.s.LowPart = local_30[0];\n      _Var13 = convert_large_integer_time_to_time_t<__int64>(_Var3,*(__int64 *)(param_4 + 0x20));\n      *(__int64 *)(param_4 + 0x28) = _Var13;\n      if (_Var13 == -1) goto LAB_0040dd0c;\n      puVar12 = local_48;\n      for (iVar11 = 6; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n      }\n      iVar11 = ___acrt_GetFileInformationByHandleEx_16(local_4c,1,local_48,0x18);\n      if (iVar11 != 0) {\n        compute_size(local_40,(long *)(param_4 + 0x14));\n        goto LAB_0040dd0c;\n      }\n    }\n  }\n  else {\n    if ((uVar10 == 2) || (uVar10 == 3)) {\n      *(ushort *)(param_4 + 6) = ((uVar10 != 2) - 1 & 0x1000) + 0x1000;\n      *(undefined2 *)(param_4 + 8) = 1;\n      *(int *)(param_4 + 0x10) = param_2;\n      *(int *)param_4 = param_2;\n      if ((uVar10 != 2) &&\n         (BVar9 = PeekNamedPipe(param_3,(LPVOID)0x0,0,(LPDWORD)0x0,(LPDWORD)&local_4c,(LPDWORD)0x0),\n         BVar9 != 0)) {\n        *(void **)(param_4 + 0x14) = local_4c;\n      }\n      goto LAB_0040dd0c;\n    }\n    if (uVar10 == 0) {\n      piVar8 = __errno();\n      *piVar8 = 9;\n      goto LAB_0040dd0c;\n    }\n  }\n  DVar7 = GetLastError();\n  ___acrt_errno_map_os_error(DVar7);\nLAB_0040dd0c:\n  uVar5 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return (bool)uVar5;\n}\n\n"
    },
    {
      "name": "convert_large_integer_time_to_time_t<__int64>",
      "entry": "0040dd1d",
      "c": "\n/* Library Function - Single Match\n    __int64 __cdecl convert_large_integer_time_to_time_t<__int64>(union _LARGE_INTEGER,__int64)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl\nconvert_large_integer_time_to_time_t<__int64>(_LARGE_INTEGER param_1,__int64 param_2)\n\n{\n  BOOL BVar1;\n  int *piVar2;\n  DWORD DVar3;\n  __int64 _Var4;\n  int local_2c;\n  _SYSTEMTIME local_28;\n  _SYSTEMTIME local_18;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if ((param_1.s.LowPart != 0) || (param_1.s.HighPart != 0)) {\n    BVar1 = FileTimeToSystemTime((FILETIME *)&param_1.s,&local_28);\n    if ((BVar1 == 0) ||\n       (BVar1 = SystemTimeToTzSpecificLocalTime((TIME_ZONE_INFORMATION *)0x0,&local_28,&local_18),\n       BVar1 == 0)) {\n      DVar3 = GetLastError();\n      ___acrt_errno_map_os_error(DVar3);\n    }\n    else {\n      local_2c = -1;\n      _Var4 = __crt_integer_traits<__int64>::\n              loctotime<unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,int>\n                        (&local_18.wYear,&local_18.wMonth,&local_18.wDay,&local_18.wHour,\n                         &local_18.wMinute,&local_18.wSecond,&local_2c);\n      if (_Var4 == -1) {\n        piVar2 = __errno();\n        *piVar2 = 0x84;\n      }\n    }\n  }\n  _Var4 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return _Var4;\n}\n\n"
    },
    {
      "name": "loctotime<unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,int>",
      "entry": "0040ddc7",
      "c": "\n/* Library Function - Single Match\n    public: static __int64 __cdecl __crt_integer_traits<__int64>::loctotime<unsigned short\n   &,unsigned short &,unsigned short &,unsigned short &,unsigned short &,unsigned short\n   &,int>(unsigned short &,unsigned short &,unsigned short &,unsigned short &,unsigned short\n   &,unsigned short &,int &&)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl\n__crt_integer_traits<__int64>::\nloctotime<unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,unsigned_short&,int>\n          (ushort *param_1,ushort *param_2,ushort *param_3,ushort *param_4,ushort *param_5,\n          ushort *param_6,int *param_7)\n\n{\n  __int64 _Var1;\n  \n  _Var1 = FUN_00416365((uint)*param_1,(uint)*param_2,(uint)*param_3,(uint)*param_4,(uint)*param_5,\n                       (uint)*param_6,*param_7);\n  return _Var1;\n}\n\n"
    },
    {
      "name": "call_wfullpath",
      "entry": "0040de05",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl call_wfullpath(wchar_t * const,wchar_t const * const,unsigned int,wchar_t * *\n   const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl call_wfullpath(wchar_t *param_1,wchar_t *param_2,uint param_3,wchar_t **param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  wchar_t *pwVar3;\n  \n  piVar2 = __errno();\n  iVar1 = *piVar2;\n  piVar2 = __errno();\n  *piVar2 = 0;\n  pwVar3 = __wfullpath(param_1,param_2,param_3);\n  piVar2 = __errno();\n  if (pwVar3 == (wchar_t *)0x0) {\n    if (*piVar2 == 0x22) {\n      piVar2 = __errno();\n      *piVar2 = iVar1;\n      pwVar3 = __wfullpath((wchar_t *)0x0,param_2,0);\n      *param_4 = pwVar3;\n    }\n    else {\n      pwVar3 = (wchar_t *)0x0;\n    }\n  }\n  else {\n    *piVar2 = iVar1;\n  }\n  return pwVar3;\n}\n\n"
    },
    {
      "name": "compute_size",
      "entry": "0040de65",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl compute_size(union _LARGE_INTEGER const &,long &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl compute_size(_LARGE_INTEGER *param_1,long *param_2)\n\n{\n  int *piVar1;\n  \n  *param_2 = 0;\n  if (((param_1->s).HighPart == 0) && ((param_1->s).LowPart < 0x80000000)) {\n    *param_2 = (param_1->s).LowPart;\n    return true;\n  }\n  piVar1 = __errno();\n  *piVar1 = 0x84;\n  return false;\n}\n\n"
    },
    {
      "name": "convert_to_stat_mode",
      "entry": "0040de97",
      "c": "\n/* Library Function - Single Match\n    unsigned short __cdecl convert_to_stat_mode(int,wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nushort __cdecl convert_to_stat_mode(int param_1,wchar_t *param_2)\n\n{\n  bool bVar1;\n  uint uVar2;\n  \n  if (((byte)param_1 >> 4 & 1) == 0) {\n    bVar1 = is_root_or_empty(param_2);\n    uVar2 = 0x8000;\n    if (!bVar1) goto LAB_0040dec2;\n  }\n  uVar2 = 0x4040;\nLAB_0040dec2:\n  uVar2 = uVar2 | ~((param_1 & 0xffU) << 7) & 0x80 | 0x100;\n  bVar1 = has_executable_extension(param_2);\n  if (bVar1) {\n    uVar2 = uVar2 | 0x40;\n  }\n  return (ushort)(uVar2 >> 6) & 7 | (ushort)uVar2 | (ushort)(uVar2 >> 3) & 0x38;\n}\n\n"
    },
    {
      "name": "get_drive_number_from_path",
      "entry": "0040defd",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl get_drive_number_from_path(wchar_t const * const,int &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl get_drive_number_from_path(wchar_t *param_1,int *param_2)\n\n{\n  wchar_t wVar1;\n  uint uVar2;\n  int iVar3;\n  \n  *param_2 = 0;\n  wVar1 = *param_1;\n  uVar2 = (uint)(ushort)wVar1;\n  if (((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) ||\n     ((0x60 < (ushort)wVar1 && (uVar2 < 0x7b)))) {\n    if (param_1[1] == L':') {\n      if (param_1[2] == L'\\0') {\n        ___acrt_errno_map_os_error(2);\n        return false;\n      }\n      if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {\n        uVar2 = uVar2 + 0x20;\n      }\n      *param_2 = uVar2 - 0x60;\n    }\n    iVar3 = __getdrive();\n    *param_2 = iVar3;\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "has_executable_extension",
      "entry": "0040df6a",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl has_executable_extension(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl has_executable_extension(wchar_t *param_1)\n\n{\n  bool bVar1;\n  undefined1 (*_Str1) [16];\n  int iVar2;\n  \n  if (param_1 == (wchar_t *)0x0) {\n    return false;\n  }\n  _Str1 = FUN_00420225((undefined1 (*) [16])param_1,0x2e);\n  if (_Str1 == (undefined1 (*) [16])0x0) {\nLAB_0040dfd0:\n    bVar1 = false;\n  }\n  else {\n    iVar2 = __wcsicmp((wchar_t *)_Str1,L\".exe\");\n    if (iVar2 != 0) {\n      iVar2 = __wcsicmp((wchar_t *)_Str1,L\".cmd\");\n      if (iVar2 != 0) {\n        iVar2 = __wcsicmp((wchar_t *)_Str1,L\".bat\");\n        if (iVar2 != 0) {\n          iVar2 = __wcsicmp((wchar_t *)_Str1,L\".com\");\n          if (iVar2 != 0) goto LAB_0040dfd0;\n        }\n      }\n    }\n    bVar1 = true;\n  }\n  return bVar1;\n}\n\n"
    },
    {
      "name": "is_root_or_empty",
      "entry": "0040dfd9",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl is_root_or_empty(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl is_root_or_empty(wchar_t *param_1)\n\n{\n  wchar_t wVar1;\n  bool bVar2;\n  int extraout_ECX;\n  \n  if (param_1 == (wchar_t *)0x0) {\n    return false;\n  }\n  wVar1 = *param_1;\n  if ((((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) ||\n      ((0x60 < (ushort)wVar1 && ((ushort)wVar1 < 0x7b)))) && (param_1[1] == L':')) {\n    param_1 = param_1 + 2;\n  }\n  if (*param_1 != L'\\0') {\n    bVar2 = is_slash(*param_1);\n    if (!bVar2) {\n      return false;\n    }\n    if (*(short *)(extraout_ECX + 2) != 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "is_root_unc_name",
      "entry": "0040e030",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl is_root_unc_name(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl is_root_unc_name(wchar_t *param_1)\n\n{\n  wchar_t wVar1;\n  bool bVar2;\n  wchar_t *extraout_ECX;\n  wchar_t *extraout_ECX_00;\n  wchar_t *pwVar3;\n  int extraout_EDX;\n  int extraout_EDX_00;\n  int extraout_EDX_01;\n  \n  pwVar3 = param_1;\n  do {\n    wVar1 = *pwVar3;\n    pwVar3 = pwVar3 + 1;\n  } while (wVar1 != L'\\0');\n  if ((((4 < (uint)((int)pwVar3 - (int)(param_1 + 1) >> 1)) && (bVar2 = is_slash(*param_1), bVar2))\n      && (bVar2 = is_slash(*(wchar_t *)(extraout_EDX + 2)), bVar2)) &&\n     ((bVar2 = is_slash(*(wchar_t *)(extraout_EDX_00 + 4)), !bVar2 &&\n      (wVar1 = *(wchar_t *)(extraout_EDX_01 + 6), wVar1 != L'\\0')))) {\n    do {\n      bVar2 = is_slash(wVar1);\n      pwVar3 = extraout_ECX;\n      if (bVar2) break;\n      pwVar3 = extraout_ECX + 1;\n      wVar1 = *pwVar3;\n    } while (wVar1 != L'\\0');\n    if ((*pwVar3 != L'\\0') && (pwVar3[1] != L'\\0')) {\n      wVar1 = pwVar3[1];\n      if (wVar1 != L'\\0') {\n        do {\n          bVar2 = is_slash(wVar1);\n          pwVar3 = extraout_ECX_00;\n          if (bVar2) break;\n          pwVar3 = extraout_ECX_00 + 1;\n          wVar1 = *pwVar3;\n        } while (wVar1 != L'\\0');\n        if ((*pwVar3 != L'\\0') && (pwVar3[1] != L'\\0')) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n"
    },
    {
      "name": "is_slash",
      "entry": "0040e0f4",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl is_slash(wchar_t)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl is_slash(wchar_t param_1)\n\n{\n  if ((param_1 != L'\\\\') && (param_1 != L'/')) {\n    return false;\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "is_usable_drive_or_unc_root",
      "entry": "0040e110",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl is_usable_drive_or_unc_root(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl is_usable_drive_or_unc_root(wchar_t *param_1)\n\n{\n  wchar_t wVar1;\n  bool bVar2;\n  undefined1 uVar3;\n  wchar_t *pwVar4;\n  wchar_t *pwVar5;\n  wchar_t *local_214;\n  wchar_t local_210 [260];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pwVar4 = _wcspbrk(param_1,L\"./\\\\\");\n  if (pwVar4 != (wchar_t *)0x0) {\n    local_214 = (wchar_t *)0x0;\n    pwVar4 = call_wfullpath(local_210,param_1,0x104,&local_214);\n    if (pwVar4 != (wchar_t *)0x0) {\n      pwVar5 = pwVar4;\n      do {\n        wVar1 = *pwVar5;\n        pwVar5 = pwVar5 + 1;\n      } while (wVar1 != L'\\0');\n      if (((int)pwVar5 - (int)(pwVar4 + 1) >> 1 == 3) || (bVar2 = is_root_unc_name(pwVar4), bVar2))\n      {\n        GetDriveTypeW(param_1);\n      }\n    }\n    FID_conflict__free(local_214);\n  }\n  uVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return (bool)uVar3;\n}\n\n"
    },
    {
      "name": "FID_conflict:__stat64i32",
      "entry": "0040e1bd",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    __stat32i64\n    __stat64\n    __stat64i32\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl FID_conflict___stat64i32(LPCSTR param_1,_stat64i32 *param_2)\n\n{\n  int iVar1;\n  wchar_t *local_8;\n  \n  if (param_1 == (LPCSTR)0x0) {\n    iVar1 = common_stat<struct__stat64i32>((wchar_t *)0x0,param_2);\n  }\n  else {\n    local_8 = (wchar_t *)0x0;\n    iVar1 = ___acrt_copy_path_to_wide_string(param_1,&local_8);\n    if (iVar1 == 0) {\n      FID_conflict__free(local_8);\n      iVar1 = -1;\n    }\n    else {\n      iVar1 = common_stat<struct__stat64i32>(local_8,param_2);\n      FID_conflict__free(local_8);\n    }\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040e21d",
      "entry": "0040e21d",
      "c": "\nvoid __cdecl FUN_0040e21d(wchar_t *param_1,_stat64i32 *param_2)\n\n{\n  common_stat<struct__stat64i32>(param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040e228",
      "entry": "0040e228",
      "c": "\nvoid FUN_0040e228(uint param_1,uint param_2)\n\n{\n  __calloc_base(param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "_setbuf",
      "entry": "0040e233",
      "c": "\n/* Library Function - Single Match\n    _setbuf\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl _setbuf(FILE *_File,char *_Buffer)\n\n{\n  int _Mode;\n  size_t _Size;\n  \n  if (_Buffer == (char *)0x0) {\n    _Size = 0;\n    _Mode = 4;\n    _Buffer = (char *)0x0;\n  }\n  else {\n    _Size = 0x200;\n    _Mode = 0;\n  }\n  _setvbuf(_File,_Buffer,_Mode,_Size);\n  return;\n}\n\n"
    },
    {
      "name": "_strncat",
      "entry": "0040e260",
      "c": "\n/* Library Function - Single Match\n    _strncat\n   \n   Library: Visual Studio */\n\nchar * __cdecl _strncat(char *_Dest,char *_Source,size_t _Count)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint *puVar6;\n  \n  if (_Count != 0) {\n    uVar4 = (uint)_Dest & 3;\n    puVar5 = (uint *)_Dest;\n    while (uVar4 != 0) {\n      uVar4 = *puVar5;\n      puVar5 = (uint *)((int)puVar5 + 1);\n      if ((byte)uVar4 == 0) goto LAB_0040e2bd;\n      uVar4 = (uint)puVar5 & 3;\n    }\n    do {\n      do {\n        puVar6 = puVar5;\n        puVar5 = puVar6 + 1;\n      } while (((*puVar6 ^ 0xffffffff ^ *puVar6 + 0x7efefeff) & 0x81010100) == 0);\n      uVar4 = *puVar6;\n      if ((char)uVar4 == '\\0') goto LAB_0040e2cf;\n      if ((char)(uVar4 >> 8) == '\\0') {\n        puVar6 = (uint *)((int)puVar6 + 1);\n        goto LAB_0040e2cf;\n      }\n      if ((uVar4 & 0xff0000) == 0) {\n        puVar6 = (uint *)((int)puVar6 + 2);\n        goto LAB_0040e2cf;\n      }\n    } while ((uVar4 & 0xff000000) != 0);\nLAB_0040e2bd:\n    puVar6 = (uint *)((int)puVar5 + -1);\nLAB_0040e2cf:\n    if (((uint)_Source & 3) == 0) {\n      uVar3 = _Count >> 2;\n    }\n    else {\n      do {\n        bVar1 = (byte)*(uint *)_Source;\n        uVar4 = (uint)bVar1;\n        _Source = (char *)((int)_Source + 1);\n        if (bVar1 == 0) goto LAB_0040e32a;\n        *(byte *)puVar6 = bVar1;\n        puVar6 = (uint *)((int)puVar6 + 1);\n        _Count = _Count - 1;\n        if (_Count == 0) goto LAB_0040e320;\n      } while (((uint)_Source & 3) != 0);\n      uVar3 = _Count >> 2;\n    }\n    for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n      uVar2 = *(uint *)_Source;\n      uVar4 = *(uint *)_Source;\n      _Source = (char *)((int)_Source + 4);\n      if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n        if ((char)uVar4 == '\\0') {\nLAB_0040e32a:\n          *(byte *)puVar6 = (byte)uVar4;\n          return _Dest;\n        }\n        if ((char)(uVar4 >> 8) == '\\0') {\n          *(short *)puVar6 = (short)uVar4;\n          return _Dest;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n          *(short *)puVar6 = (short)uVar4;\n          *(byte *)((int)puVar6 + 2) = 0;\n          return _Dest;\n        }\n        if ((uVar4 & 0xff000000) == 0) {\n          *puVar6 = uVar4;\n          return _Dest;\n        }\n      }\n      *puVar6 = uVar4;\n      puVar6 = puVar6 + 1;\n    }\n    for (_Count = _Count & 3; _Count != 0; _Count = _Count - 1) {\n      uVar4 = *(uint *)_Source;\n      _Source = (char *)((int)_Source + 1);\n      *(byte *)puVar6 = (byte)uVar4;\n      puVar6 = (uint *)((int)puVar6 + 1);\n      if ((byte)uVar4 == 0) {\n        return _Dest;\n      }\n    }\nLAB_0040e320:\n    *(byte *)puVar6 = (byte)_Count;\n  }\n  return _Dest;\n}\n\n"
    },
    {
      "name": "common_fullpath_dynamic_buffer<char>",
      "entry": "0040e395",
      "c": "\n/* Library Function - Single Match\n    char * __cdecl common_fullpath_dynamic_buffer<char>(char const * const,unsigned int,int,char\n   const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl\ncommon_fullpath_dynamic_buffer<char>\n          (char *param_1,uint param_2,int param_3,char *param_4,int param_5)\n\n{\n  DWORD DVar1;\n  char *pcVar2;\n  char *pcVar3;\n  int *piVar4;\n  char *pcVar5;\n  char *pcVar6;\n  \n  DVar1 = GetFullPathNameA(param_1,0,(LPSTR)0x0,(LPSTR *)0x0);\n  if (DVar1 == 0) {\n    DVar1 = GetLastError();\n    ___acrt_errno_map_os_error(DVar1);\n    pcVar2 = (char *)0x0;\n  }\n  else {\n    if (param_2 <= DVar1) {\n      param_2 = DVar1;\n    }\n    pcVar3 = (char *)FUN_0040e228(param_2,1);\n    pcVar6 = pcVar3;\n    pcVar2 = (char *)0x0;\n    if (pcVar3 == (char *)0x0) {\n      piVar4 = __errno();\n      *piVar4 = 0xc;\n    }\n    else {\n      pcVar5 = common_fullpath_user_buffer<char>(pcVar3,param_1,param_2);\n      if (pcVar5 != (char *)0x0) {\n        pcVar6 = (char *)0x0;\n        pcVar2 = pcVar3;\n      }\n    }\n    FID_conflict__free(pcVar6);\n  }\n  return pcVar2;\n}\n\n"
    },
    {
      "name": "common_fullpath_dynamic_buffer<wchar_t>",
      "entry": "0040e40b",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl common_fullpath_dynamic_buffer<wchar_t>(wchar_t const * const,unsigned\n   int,int,char const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl\ncommon_fullpath_dynamic_buffer<wchar_t>\n          (wchar_t *param_1,uint param_2,int param_3,char *param_4,int param_5)\n\n{\n  DWORD DVar1;\n  wchar_t *pwVar2;\n  wchar_t *pwVar3;\n  int *piVar4;\n  wchar_t *pwVar5;\n  wchar_t *pwVar6;\n  \n  DVar1 = GetFullPathNameW(param_1,0,(LPWSTR)0x0,(LPWSTR *)0x0);\n  if (DVar1 == 0) {\n    DVar1 = GetLastError();\n    ___acrt_errno_map_os_error(DVar1);\n    pwVar2 = (wchar_t *)0x0;\n  }\n  else {\n    if (param_2 <= DVar1) {\n      param_2 = DVar1;\n    }\n    pwVar3 = (wchar_t *)FUN_0040e228(param_2,2);\n    pwVar6 = pwVar3;\n    pwVar2 = (wchar_t *)0x0;\n    if (pwVar3 == (wchar_t *)0x0) {\n      piVar4 = __errno();\n      *piVar4 = 0xc;\n    }\n    else {\n      pwVar5 = common_fullpath_user_buffer<wchar_t>(pwVar3,param_1,param_2);\n      if (pwVar5 != (wchar_t *)0x0) {\n        pwVar6 = (wchar_t *)0x0;\n        pwVar2 = pwVar3;\n      }\n    }\n    FID_conflict__free(pwVar6);\n  }\n  return pwVar2;\n}\n\n"
    },
    {
      "name": "common_fullpath_user_buffer<char>",
      "entry": "0040e481",
      "c": "\n/* Library Function - Single Match\n    char * __cdecl common_fullpath_user_buffer<char>(char * const,char const * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl common_fullpath_user_buffer<char>(char *param_1,char *param_2,uint param_3)\n\n{\n  int *piVar1;\n  DWORD DVar2;\n  \n  if (param_3 == 0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    DVar2 = GetFullPathNameA(param_2,param_3,param_1,(LPSTR *)0x0);\n    if (DVar2 < param_3) {\n      if (DVar2 != 0) {\n        return param_1;\n      }\n      DVar2 = GetLastError();\n      ___acrt_errno_map_os_error(DVar2);\n    }\n    else {\n      piVar1 = __errno();\n      *piVar1 = 0x22;\n    }\n  }\n  return (char *)0x0;\n}\n\n"
    },
    {
      "name": "common_fullpath_user_buffer<wchar_t>",
      "entry": "0040e4e0",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl common_fullpath_user_buffer<wchar_t>(wchar_t * const,wchar_t const *\n   const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl\ncommon_fullpath_user_buffer<wchar_t>(wchar_t *param_1,wchar_t *param_2,uint param_3)\n\n{\n  int *piVar1;\n  DWORD DVar2;\n  \n  if (param_3 == 0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    DVar2 = GetFullPathNameW(param_2,param_3,param_1,(LPWSTR *)0x0);\n    if (DVar2 < param_3) {\n      if (DVar2 != 0) {\n        return param_1;\n      }\n      DVar2 = GetLastError();\n      ___acrt_errno_map_os_error(DVar2);\n    }\n    else {\n      piVar1 = __errno();\n      *piVar1 = 0x22;\n    }\n  }\n  return (wchar_t *)0x0;\n}\n\n"
    },
    {
      "name": "__fullpath",
      "entry": "0040e53f",
      "c": "\n/* Library Function - Single Match\n    __fullpath\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl __fullpath(char *_FullPath,char *_Path,size_t _SizeInBytes)\n\n{\n  char *pcVar1;\n  \n  if ((_Path != (char *)0x0) && (*_Path != '\\0')) {\n    if (_FullPath != (char *)0x0) {\n      pcVar1 = common_fullpath_user_buffer<char>(_FullPath,_Path,_SizeInBytes);\n      return pcVar1;\n    }\n    pcVar1 = common_fullpath_dynamic_buffer<char>(_Path,_SizeInBytes,1,(char *)0x0,0);\n    return pcVar1;\n  }\n  if (0x7ffffffe < _SizeInBytes) {\n    _SizeInBytes = 0x7fffffff;\n  }\n  pcVar1 = __getcwd(_FullPath,_SizeInBytes);\n  return pcVar1;\n}\n\n"
    },
    {
      "name": "__wfullpath",
      "entry": "0040e596",
      "c": "\n/* Library Function - Single Match\n    __wfullpath\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl __wfullpath(wchar_t *_FullPath,wchar_t *_Path,size_t _SizeInWords)\n\n{\n  wchar_t *pwVar1;\n  \n  if ((_Path != (wchar_t *)0x0) && (*_Path != L'\\0')) {\n    if (_FullPath != (wchar_t *)0x0) {\n      pwVar1 = common_fullpath_user_buffer<wchar_t>(_FullPath,_Path,_SizeInWords);\n      return pwVar1;\n    }\n    pwVar1 = common_fullpath_dynamic_buffer<wchar_t>(_Path,_SizeInWords,1,(char *)0x0,0);\n    return pwVar1;\n  }\n  if (0x7ffffffe < _SizeInWords) {\n    _SizeInWords = 0x7fffffff;\n  }\n  pwVar1 = __wgetcwd(_FullPath,_SizeInWords);\n  return pwVar1;\n}\n\n"
    },
    {
      "name": "common_fsopen<wchar_t>",
      "entry": "0040e5ec",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    struct _iobuf * __cdecl common_fsopen<wchar_t>(wchar_t const * const,wchar_t const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\n_iobuf * __cdecl common_fsopen<wchar_t>(wchar_t *param_1,wchar_t *param_2,int param_3)\n\n{\n  int *piVar1;\n  _iobuf *p_Var2;\n  int local_20;\n  \n  if (((param_1 == (wchar_t *)0x0) || (param_2 == (wchar_t *)0x0)) || (*param_2 == L'\\0')) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  else if (*param_1 == L'\\0') {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n  }\n  else {\n    __acrt_stdio_allocate_stream();\n    if (local_20 != 0) {\n      p_Var2 = (_iobuf *)FUN_00416d02();\n      FUN_0040e696();\n      return p_Var2;\n    }\n    piVar1 = __errno();\n    *piVar1 = 0x18;\n  }\n  return (_iobuf *)0x0;\n}\n\n"
    },
    {
      "name": "FUN_0040e696",
      "entry": "0040e696",
      "c": "\nvoid FUN_0040e696(void)\n\n{\n  int unaff_EBP;\n  int unaff_ESI;\n  \n  if (unaff_ESI == 0) {\n    __acrt_stdio_free_stream(*(undefined4 *)(unaff_EBP + -0x1c));\n  }\n  __unlock_file(*(FILE **)(unaff_EBP + -0x1c));\n  return;\n}\n\n"
    },
    {
      "name": "__wfopen",
      "entry": "0040e6ad",
      "c": "\n/* Library Function - Single Match\n    __wfopen\n   \n   Library: Visual Studio 2015 Release */\n\nFILE * __cdecl __wfopen(wchar_t *_Filename,wchar_t *_Mode)\n\n{\n  _iobuf *p_Var1;\n  \n  p_Var1 = common_fsopen<wchar_t>(_Filename,_Mode,0x40);\n  return p_Var1;\n}\n\n"
    },
    {
      "name": "__strdup",
      "entry": "0040e6c4",
      "c": "\n/* Library Function - Single Match\n    __strdup\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl __strdup(char *_Src)\n\n{\n  char cVar1;\n  char *_Dst;\n  errno_t eVar2;\n  char *pcVar3;\n  \n  if (_Src == (char *)0x0) {\n    return (char *)0x0;\n  }\n  pcVar3 = _Src;\n  do {\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar3 + 1;\n  } while (cVar1 != '\\0');\n  _Dst = (char *)FUN_00409dbb((size_t)(pcVar3 + (1 - (int)(_Src + 1))));\n  if ((_Dst != (char *)0x0) &&\n     (eVar2 = _strcpy_s(_Dst,(rsize_t)(pcVar3 + (1 - (int)(_Src + 1))),_Src), eVar2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  }\n  return _Dst;\n}\n\n"
    },
    {
      "name": "_mbstowcs_l_helper",
      "entry": "0040e71a",
      "c": "\n/* Library Function - Single Match\n    unsigned int __cdecl _mbstowcs_l_helper(wchar_t *,char const *,unsigned int,struct\n   __crt_locale_pointers *)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl\n_mbstowcs_l_helper(wchar_t *param_1,char *param_2,uint param_3,__crt_locale_pointers *param_4)\n\n{\n  char *pcVar1;\n  char cVar2;\n  int *piVar3;\n  int iVar4;\n  DWORD DVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int local_1c;\n  localeinfo_struct local_18;\n  char local_10;\n  uint local_c;\n  byte *local_8;\n  \n  uVar7 = 0;\n  if (param_1 != (wchar_t *)0x0) {\n    if (param_3 == 0) {\n      return 0;\n    }\n    *param_1 = L'\\0';\n  }\n  if (param_2 == (char *)0x0) {\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    FUN_00412362();\n    return 0xffffffff;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,param_4);\n  if (param_1 == (wchar_t *)0x0) {\n    if ((local_18.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n      pcVar1 = param_2 + 1;\n      do {\n        cVar2 = *param_2;\n        param_2 = param_2 + 1;\n      } while (cVar2 != '\\0');\n      uVar7 = (int)param_2 - (int)pcVar1;\n      goto LAB_0040e87a;\n    }\n    uVar7 = 0xffffffff;\n    iVar4 = MultiByteToWideChar((local_18.locinfo)->lc_collate_cp,9,param_2,-1,(LPWSTR)0x0,0);\n    if (iVar4 == 0) {\n      piVar3 = __errno();\n      *piVar3 = 0x2a;\n      goto LAB_0040e87a;\n    }\n  }\n  else {\n    if ((local_18.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n      if (param_3 != 0) {\n        do {\n          *param_1 = (ushort)(byte)param_2[uVar7];\n          if (param_2[uVar7] == '\\0') break;\n          uVar7 = uVar7 + 1;\n          param_1 = param_1 + 1;\n        } while (uVar7 < param_3);\n      }\n      goto LAB_0040e87a;\n    }\n    iVar4 = MultiByteToWideChar((local_18.locinfo)->lc_collate_cp,9,param_2,-1,param_1,param_3);\n    if (iVar4 == 0) {\n      DVar5 = GetLastError();\n      if (DVar5 == 0x7a) {\n        local_8 = (byte *)param_2;\n        uVar7 = param_3;\n        if (param_3 != 0) {\n          do {\n            local_c = uVar7 - 1;\n            if (*local_8 == 0) break;\n            iVar4 = __isleadbyte_l((uint)*local_8,&local_18);\n            pbVar6 = local_8;\n            if ((iVar4 != 0) && (pbVar6 = local_8 + 1, *pbVar6 == 0)) goto LAB_0040e823;\n            local_8 = pbVar6 + 1;\n            uVar7 = local_c;\n          } while (local_c != 0);\n        }\n        uVar7 = MultiByteToWideChar((local_18.locinfo)->lc_collate_cp,1,param_2,\n                                    (int)local_8 - (int)param_2,param_1,param_3);\n        if (uVar7 != 0) goto LAB_0040e87a;\n      }\nLAB_0040e823:\n      piVar3 = __errno();\n      *piVar3 = 0x2a;\n      *param_1 = L'\\0';\n      uVar7 = 0xffffffff;\n      goto LAB_0040e87a;\n    }\n  }\n  uVar7 = iVar4 - 1;\nLAB_0040e87a:\n  if (local_10 != '\\0') {\n    *(uint *)(local_1c + 0x350) = *(uint *)(local_1c + 0x350) & 0xfffffffd;\n  }\n  return uVar7;\n}\n\n"
    },
    {
      "name": "_mbstowcs",
      "entry": "0040e893",
      "c": "\n/* Library Function - Single Match\n    _mbstowcs\n   \n   Library: Visual Studio 2015 Release */\n\nsize_t __cdecl _mbstowcs(wchar_t *_Dest,char *_Source,size_t _MaxCount)\n\n{\n  uint uVar1;\n  undefined **ppuVar2;\n  \n  if (DAT_0043b0e8 == 0) {\n    ppuVar2 = &PTR_PTR_0042d300;\n  }\n  else {\n    ppuVar2 = (undefined **)0x0;\n  }\n  uVar1 = _mbstowcs_l_helper(_Dest,_Source,_MaxCount,(__crt_locale_pointers *)ppuVar2);\n  return uVar1;\n}\n\n"
    },
    {
      "name": "__get_fmode",
      "entry": "0040e8bd",
      "c": "\n/* Library Function - Single Match\n    __get_fmode\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl __get_fmode(int *_PMode)\n\n{\n  int *piVar1;\n  \n  if (_PMode == (int *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0x16;\n  }\n  *_PMode = DAT_0043b3fc;\n  return 0;\n}\n\n"
    },
    {
      "name": "__set_fmode",
      "entry": "0040e8e9",
      "c": "\n/* Library Function - Single Match\n    __set_fmode\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nerrno_t __cdecl __set_fmode(int _Mode)\n\n{\n  int *piVar1;\n  \n  if (((_Mode != 0x4000) && (_Mode != 0x8000)) && (_Mode != 0x10000)) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0x16;\n  }\n  LOCK();\n  DAT_0043b3fc = _Mode;\n  UNLOCK();\n  return 0;\n}\n\n"
    },
    {
      "name": "__setmode",
      "entry": "0040e926",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    __setmode\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __setmode(int _FileHandle,int _Mode)\n\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  \n  if ((((_Mode == 0x4000) || (_Mode == 0x8000)) || (_Mode == 0x10000)) ||\n     ((_Mode == 0x40000 || (_Mode == 0x20000)))) {\n    if (_FileHandle == -2) {\n      piVar1 = __errno();\n      *piVar1 = 9;\n      return -1;\n    }\n    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) {\n      iVar2 = (_FileHandle & 0x3fU) * 0x30;\n      if ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + iVar2) & 1) != 0) {\n        ___acrt_lowio_lock_fh(_FileHandle);\n        iVar3 = -1;\n        if ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + iVar2) & 1) == 0) {\n          piVar1 = __errno();\n          *piVar1 = 9;\n        }\n        else {\n          iVar3 = __setmode_nolock(_FileHandle,_Mode);\n        }\n        FUN_0040ea13();\n        return iVar3;\n      }\n    }\n    piVar1 = __errno();\n    *piVar1 = 9;\n  }\n  else {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n  }\n  FUN_00412362();\n  return -1;\n}\n\n"
    },
    {
      "name": "FUN_0040ea13",
      "entry": "0040ea13",
      "c": "\nvoid FUN_0040ea13(void)\n\n{\n  uint unaff_ESI;\n  \n  ___acrt_lowio_unlock_fh(unaff_ESI);\n  return;\n}\n\n"
    },
    {
      "name": "__setmode_nolock",
      "entry": "0040ea34",
      "c": "\n/* Library Function - Single Match\n    __setmode_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __setmode_nolock(int _FileHandle,int _Mode)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  \n  iVar5 = _FileHandle >> 6;\n  iVar4 = (_FileHandle & 0x3fU) * 0x30;\n  iVar3 = (&DAT_0043b110)[iVar5];\n  bVar1 = *(byte *)(iVar3 + 0x28 + iVar4);\n  cVar2 = *(char *)(iVar3 + 0x29 + iVar4);\n  if (_Mode == 0x4000) {\n    *(byte *)(iVar3 + 0x28 + iVar4) = bVar1 | 0x80;\n    *(undefined1 *)((&DAT_0043b110)[iVar5] + 0x29 + iVar4) = 0;\n  }\n  else if (_Mode == 0x8000) {\n    *(byte *)(iVar3 + 0x28 + iVar4) = bVar1 & 0x7f;\n  }\n  else if ((_Mode == 0x10000) || (_Mode == 0x20000)) {\n    *(byte *)(iVar3 + 0x28 + iVar4) = bVar1 | 0x80;\n    *(undefined1 *)((&DAT_0043b110)[iVar5] + 0x29 + iVar4) = 2;\n  }\n  else if (_Mode == 0x40000) {\n    *(byte *)(iVar3 + 0x28 + iVar4) = bVar1 | 0x80;\n    *(undefined1 *)((&DAT_0043b110)[iVar5] + 0x29 + iVar4) = 1;\n  }\n  if ((bVar1 & 0x80) == 0) {\n    iVar3 = 0x8000;\n  }\n  else if (cVar2 == '\\0') {\n    iVar3 = 0x4000;\n  }\n  else {\n    iVar3 = ((cVar2 != '\\x01') - 1 & 0x30000) + 0x10000;\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "___acrt_stdio_flush_nolock",
      "entry": "0040eb05",
      "c": "\n/* Library Function - Single Match\n    ___acrt_stdio_flush_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl ___acrt_stdio_flush_nolock(FILE *param_1)\n\n{\n  int *piVar1;\n  int _FileHandle;\n  uint uVar2;\n  uint uVar3;\n  char *_Buf;\n  \n  piVar1 = &param_1->_flag;\n  if ((((byte)*piVar1 & 3) == 2) && ((*piVar1 & 0xc0U) != 0)) {\n    _Buf = (char *)param_1->_cnt;\n    uVar3 = (int)param_1->_ptr - (int)_Buf;\n    param_1->_ptr = _Buf;\n    param_1->_base = (char *)0x0;\n    if (0 < (int)uVar3) {\n      uVar2 = uVar3;\n      _FileHandle = __fileno(param_1);\n      uVar2 = __write(_FileHandle,_Buf,uVar2);\n      if (uVar3 != uVar2) {\n        LOCK();\n        *piVar1 = *piVar1 | 0x10;\n        UNLOCK();\n        return 0xffffffff;\n      }\n      if (((uint)*piVar1 >> 2 & 1) != 0) {\n        LOCK();\n        *piVar1 = *piVar1 & 0xfffffffd;\n        UNLOCK();\n      }\n    }\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "__fflush_nolock",
      "entry": "0040eb6b",
      "c": "\n/* Library Function - Single Match\n    __fflush_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __fflush_nolock(FILE *_File)\n\n{\n  int iVar1;\n  \n  if (_File == (FILE *)0x0) {\n    iVar1 = common_flush_all(0);\n    return iVar1;\n  }\n  iVar1 = ___acrt_stdio_flush_nolock(_File);\n  if (iVar1 == 0) {\n    if (((uint)_File->_flag >> 0xb & 1) != 0) {\n      iVar1 = __fileno(_File);\n      iVar1 = __commit(iVar1);\n      if (iVar1 != 0) goto LAB_0040eb8c;\n    }\n    iVar1 = 0;\n  }\n  else {\nLAB_0040eb8c:\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040ebb2",
      "entry": "0040ebb2",
      "c": "\nvoid FUN_0040ebb2(void)\n\n{\n  common_flush_all(1);\n  return;\n}\n\n"
    },
    {
      "name": "common_flush_all",
      "entry": "0040ebbb",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    _common_flush_all\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_flush_all(int param_1)\n\n{\n  undefined4 *puVar1;\n  FILE *_File;\n  int iVar2;\n  undefined4 *puVar3;\n  int local_28;\n  int local_20;\n  \n  local_20 = 0;\n  local_28 = 0;\n  ___acrt_lock(8);\n  puVar1 = DAT_0043ae98 + DAT_0043ae94;\n  for (puVar3 = DAT_0043ae98; puVar3 != puVar1; puVar3 = puVar3 + 1) {\n    _File = (FILE *)*puVar3;\n    if (_File != (FILE *)0x0) {\n      __lock_file(_File);\n      if (((uint)_File->_flag >> 0xd & 1) != 0) {\n        if (param_1 == 1) {\n          iVar2 = __fflush_nolock(_File);\n          if (iVar2 != -1) {\n            local_20 = local_20 + 1;\n          }\n        }\n        else if ((param_1 == 0) && (((uint)_File->_flag >> 1 & 1) != 0)) {\n          iVar2 = __fflush_nolock(_File);\n          if (iVar2 == -1) {\n            local_28 = -1;\n          }\n        }\n      }\n      FUN_0040ec60();\n    }\n  }\n  FUN_0040ec8a();\n  if (param_1 != 1) {\n    local_20 = local_28;\n  }\n  return local_20;\n}\n\n"
    },
    {
      "name": "FUN_0040ec60",
      "entry": "0040ec60",
      "c": "\nvoid FUN_0040ec60(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file(*(FILE **)(unaff_EBP + -0x28));\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040ec8a",
      "entry": "0040ec8a",
      "c": "\nvoid FUN_0040ec8a(void)\n\n{\n  ___acrt_unlock(8);\n  return;\n}\n\n"
    },
    {
      "name": "_fflush",
      "entry": "0040ec93",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    _fflush\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _fflush(FILE *_File)\n\n{\n  int iVar1;\n  \n  if (_File == (FILE *)0x0) {\n    iVar1 = common_flush_all(0);\n  }\n  else {\n    __lock_file(_File);\n    iVar1 = __fflush_nolock(_File);\n    FUN_0040ece4();\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040ece4",
      "entry": "0040ece4",
      "c": "\nvoid FUN_0040ece4(void)\n\n{\n  FILE *unaff_ESI;\n  \n  __unlock_file(unaff_ESI);\n  return;\n}\n\n"
    },
    {
      "name": "__fileno",
      "entry": "0040ecec",
      "c": "\n/* Library Function - Single Match\n    __fileno\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __fileno(FILE *_File)\n\n{\n  int *piVar1;\n  \n  if (_File == (FILE *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return -1;\n  }\n  return _File->_file;\n}\n\n"
    },
    {
      "name": "common_putenv<>",
      "entry": "0040ed12",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Multiple Matches With Same Base Name\n    int __cdecl common_putenv<char>(char const * const,char const * const)\n    int __cdecl common_putenv<wchar_t>(wchar_t const * const,wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_putenv<>(wchar_t *param_1,wchar_t *param_2)\n\n{\n  int iVar1;\n  \n  ___acrt_lock(0xb);\n  iVar1 = common_putenv_nolock<wchar_t>(param_1,param_2);\n  FUN_0040ed57();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040ed57",
      "entry": "0040ed57",
      "c": "\nvoid FUN_0040ed57(void)\n\n{\n  ___acrt_unlock(0xb);\n  return;\n}\n\n"
    },
    {
      "name": "common_putenv_nolock<wchar_t>",
      "entry": "0040ed60",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_putenv_nolock<wchar_t>(wchar_t const * const,wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_putenv_nolock<wchar_t>(wchar_t *param_1,wchar_t *param_2)\n\n{\n  bool bVar1;\n  int *piVar2;\n  wchar_t *pwVar3;\n  int iVar4;\n  \n  if ((DAT_0043b0cc == 0) && (DAT_0043b0d0 == 0)) {\n    return -1;\n  }\n  if (param_1 != (wchar_t *)0x0) {\n    pwVar3 = create_environment_string<wchar_t>(param_1,param_2);\n    if (((pwVar3 == (wchar_t *)0x0) || (iVar4 = FUN_00417616(pwVar3,1), iVar4 != 0)) ||\n       ((DAT_0043b0cc != 0 &&\n        (bVar1 = set_variable_in_other_environment<wchar_t>(param_1,param_2), !bVar1)))) {\n      iVar4 = -1;\n    }\n    else {\n      iVar4 = 0;\n    }\n    FID_conflict__free((void *)0x0);\n    return iVar4;\n  }\n  piVar2 = __errno();\n  *piVar2 = 0x16;\n  FUN_00412362();\n  return -1;\n}\n\n"
    },
    {
      "name": "create_environment_string<wchar_t>",
      "entry": "0040ede1",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl create_environment_string<wchar_t>(wchar_t const * const,wchar_t const *\n   const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl create_environment_string<wchar_t>(wchar_t *param_1,wchar_t *param_2)\n\n{\n  wchar_t wVar1;\n  uint uVar2;\n  uint uVar3;\n  int *piVar4;\n  uint _SizeInWords;\n  wchar_t *pwVar5;\n  ushort *puVar6;\n  \n  if (param_2 == (wchar_t *)0x0) {\n    puVar6 = FUN_004202c6((ushort *)param_1,0x3d);\n    if ((puVar6 != (ushort *)0x0) &&\n       ((0xfffd < (int)((int)puVar6 - (int)param_1 & 0xfffffffeU) ||\n        (uVar2 = FUN_00409bff((short *)(puVar6 + 1),0x7fff), 0x7ffe < uVar2)))) goto LAB_0040ee1b;\n    pwVar5 = param_1;\n    do {\n      wVar1 = *pwVar5;\n      pwVar5 = pwVar5 + 1;\n    } while (wVar1 != L'\\0');\n    uVar2 = ((int)pwVar5 - (int)(param_1 + 1) >> 1) + 1;\n    pwVar5 = (wchar_t *)__calloc_base(uVar2,2);\n    if (pwVar5 != (wchar_t *)0x0) {\n      _wcscpy_s(pwVar5,uVar2,param_1);\n      goto LAB_0040eefb;\n    }\n  }\n  else {\n    uVar2 = FUN_00409bff(param_1,0x7fff);\n    uVar3 = FUN_00409bff(param_2,0x7fff);\n    if ((0x7ffe < uVar2) || (0x7ffe < uVar3)) {\nLAB_0040ee1b:\n      piVar4 = __errno();\n      *piVar4 = 0x16;\n      FUN_00412362();\n      return (wchar_t *)0x0;\n    }\n    _SizeInWords = uVar3 + 2 + uVar2;\n    pwVar5 = (wchar_t *)__calloc_base(_SizeInWords,2);\n    if (pwVar5 != (wchar_t *)0x0) {\n      _wcscpy_s(pwVar5,_SizeInWords,param_1);\n      pwVar5[uVar2] = L'=';\n      _wcscpy_s(pwVar5 + uVar2 + 1,uVar3 + 1,param_2);\n      goto LAB_0040eefb;\n    }\n  }\n  pwVar5 = (wchar_t *)0x0;\nLAB_0040eefb:\n  FID_conflict__free((void *)0x0);\n  return pwVar5;\n}\n\n"
    },
    {
      "name": "set_variable_in_other_environment<wchar_t>",
      "entry": "0040ef0b",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl set_variable_in_other_environment<wchar_t>(wchar_t const * const,wchar_t const *\n   const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl set_variable_in_other_environment<wchar_t>(wchar_t *param_1,wchar_t *param_2)\n\n{\n  uint cbMultiByte;\n  int *piVar1;\n  char *lpMultiByteStr;\n  int iVar2;\n  char cVar3;\n  char *_Memory;\n  \n  cbMultiByte = WideCharToMultiByte(0,0,param_1,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);\n  if (cbMultiByte == 0) {\nLAB_0040ef32:\n    piVar1 = __errno();\n    cbMultiByte = 0;\n    *piVar1 = 0x2a;\n  }\n  else if (param_2 != (wchar_t *)0x0) {\n    iVar2 = WideCharToMultiByte(0,0,param_2,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);\n    if (iVar2 == 0) goto LAB_0040ef32;\n    cbMultiByte = cbMultiByte + iVar2;\n  }\n  lpMultiByteStr = (char *)__calloc_base(cbMultiByte,1);\n  if (lpMultiByteStr != (char *)0x0) {\n    iVar2 = WideCharToMultiByte(0,0,param_1,-1,lpMultiByteStr,cbMultiByte,(LPCSTR)0x0,(LPBOOL)0x0);\n    if (iVar2 != 0) {\n      if (param_2 != (wchar_t *)0x0) {\n        (lpMultiByteStr + iVar2)[-1] = '=';\n        iVar2 = WideCharToMultiByte(0,0,param_2,-1,lpMultiByteStr + iVar2,cbMultiByte - iVar2,\n                                    (LPCSTR)0x0,(LPBOOL)0x0);\n        if (iVar2 == 0) goto LAB_0040ef81;\n      }\n      _Memory = (char *)0x0;\n      iVar2 = FUN_0041760b(lpMultiByteStr,0);\n      cVar3 = '\\x01' - (iVar2 != 0);\n      goto LAB_0040ef8e;\n    }\nLAB_0040ef81:\n    piVar1 = __errno();\n    *piVar1 = 0x2a;\n  }\n  cVar3 = '\\0';\n  _Memory = lpMultiByteStr;\nLAB_0040ef8e:\n  FID_conflict__free(_Memory);\n  return (bool)cVar3;\n}\n\n"
    },
    {
      "name": "FID_conflict:__wputenv_s",
      "entry": "0040efd5",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    __putenv_s\n    __wputenv_s\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nerrno_t __cdecl FID_conflict___wputenv_s(wchar_t *_Name,wchar_t *_Value)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if (_Value == (wchar_t *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0x16;\n  }\n  iVar2 = common_putenv<>(_Name,_Value);\n  if (iVar2 == 0) {\n    return 0;\n  }\n  piVar1 = __errno();\n  return *piVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040f011",
      "entry": "0040f011",
      "c": "\nundefined4 __cdecl FUN_0040f011(LPCWSTR param_1)\n\n{\n  BOOL BVar1;\n  DWORD DVar2;\n  \n  BVar1 = RemoveDirectoryW(param_1);\n  if (BVar1 == 0) {\n    DVar2 = GetLastError();\n    ___acrt_errno_map_os_error(DVar2);\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "common_find_first_wide<struct__wfinddata64i32_t>",
      "entry": "0040f039",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_find_first_wide<struct _wfinddata64i32_t>(wchar_t const * const,struct\n   _wfinddata64i32_t * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_find_first_wide<struct__wfinddata64i32_t>(wchar_t *param_1,_wfinddata64i32_t *param_2)\n\n{\n  int *piVar1;\n  HANDLE pvVar2;\n  DWORD DVar3;\n  int iVar4;\n  errno_t eVar5;\n  __int64 _Var6;\n  uint local_258;\n  _FILETIME local_254;\n  _FILETIME local_24c;\n  _FILETIME local_244;\n  undefined4 local_238;\n  wchar_t local_22c [274];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if ((param_2 == (_wfinddata64i32_t *)0x0) || (param_1 == (wchar_t *)0x0)) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    goto LAB_0040f0bb;\n  }\n  pvVar2 = FindFirstFileExW(param_1,FindExInfoStandard,&local_258,FindExSearchNameMatch,(LPVOID)0x0,\n                            0);\n  if (pvVar2 != (HANDLE)0xffffffff) {\n    *(uint *)param_2 = -(uint)(local_258 != 0x80) & local_258;\n    _Var6 = convert_file_time_to_time_t<__int64>(&local_254);\n    *(__int64 *)(param_2 + 8) = _Var6;\n    _Var6 = convert_file_time_to_time_t<__int64>(&local_24c);\n    *(__int64 *)(param_2 + 0x10) = _Var6;\n    _Var6 = convert_file_time_to_time_t<__int64>(&local_244);\n    *(int *)(param_2 + 0x18) = (int)_Var6;\n    *(undefined4 *)(param_2 + 0x20) = local_238;\n    *(int *)(param_2 + 0x1c) = (int)((ulonglong)_Var6 >> 0x20);\n    eVar5 = _wcscpy_s((wchar_t *)(param_2 + 0x24),0x104,local_22c);\n    if (eVar5 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    goto LAB_0040f0bb;\n  }\n  DVar3 = GetLastError();\n  if (DVar3 < 2) {\nLAB_0040f0ab:\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n  }\n  else {\n    if (3 < DVar3) {\n      if (DVar3 == 8) {\n        piVar1 = __errno();\n        *piVar1 = 0xc;\n        goto LAB_0040f0bb;\n      }\n      if (DVar3 != 0x12) goto LAB_0040f0ab;\n    }\n    piVar1 = __errno();\n    *piVar1 = 2;\n  }\nLAB_0040f0bb:\n  iVar4 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar4;\n}\n\n"
    },
    {
      "name": "common_find_next_wide<struct__wfinddata64i32_t>",
      "entry": "0040f162",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_find_next_wide<struct _wfinddata64i32_t>(int,struct _wfinddata64i32_t *\n   const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_find_next_wide<struct__wfinddata64i32_t>(int param_1,_wfinddata64i32_t *param_2)\n\n{\n  int *piVar1;\n  int iVar2;\n  BOOL BVar3;\n  DWORD DVar4;\n  errno_t eVar5;\n  __int64 _Var6;\n  _WIN32_FIND_DATAW local_258;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (((param_1 == 0) || (param_1 == -1)) || (param_2 == (_wfinddata64i32_t *)0x0)) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    goto LAB_0040f195;\n  }\n  BVar3 = FindNextFileW((HANDLE)param_1,&local_258);\n  if (BVar3 != 0) {\n    *(uint *)param_2 = -(uint)(local_258.dwFileAttributes != 0x80) & local_258.dwFileAttributes;\n    _Var6 = convert_file_time_to_time_t<__int64>(&local_258.ftCreationTime);\n    *(__int64 *)(param_2 + 8) = _Var6;\n    _Var6 = convert_file_time_to_time_t<__int64>(&local_258.ftLastAccessTime);\n    *(__int64 *)(param_2 + 0x10) = _Var6;\n    _Var6 = convert_file_time_to_time_t<__int64>(&local_258.ftLastWriteTime);\n    *(int *)(param_2 + 0x18) = (int)_Var6;\n    *(DWORD *)(param_2 + 0x20) = local_258.nFileSizeLow;\n    *(int *)(param_2 + 0x1c) = (int)((ulonglong)_Var6 >> 0x20);\n    eVar5 = _wcscpy_s((wchar_t *)(param_2 + 0x24),0x104,local_258.cFileName);\n    if (eVar5 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    goto LAB_0040f195;\n  }\n  DVar4 = GetLastError();\n  if (DVar4 < 2) {\nLAB_0040f1db:\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n  }\n  else {\n    if (3 < DVar4) {\n      if (DVar4 == 8) {\n        piVar1 = __errno();\n        *piVar1 = 0xc;\n        goto LAB_0040f195;\n      }\n      if (DVar4 != 0x12) goto LAB_0040f1db;\n    }\n    piVar1 = __errno();\n    *piVar1 = 2;\n  }\nLAB_0040f195:\n  iVar2 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar2;\n}\n\n"
    },
    {
      "name": "convert_file_time_to_time_t<__int64>",
      "entry": "0040f27f",
      "c": "\n/* Library Function - Single Match\n    __int64 __cdecl convert_file_time_to_time_t<__int64>(struct _FILETIME const &)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl convert_file_time_to_time_t<__int64>(_FILETIME *param_1)\n\n{\n  BOOL BVar1;\n  __int64 _Var2;\n  _SYSTEMTIME local_28;\n  _SYSTEMTIME local_18;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if ((((param_1->dwLowDateTime != 0) || (param_1->dwHighDateTime != 0)) &&\n      (BVar1 = FileTimeToSystemTime(param_1,&local_28), BVar1 != 0)) &&\n     (BVar1 = SystemTimeToTzSpecificLocalTime((TIME_ZONE_INFORMATION *)0x0,&local_28,&local_18),\n     BVar1 != 0)) {\n    FUN_00416365((uint)local_18.wYear,(uint)local_18.wMonth,(uint)local_18.wDay,(uint)local_18.wHour\n                 ,(uint)local_18.wMinute,(uint)local_18.wSecond,-1);\n  }\n  _Var2 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return _Var2;\n}\n\n"
    },
    {
      "name": "FUN_0040f2ff",
      "entry": "0040f2ff",
      "c": "\nundefined4 __cdecl FUN_0040f2ff(HANDLE param_1)\n\n{\n  BOOL BVar1;\n  int *piVar2;\n  \n  BVar1 = FindClose(param_1);\n  if (BVar1 == 0) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_0040f325",
      "entry": "0040f325",
      "c": "\nvoid __cdecl FUN_0040f325(wchar_t *param_1,_wfinddata64i32_t *param_2)\n\n{\n  common_find_first_wide<struct__wfinddata64i32_t>(param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040f330",
      "entry": "0040f330",
      "c": "\nvoid __cdecl FUN_0040f330(int param_1,_wfinddata64i32_t *param_2)\n\n{\n  common_find_next_wide<struct__wfinddata64i32_t>(param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_lowio_create_handle_array",
      "entry": "0040f33b",
      "c": "\n/* Library Function - Single Match\n    ___acrt_lowio_create_handle_array\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 * ___acrt_lowio_create_handle_array(void)\n\n{\n  undefined4 *puVar1;\n  undefined4 *puVar2;\n  undefined4 *puVar3;\n  \n  puVar2 = (undefined4 *)__calloc_base(0x40,0x30);\n  if (puVar2 == (undefined4 *)0x0) {\n    puVar2 = (undefined4 *)0x0;\n  }\n  else if (puVar2 != puVar2 + 0x300) {\n    puVar3 = puVar2 + 8;\n    do {\n      ___acrt_InitializeCriticalSectionEx_12((LPCRITICAL_SECTION)(puVar3 + -8),4000,0);\n      puVar3[-2] = 0xffffffff;\n      *puVar3 = 0;\n      puVar3[1] = 0;\n      puVar1 = puVar3 + 4;\n      puVar3[2] = 0xa0a0000;\n      *(undefined1 *)(puVar3 + 3) = 10;\n      *(byte *)((int)puVar3 + 0xd) = *(byte *)((int)puVar3 + 0xd) & 0xf8;\n      *(undefined1 *)((int)puVar3 + 0xe) = 0;\n      puVar3 = puVar3 + 0xc;\n    } while (puVar1 != puVar2 + 0x300);\n  }\n  FID_conflict__free((void *)0x0);\n  return puVar2;\n}\n\n"
    },
    {
      "name": "___acrt_lowio_destroy_handle_array",
      "entry": "0040f3b5",
      "c": "\n/* Library Function - Single Match\n    ___acrt_lowio_destroy_handle_array\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_lowio_destroy_handle_array(LPCRITICAL_SECTION param_1)\n\n{\n  LPCRITICAL_SECTION lpCriticalSection;\n  \n  if (param_1 != (LPCRITICAL_SECTION)0x0) {\n    lpCriticalSection = param_1;\n    if (param_1 != param_1 + 0x80) {\n      do {\n        DeleteCriticalSection(lpCriticalSection);\n        lpCriticalSection = lpCriticalSection + 2;\n      } while (lpCriticalSection != param_1 + 0x80);\n    }\n    FID_conflict__free(param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_lowio_ensure_fh_exists",
      "entry": "0040f3ea",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    ___acrt_lowio_ensure_fh_exists\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl ___acrt_lowio_ensure_fh_exists(uint param_1)\n\n{\n  int *piVar1;\n  undefined4 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  int iVar5;\n  \n  if (param_1 < 0x2000) {\n    uVar4 = 0;\n    ___acrt_lock(7);\n    iVar5 = 0;\n    iVar3 = DAT_0043b310;\n    while (iVar3 <= (int)param_1) {\n      if ((&DAT_0043b110)[iVar5] == 0) {\n        puVar2 = ___acrt_lowio_create_handle_array();\n        (&DAT_0043b110)[iVar5] = puVar2;\n        if (puVar2 == (undefined4 *)0x0) {\n          uVar4 = 0xc;\n          break;\n        }\n        iVar3 = DAT_0043b310 + 0x40;\n        DAT_0043b310 = iVar3;\n      }\n      iVar5 = iVar5 + 1;\n    }\n    FUN_0040f479();\n  }\n  else {\n    piVar1 = __errno();\n    uVar4 = 9;\n    *piVar1 = 9;\n    FUN_00412362();\n  }\n  return uVar4;\n}\n\n"
    },
    {
      "name": "FUN_0040f479",
      "entry": "0040f479",
      "c": "\nvoid FUN_0040f479(void)\n\n{\n  ___acrt_unlock(7);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_lowio_lock_fh",
      "entry": "0040f482",
      "c": "\n/* Library Function - Single Match\n    ___acrt_lowio_lock_fh\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_lowio_lock_fh(uint param_1)\n\n{\n  EnterCriticalSection\n            ((LPCRITICAL_SECTION)((param_1 & 0x3f) * 0x30 + (&DAT_0043b110)[(int)param_1 >> 6]));\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_lowio_set_os_handle",
      "entry": "0040f4a5",
      "c": "\n/* Library Function - Single Match\n    ___acrt_lowio_set_os_handle\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl ___acrt_lowio_set_os_handle(uint param_1,HANDLE param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  ulong *puVar3;\n  int iVar4;\n  DWORD nStdHandle;\n  \n  if ((-1 < (int)param_1) && (param_1 < DAT_0043b310)) {\n    iVar4 = (param_1 & 0x3f) * 0x30;\n    if (*(int *)(iVar4 + 0x18 + (&DAT_0043b110)[(int)param_1 >> 6]) == -1) {\n      iVar1 = FUN_0041035f();\n      if (iVar1 == 1) {\n        if (param_1 == 0) {\n          nStdHandle = 0xfffffff6;\n        }\n        else if (param_1 == 1) {\n          nStdHandle = 0xfffffff5;\n        }\n        else {\n          if (param_1 != 2) goto LAB_0040f50a;\n          nStdHandle = 0xfffffff4;\n        }\n        SetStdHandle(nStdHandle,param_2);\n      }\nLAB_0040f50a:\n      *(HANDLE *)(iVar4 + 0x18 + (&DAT_0043b110)[(int)param_1 >> 6]) = param_2;\n      return 0;\n    }\n  }\n  piVar2 = __errno();\n  *piVar2 = 9;\n  puVar3 = ___doserrno();\n  *puVar3 = 0;\n  return 0xffffffff;\n}\n\n"
    },
    {
      "name": "___acrt_lowio_unlock_fh",
      "entry": "0040f539",
      "c": "\n/* Library Function - Single Match\n    ___acrt_lowio_unlock_fh\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_lowio_unlock_fh(uint param_1)\n\n{\n  LeaveCriticalSection\n            ((LPCRITICAL_SECTION)((param_1 & 0x3f) * 0x30 + (&DAT_0043b110)[(int)param_1 >> 6]));\n  return;\n}\n\n"
    },
    {
      "name": "__alloc_osfhnd",
      "entry": "0040f55c",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    __alloc_osfhnd\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __alloc_osfhnd(void)\n\n{\n  LPCRITICAL_SECTION p_Var1;\n  undefined4 *puVar2;\n  int iVar3;\n  LPCRITICAL_SECTION lpCriticalSection;\n  uint uVar4;\n  \n  ___acrt_lock(7);\n  uVar4 = 0xffffffff;\n  iVar3 = 0;\n  do {\n    if (0x7f < iVar3) {\nLAB_0040f5d3:\n      FUN_0040f665();\n      return uVar4;\n    }\n    p_Var1 = (LPCRITICAL_SECTION)(&DAT_0043b110)[iVar3];\n    if (p_Var1 == (LPCRITICAL_SECTION)0x0) {\n      puVar2 = ___acrt_lowio_create_handle_array();\n      (&DAT_0043b110)[iVar3] = puVar2;\n      if (puVar2 != (undefined4 *)0x0) {\n        DAT_0043b310 = DAT_0043b310 + 0x40;\n        uVar4 = iVar3 << 6;\n        ___acrt_lowio_lock_fh(uVar4);\n        *(undefined1 *)((&DAT_0043b110)[(int)uVar4 >> 6] + 0x28) = 1;\n      }\n      goto LAB_0040f5d3;\n    }\n    for (lpCriticalSection = p_Var1; lpCriticalSection != p_Var1 + 0x80;\n        lpCriticalSection = lpCriticalSection + 2) {\n      if (((uint)lpCriticalSection[1].LockSemaphore & 1) == 0) {\n        EnterCriticalSection(lpCriticalSection);\n        if (((uint)lpCriticalSection[1].LockSemaphore & 1) == 0) {\n          uVar4 = iVar3 * 0x40 + ((int)lpCriticalSection - (int)p_Var1) / 0x30;\n          iVar3 = (uVar4 & 0x3f) * 0x30;\n          *(undefined1 *)(iVar3 + 0x28 + (&DAT_0043b110)[(int)uVar4 >> 6]) = 1;\n          *(undefined4 *)(iVar3 + 0x18 + (&DAT_0043b110)[(int)uVar4 >> 6]) = 0xffffffff;\n          goto LAB_0040f5d3;\n        }\n        LeaveCriticalSection(lpCriticalSection);\n      }\n    }\n    iVar3 = iVar3 + 1;\n  } while( true );\n}\n\n"
    },
    {
      "name": "FUN_0040f665",
      "entry": "0040f665",
      "c": "\nvoid FUN_0040f665(void)\n\n{\n  ___acrt_unlock(7);\n  return;\n}\n\n"
    },
    {
      "name": "__free_osfhnd",
      "entry": "0040f66e",
      "c": "\n/* Library Function - Single Match\n    __free_osfhnd\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __free_osfhnd(int param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  ulong *puVar3;\n  int iVar4;\n  DWORD nStdHandle;\n  \n  if ((-1 < param_1) && ((uint)param_1 < DAT_0043b310)) {\n    iVar4 = (param_1 & 0x3fU) * 0x30;\n    if (((*(byte *)(iVar4 + 0x28 + (&DAT_0043b110)[param_1 >> 6]) & 1) != 0) &&\n       (*(int *)(iVar4 + 0x18 + (&DAT_0043b110)[param_1 >> 6]) != -1)) {\n      iVar1 = FUN_0041035f();\n      if (iVar1 == 1) {\n        if (param_1 == 0) {\n          nStdHandle = 0xfffffff6;\n        }\n        else if (param_1 == 1) {\n          nStdHandle = 0xfffffff5;\n        }\n        else {\n          if (param_1 != 2) goto LAB_0040f6d4;\n          nStdHandle = 0xfffffff4;\n        }\n        SetStdHandle(nStdHandle,(HANDLE)0x0);\n      }\nLAB_0040f6d4:\n      *(undefined4 *)(iVar4 + 0x18 + (&DAT_0043b110)[param_1 >> 6]) = 0xffffffff;\n      return 0;\n    }\n  }\n  piVar2 = __errno();\n  *piVar2 = 9;\n  puVar3 = ___doserrno();\n  *puVar3 = 0;\n  return -1;\n}\n\n"
    },
    {
      "name": "__get_osfhandle",
      "entry": "0040f6ff",
      "c": "\n/* Library Function - Single Match\n    __get_osfhandle\n   \n   Library: Visual Studio 2015 Release */\n\nintptr_t __cdecl __get_osfhandle(int _FileHandle)\n\n{\n  ulong *puVar1;\n  int *piVar2;\n  int iVar3;\n  \n  if (_FileHandle == -2) {\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n  }\n  else {\n    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) {\n      iVar3 = (_FileHandle & 0x3fU) * 0x30;\n      if ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + iVar3) & 1) != 0) {\n        return *(intptr_t *)((&DAT_0043b110)[_FileHandle >> 6] + 0x18 + iVar3);\n      }\n    }\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n    FUN_00412362();\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "operator()<>",
      "entry": "0040f769",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Multiple Matches With Same Base Name\n    public: void (__cdecl*__thiscall __crt_seh_guarded_call<void (__cdecl*)(int)>::operator()<class\n   <lambda_a048d3beccc847880fc8490e18b82769>,class <lambda_ec61778202f4f5fc7e7711acc23c3bca> &,class\n   <lambda_f7496a158712204296dd6628a163878e> >(class <lambda_a048d3beccc847880fc8490e18b82769>\n   &&,class <lambda_ec61778202f4f5fc7e7711acc23c3bca> &,class\n   <lambda_f7496a158712204296dd6628a163878e> &&))(int)\n    public: void (__cdecl*__thiscall __crt_seh_guarded_call<void (__cdecl*)(int)>::operator()<class\n   <lambda_cbab9ec6f41b0180b23cc171c22676b0>,class <lambda_44731a7d0e6d81c3e6aa82d741081786> &,class\n   <lambda_4b292cb8dd18144e164572427af410ab> >(class <lambda_cbab9ec6f41b0180b23cc171c22676b0>\n   &&,class <lambda_44731a7d0e6d81c3e6aa82d741081786> &,class\n   <lambda_4b292cb8dd18144e164572427af410ab> &&))(int)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nuint operator()<>(int *param_1)\n\n{\n  byte bVar1;\n  uint uVar2;\n  \n  ___acrt_lock(*param_1);\n  bVar1 = (byte)DAT_0042d008 & 0x1f;\n  uVar2 = DAT_0042d008 ^ _DAT_0043aeac;\n  FUN_0040f7b7();\n  return uVar2 >> bVar1 | uVar2 << 0x20 - bVar1;\n}\n\n"
    },
    {
      "name": "FUN_0040f7b7",
      "entry": "0040f7b7",
      "c": "\nvoid FUN_0040f7b7(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>",
      "entry": "0040f7c3",
      "c": "\n/* Library Function - Single Match\n    void (__cdecl*__cdecl __acrt_lock_and_call<class <lambda_ec61778202f4f5fc7e7711acc23c3bca>\n   >(enum __acrt_lock_id,class <lambda_ec61778202f4f5fc7e7711acc23c3bca> &&))(int)\n   \n   Library: Visual Studio 2015 Release */\n\n_func_void_int * __cdecl\n__acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>\n          (__acrt_lock_id param_1,<lambda_ec61778202f4f5fc7e7711acc23c3bca> *param_2)\n\n{\n  _func_void_int *p_Var1;\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  p_Var1 = (_func_void_int *)operator()<>((int *)&local_10);\n  return p_Var1;\n}\n\n"
    },
    {
      "name": "__crt_fast_encode_pointer<>",
      "entry": "0040f7eb",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    int (__cdecl*__cdecl __crt_fast_encode_pointer<int (__cdecl*)(void)>(int\n   (__cdecl*const)(void)))(void)\n    void (__cdecl** __cdecl __crt_fast_encode_pointer<void (__cdecl**)(void)>(void (__cdecl**\n   const)(void)))(void)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl __crt_fast_encode_pointer<>(uint param_1)\n\n{\n  byte bVar1;\n  \n  bVar1 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n  return (param_1 >> bVar1 | param_1 << 0x20 - bVar1) ^ DAT_0042d008;\n}\n\n"
    },
    {
      "name": "FUN_0040f893",
      "entry": "0040f893",
      "c": "\nvoid FUN_0040f893(void)\n\n{\n  ___acrt_unlock(3);\n  return;\n}\n\n"
    },
    {
      "name": "get_global_action_nolock",
      "entry": "0040f8b8",
      "c": "\n/* Library Function - Single Match\n    void (__cdecl** __cdecl get_global_action_nolock(int))(int)\n   \n   Library: Visual Studio 2015 Release */\n\n_func_void_int ** __cdecl get_global_action_nolock(int param_1)\n\n{\n  if (param_1 == 2) {\n    return (_func_void_int **)&DAT_0043aea4;\n  }\n  if (param_1 != 6) {\n    if (param_1 == 0xf) {\n      return (_func_void_int **)&DAT_0043aeb0;\n    }\n    if (param_1 == 0x15) {\n      return (_func_void_int **)&DAT_0043aea8;\n    }\n    if (param_1 != 0x16) {\n      return (_func_void_int **)0x0;\n    }\n  }\n  return (_func_void_int **)&DAT_0043aeac;\n}\n\n"
    },
    {
      "name": "siglookup",
      "entry": "0040f8fa",
      "c": "\n/* Library Function - Single Match\n    struct __crt_signal_action_t * __cdecl siglookup(int,struct __crt_signal_action_t * const)\n   \n   Library: Visual Studio 2015 Release */\n\n__crt_signal_action_t * __cdecl siglookup(int param_1,__crt_signal_action_t *param_2)\n\n{\n  __crt_signal_action_t *p_Var1;\n  \n  p_Var1 = param_2 + DAT_004267e0 * 0xc;\n  if (param_2 != p_Var1) {\n    do {\n      if (*(int *)(param_2 + 4) == param_1) {\n        return param_2;\n      }\n      param_2 = param_2 + 0xc;\n    } while (param_2 != p_Var1);\n  }\n  return (__crt_signal_action_t *)0x0;\n}\n\n"
    },
    {
      "name": "signal_failed",
      "entry": "0040f922",
      "c": "\n/* Library Function - Single Match\n    void (__cdecl*__cdecl signal_failed(int))(int)\n   \n   Library: Visual Studio 2015 Release */\n\n_func_void_int * __cdecl signal_failed(int param_1)\n\n{\n  int *piVar1;\n  \n  if ((((param_1 != 1) && (param_1 != 3)) && (param_1 != 0xd)) &&\n     ((param_1 < 0x10 || (0x11 < param_1)))) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n  }\n  return (_func_void_int *)0xffffffff;\n}\n\n"
    },
    {
      "name": "___acrt_get_sigabrt_handler",
      "entry": "0040f953",
      "c": "\n/* Library Function - Single Match\n    ___acrt_get_sigabrt_handler\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_get_sigabrt_handler(void)\n\n{\n  <lambda_ec61778202f4f5fc7e7711acc23c3bca> local_5;\n  \n  __acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>(3,&local_5);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_initialize_signal_handlers",
      "entry": "0040f96a",
      "c": "\n/* Library Function - Single Match\n    ___acrt_initialize_signal_handlers\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_initialize_signal_handlers(undefined4 param_1)\n\n{\n  initialize(&DAT_0043aea4,param_1);\n  initialize(&DAT_0043aea8,param_1);\n  initialize(&DAT_0043aeac,param_1);\n  initialize(&DAT_0043aeb0,param_1);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040f9a5",
      "entry": "0040f9a5",
      "c": "\nint FUN_0040f9a5(void)\n\n{\n  __acrt_ptd *p_Var1;\n  \n  p_Var1 = ___acrt_getptd();\n  return (int)(p_Var1 + 8);\n}\n\n"
    },
    {
      "name": "_raise",
      "entry": "0040f9ae",
      "c": "\n/* WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4 */\n/* Library Function - Single Match\n    _raise\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _raise(int _SigNum)\n\n{\n  __crt_signal_action_t *p_Var1;\n  int *piVar2;\n  undefined4 *puVar3;\n  int iVar4;\n  __acrt_ptd *p_Var5;\n  char extraout_CL;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  _func_void_int *p_Var9;\n  __acrt_ptd *p_Var10;\n  undefined4 local_38;\n  int local_34;\n  char local_21;\n  \n  p_Var10 = (__acrt_ptd *)0x0;\n  local_38 = 0;\n  local_21 = '\\x01';\n  if (8 < _SigNum) {\n    if (_SigNum == 0xb) goto LAB_0040fa08;\n    if ((_SigNum == 0xf) || ((0x14 < _SigNum && (_SigNum < 0x17)))) goto LAB_0040f9fd;\nLAB_0040fa33:\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    goto LAB_0040fbb0;\n  }\n  if (_SigNum == 8) {\nLAB_0040fa08:\n    p_Var10 = ___acrt_getptd_noexit();\n    if (p_Var10 == (__acrt_ptd *)0x0) goto LAB_0040fbb0;\n    p_Var1 = siglookup(_SigNum,*(__crt_signal_action_t **)p_Var10);\n    if (p_Var1 == (__crt_signal_action_t *)0x0) goto LAB_0040fa33;\n    p_Var1 = p_Var1 + 8;\n    cVar6 = '\\0';\n    local_21 = '\\0';\n  }\n  else {\n    if (_SigNum != 2) {\n      if (_SigNum == 4) goto LAB_0040fa08;\n      if (_SigNum != 6) goto LAB_0040fa33;\n    }\nLAB_0040f9fd:\n    p_Var1 = (__crt_signal_action_t *)get_global_action_nolock(_SigNum);\n    cVar6 = extraout_CL;\n  }\n  local_34 = 0;\n  if (cVar6 != '\\0') {\n    ___acrt_lock(3);\n    cVar6 = local_21;\n  }\n  if (cVar6 == '\\0') {\n    p_Var9 = *(_func_void_int **)p_Var1;\n    local_21 = '\\0';\n  }\n  else {\n    bVar7 = (byte)DAT_0042d008 & 0x1f;\n    p_Var9 = (_func_void_int *)\n             ((DAT_0042d008 ^ (uint)*(_func_void_int **)p_Var1) >> bVar7 |\n             (DAT_0042d008 ^ (uint)*(_func_void_int **)p_Var1) << 0x20 - bVar7);\n  }\n  if (p_Var9 != (_func_void_int *)0x1) {\n    if (p_Var9 == (_func_void_int *)0x0) {\n      if (local_21 != '\\0') {\n        ___acrt_unlock(3);\n      }\n      __exit(3);\n    }\n    if (((_SigNum == 8) || (_SigNum == 0xb)) || (_SigNum == 4)) {\n      local_34 = *(int *)(p_Var10 + 4);\n      *(int *)(p_Var10 + 4) = 0;\n      if (_SigNum == 8) {\n        puVar3 = (undefined4 *)FUN_0040f9a5();\n        local_38 = *puVar3;\n        puVar3 = (undefined4 *)FUN_0040f9a5();\n        *puVar3 = 0x8c;\n        goto LAB_0040faef;\n      }\n    }\n    else {\nLAB_0040faef:\n      if (_SigNum == 8) {\n        iVar4 = DAT_004267e8 * 0xc + *(int *)p_Var10;\n        iVar8 = DAT_004267ec * 0xc + iVar4;\n        for (; iVar4 != iVar8; iVar4 = iVar4 + 0xc) {\n          *(undefined4 *)(iVar4 + 8) = 0;\n        }\n        goto LAB_0040fb31;\n      }\n    }\n    bVar7 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n    *(_func_void_int **)p_Var1 =\n         (_func_void_int *)((0U >> bVar7 | 0 << 0x20 - bVar7) ^ DAT_0042d008);\n  }\nLAB_0040fb31:\n  FUN_0040fb6e();\n  if (p_Var9 != (_func_void_int *)0x1) {\n    if (_SigNum == 8) {\n      p_Var5 = ___acrt_getptd();\n      iVar4 = 0x40fb59;\n      (*(code *)PTR_guard_check_icall_0042118c)(8,*(undefined4 *)(p_Var5 + 8));\n      (*p_Var9)(iVar4);\n    }\n    else {\n      iVar4 = 0x40fb87;\n      (*(code *)PTR_guard_check_icall_0042118c)(_SigNum);\n      (*p_Var9)(iVar4);\n      if ((_SigNum != 0xb) && (_SigNum != 4)) goto LAB_0040fbb0;\n    }\n    *(int *)(p_Var10 + 4) = local_34;\n    if (_SigNum == 8) {\n      p_Var10 = ___acrt_getptd();\n      *(undefined4 *)(p_Var10 + 8) = local_38;\n    }\n  }\nLAB_0040fbb0:\n  iVar4 = FUN_0041ffc9();\n  return iVar4;\n}\n\n"
    },
    {
      "name": "FUN_0040fb6e",
      "entry": "0040fb6e",
      "c": "\nvoid FUN_0040fb6e(void)\n\n{\n  int unaff_EBP;\n  \n  if (*(char *)(unaff_EBP + -0x1d) != '\\0') {\n    ___acrt_unlock(3);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "_signal",
      "entry": "0040fbb6",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    _signal\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl _signal(int param_1)\n\n{\n  __crt_signal_action_t *p_Var1;\n  bool bVar2;\n  __crt_signal_action_t *p_Var3;\n  __acrt_ptd *p_Var4;\n  uint *puVar5;\n  __crt_signal_action_t *p_Var6;\n  BOOL BVar7;\n  ulong *puVar8;\n  DWORD DVar9;\n  _func_void_int **pp_Var10;\n  _func_void_int *p_Var11;\n  int iVar12;\n  uint in_stack_00000008;\n  \n  if ((in_stack_00000008 != 4) && (in_stack_00000008 != 3)) {\n    if (((param_1 == 2) || (((param_1 == 0x15 || (param_1 == 0x16)) || (param_1 == 6)))) ||\n       (param_1 == 0xf)) {\n      bVar2 = false;\n      ___acrt_lock(3);\n      if (((param_1 == 2) || (param_1 == 0x15)) && (DAT_0043aea0 == '\\0')) {\n        BVar7 = SetConsoleCtrlHandler((PHANDLER_ROUTINE)&LAB_0040f80a,1);\n        if (BVar7 == 0) {\n          puVar8 = ___doserrno();\n          DVar9 = GetLastError();\n          *puVar8 = DVar9;\n          bVar2 = true;\n        }\n        else {\n          DAT_0043aea0 = '\\x01';\n        }\n      }\n      pp_Var10 = get_global_action_nolock(param_1);\n      if ((pp_Var10 != (_func_void_int **)0x0) && (in_stack_00000008 != 2)) {\n        p_Var11 = (_func_void_int *)__crt_fast_encode_pointer<>(in_stack_00000008);\n        *pp_Var10 = p_Var11;\n      }\n      FUN_0040fd50();\n      if (!bVar2) {\n        return;\n      }\n    }\n    else if ((((param_1 == 8) || (param_1 == 4)) || (param_1 == 0xb)) &&\n            (p_Var4 = ___acrt_getptd_noexit(), p_Var4 != (__acrt_ptd *)0x0)) {\n      if (*(undefined **)p_Var4 == &DAT_00426750) {\n        puVar5 = (uint *)__malloc_base(DAT_004267e4);\n        *(uint **)p_Var4 = puVar5;\n        if (puVar5 == (uint *)0x0) goto LAB_0040fd5c;\n        FUN_00408c90(puVar5,(uint *)&DAT_00426750,DAT_004267e4);\n      }\n      p_Var1 = *(__crt_signal_action_t **)p_Var4;\n      p_Var6 = siglookup(param_1,p_Var1);\n      if (p_Var6 != (__crt_signal_action_t *)0x0) {\n        if (in_stack_00000008 == 2) {\n          return;\n        }\n        iVar12 = DAT_004267e0 * 0xc;\n        p_Var3 = p_Var6 + 8;\n        while( true ) {\n          if (p_Var6 == p_Var1 + iVar12) {\n            return;\n          }\n          if (*(int *)(p_Var3 + -4) != param_1) break;\n          *(uint *)p_Var3 = in_stack_00000008;\n          p_Var6 = p_Var3 + 4;\n          p_Var3 = p_Var3 + 0xc;\n        }\n        return;\n      }\n    }\n  }\nLAB_0040fd5c:\n  signal_failed(param_1);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040fd50",
      "entry": "0040fd50",
      "c": "\nvoid FUN_0040fd50(void)\n\n{\n  ___acrt_unlock(3);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0040fd68",
      "entry": "0040fd68",
      "c": "\nundefined4 __cdecl FUN_0040fd68(LPCWSTR param_1)\n\n{\n  BOOL BVar1;\n  DWORD DVar2;\n  \n  BVar1 = DeleteFileW(param_1);\n  if (BVar1 == 0) {\n    DVar2 = GetLastError();\n    ___acrt_errno_map_os_error(DVar2);\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "common_tempnam<wchar_t>",
      "entry": "0040fd90",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl common_tempnam<wchar_t>(wchar_t const * const,wchar_t const * const,int,char\n   const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl\ncommon_tempnam<wchar_t>(wchar_t *param_1,wchar_t *param_2,int param_3,char *param_4,int param_5)\n\n{\n  wchar_t wVar1;\n  bool bVar2;\n  wchar_t *_Memory;\n  uint _SizeInWords;\n  wchar_t *pwVar3;\n  errno_t eVar4;\n  uint uVar5;\n  wchar_t *pwVar6;\n  wchar_t *local_8;\n  \n  local_8 = (wchar_t *)0x0;\n  _Memory = get_directory<wchar_t>(param_1,&local_8);\n  if (param_2 == (wchar_t *)0x0) {\n    uVar5 = 0;\n  }\n  else {\n    pwVar3 = param_2;\n    do {\n      wVar1 = *pwVar3;\n      pwVar3 = pwVar3 + 1;\n    } while (wVar1 != L'\\0');\n    uVar5 = (int)pwVar3 - (int)(param_2 + 1) >> 1;\n  }\n  pwVar3 = local_8;\n  do {\n    wVar1 = *pwVar3;\n    pwVar3 = pwVar3 + 1;\n  } while (wVar1 != L'\\0');\n  _SizeInWords = ((int)pwVar3 - (int)(local_8 + 1) >> 1) + 0xc + uVar5;\n  pwVar3 = (wchar_t *)FUN_0040e228(_SizeInWords,2);\n  if (pwVar3 != (wchar_t *)0x0) {\n    *pwVar3 = L'\\0';\n    eVar4 = _wcscat_s(pwVar3,_SizeInWords,local_8);\n    if (eVar4 != 0) {\nLAB_0040feaf:\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    bVar2 = __crt_stdio_path_requires_backslash(local_8);\n    if (bVar2) {\n      eVar4 = _wcscat_s(pwVar3,_SizeInWords,L\"\\\\\");\n      if (eVar4 != 0) goto LAB_0040feaf;\n    }\n    if (param_2 != (wchar_t *)0x0) {\n      eVar4 = _wcscat_s(pwVar3,_SizeInWords,param_2);\n      if (eVar4 != 0) goto LAB_0040feaf;\n    }\n    pwVar6 = pwVar3;\n    do {\n      wVar1 = *pwVar6;\n      pwVar6 = pwVar6 + 1;\n    } while (wVar1 != L'\\0');\n    bVar2 = compute_name<wchar_t>\n                      (pwVar3,pwVar3 + ((int)pwVar6 - (int)(pwVar3 + 1) >> 1),\n                       _SizeInWords -\n                       ((int)(pwVar3 + ((int)pwVar6 - (int)(pwVar3 + 1) >> 1)) - (int)pwVar3 >> 1),\n                       uVar5);\n    if (bVar2) {\n      pwVar6 = pwVar3;\n      pwVar3 = (wchar_t *)0x0;\n      goto LAB_0040fe98;\n    }\n  }\n  pwVar6 = (wchar_t *)0x0;\nLAB_0040fe98:\n  FID_conflict__free(pwVar3);\n  FID_conflict__free(_Memory);\n  return pwVar6;\n}\n\n"
    },
    {
      "name": "compute_name<wchar_t>",
      "entry": "0040febc",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    bool __cdecl compute_name<wchar_t>(wchar_t const * const,wchar_t * const,unsigned int,unsigned\n   int)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl compute_name<wchar_t>(wchar_t *param_1,wchar_t *param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  ulong uVar2;\n  int *piVar3;\n  errno_t eVar4;\n  bool bVar5;\n  \n  bVar5 = false;\n  ___acrt_lock(0xc);\n  if (DAT_0043b53c < param_4) {\n    DAT_0042d310 = 1;\n  }\n  uVar2 = DAT_0042d310;\n  DAT_0043b53c = param_4;\n  piVar3 = __errno();\n  iVar1 = *piVar3;\n  do {\n    do {\n      DAT_0042d310 = DAT_0042d310 + 1;\n      if (0x7fffffff < DAT_0042d310 - uVar2) {\n        piVar3 = __errno();\n        *piVar3 = iVar1;\n        goto LAB_0040ff6b;\n      }\n      eVar4 = __ultow_s(DAT_0042d310,param_2,param_3,10);\n      if (eVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n      }\n      piVar3 = __errno();\n      *piVar3 = 0;\n      eVar4 = __waccess_s(param_1,0);\n    } while (eVar4 == 0);\n    piVar3 = __errno();\n  } while (*piVar3 == 0xd);\n  piVar3 = __errno();\n  *piVar3 = iVar1;\n  bVar5 = true;\nLAB_0040ff6b:\n  FUN_0040ff82();\n  return bVar5;\n}\n\n"
    },
    {
      "name": "FUN_0040ff82",
      "entry": "0040ff82",
      "c": "\nvoid FUN_0040ff82(void)\n\n{\n  ___acrt_unlock(0xc);\n  return;\n}\n\n"
    },
    {
      "name": "get_directory<wchar_t>",
      "entry": "0040ff8b",
      "c": "\n/* Library Function - Single Match\n    wchar_t const * __cdecl get_directory<wchar_t>(wchar_t const * const,wchar_t const * * const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl get_directory<wchar_t>(wchar_t *param_1,wchar_t **param_2)\n\n{\n  errno_t eVar1;\n  wchar_t *_Filename;\n  wchar_t *pwVar2;\n  wchar_t *_Memory;\n  wchar_t *local_8;\n  \n  local_8 = (wchar_t *)0x0;\n  eVar1 = FID_conflict___dupenv_s(&local_8,(size_t *)0x0,L\"TMP\");\n  pwVar2 = local_8;\n  if (eVar1 == 0) {\n    if (local_8 != (wchar_t *)0x0) {\n      eVar1 = __waccess_s(local_8,0);\n      if (eVar1 == 0) {\n        *param_2 = pwVar2;\n        _Memory = (wchar_t *)0x0;\n        _Filename = pwVar2;\n        goto LAB_00410042;\n      }\n      _Filename = strip_quotes<wchar_t>(pwVar2);\n      if ((_Filename != (wchar_t *)0x0) && (eVar1 = __waccess_s(_Filename,0), eVar1 == 0)) {\n        *param_2 = _Filename;\n        FID_conflict__free((void *)0x0);\n        _Memory = pwVar2;\n        goto LAB_00410042;\n      }\n      FID_conflict__free(_Filename);\n    }\n  }\n  else {\n    if (eVar1 == 0x16) {\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    pwVar2 = (wchar_t *)0x0;\n  }\n  if ((param_1 == (wchar_t *)0x0) || (eVar1 = __waccess_s(param_1,0), eVar1 != 0)) {\n    param_1 = L\"\\\\\";\n    eVar1 = __waccess_s(L\"\\\\\",0);\n    if (eVar1 == 0) goto LAB_00410021;\n    *param_2 = L\".\";\n  }\n  else {\nLAB_00410021:\n    *param_2 = param_1;\n  }\n  _Memory = pwVar2;\n  _Filename = (wchar_t *)0x0;\nLAB_00410042:\n  FID_conflict__free(_Memory);\n  return _Filename;\n}\n\n"
    },
    {
      "name": "strip_quotes<wchar_t>",
      "entry": "0041005d",
      "c": "\n/* Library Function - Single Match\n    wchar_t const * __cdecl strip_quotes<wchar_t>(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl strip_quotes<wchar_t>(wchar_t *param_1)\n\n{\n  int iVar1;\n  wchar_t *pwVar2;\n  wchar_t *pwVar3;\n  int iVar4;\n  wchar_t wVar5;\n  \n  iVar4 = 0;\n  iVar1 = 0;\n  wVar5 = *param_1;\n  pwVar2 = param_1;\n  if (wVar5 != L'\\0') {\n    do {\n      if (wVar5 == L'\\\"') {\n        iVar4 = iVar4 + 1;\n      }\n      iVar1 = iVar1 + 1;\n      wVar5 = pwVar2[1];\n      pwVar2 = pwVar2 + 1;\n    } while (wVar5 != L'\\0');\n    if (iVar4 != 0) {\n      pwVar2 = (wchar_t *)__calloc_base((iVar1 - iVar4) + 1,2);\n      if (pwVar2 == (wchar_t *)0x0) {\n        pwVar2 = (wchar_t *)0x0;\n      }\n      else {\n        wVar5 = *param_1;\n        pwVar3 = pwVar2;\n        while (wVar5 != L'\\0') {\n          if (*param_1 != L'\\\"') {\n            *pwVar3 = *param_1;\n            pwVar3 = pwVar3 + 1;\n          }\n          param_1 = param_1 + 1;\n          wVar5 = *param_1;\n        }\n        *pwVar3 = L'\\0';\n      }\n      FID_conflict__free((void *)0x0);\n      return pwVar2;\n    }\n  }\n  return (wchar_t *)0x0;\n}\n\n"
    },
    {
      "name": "__crt_stdio_path_requires_backslash",
      "entry": "004100e7",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __crt_stdio_path_requires_backslash(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __crt_stdio_path_requires_backslash(wchar_t *param_1)\n\n{\n  wchar_t wVar1;\n  wchar_t *pwVar2;\n  \n  pwVar2 = param_1;\n  do {\n    wVar1 = *pwVar2;\n    pwVar2 = pwVar2 + 1;\n  } while (wVar1 != L'\\0');\n  if ((param_1 != param_1 + ((int)pwVar2 - (int)(param_1 + 1) >> 1)) &&\n     (wVar1 = (param_1 + ((int)pwVar2 - (int)(param_1 + 1) >> 1))[-1], wVar1 != L'\\\\')) {\n    return wVar1 != L'/';\n  }\n  return false;\n}\n\n"
    },
    {
      "name": "__wtempnam",
      "entry": "00410121",
      "c": "\n/* Library Function - Single Match\n    __wtempnam\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl __wtempnam(wchar_t *_Directory,wchar_t *_FilePrefix)\n\n{\n  wchar_t *pwVar1;\n  \n  pwVar1 = common_tempnam<wchar_t>(_Directory,_FilePrefix,1,(char *)0x0,0);\n  return pwVar1;\n}\n\n"
    },
    {
      "name": "_clearerr_s",
      "entry": "0041013c",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n\nerrno_t __cdecl _clearerr_s(FILE *_File)\n\n{\n  int *piVar1;\n  int iVar2;\n  uint uVar3;\n  undefined *puVar4;\n  \n  if (_File != (FILE *)0x0) {\n    __lock_file(_File);\n    LOCK();\n    _File->_flag = _File->_flag & 0xffffffe7;\n    UNLOCK();\n    iVar2 = __fileno(_File);\n    if ((iVar2 == -1) || (iVar2 = __fileno(_File), iVar2 == -2)) {\n      puVar4 = &DAT_0042d210;\n    }\n    else {\n      iVar2 = __fileno(_File);\n      uVar3 = __fileno(_File);\n      puVar4 = (undefined *)((uVar3 & 0x3f) * 0x30 + (&DAT_0043b110)[iVar2 >> 6]);\n    }\n    puVar4[0x28] = puVar4[0x28] & 0xfd;\n    FUN_004101e4();\n    return 0;\n  }\n  piVar1 = __errno();\n  *piVar1 = 0x16;\n  FUN_00412362();\n  return 0x16;\n}\n\n"
    },
    {
      "name": "_clearerr_s",
      "entry": "00410141",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    _clearerr_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl _clearerr_s(FILE *_File)\n\n{\n  int *piVar1;\n  int iVar2;\n  uint uVar3;\n  undefined *puVar4;\n  \n  if (_File != (FILE *)0x0) {\n    __lock_file(_File);\n    LOCK();\n    _File->_flag = _File->_flag & 0xffffffe7;\n    UNLOCK();\n    iVar2 = __fileno(_File);\n    if ((iVar2 == -1) || (iVar2 = __fileno(_File), iVar2 == -2)) {\n      puVar4 = &DAT_0042d210;\n    }\n    else {\n      iVar2 = __fileno(_File);\n      uVar3 = __fileno(_File);\n      puVar4 = (undefined *)((uVar3 & 0x3f) * 0x30 + (&DAT_0043b110)[iVar2 >> 6]);\n    }\n    puVar4[0x28] = puVar4[0x28] & 0xfd;\n    FUN_004101e4();\n    return 0;\n  }\n  piVar1 = __errno();\n  *piVar1 = 0x16;\n  FUN_00412362();\n  return 0x16;\n}\n\n"
    },
    {
      "name": "FUN_004101e4",
      "entry": "004101e4",
      "c": "\nvoid FUN_004101e4(void)\n\n{\n  FILE *unaff_ESI;\n  \n  __unlock_file(unaff_ESI);\n  return;\n}\n\n"
    },
    {
      "name": "__seh_filter_exe",
      "entry": "004101ec",
      "c": "\n/* Library Function - Single Match\n    __seh_filter_exe\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __seh_filter_exe(uint param_1,undefined4 param_2)\n\n{\n  uint *puVar1;\n  code *pcVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  uint uVar5;\n  __acrt_ptd *p_Var6;\n  uint *puVar7;\n  uint *puVar8;\n  \n  uVar5 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  p_Var6 = ___acrt_getptd_noexit();\n  if (p_Var6 != (__acrt_ptd *)0x0) {\n    puVar1 = *(uint **)p_Var6;\n    for (puVar8 = puVar1; puVar8 != puVar1 + 0x24; puVar8 = puVar8 + 3) {\n      if (*puVar8 == param_1) goto LAB_0041022f;\n    }\n    puVar8 = (uint *)0x0;\nLAB_0041022f:\n    if ((puVar8 != (uint *)0x0) && (pcVar2 = (code *)puVar8[2], pcVar2 != (code *)0x0)) {\n      if (pcVar2 == (code *)0x5) {\n        puVar8[2] = 0;\n      }\n      else if (pcVar2 != (code *)0x1) {\n        uVar3 = *(undefined4 *)(p_Var6 + 4);\n        *(undefined4 *)(p_Var6 + 4) = param_2;\n        if (puVar8[1] == 8) {\n          for (puVar7 = puVar1 + 9; puVar7 != puVar1 + 0x24; puVar7 = puVar7 + 3) {\n            puVar7[2] = 0;\n          }\n          uVar4 = *(undefined4 *)(p_Var6 + 8);\n          if (*puVar8 < 0xc0000092) {\n            if (*puVar8 == 0xc0000091) {\n              *(undefined4 *)(p_Var6 + 8) = 0x84;\n            }\n            else if (*puVar8 == 0xc000008d) {\n              *(undefined4 *)(p_Var6 + 8) = 0x82;\n            }\n            else if (*puVar8 == 0xc000008e) {\n              *(undefined4 *)(p_Var6 + 8) = 0x83;\n            }\n            else if (*puVar8 == 0xc000008f) {\n              *(undefined4 *)(p_Var6 + 8) = 0x86;\n            }\n            else if (*puVar8 == 0xc0000090) {\n              *(undefined4 *)(p_Var6 + 8) = 0x81;\n            }\n          }\n          else if (*puVar8 == 0xc0000092) {\n            *(undefined4 *)(p_Var6 + 8) = 0x8a;\n          }\n          else if (*puVar8 == 0xc0000093) {\n            *(undefined4 *)(p_Var6 + 8) = 0x85;\n          }\n          else if (*puVar8 == 0xc00002b4) {\n            *(undefined4 *)(p_Var6 + 8) = 0x8e;\n          }\n          else if (*puVar8 == 0xc00002b5) {\n            *(undefined4 *)(p_Var6 + 8) = 0x8d;\n          }\n          (*(code *)PTR_guard_check_icall_0042118c)(8,*(undefined4 *)(p_Var6 + 8));\n          (*pcVar2)();\n          *(undefined4 *)(p_Var6 + 8) = uVar4;\n        }\n        else {\n          puVar8[2] = 0;\n          (*(code *)PTR_guard_check_icall_0042118c)(puVar8[1]);\n          (*pcVar2)();\n        }\n        *(undefined4 *)(p_Var6 + 4) = uVar3;\n      }\n    }\n  }\n  __security_check_cookie(uVar5 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041035f",
      "entry": "0041035f",
      "c": "\nundefined4 FUN_0041035f(void)\n\n{\n  return DAT_0043aeb4;\n}\n\n"
    },
    {
      "name": "FUN_00410365",
      "entry": "00410365",
      "c": "\nvoid __cdecl FUN_00410365(undefined4 param_1)\n\n{\n  DAT_0043aeb4 = param_1;\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_has_user_matherr",
      "entry": "00410374",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___acrt_has_user_matherr\n   \n   Library: Visual Studio 2015 Release */\n\nbool ___acrt_has_user_matherr(void)\n\n{\n  byte bVar1;\n  \n  bVar1 = (byte)DAT_0042d008 & 0x1f;\n  return (DAT_0042d008 ^ _DAT_0043aeb8) >> bVar1 != 0 ||\n         (DAT_0042d008 ^ _DAT_0043aeb8) << 0x20 - bVar1 != 0;\n}\n\n"
    },
    {
      "name": "FUN_0041038d",
      "entry": "0041038d",
      "c": "\nvoid __cdecl FUN_0041038d(undefined4 param_1)\n\n{\n  initialize(&DAT_0043aeb8,param_1);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_invoke_user_matherr",
      "entry": "004103a1",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___acrt_invoke_user_matherr\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_invoke_user_matherr(undefined4 param_1)\n\n{\n  uint uVar1;\n  byte bVar2;\n  code *pcVar3;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  bVar2 = (byte)DAT_0042d008 & 0x1f;\n  pcVar3 = (code *)((DAT_0042d008 ^ _DAT_0043aeb8) >> bVar2 |\n                   (DAT_0042d008 ^ _DAT_0043aeb8) << 0x20 - bVar2);\n  if (pcVar3 != (code *)0x0) {\n    (*(code *)PTR_guard_check_icall_0042118c)(param_1);\n    (*pcVar3)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___setusermatherr",
      "entry": "004103ea",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___setusermatherr\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl ___setusermatherr(uint param_1)\n\n{\n  _DAT_0043aeb8 = __crt_fast_encode_pointer<>(param_1);\n  return;\n}\n\n"
    },
    {
      "name": "common_configure_argv<wchar_t>",
      "entry": "004103ff",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    int __cdecl common_configure_argv<wchar_t>(enum _crt_argv_mode)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_configure_argv<wchar_t>(_crt_argv_mode param_1)\n\n{\n  int *piVar1;\n  wchar_t **ppwVar2;\n  wchar_t *pwVar3;\n  wchar_t **ppwVar4;\n  int iVar5;\n  uint local_10;\n  wchar_t **local_c;\n  uint local_8;\n  \n  if ((param_1 == 2) || (param_1 == 1)) {\n    iVar5 = 0;\n    GetModuleFileNameW((HMODULE)0x0,(LPWSTR)&DAT_0043aec0,0x104);\n    _DAT_0043ae90 = &DAT_0043aec0;\n    if ((DAT_0043ae8c == (wchar_t *)0x0) || (pwVar3 = DAT_0043ae8c, *DAT_0043ae8c == L'\\0')) {\n      pwVar3 = (wchar_t *)&DAT_0043aec0;\n    }\n    local_8 = 0;\n    local_10 = 0;\n    parse_command_line<wchar_t>(pwVar3,(wchar_t **)0x0,(wchar_t *)0x0,&local_8,&local_10);\n    ppwVar2 = (wchar_t **)___acrt_allocate_buffer_for_argv(local_8,local_10,2);\n    ppwVar4 = ppwVar2;\n    if (ppwVar2 == (wchar_t **)0x0) {\n      piVar1 = __errno();\n      iVar5 = 0xc;\n      *piVar1 = 0xc;\n    }\n    else {\n      parse_command_line<wchar_t>(pwVar3,ppwVar2,(wchar_t *)(ppwVar2 + local_8),&local_8,&local_10);\n      if (param_1 == 1) {\n        _DAT_0043ae7c = local_8 - 1;\n        ppwVar4 = (wchar_t **)0x0;\n        DAT_0043ae84 = ppwVar2;\n      }\n      else {\n        local_c = (wchar_t **)0x0;\n        iVar5 = FUN_0041821c(ppwVar2,&local_c);\n        ppwVar2 = local_c;\n        if (iVar5 == 0) {\n          _DAT_0043ae7c = 0;\n          pwVar3 = *local_c;\n          while (pwVar3 != (wchar_t *)0x0) {\n            local_c = local_c + 1;\n            _DAT_0043ae7c = _DAT_0043ae7c + 1;\n            pwVar3 = *local_c;\n          }\n          local_c = (wchar_t **)0x0;\n          iVar5 = 0;\n          DAT_0043ae84 = ppwVar2;\n        }\n        FID_conflict__free(local_c);\n        local_c = (wchar_t **)0x0;\n      }\n    }\n    FID_conflict__free(ppwVar4);\n  }\n  else {\n    piVar1 = __errno();\n    iVar5 = 0x16;\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  return iVar5;\n}\n\n"
    },
    {
      "name": "parse_command_line<wchar_t>",
      "entry": "0041051e",
      "c": "\n/* Library Function - Single Match\n    void __cdecl parse_command_line<wchar_t>(wchar_t *,wchar_t * *,wchar_t *,unsigned int *,unsigned\n   int *)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\nparse_command_line<wchar_t>\n          (wchar_t *param_1,wchar_t **param_2,wchar_t *param_3,uint *param_4,uint *param_5)\n\n{\n  bool bVar1;\n  bool bVar2;\n  wchar_t wVar3;\n  uint uVar4;\n  \n  bVar1 = false;\n  bVar2 = false;\n  *param_5 = 0;\n  *param_4 = 1;\n  if (param_2 != (wchar_t **)0x0) {\n    *param_2 = param_3;\n    param_2 = param_2 + 1;\n  }\n  do {\n    wVar3 = L'\\\"';\n    if (*param_1 == L'\\\"') {\n      bVar1 = !bVar1;\n      bVar2 = bVar1;\n    }\n    else {\n      *param_5 = *param_5 + 1;\n      if (param_3 != (wchar_t *)0x0) {\n        *param_3 = *param_1;\n        param_3 = param_3 + 1;\n      }\n      wVar3 = *param_1;\n      if (wVar3 == L'\\0') goto LAB_004105aa;\n    }\n    param_1 = param_1 + 1;\n  } while ((bVar2) || ((wVar3 != L' ' && (wVar3 != L'\\t'))));\n  if (param_3 != (wchar_t *)0x0) {\n    param_3[-1] = L'\\0';\n  }\nLAB_004105aa:\n  bVar1 = false;\n  while (*param_1 != L'\\0') {\n    for (; (*param_1 == L' ' || (*param_1 == L'\\t')); param_1 = param_1 + 1) {\n    }\n    if (*param_1 == L'\\0') break;\n    if (param_2 != (wchar_t **)0x0) {\n      *param_2 = param_3;\n      param_2 = param_2 + 1;\n    }\n    *param_4 = *param_4 + 1;\n    while( true ) {\n      bVar2 = true;\n      uVar4 = 0;\n      for (; *param_1 == L'\\\\'; param_1 = param_1 + 1) {\n        uVar4 = uVar4 + 1;\n      }\n      if (*param_1 == L'\\\"') {\n        if ((uVar4 & 1) == 0) {\n          if ((bVar1) && (param_1[1] == L'\\\"')) {\n            param_1 = param_1 + 1;\n          }\n          else {\n            bVar1 = !bVar1;\n            bVar2 = false;\n          }\n        }\n        uVar4 = uVar4 >> 1;\n      }\n      while (uVar4 != 0) {\n        uVar4 = uVar4 - 1;\n        if (param_3 != (wchar_t *)0x0) {\n          *param_3 = L'\\\\';\n          param_3 = param_3 + 1;\n        }\n        *param_5 = *param_5 + 1;\n      }\n      wVar3 = *param_1;\n      if ((wVar3 == L'\\0') || ((!bVar1 && ((wVar3 == L' ' || (wVar3 == L'\\t')))))) break;\n      if (bVar2) {\n        if (param_3 != (wchar_t *)0x0) {\n          *param_3 = wVar3;\n          param_3 = param_3 + 1;\n        }\n        *param_5 = *param_5 + 1;\n      }\n      param_1 = param_1 + 1;\n    }\n    if (param_3 != (wchar_t *)0x0) {\n      *param_3 = L'\\0';\n      param_3 = param_3 + 1;\n    }\n    *param_5 = *param_5 + 1;\n  }\n  if (param_2 != (wchar_t **)0x0) {\n    *param_2 = (wchar_t *)0x0;\n  }\n  *param_4 = *param_4 + 1;\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_allocate_buffer_for_argv",
      "entry": "004106a4",
      "c": "\n/* Library Function - Single Match\n    ___acrt_allocate_buffer_for_argv\n   \n   Library: Visual Studio 2015 Release */\n\nLPVOID __cdecl ___acrt_allocate_buffer_for_argv(uint param_1,uint param_2,uint param_3)\n\n{\n  LPVOID pvVar1;\n  \n  if ((param_1 < 0x3fffffff) && (param_2 < (uint)(0xffffffff / (ulonglong)param_3))) {\n    if (param_2 * param_3 < param_1 * -4 - 1) {\n      pvVar1 = __calloc_base(param_2 * param_3 + param_1 * 4,1);\n      FID_conflict__free((void *)0x0);\n      return pvVar1;\n    }\n  }\n  return (LPVOID)0x0;\n}\n\n"
    },
    {
      "name": "FUN_004106f9",
      "entry": "004106f9",
      "c": "\nvoid __cdecl FUN_004106f9(_crt_argv_mode param_1)\n\n{\n  common_configure_argv<wchar_t>(param_1);\n  return;\n}\n\n"
    },
    {
      "name": "common_get_or_create_environment_nolock<char>",
      "entry": "00410704",
      "c": "\n/* Library Function - Single Match\n    char * * __cdecl common_get_or_create_environment_nolock<char>(void)\n   \n   Library: Visual Studio 2015 Release */\n\nchar ** __cdecl common_get_or_create_environment_nolock<char>(void)\n\n{\n  int iVar1;\n  \n  if (DAT_0043b0cc != (char **)0x0) {\n    return DAT_0043b0cc;\n  }\n  if ((DAT_0043b0d0 != 0) && (iVar1 = common_initialize_environment_nolock<char>(), iVar1 == 0)) {\n    iVar1 = initialize_environment_by_cloning_nolock<char>();\n    return (char **)(~-(uint)(iVar1 != 0) & (uint)DAT_0043b0cc);\n  }\n  return (char **)0x0;\n}\n\n"
    },
    {
      "name": "common_get_or_create_environment_nolock<wchar_t>",
      "entry": "00410733",
      "c": "\n/* Library Function - Single Match\n    wchar_t * * __cdecl common_get_or_create_environment_nolock<wchar_t>(void)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t ** __cdecl common_get_or_create_environment_nolock<wchar_t>(void)\n\n{\n  int iVar1;\n  \n  if (DAT_0043b0d0 != (wchar_t **)0x0) {\n    return DAT_0043b0d0;\n  }\n  if ((DAT_0043b0cc != 0) && (iVar1 = common_initialize_environment_nolock<wchar_t>(), iVar1 == 0))\n  {\n    iVar1 = initialize_environment_by_cloning_nolock<wchar_t>();\n    return (wchar_t **)(~-(uint)(iVar1 != 0) & (uint)DAT_0043b0d0);\n  }\n  return (wchar_t **)0x0;\n}\n\n"
    },
    {
      "name": "common_initialize_environment_nolock<char>",
      "entry": "00410762",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_initialize_environment_nolock<char>(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_initialize_environment_nolock<char>(void)\n\n{\n  LPSTR _Memory;\n  char **ppcVar1;\n  int iVar2;\n  \n  if (DAT_0043b0cc != 0) {\n    return 0;\n  }\n  ___acrt_initialize_multibyte();\n  _Memory = ___dcrt_get_narrow_environment_from_os();\n  if (_Memory == (LPSTR)0x0) {\n    iVar2 = -1;\n  }\n  else {\n    ppcVar1 = create_environment<char>(_Memory);\n    if (ppcVar1 == (char **)0x0) {\n      iVar2 = -1;\n    }\n    else {\n      DAT_0043b0d8 = ppcVar1;\n      initialize(&DAT_0043b0cc,ppcVar1);\n      iVar2 = 0;\n    }\n    FID_conflict__free((void *)0x0);\n  }\n  FID_conflict__free(_Memory);\n  return iVar2;\n}\n\n"
    },
    {
      "name": "common_initialize_environment_nolock<wchar_t>",
      "entry": "004107bb",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_initialize_environment_nolock<wchar_t>(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_initialize_environment_nolock<wchar_t>(void)\n\n{\n  wchar_t *_Memory;\n  wchar_t **ppwVar1;\n  int iVar2;\n  \n  if (DAT_0043b0d0 != 0) {\n    return 0;\n  }\n  _Memory = (wchar_t *)___dcrt_get_wide_environment_from_os();\n  if (_Memory == (wchar_t *)0x0) {\n    iVar2 = -1;\n  }\n  else {\n    ppwVar1 = create_environment<wchar_t>(_Memory);\n    if (ppwVar1 == (wchar_t **)0x0) {\n      iVar2 = -1;\n    }\n    else {\n      DAT_0043b0d4 = ppwVar1;\n      initialize(&DAT_0043b0d0,ppwVar1);\n      iVar2 = 0;\n    }\n    FID_conflict__free((void *)0x0);\n  }\n  FID_conflict__free(_Memory);\n  return iVar2;\n}\n\n"
    },
    {
      "name": "create_environment<char>",
      "entry": "0041080f",
      "c": "\n/* Library Function - Single Match\n    char * * __cdecl create_environment<char>(char * const)\n   \n   Library: Visual Studio 2015 Release */\n\nchar ** __cdecl create_environment<char>(char *param_1)\n\n{\n  char cVar1;\n  wchar_t **ppwVar2;\n  wchar_t *_Dst;\n  errno_t eVar3;\n  char *pcVar4;\n  int iVar5;\n  wchar_t **local_8;\n  \n  iVar5 = 0;\n  cVar1 = *param_1;\n  pcVar4 = param_1;\n  while (cVar1 != '\\0') {\n    if (cVar1 != '=') {\n      iVar5 = iVar5 + 1;\n    }\n    do {\n      cVar1 = *pcVar4;\n      pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    cVar1 = *pcVar4;\n  }\n  ppwVar2 = (wchar_t **)__calloc_base(iVar5 + 1,4);\n  local_8 = ppwVar2;\n  if (ppwVar2 == (wchar_t **)0x0) {\nLAB_004108c0:\n    ppwVar2 = (wchar_t **)0x0;\n  }\n  else {\n    for (; *param_1 != '\\0'; param_1 = param_1 + (int)pcVar4) {\n      pcVar4 = param_1;\n      do {\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n      } while (cVar1 != '\\0');\n      pcVar4 = pcVar4 + (1 - (int)(param_1 + 1));\n      if (*param_1 != '=') {\n        _Dst = (wchar_t *)__calloc_base((uint)pcVar4,1);\n        if (_Dst == (wchar_t *)0x0) {\n          free_environment<wchar_t>(ppwVar2);\n          FID_conflict__free((void *)0x0);\n          goto LAB_004108c0;\n        }\n        eVar3 = _strcpy_s((char *)_Dst,(rsize_t)pcVar4,param_1);\n        if (eVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        *local_8 = _Dst;\n        local_8 = local_8 + 1;\n        FID_conflict__free((void *)0x0);\n      }\n    }\n  }\n  FID_conflict__free((void *)0x0);\n  return (char **)ppwVar2;\n}\n\n"
    },
    {
      "name": "create_environment<wchar_t>",
      "entry": "004108e0",
      "c": "\n/* Library Function - Single Match\n    wchar_t * * __cdecl create_environment<wchar_t>(wchar_t * const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t ** __cdecl create_environment<wchar_t>(wchar_t *param_1)\n\n{\n  uint _SizeInWords;\n  wchar_t wVar1;\n  wchar_t **ppwVar2;\n  wchar_t *pwVar3;\n  errno_t eVar4;\n  wchar_t *pwVar5;\n  int iVar6;\n  wchar_t **local_8;\n  \n  iVar6 = 0;\n  wVar1 = *param_1;\n  pwVar3 = param_1;\n  while (wVar1 != L'\\0') {\n    if (wVar1 != L'=') {\n      iVar6 = iVar6 + 1;\n    }\n    pwVar5 = pwVar3;\n    do {\n      wVar1 = *pwVar5;\n      pwVar5 = pwVar5 + 1;\n    } while (wVar1 != L'\\0');\n    pwVar3 = pwVar3 + ((int)pwVar5 - (int)(pwVar3 + 1) >> 1) + 1;\n    wVar1 = *pwVar3;\n  }\n  ppwVar2 = (wchar_t **)__calloc_base(iVar6 + 1,4);\n  local_8 = ppwVar2;\n  if (ppwVar2 == (wchar_t **)0x0) {\nLAB_004109bb:\n    ppwVar2 = (wchar_t **)0x0;\n  }\n  else {\n    for (; *param_1 != L'\\0'; param_1 = param_1 + _SizeInWords) {\n      pwVar3 = param_1;\n      do {\n        wVar1 = *pwVar3;\n        pwVar3 = pwVar3 + 1;\n      } while (wVar1 != L'\\0');\n      _SizeInWords = ((int)pwVar3 - (int)(param_1 + 1) >> 1) + 1;\n      if (*param_1 != L'=') {\n        pwVar3 = (wchar_t *)__calloc_base(_SizeInWords,2);\n        if (pwVar3 == (wchar_t *)0x0) {\n          free_environment<wchar_t>(ppwVar2);\n          FID_conflict__free((void *)0x0);\n          goto LAB_004109bb;\n        }\n        eVar4 = _wcscpy_s(pwVar3,_SizeInWords,param_1);\n        if (eVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        *local_8 = pwVar3;\n        local_8 = local_8 + 1;\n        FID_conflict__free((void *)0x0);\n      }\n    }\n  }\n  FID_conflict__free((void *)0x0);\n  return ppwVar2;\n}\n\n"
    },
    {
      "name": "free_environment<wchar_t>",
      "entry": "004109da",
      "c": "\n/* Library Function - Single Match\n    void __cdecl free_environment<wchar_t>(wchar_t * * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl free_environment<wchar_t>(wchar_t **param_1)\n\n{\n  wchar_t *_Memory;\n  wchar_t **ppwVar1;\n  \n  if (param_1 != (wchar_t **)0x0) {\n    _Memory = *param_1;\n    ppwVar1 = param_1;\n    while (_Memory != (wchar_t *)0x0) {\n      FID_conflict__free(_Memory);\n      ppwVar1 = ppwVar1 + 1;\n      _Memory = *ppwVar1;\n    }\n    FID_conflict__free(param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "initialize_environment_by_cloning_nolock<char>",
      "entry": "00410a09",
      "c": "\n/* Library Function - Single Match\n    int __cdecl initialize_environment_by_cloning_nolock<char>(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl initialize_environment_by_cloning_nolock<char>(void)\n\n{\n  uint cbMultiByte;\n  char *lpMultiByteStr;\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = DAT_0043b0d0;\n  if (DAT_0043b0d0 == (int *)0x0) {\n    return -1;\n  }\n  while( true ) {\n    if (*piVar2 == 0) {\n      return 0;\n    }\n    cbMultiByte = WideCharToMultiByte(0,0,(LPCWSTR)*piVar2,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);\n    if (cbMultiByte == 0) break;\n    lpMultiByteStr = (char *)__calloc_base(cbMultiByte,1);\n    if ((lpMultiByteStr == (char *)0x0) ||\n       (iVar1 = WideCharToMultiByte(0,0,(LPCWSTR)*piVar2,-1,lpMultiByteStr,cbMultiByte,(LPCSTR)0x0,\n                                    (LPBOOL)0x0), iVar1 == 0)) {\n      FID_conflict__free(lpMultiByteStr);\n      return -1;\n    }\n    FUN_0041760b(lpMultiByteStr,0);\n    FID_conflict__free((void *)0x0);\n    piVar2 = piVar2 + 1;\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "initialize_environment_by_cloning_nolock<wchar_t>",
      "entry": "00410a88",
      "c": "\n/* Library Function - Single Match\n    int __cdecl initialize_environment_by_cloning_nolock<wchar_t>(void)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl initialize_environment_by_cloning_nolock<wchar_t>(void)\n\n{\n  uint cchWideChar;\n  wchar_t *lpWideCharStr;\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = DAT_0043b0cc;\n  if (DAT_0043b0cc == (int *)0x0) {\n    return -1;\n  }\n  while( true ) {\n    if (*piVar2 == 0) {\n      return 0;\n    }\n    cchWideChar = MultiByteToWideChar(0,0,(LPCSTR)*piVar2,-1,(LPWSTR)0x0,0);\n    if (cchWideChar == 0) break;\n    lpWideCharStr = (wchar_t *)__calloc_base(cchWideChar,2);\n    if ((lpWideCharStr == (wchar_t *)0x0) ||\n       (iVar1 = MultiByteToWideChar(0,0,(LPCSTR)*piVar2,-1,lpWideCharStr,cchWideChar), iVar1 == 0))\n    {\n      FID_conflict__free(lpWideCharStr);\n      return -1;\n    }\n    FUN_00417616(lpWideCharStr,0);\n    FID_conflict__free((void *)0x0);\n    piVar2 = piVar2 + 1;\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "uninitialize<>",
      "entry": "00410b01",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    public: void __thiscall __crt_state_management::dual_state_global<char * *>::uninitialize<void\n   (__cdecl&)(char * * &)>(void (__cdecl&)(char * * &))\n    public: void __thiscall __crt_state_management::dual_state_global<wchar_t *\n   *>::uninitialize<void (__cdecl&)(wchar_t * * &)>(void (__cdecl&)(wchar_t * * &))\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nvoid __thiscall uninitialize<>(void *this,undefined *param_1)\n\n{\n  void *pvVar1;\n  uint uVar2;\n  \n  uVar2 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pvVar1 = (void *)((int)this + 4);\n  for (; this != pvVar1; this = (void *)((int)this + 4)) {\n    (*(code *)PTR_guard_check_icall_0042118c)(this);\n    (*(code *)param_1)();\n  }\n  __security_check_cookie(uVar2 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "uninitialize_environment_internal<>",
      "entry": "00410b41",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    void __cdecl uninitialize_environment_internal<char>(char * * &)\n    void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl uninitialize_environment_internal<>(undefined4 *param_1)\n\n{\n  if ((wchar_t **)*param_1 != DAT_0043b0d8) {\n    free_environment<wchar_t>((wchar_t **)*param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "uninitialize_environment_internal<>",
      "entry": "00410b5c",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    void __cdecl uninitialize_environment_internal<char>(char * * &)\n    void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * * &)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl uninitialize_environment_internal<>(undefined4 *param_1)\n\n{\n  if ((wchar_t **)*param_1 != DAT_0043b0d4) {\n    free_environment<wchar_t>((wchar_t **)*param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "common_get_or_create_environment_nolock<char>",
      "entry": "00410b77",
      "c": "\nchar ** __cdecl common_get_or_create_environment_nolock<char>(void)\n\n{\n  int iVar1;\n  \n  if (DAT_0043b0cc != (char **)0x0) {\n    return DAT_0043b0cc;\n  }\n  if ((DAT_0043b0d0 != 0) && (iVar1 = common_initialize_environment_nolock<char>(), iVar1 == 0)) {\n    iVar1 = initialize_environment_by_cloning_nolock<char>();\n    return (char **)(~-(uint)(iVar1 != 0) & (uint)DAT_0043b0cc);\n  }\n  return (char **)0x0;\n}\n\n"
    },
    {
      "name": "common_get_or_create_environment_nolock<wchar_t>",
      "entry": "00410b7c",
      "c": "\nwchar_t ** __cdecl common_get_or_create_environment_nolock<wchar_t>(void)\n\n{\n  int iVar1;\n  \n  if (DAT_0043b0d0 != (wchar_t **)0x0) {\n    return DAT_0043b0d0;\n  }\n  if ((DAT_0043b0cc != 0) && (iVar1 = common_initialize_environment_nolock<wchar_t>(), iVar1 == 0))\n  {\n    iVar1 = initialize_environment_by_cloning_nolock<wchar_t>();\n    return (wchar_t **)(~-(uint)(iVar1 != 0) & (uint)DAT_0043b0d0);\n  }\n  return (wchar_t **)0x0;\n}\n\n"
    },
    {
      "name": "FUN_00410b81",
      "entry": "00410b81",
      "c": "\nvoid FUN_00410b81(void)\n\n{\n  uninitialize<>(&DAT_0043b0cc,uninitialize_environment_internal<>);\n  uninitialize<>(&DAT_0043b0d0,uninitialize_environment_internal<>);\n  free_environment<wchar_t>(DAT_0043b0d8);\n  free_environment<wchar_t>(DAT_0043b0d4);\n  return;\n}\n\n"
    },
    {
      "name": "FID_conflict:__get_initial_narrow_environment",
      "entry": "00410bb8",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    __get_initial_narrow_environment\n    __get_initial_wide_environment\n   \n   Library: Visual Studio 2015 Release */\n\nvoid FID_conflict___get_initial_narrow_environment(void)\n\n{\n  if (DAT_0043b0d4 == (wchar_t **)0x0) {\n    DAT_0043b0d4 = common_get_or_create_environment_nolock<wchar_t>();\n  }\n  return;\n}\n\n"
    },
    {
      "name": "common_initialize_environment_nolock<wchar_t>",
      "entry": "00410bcc",
      "c": "\nint __cdecl common_initialize_environment_nolock<wchar_t>(void)\n\n{\n  wchar_t *_Memory;\n  wchar_t **ppwVar1;\n  int iVar2;\n  \n  if (DAT_0043b0d0 != 0) {\n    return 0;\n  }\n  _Memory = (wchar_t *)___dcrt_get_wide_environment_from_os();\n  if (_Memory == (wchar_t *)0x0) {\n    iVar2 = -1;\n  }\n  else {\n    ppwVar1 = create_environment<wchar_t>(_Memory);\n    if (ppwVar1 == (wchar_t **)0x0) {\n      iVar2 = -1;\n    }\n    else {\n      DAT_0043b0d4 = ppwVar1;\n      initialize(&DAT_0043b0d0,ppwVar1);\n      iVar2 = 0;\n    }\n    FID_conflict__free((void *)0x0);\n  }\n  FID_conflict__free(_Memory);\n  return iVar2;\n}\n\n"
    },
    {
      "name": "__initterm",
      "entry": "00410bd1",
      "c": "\n/* Library Function - Single Match\n    __initterm\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __initterm(undefined4 *param_1,undefined4 *param_2)\n\n{\n  code *pcVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar2 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  uVar4 = 0;\n  uVar3 = ~-(uint)(param_2 < param_1) & (uint)((int)param_2 + (3 - (int)param_1)) >> 2;\n  if (uVar3 != 0) {\n    do {\n      pcVar1 = (code *)*param_1;\n      if (pcVar1 != (code *)0x0) {\n        (*(code *)PTR_guard_check_icall_0042118c)();\n        (*pcVar1)();\n      }\n      param_1 = param_1 + 1;\n      uVar4 = uVar4 + 1;\n    } while (uVar4 != uVar3);\n  }\n  __security_check_cookie(uVar2 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "__initterm_e",
      "entry": "00410c2d",
      "c": "\n/* Library Function - Single Match\n    __initterm_e\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __initterm_e(undefined4 *param_1,undefined4 *param_2)\n\n{\n  code *pcVar1;\n  uint uVar2;\n  int iVar3;\n  \n  uVar2 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  for (; param_1 != param_2; param_1 = param_1 + 1) {\n    pcVar1 = (code *)*param_1;\n    if (pcVar1 != (code *)0x0) {\n      (*(code *)PTR_guard_check_icall_0042118c)();\n      iVar3 = (*pcVar1)();\n      if (iVar3 != 0) break;\n    }\n  }\n  __security_check_cookie(uVar2 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "atexit_exception_filter",
      "entry": "00410c72",
      "c": "\n/* Library Function - Single Match\n    int __cdecl atexit_exception_filter(unsigned long)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl atexit_exception_filter(ulong param_1)\n\n{\n  return (uint)(param_1 == 0xe06d7363);\n}\n\n"
    },
    {
      "name": "common_exit",
      "entry": "00410c85",
      "c": "\n/* WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4 */\n/* Library Function - Single Match\n    void __cdecl common_exit(int,enum _crt_exit_cleanup_mode,enum _crt_exit_return_mode)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl common_exit(int param_1,_crt_exit_cleanup_mode param_2,_crt_exit_return_mode param_3)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint uVar3;\n  undefined4 *local_18;\n  \n  if ((param_3 == 0) && (uVar3 = ___scrt_is_managed_app(), (char)uVar3 != '\\0')) {\n    try_cor_exit_process(param_1);\n  }\n  ___acrt_lock(2);\n  if (DAT_0043b0e4 != '\\0') goto LAB_00410d5c;\n  LOCK();\n  DAT_0043b0dc = 1;\n  UNLOCK();\n  if (param_2 == 0) {\n    bVar2 = (byte)DAT_0042d008 & 0x1f;\n    bVar1 = 0x20 - bVar2 & 0x1f;\n    if (DAT_0043b0e0 != ((0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0042d008)) {\n      uVar3 = DAT_0042d008 ^ DAT_0043b0e0;\n      (*(code *)PTR_guard_check_icall_0042118c)(0,0,0);\n      (*(code *)(uVar3 >> bVar2 | uVar3 << 0x20 - bVar2))();\n    }\nLAB_00410d21:\n    __execute_onexit_table();\n  }\n  else if (param_2 == 1) goto LAB_00410d21;\n  if (param_2 == 0) {\n    __initterm((undefined4 *)&DAT_004211bc,(undefined4 *)&DAT_004211d0);\n  }\n  __initterm((undefined4 *)&DAT_004211d4,(undefined4 *)&DAT_004211d8);\n  if (param_3 == 0) {\n    DAT_0043b0e4 = '\\x01';\n  }\nLAB_00410d5c:\n  FUN_00410d8f();\n  if (param_3 != 0) {\n    FUN_0041ffc9();\n    return;\n  }\n  exit_or_terminate_process(param_1);\n  atexit_exception_filter(*(ulong *)*local_18);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00410d8f",
      "entry": "00410d8f",
      "c": "\nvoid FUN_00410d8f(void)\n\n{\n  ___acrt_unlock(2);\n  return;\n}\n\n"
    },
    {
      "name": "exit_or_terminate_process",
      "entry": "00410d9e",
      "c": "\n/* Library Function - Single Match\n    void __cdecl exit_or_terminate_process(unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl exit_or_terminate_process(uint param_1)\n\n{\n  char cVar1;\n  HANDLE hProcess;\n  undefined4 in_ECX;\n  uint uExitCode;\n  \n  cVar1 = ___acrt_is_packaged_app(in_ECX);\n  if ((cVar1 != '\\0') && ((*(uint *)((int)ProcessEnvironmentBlock + 0x68) >> 8 & 1) == 0)) {\n    uExitCode = param_1;\n    hProcess = GetCurrentProcess();\n    TerminateProcess(hProcess,uExitCode);\n  }\n  try_cor_exit_process(param_1);\n                    /* WARNING: Subroutine does not return */\n  ExitProcess(param_1);\n}\n\n"
    },
    {
      "name": "___scrt_is_managed_app",
      "entry": "00410ddf",
      "c": "\n/* Library Function - Single Match\n    ___scrt_is_managed_app\n   \n   Library: Visual Studio 2015 Release */\n\nuint ___scrt_is_managed_app(void)\n\n{\n  HMODULE pHVar1;\n  HMODULE pHVar2;\n  \n  pHVar1 = GetModuleHandleW((LPCWSTR)0x0);\n  pHVar2 = pHVar1;\n  if ((((pHVar1 != (HMODULE)0x0) && (pHVar2 = (HMODULE)0x5a4d, (short)pHVar1->unused == 0x5a4d)) &&\n      (pHVar2 = (HMODULE)((int)&pHVar1->unused + pHVar1[0xf].unused), pHVar2->unused == 0x4550)) &&\n     (((short)pHVar2[6].unused == 0x10b && (0xe < (uint)pHVar2[0x1d].unused)))) {\n    return CONCAT31((int3)((uint)pHVar2 >> 8),pHVar2[0x3a].unused != 0);\n  }\n  return (uint)pHVar2 & 0xffffff00;\n}\n\n"
    },
    {
      "name": "try_cor_exit_process",
      "entry": "00410e23",
      "c": "\n/* Library Function - Single Match\n    void __cdecl try_cor_exit_process(unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl try_cor_exit_process(uint param_1)\n\n{\n  BOOL BVar1;\n  FARPROC pFVar2;\n  HMODULE local_c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_c = (HMODULE)0x0;\n  BVar1 = GetModuleHandleExW(0,L\"mscoree.dll\",&local_c);\n  if ((BVar1 != 0) && (pFVar2 = GetProcAddress(local_c,\"CorExitProcess\"), pFVar2 != (FARPROC)0x0)) {\n    (*(code *)PTR_guard_check_icall_0042118c)(param_1);\n    (*pFVar2)();\n  }\n  if (local_c != (HMODULE)0x0) {\n    FreeLibrary(local_c);\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00410e8d",
      "entry": "00410e8d",
      "c": "\nvoid __cdecl FUN_00410e8d(undefined4 param_1)\n\n{\n  DAT_0043b0e0 = param_1;\n  return;\n}\n\n"
    },
    {
      "name": "__cexit",
      "entry": "00410eab",
      "c": "\n/* Library Function - Single Match\n    __cexit\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __cexit(void)\n\n{\n  common_exit(0,0,1);\n  return;\n}\n\n"
    },
    {
      "name": "__exit",
      "entry": "00410eba",
      "c": "\n/* Library Function - Single Match\n    __exit\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __exit(int param_1)\n\n{\n  common_exit(param_1,2,0);\n  return;\n}\n\n"
    },
    {
      "name": "__register_thread_local_exe_atexit_callback",
      "entry": "00410ed0",
      "c": "\n/* WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4 */\n/* Library Function - Single Match\n    __register_thread_local_exe_atexit_callback\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __register_thread_local_exe_atexit_callback(uint param_1)\n\n{\n  code *pcVar1;\n  byte bVar2;\n  __acrt_ptd *p_Var3;\n  \n  bVar2 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n  if (DAT_0043b0e0 == ((0U >> bVar2 | 0 << 0x20 - bVar2) ^ DAT_0042d008)) {\n    DAT_0043b0e0 = __crt_fast_encode_pointer<>(param_1);\n    return;\n  }\n  p_Var3 = ___acrt_getptd();\n  pcVar1 = *(code **)(p_Var3 + 0xc);\n  if (pcVar1 != (code *)0x0) {\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    (*pcVar1)();\n  }\n                    /* WARNING: Subroutine does not return */\n  _abort();\n}\n\n"
    },
    {
      "name": "_exit",
      "entry": "00410f08",
      "c": "\n/* Library Function - Single Match\n    _exit\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl _exit(int _Code)\n\n{\n  common_exit(_Code,0,0);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_set_locale_changed",
      "entry": "00410f1e",
      "c": "\n/* Library Function - Single Match\n    ___acrt_set_locale_changed\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 ___acrt_set_locale_changed(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = DAT_0043b0e8;\n  LOCK();\n  DAT_0043b0e8 = 1;\n  UNLOCK();\n  return uVar1;\n}\n\n"
    },
    {
      "name": "FUN_00410f72",
      "entry": "00410f72",
      "c": "\nvoid FUN_00410f72(void)\n\n{\n  ___acrt_unlock(4);\n  return;\n}\n\n"
    },
    {
      "name": "__configthreadlocale",
      "entry": "00410f7b",
      "c": "\n/* Library Function - Single Match\n    __configthreadlocale\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __configthreadlocale(int _Flag)\n\n{\n  uint uVar1;\n  __acrt_ptd *p_Var2;\n  int *piVar3;\n  uint uVar4;\n  \n  p_Var2 = ___acrt_getptd();\n  uVar1 = *(uint *)(p_Var2 + 0x350);\n  if (_Flag == -1) {\n    DAT_0042d30c = 0xffffffff;\n  }\n  else if (_Flag != 0) {\n    if (_Flag == 1) {\n      uVar4 = uVar1 | 2;\n    }\n    else {\n      if (_Flag != 2) {\n        piVar3 = __errno();\n        *piVar3 = 0x16;\n        FUN_00412362();\n        return -1;\n      }\n      uVar4 = uVar1 & 0xfffffffd;\n    }\n    *(uint *)(p_Var2 + 0x350) = uVar4;\n  }\n  return ((uVar1 & 2) == 0) + 1;\n}\n\n"
    },
    {
      "name": "FUN_00410fdd",
      "entry": "00410fdd",
      "c": "\nundefined4 FUN_00410fdd(void)\n\n{\n  return DAT_0043b0ec;\n}\n\n"
    },
    {
      "name": "__set_new_mode",
      "entry": "00410fe3",
      "c": "\n/* Library Function - Single Match\n    __set_new_mode\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined4 __cdecl __set_new_mode(int param_1)\n\n{\n  undefined4 uVar1;\n  int *piVar2;\n  \n  uVar1 = DAT_0043b0ec;\n  if ((param_1 != 0) && (param_1 != 1)) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    return 0xffffffff;\n  }\n  LOCK();\n  DAT_0043b0ec = param_1;\n  UNLOCK();\n  return uVar1;\n}\n\n"
    },
    {
      "name": "FUN_00411012",
      "entry": "00411012",
      "c": "\nundefined4 * FUN_00411012(void)\n\n{\n  return &DAT_0043b0f0;\n}\n\n"
    },
    {
      "name": "operator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>",
      "entry": "00411018",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_800076c951b434888f4765a74a194fcc>,class <lambda_4e60a939b0d047cfe11ddc22648dfba9> &,class\n   <lambda_6dbb1268764f43b569ce7b67e331d33a> >(class <lambda_800076c951b434888f4765a74a194fcc>\n   &&,class <lambda_4e60a939b0d047cfe11ddc22648dfba9> &,class\n   <lambda_6dbb1268764f43b569ce7b67e331d33a> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_800076c951b434888f4765a74a194fcc> *param_1,\n          <lambda_4e60a939b0d047cfe11ddc22648dfba9> *param_2,\n          <lambda_6dbb1268764f43b569ce7b67e331d33a> *param_3)\n\n{\n  int iVar1;\n  \n  ___acrt_lock(*(int *)param_1);\n  iVar1 = <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()(param_2);\n  FUN_0041105d();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0041105d",
      "entry": "0041105d",
      "c": "\nvoid FUN_0041105d(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "operator()<class_<lambda_995298e7d72eb4c2aab26c0585b3abe5>,class_<lambda_275893d493268fdec8709772e3fcec0e>&,class_<lambda_293819299cbf9a7022e18b56a874bb5c>_>",
      "entry": "00411069",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_995298e7d72eb4c2aab26c0585b3abe5>,class <lambda_275893d493268fdec8709772e3fcec0e> &,class\n   <lambda_293819299cbf9a7022e18b56a874bb5c> >(class <lambda_995298e7d72eb4c2aab26c0585b3abe5>\n   &&,class <lambda_275893d493268fdec8709772e3fcec0e> &,class\n   <lambda_293819299cbf9a7022e18b56a874bb5c> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_995298e7d72eb4c2aab26c0585b3abe5>,class_<lambda_275893d493268fdec8709772e3fcec0e>&,class_<lambda_293819299cbf9a7022e18b56a874bb5c>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_995298e7d72eb4c2aab26c0585b3abe5> *param_1,\n          <lambda_275893d493268fdec8709772e3fcec0e> *param_2,\n          <lambda_293819299cbf9a7022e18b56a874bb5c> *param_3)\n\n{\n  int iVar1;\n  \n  ___acrt_lock(*(int *)param_1);\n  iVar1 = <lambda_275893d493268fdec8709772e3fcec0e>::operator()(param_2);\n  FUN_004110ae();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_004110ae",
      "entry": "004110ae",
      "c": "\nvoid FUN_004110ae(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>",
      "entry": "004110ba",
      "c": "\n/* Library Function - Single Match\n    int __cdecl __acrt_lock_and_call<class <lambda_275893d493268fdec8709772e3fcec0e> >(enum\n   __acrt_lock_id,class <lambda_275893d493268fdec8709772e3fcec0e> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n__acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>\n          (__acrt_lock_id param_1,<lambda_275893d493268fdec8709772e3fcec0e> *param_2)\n\n{\n  int iVar1;\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  __crt_seh_guarded_call<int> local_5;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  iVar1 = __crt_seh_guarded_call<int>::\n          operator()<class_<lambda_995298e7d72eb4c2aab26c0585b3abe5>,class_<lambda_275893d493268fdec8709772e3fcec0e>&,class_<lambda_293819299cbf9a7022e18b56a874bb5c>_>\n                    (&local_5,(<lambda_995298e7d72eb4c2aab26c0585b3abe5> *)&local_10,param_2,\n                     (<lambda_293819299cbf9a7022e18b56a874bb5c> *)&local_c);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>",
      "entry": "004110e2",
      "c": "\n/* Library Function - Single Match\n    int __cdecl __acrt_lock_and_call<class <lambda_4e60a939b0d047cfe11ddc22648dfba9> >(enum\n   __acrt_lock_id,class <lambda_4e60a939b0d047cfe11ddc22648dfba9> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n__acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>\n          (__acrt_lock_id param_1,<lambda_4e60a939b0d047cfe11ddc22648dfba9> *param_2)\n\n{\n  int iVar1;\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  __crt_seh_guarded_call<int> local_5;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  iVar1 = __crt_seh_guarded_call<int>::\n          operator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>\n                    (&local_5,(<lambda_800076c951b434888f4765a74a194fcc> *)&local_10,param_2,\n                     (<lambda_6dbb1268764f43b569ce7b67e331d33a> *)&local_c);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "operator()",
      "entry": "0041110a",
      "c": "\n/* Library Function - Single Match\n    public: int __thiscall <lambda_275893d493268fdec8709772e3fcec0e>::operator()(void)const \n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n<lambda_275893d493268fdec8709772e3fcec0e>::operator()\n          (<lambda_275893d493268fdec8709772e3fcec0e> *this)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint *puVar5;\n  int iVar6;\n  sbyte sVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint *_Memory;\n  uint local_18;\n  \n  uVar3 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  puVar8 = (uint *)**(int **)this;\n  if (puVar8 != (uint *)0x0) {\n    local_18 = DAT_0042d008 & 0x1f;\n    sVar7 = (sbyte)local_18;\n    _Memory = (uint *)((*puVar8 ^ DAT_0042d008) >> sVar7 | (*puVar8 ^ DAT_0042d008) << 0x20 - sVar7)\n    ;\n    puVar8 = (uint *)((puVar8[1] ^ DAT_0042d008) >> sVar7 |\n                     (puVar8[1] ^ DAT_0042d008) << 0x20 - sVar7);\n    if ((_Memory != (uint *)0x0) && (puVar9 = puVar8, _Memory != (uint *)0xffffffff)) {\n      do {\n        sVar7 = (sbyte)local_18;\n        bVar2 = 0x20U - sVar7 & 0x1f;\n        uVar4 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ DAT_0042d008;\n        do {\n          puVar8 = puVar8 + -1;\n          if (puVar8 < _Memory) {\n            if (_Memory != (uint *)0xffffffff) {\n              FID_conflict__free(_Memory);\n            }\n            bVar2 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n            uVar4 = (0U >> bVar2 | 0 << 0x20 - bVar2) ^ DAT_0042d008;\n            *(uint *)**(undefined4 **)this = uVar4;\n            *(uint *)(**(int **)this + 4) = uVar4;\n            *(uint *)(**(int **)this + 8) = uVar4;\n            goto LAB_0041121b;\n          }\n        } while (*puVar8 == uVar4);\n        uVar10 = *puVar8 ^ DAT_0042d008;\n        *puVar8 = uVar4;\n        (*(code *)PTR_guard_check_icall_0042118c)();\n        (*(code *)(uVar10 >> sVar7 | uVar10 << 0x20 - sVar7))();\n        local_18 = DAT_0042d008 & 0x1f;\n        uVar10 = *(uint *)**(int **)this ^ DAT_0042d008;\n        uVar4 = ((uint *)**(int **)this)[1] ^ DAT_0042d008;\n        sVar7 = (sbyte)local_18;\n        puVar1 = (uint *)(uVar10 >> sVar7 | uVar10 << 0x20 - sVar7);\n        puVar5 = (uint *)(uVar4 >> sVar7 | uVar4 << 0x20 - sVar7);\n        if ((puVar1 != _Memory) || (puVar5 != puVar9)) {\n          puVar8 = puVar5;\n          _Memory = puVar1;\n          puVar9 = puVar5;\n        }\n      } while( true );\n    }\n  }\nLAB_0041121b:\n  iVar6 = __security_check_cookie(uVar3 ^ (uint)&stack0xfffffffc);\n  return iVar6;\n}\n\n"
    },
    {
      "name": "operator()",
      "entry": "0041122a",
      "c": "\n/* Library Function - Single Match\n    public: int __thiscall <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()(void)const \n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n<lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()\n          (<lambda_4e60a939b0d047cfe11ddc22648dfba9> *this)\n\n{\n  LPCVOID pvVar1;\n  uint uVar2;\n  uint uVar3;\n  void *pvVar4;\n  byte bVar5;\n  uint *puVar6;\n  LPCVOID pvVar7;\n  uint *puVar8;\n  uint uVar9;\n  uint *puVar10;\n  \n  puVar6 = (uint *)**(int **)this;\n  if (puVar6 == (uint *)0x0) {\n    return -1;\n  }\n  bVar5 = (byte)DAT_0042d008 & 0x1f;\n  puVar10 = (uint *)((puVar6[1] ^ DAT_0042d008) >> bVar5 |\n                    (puVar6[1] ^ DAT_0042d008) << 0x20 - bVar5);\n  puVar8 = (uint *)((puVar6[2] ^ DAT_0042d008) >> bVar5 | (puVar6[2] ^ DAT_0042d008) << 0x20 - bVar5\n                   );\n  pvVar7 = (LPCVOID)((*puVar6 ^ DAT_0042d008) >> bVar5 | (*puVar6 ^ DAT_0042d008) << 0x20 - bVar5);\n  pvVar1 = pvVar7;\n  if (puVar10 != puVar8) goto LAB_00411324;\n  uVar9 = (int)puVar8 - (int)pvVar7 >> 2;\n  uVar2 = 0x200;\n  if (uVar9 < 0x201) {\n    uVar2 = uVar9;\n  }\n  uVar2 = uVar2 + uVar9;\n  if (uVar2 == 0) {\n    uVar2 = 0x20;\n  }\n  if (uVar2 < uVar9) {\nLAB_004112ab:\n    uVar2 = uVar9 + 4;\n    pvVar1 = FUN_00419319(pvVar7,uVar2,4);\n    FID_conflict__free((void *)0x0);\n    if (pvVar1 == (LPVOID)0x0) {\n      return -1;\n    }\n  }\n  else {\n    pvVar1 = FUN_00419319(pvVar7,uVar2,4);\n    FID_conflict__free((void *)0x0);\n    if (pvVar1 == (LPVOID)0x0) goto LAB_004112ab;\n  }\n  puVar10 = (uint *)((int)pvVar1 + uVar9 * 4);\n  puVar8 = (uint *)((int)pvVar1 + uVar2 * 4);\n  bVar5 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n  uVar2 = (0U >> bVar5 | 0 << 0x20 - bVar5) ^ DAT_0042d008;\n  uVar9 = ~-(uint)(puVar8 < puVar10) & (uint)((int)puVar8 + (3 - (int)puVar10)) >> 2;\n  if (uVar9 != 0) {\n    uVar3 = 0;\n    puVar6 = puVar10;\n    do {\n      uVar3 = uVar3 + 1;\n      *puVar6 = uVar2;\n      puVar6 = puVar6 + 1;\n    } while (uVar3 != uVar9);\n  }\nLAB_00411324:\n  uVar2 = __crt_fast_encode_pointer<>(**(uint **)(this + 4));\n  *puVar10 = uVar2;\n  pvVar4 = __crt_fast_encode_pointer<void*>(pvVar1);\n  *(void **)**(undefined4 **)this = pvVar4;\n  pvVar4 = __crt_fast_encode_pointer<void*>(puVar10 + 1);\n  *(void **)(**(int **)this + 4) = pvVar4;\n  pvVar4 = __crt_fast_encode_pointer<void*>(puVar8);\n  *(void **)(**(int **)this + 8) = pvVar4;\n  return 0;\n}\n\n"
    },
    {
      "name": "__crt_atexit",
      "entry": "0041136b",
      "c": "\n/* Library Function - Single Match\n    __crt_atexit\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __crt_atexit(void)\n\n{\n  __register_onexit_function();\n  return;\n}\n\n"
    },
    {
      "name": "__execute_onexit_table",
      "entry": "00411381",
      "c": "\n/* Library Function - Single Match\n    __execute_onexit_table\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __execute_onexit_table(void)\n\n{\n  undefined1 *local_8;\n  \n  local_8 = &stack0x00000004;\n  __acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>\n            (2,(<lambda_275893d493268fdec8709772e3fcec0e> *)&local_8);\n  return;\n}\n\n"
    },
    {
      "name": "__initialize_onexit_table",
      "entry": "0041139e",
      "c": "\n/* Library Function - Single Match\n    __initialize_onexit_table\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl __initialize_onexit_table(uint *param_1)\n\n{\n  byte bVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  \n  if (param_1 == (uint *)0x0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    if (*param_1 == param_1[2]) {\n      bVar1 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n      uVar3 = (0U >> bVar1 | 0 << 0x20 - bVar1) ^ DAT_0042d008;\n      *param_1 = uVar3;\n      param_1[1] = uVar3;\n      param_1[2] = uVar3;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n"
    },
    {
      "name": "__register_onexit_function",
      "entry": "004113db",
      "c": "\n/* Library Function - Single Match\n    __register_onexit_function\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __register_onexit_function(void)\n\n{\n  undefined1 *local_c;\n  undefined1 *local_8;\n  \n  local_c = &stack0x00000004;\n  local_8 = &stack0x00000008;\n  __acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>\n            (2,(<lambda_4e60a939b0d047cfe11ddc22648dfba9> *)&local_c);\n  return;\n}\n\n"
    },
    {
      "name": "initialize",
      "entry": "004114f0",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    public: void __thiscall __crt_state_management::dual_state_global<char * *>::initialize(char * *\n   const)\n    public: void __thiscall __crt_state_management::dual_state_global<wchar_t *\n   *>::initialize(wchar_t * * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall initialize(void *this,undefined4 param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar2 = 0;\n  uVar1 = ~-(uint)((void *)((int)this + 4U) < this) &\n          (uint)((int)((int)this + 4U) + (3 - (int)this)) >> 2;\n  if (uVar1 != 0) {\n    do {\n      uVar2 = uVar2 + 1;\n      *(undefined4 *)this = param_1;\n      this = (void *)((int)this + 4);\n    } while (uVar2 != uVar1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_initialize",
      "entry": "00411521",
      "c": "\n/* Library Function - Single Match\n    ___acrt_initialize\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_initialize(void)\n\n{\n  ___acrt_execute_initializers(&PTR_LAB_00426818,&DAT_00426890);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_uninitialize",
      "entry": "00411533",
      "c": "\n/* Library Function - Single Match\n    ___acrt_uninitialize\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_uninitialize(void)\n\n{\n  ___acrt_execute_uninitializers(&PTR_LAB_00426818,&DAT_00426890);\n  return;\n}\n\n"
    },
    {
      "name": "__controlfp_s",
      "entry": "00411545",
      "c": "\n/* Library Function - Single Match\n    __controlfp_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl __controlfp_s(uint *_CurrentState,uint _NewValue,uint _Mask)\n\n{\n  int *piVar1;\n  errno_t eVar2;\n  uint uVar3;\n  \n  uVar3 = _Mask & 0xfff7ffff;\n  if ((_NewValue & uVar3 & 0xfcf0fce0) == 0) {\n    if (_CurrentState == (uint *)0x0) {\n      __control87(_NewValue,uVar3);\n    }\n    else {\n      uVar3 = __control87(_NewValue,uVar3);\n      *_CurrentState = uVar3;\n    }\n    eVar2 = 0;\n  }\n  else {\n    if (_CurrentState != (uint *)0x0) {\n      uVar3 = __control87(0,0);\n      *_CurrentState = uVar3;\n    }\n    piVar1 = __errno();\n    eVar2 = 0x16;\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  return eVar2;\n}\n\n"
    },
    {
      "name": "terminate",
      "entry": "004115a4",
      "c": "\n/* WARNING: Function: __SEH_prolog4_GS replaced with injection: SEH_prolog4 */\n/* Library Function - Single Match\n    _terminate\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl terminate(void)\n\n{\n  code *pcVar1;\n  __acrt_ptd *p_Var2;\n  \n  p_Var2 = ___acrt_getptd();\n  pcVar1 = *(code **)(p_Var2 + 0xc);\n  if (pcVar1 != (code *)0x0) {\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    (*pcVar1)();\n  }\n                    /* WARNING: Subroutine does not return */\n  _abort();\n}\n\n"
    },
    {
      "name": "FID_conflict:_free",
      "entry": "004115e0",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    __free_base\n    _free\n   \n   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,\n   Visual Studio 2019 Release */\n\nvoid __cdecl FID_conflict__free(void *_Memory)\n\n{\n  BOOL BVar1;\n  int *piVar2;\n  DWORD DVar3;\n  int iVar4;\n  \n  if (_Memory != (void *)0x0) {\n    BVar1 = HeapFree(DAT_0043b564,0,_Memory);\n    if (BVar1 == 0) {\n      piVar2 = __errno();\n      DVar3 = GetLastError();\n      iVar4 = FID_conflict____acrt_errno_from_os_error(DVar3);\n      *piVar2 = iVar4;\n    }\n  }\n  return;\n}\n\n"
    },
    {
      "name": "__malloc_base",
      "entry": "0041161a",
      "c": "\n/* Library Function - Single Match\n    __malloc_base\n   \n   Library: Visual Studio 2015 Release */\n\nLPVOID __cdecl __malloc_base(size_t param_1)\n\n{\n  int iVar1;\n  LPVOID pvVar2;\n  int *piVar3;\n  \n  if (param_1 < 0xffffffe1) {\n    if (param_1 == 0) {\n      param_1 = 1;\n    }\n    do {\n      pvVar2 = HeapAlloc(DAT_0043b564,0,param_1);\n      if (pvVar2 != (LPVOID)0x0) {\n        return pvVar2;\n      }\n      iVar1 = FUN_00410fdd();\n    } while ((iVar1 != 0) && (iVar1 = __callnewh(param_1), iVar1 != 0));\n  }\n  piVar3 = __errno();\n  *piVar3 = 0xc;\n  return (LPVOID)0x0;\n}\n\n"
    },
    {
      "name": "_strcpy_s",
      "entry": "00411668",
      "c": "\n/* Library Function - Single Match\n    _strcpy_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)\n\n{\n  char cVar1;\n  int *piVar2;\n  char *pcVar3;\n  int iVar4;\n  \n  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {\n    if (_Src != (char *)0x0) {\n      pcVar3 = _Dst;\n      do {\n        cVar1 = pcVar3[(int)_Src - (int)_Dst];\n        *pcVar3 = cVar1;\n        pcVar3 = pcVar3 + 1;\n        if (cVar1 == '\\0') break;\n        _SizeInBytes = _SizeInBytes - 1;\n      } while (_SizeInBytes != 0);\n      if (_SizeInBytes != 0) {\n        return 0;\n      }\n      *_Dst = '\\0';\n      piVar2 = __errno();\n      iVar4 = 0x22;\n      goto LAB_0041168d;\n    }\n    *_Dst = '\\0';\n  }\n  piVar2 = __errno();\n  iVar4 = 0x16;\nLAB_0041168d:\n  *piVar2 = iVar4;\n  FUN_00412362();\n  return iVar4;\n}\n\n"
    },
    {
      "name": "_abort",
      "entry": "004116c2",
      "c": "\n/* Library Function - Single Match\n    _abort\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl _abort(void)\n\n{\n  code *pcVar1;\n  int iVar2;\n  BOOL BVar3;\n  \n  iVar2 = ___acrt_get_sigabrt_handler();\n  if (iVar2 != 0) {\n    _raise(0x16);\n  }\n  if ((DAT_0042d100 & 2) != 0) {\n    BVar3 = IsProcessorFeaturePresent(0x17);\n    if (BVar3 != 0) {\n      pcVar1 = (code *)swi(0x29);\n      (*pcVar1)();\n    }\n    ___acrt_call_reportfault(3,0x40000015,1);\n  }\n  __exit(3);\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n"
    },
    {
      "name": "__calloc_base",
      "entry": "00411705",
      "c": "\n/* Library Function - Single Match\n    __calloc_base\n   \n   Library: Visual Studio 2015 Release */\n\nLPVOID __cdecl __calloc_base(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  LPVOID pvVar2;\n  int *piVar3;\n  size_t dwBytes;\n  \n  if ((param_1 == 0) || (param_2 <= 0xffffffe0 / param_1)) {\n    dwBytes = param_1 * param_2;\n    if (dwBytes == 0) {\n      dwBytes = 1;\n    }\n    do {\n      pvVar2 = HeapAlloc(DAT_0043b564,8,dwBytes);\n      if (pvVar2 != (LPVOID)0x0) {\n        return pvVar2;\n      }\n      iVar1 = FUN_00410fdd();\n    } while ((iVar1 != 0) && (iVar1 = __callnewh(dwBytes), iVar1 != 0));\n  }\n  piVar3 = __errno();\n  *piVar3 = 0xc;\n  return (LPVOID)0x0;\n}\n\n"
    },
    {
      "name": "is_overflow_condition<unsigned_long>",
      "entry": "00411762",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __crt_strtox::is_overflow_condition<unsigned long>(unsigned int,unsigned long)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __crt_strtox::is_overflow_condition<unsigned_long>(uint param_1,ulong param_2)\n\n{\n  if (((param_1 & 4) == 0) &&\n     (((param_1 & 1) == 0 ||\n      ((((param_1 & 2) == 0 || (param_2 < 0x80000001)) &&\n       (((param_1 & 2) != 0 || (param_2 < 0x80000000)))))))) {\n    return false;\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "make_c_string_character_source<>",
      "entry": "00411795",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    class __crt_strtox::c_string_character_source<char> __cdecl\n   __crt_strtox::make_c_string_character_source<char,std::nullptr_t>(char const *\n   const,std::nullptr_t)\n    class __crt_strtox::c_string_character_source<char> __cdecl\n   __crt_strtox::make_c_string_character_source<char,char * *>(char const * const,char * * const)\n    class __crt_strtox::c_string_character_source<wchar_t> __cdecl\n   __crt_strtox::make_c_string_character_source<wchar_t,std::nullptr_t>(wchar_t const *\n   const,std::nullptr_t)\n    class __crt_strtox::c_string_character_source<wchar_t> __cdecl\n   __crt_strtox::make_c_string_character_source<wchar_t,wchar_t * *>(wchar_t const * const,wchar_t *\n   * const)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl\nmake_c_string_character_source<>(undefined4 *param_1,undefined4 param_2,undefined4 *param_3)\n\n{\n  *param_1 = param_2;\n  param_1[1] = param_3;\n  if (param_3 != (undefined4 *)0x0) {\n    *param_3 = param_2;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>",
      "entry": "004117b0",
      "c": "\n/* Library Function - Single Match\n    unsigned long __cdecl __crt_strtox::parse_integer<unsigned long,class\n   __crt_strtox::c_string_character_source<char> >(struct __crt_locale_pointers * const,class\n   __crt_strtox::c_string_character_source<char>,int,bool)\n   \n   Library: Visual Studio 2015 Release */\n\nulong __cdecl\n__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>\n          (__crt_locale_pointers *param_1,byte *param_2,undefined4 *param_3,uint param_4,\n          char param_5)\n\n{\n  byte bVar1;\n  bool bVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte bVar7;\n  uint uVar8;\n  int local_2c;\n  localeinfo_struct local_28;\n  char local_20;\n  byte *local_1c;\n  uint local_18;\n  uint local_14;\n  uint local_10;\n  uint local_c;\n  byte local_8;\n  undefined3 uStack_7;\n  \n  bVar2 = c_string_character_source<wchar_t>::validate\n                    ((c_string_character_source<wchar_t> *)&param_2);\n  uVar8 = param_4;\n  if (bVar2) {\n    if ((param_4 == 0) || ((1 < (int)param_4 && ((int)param_4 < 0x25)))) {\n      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_2c,param_1);\n      local_10 = 0;\n      local_1c = param_2;\n      do {\n        bVar7 = *param_2;\n        param_2 = param_2 + 1;\n        _local_8 = CONCAT31(uStack_7,bVar7);\n        iVar4 = __ischartype_l((uint)bVar7,8,&local_28);\n      } while (iVar4 != 0);\n      local_c = (uint)(param_5 != '\\0');\n      if (bVar7 == 0x2d) {\n        local_c = local_c | 2;\nLAB_00411853:\n        bVar7 = *param_2;\n        param_2 = param_2 + 1;\n        _local_8 = CONCAT31(uStack_7,bVar7);\n      }\n      else if (bVar7 == 0x2b) goto LAB_00411853;\n      if ((uVar8 == 0) || (uVar8 == 0x10)) {\n        if ((byte)(bVar7 - 0x30) < 10) {\n          iVar4 = (char)bVar7 + -0x30;\n        }\n        else if ((byte)(bVar7 + 0x9f) < 0x1a) {\n          iVar4 = (char)bVar7 + -0x57;\n        }\n        else if ((byte)(bVar7 + 0xbf) < 0x1a) {\n          iVar4 = (char)bVar7 + -0x37;\n        }\n        else {\n          iVar4 = -1;\n        }\n        if (iVar4 == 0) {\n          bVar1 = *param_2;\n          local_14 = CONCAT31(local_14._1_3_,bVar1);\n          if ((bVar1 == 0x78) || (bVar1 == 0x58)) {\n            if (uVar8 == 0) {\n              uVar8 = 0x10;\n            }\n            bVar7 = param_2[1];\n            param_2 = param_2 + 2;\n            _local_8 = CONCAT31(uStack_7,bVar7);\n          }\n          else {\n            if (uVar8 == 0) {\n              uVar8 = 8;\n            }\n            param_2 = param_2 + 1;\n            c_string_character_source<char>::unget\n                      ((c_string_character_source<char> *)&param_2,bVar1);\n          }\n        }\n        else if (uVar8 == 0) {\n          uVar8 = 10;\n        }\n      }\n      local_14 = (uint)(0xffffffff / (ulonglong)uVar8);\n      local_18 = (uint)(0xffffffff % (ulonglong)uVar8);\n      while( true ) {\n        if ((byte)(bVar7 - 0x30) < 10) {\n          uVar5 = (int)(char)bVar7 - 0x30;\n        }\n        else if ((byte)(bVar7 + 0x9f) < 0x1a) {\n          uVar5 = (int)(char)bVar7 - 0x57;\n        }\n        else if ((byte)(bVar7 + 0xbf) < 0x1a) {\n          uVar5 = (int)(char)bVar7 - 0x37;\n        }\n        else {\n          uVar5 = 0xffffffff;\n        }\n        if ((uVar5 == 0xffffffff) || (uVar8 <= uVar5)) break;\n        uVar6 = local_c | 8;\n        if ((local_10 < local_14) || ((local_10 == local_14 && (uVar5 <= local_18)))) {\n          local_10 = local_10 * uVar8 + uVar5;\n        }\n        else {\n          uVar6 = local_c | 0xc;\n        }\n        bVar7 = *param_2;\n        param_2 = param_2 + 1;\n        _local_8 = CONCAT31(uStack_7,bVar7);\n        local_c = uVar6;\n      }\n      c_string_character_source<char>::unget\n                ((c_string_character_source<char> *)&param_2,(char)_local_8);\n      uVar5 = local_c;\n      uVar8 = local_10;\n      if ((local_c & 8) == 0) {\n        uVar8 = 0;\n        param_2 = local_1c;\n      }\n      else {\n        bVar2 = is_overflow_condition<unsigned_long>(local_c,local_10);\n        if (bVar2) {\n          piVar3 = __errno();\n          *piVar3 = 0x22;\n          if ((uVar5 & 1) == 0) {\n            uVar8 = 0xffffffff;\n          }\n          else if ((uVar5 & 2) == 0) {\n            uVar8 = 0x7fffffff;\n          }\n          else {\n            uVar8 = 0x80000000;\n          }\n        }\n        else if ((uVar5 & 2) != 0) {\n          uVar8 = -uVar8;\n        }\n      }\n      if (local_20 != '\\0') {\n        *(uint *)(local_2c + 0x350) = *(uint *)(local_2c + 0x350) & 0xfffffffd;\n      }\n      goto LAB_004117e9;\n    }\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    FUN_00412362();\n  }\n  uVar8 = 0;\nLAB_004117e9:\n  if (param_3 != (undefined4 *)0x0) {\n    *param_3 = param_2;\n  }\n  return uVar8;\n}\n\n"
    },
    {
      "name": "parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>",
      "entry": "004119d8",
      "c": "\n/* Library Function - Single Match\n    unsigned long __cdecl __crt_strtox::parse_integer<unsigned long,class\n   __crt_strtox::c_string_character_source<wchar_t> >(struct __crt_locale_pointers * const,class\n   __crt_strtox::c_string_character_source<wchar_t>,int,bool)\n   \n   Library: Visual Studio 2015 Release */\n\nulong __cdecl\n__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>\n          (__crt_locale_pointers *param_1,wchar_t *param_2,undefined4 *param_3,uint param_4,\n          char param_5)\n\n{\n  bool bVar1;\n  int *piVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  wchar_t wVar9;\n  int local_20 [3];\n  char local_14;\n  wchar_t *local_10;\n  uint local_c;\n  undefined4 local_8;\n  \n  bVar1 = c_string_character_source<wchar_t>::validate\n                    ((c_string_character_source<wchar_t> *)&param_2);\n  if (bVar1) {\n    if ((param_4 == 0) || ((1 < (int)param_4 && ((int)param_4 < 0x25)))) {\n      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_20,param_1);\n      local_c = 0;\n      local_10 = param_2;\n      do {\n        wVar9 = *param_2;\n        param_2 = param_2 + 1;\n        iVar3 = _iswctype(wVar9,8);\n      } while (iVar3 != 0);\n      uVar7 = (uint)(param_5 != '\\0');\n      if (wVar9 == L'-') {\n        uVar7 = uVar7 | 2;\nLAB_00411a71:\n        wVar9 = *param_2;\n        param_2 = param_2 + 1;\n      }\n      else if (wVar9 == L'+') goto LAB_00411a71;\n      uVar6 = (uint)(ushort)wVar9;\n      local_8 = 0x19;\n      if ((param_4 != 0) && (param_4 != 0x10)) goto LAB_00411d79;\n      if ((ushort)wVar9 < 0x30) goto LAB_00411cfc;\n      if ((ushort)wVar9 < 0x3a) {\n        iVar3 = uVar6 - 0x30;\nLAB_00411cf7:\n        if (iVar3 == -1) goto LAB_00411cfc;\n      }\n      else {\n        if (0xff0f < (ushort)wVar9) {\n          if ((ushort)wVar9 < 0xff1a) {\n            iVar3 = uVar6 - 0xff10;\n          }\n          else {\n            iVar3 = -1;\n          }\n          goto LAB_00411cf7;\n        }\n        if (0x65f < (ushort)wVar9) {\n          if ((ushort)wVar9 < 0x66a) {\n            iVar3 = uVar6 - 0x660;\n          }\n          else {\n            if ((ushort)wVar9 < 0x6f0) goto LAB_00411cfc;\n            if ((ushort)wVar9 < 0x6fa) {\n              iVar3 = uVar6 - 0x6f0;\n            }\n            else {\n              if ((ushort)wVar9 < 0x966) goto LAB_00411cfc;\n              if ((ushort)wVar9 < 0x970) {\n                iVar3 = uVar6 - 0x966;\n              }\n              else {\n                if ((ushort)wVar9 < 0x9e6) goto LAB_00411cfc;\n                if ((ushort)wVar9 < 0x9f0) {\n                  iVar3 = uVar6 - 0x9e6;\n                }\n                else {\n                  if ((ushort)wVar9 < 0xa66) goto LAB_00411cfc;\n                  if ((ushort)wVar9 < 0xa70) {\n                    iVar3 = uVar6 - 0xa66;\n                  }\n                  else {\n                    if ((ushort)wVar9 < 0xae6) goto LAB_00411cfc;\n                    if ((ushort)wVar9 < 0xaf0) {\n                      iVar3 = uVar6 - 0xae6;\n                    }\n                    else {\n                      if ((ushort)wVar9 < 0xb66) goto LAB_00411cfc;\n                      if ((ushort)wVar9 < 0xb70) {\n                        iVar3 = uVar6 - 0xb66;\n                      }\n                      else {\n                        if ((ushort)wVar9 < 0xc66) goto LAB_00411cfc;\n                        if ((ushort)wVar9 < 0xc70) {\n                          iVar3 = uVar6 - 0xc66;\n                        }\n                        else {\n                          if ((ushort)wVar9 < 0xce6) goto LAB_00411cfc;\n                          if ((ushort)wVar9 < 0xcf0) {\n                            iVar3 = uVar6 - 0xce6;\n                          }\n                          else {\n                            if ((ushort)wVar9 < 0xd66) goto LAB_00411cfc;\n                            if ((ushort)wVar9 < 0xd70) {\n                              iVar3 = uVar6 - 0xd66;\n                            }\n                            else {\n                              if ((ushort)wVar9 < 0xe50) goto LAB_00411cfc;\n                              if ((ushort)wVar9 < 0xe5a) {\n                                iVar3 = uVar6 - 0xe50;\n                              }\n                              else {\n                                if ((ushort)wVar9 < 0xed0) goto LAB_00411cfc;\n                                if ((ushort)wVar9 < 0xeda) {\n                                  iVar3 = uVar6 - 0xed0;\n                                }\n                                else {\n                                  if ((ushort)wVar9 < 0xf20) goto LAB_00411cfc;\n                                  if ((ushort)wVar9 < 0xf2a) {\n                                    iVar3 = uVar6 - 0xf20;\n                                  }\n                                  else {\n                                    if ((ushort)wVar9 < 0x1040) goto LAB_00411cfc;\n                                    if ((ushort)wVar9 < 0x104a) {\n                                      iVar3 = uVar6 - 0x1040;\n                                    }\n                                    else {\n                                      if ((ushort)wVar9 < 0x17e0) goto LAB_00411cfc;\n                                      if ((ushort)wVar9 < 0x17ea) {\n                                        iVar3 = uVar6 - 0x17e0;\n                                      }\n                                      else {\n                                        if (((ushort)wVar9 < 0x1810) || (0x1819 < (ushort)wVar9))\n                                        goto LAB_00411cfc;\n                                        iVar3 = uVar6 - 0x1810;\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          goto LAB_00411cf7;\n        }\nLAB_00411cfc:\n        if ((((ushort)wVar9 < 0x41) || (0x5a < (ushort)wVar9)) && (0x19 < (ushort)(wVar9 + L'\uff9f')))\n        {\n          iVar3 = -1;\n        }\n        else {\n          uVar4 = uVar6;\n          if ((ushort)(wVar9 + L'\uff9f') < 0x1a) {\n            uVar4 = uVar6 - 0x20;\n          }\n          iVar3 = uVar4 - 0x37;\n        }\n      }\n      if (iVar3 == 0) {\n        wVar9 = *param_2;\n        if ((wVar9 == L'x') || (wVar9 == L'X')) {\n          if (param_4 == 0) {\n            param_4 = 0x10;\n          }\n          uVar6 = (uint)(ushort)param_2[1];\n          param_2 = param_2 + 2;\n        }\n        else {\n          if (param_4 == 0) {\n            param_4 = 8;\n          }\n          param_2 = param_2 + 1;\n          c_string_character_source<wchar_t>::unget\n                    ((c_string_character_source<wchar_t> *)&param_2,wVar9);\n        }\n      }\n      else if (param_4 == 0) {\n        param_4 = 10;\n      }\nLAB_00411d79:\n      uVar4 = (uint)(0xffffffff / (ulonglong)param_4);\n      do {\n        wVar9 = (wchar_t)uVar6;\n        if ((ushort)wVar9 < 0x30) goto LAB_00411fe4;\n        if ((ushort)wVar9 < 0x3a) {\n          uVar5 = uVar6 - 0x30;\nLAB_00411fdf:\n          if (uVar5 == 0xffffffff) goto LAB_00411fe4;\n        }\n        else {\n          if (0xff0f < (ushort)wVar9) {\n            if ((ushort)wVar9 < 0xff1a) {\n              uVar5 = uVar6 - 0xff10;\n            }\n            else {\n              uVar5 = 0xffffffff;\n            }\n            goto LAB_00411fdf;\n          }\n          if (0x65f < (ushort)wVar9) {\n            if ((ushort)wVar9 < 0x66a) {\n              uVar5 = uVar6 - 0x660;\n            }\n            else {\n              if ((ushort)wVar9 < 0x6f0) goto LAB_00411fe4;\n              if ((ushort)wVar9 < 0x6fa) {\n                uVar5 = uVar6 - 0x6f0;\n              }\n              else {\n                if ((ushort)wVar9 < 0x966) goto LAB_00411fe4;\n                if ((ushort)wVar9 < 0x970) {\n                  uVar5 = uVar6 - 0x966;\n                }\n                else {\n                  if ((ushort)wVar9 < 0x9e6) goto LAB_00411fe4;\n                  if ((ushort)wVar9 < 0x9f0) {\n                    uVar5 = uVar6 - 0x9e6;\n                  }\n                  else {\n                    if ((ushort)wVar9 < 0xa66) goto LAB_00411fe4;\n                    if ((ushort)wVar9 < 0xa70) {\n                      uVar5 = uVar6 - 0xa66;\n                    }\n                    else {\n                      if ((ushort)wVar9 < 0xae6) goto LAB_00411fe4;\n                      if ((ushort)wVar9 < 0xaf0) {\n                        uVar5 = uVar6 - 0xae6;\n                      }\n                      else {\n                        if ((ushort)wVar9 < 0xb66) goto LAB_00411fe4;\n                        if ((ushort)wVar9 < 0xb70) {\n                          uVar5 = uVar6 - 0xb66;\n                        }\n                        else {\n                          if ((ushort)wVar9 < 0xc66) goto LAB_00411fe4;\n                          if ((ushort)wVar9 < 0xc70) {\n                            uVar5 = uVar6 - 0xc66;\n                          }\n                          else {\n                            if ((ushort)wVar9 < 0xce6) goto LAB_00411fe4;\n                            if ((ushort)wVar9 < 0xcf0) {\n                              uVar5 = uVar6 - 0xce6;\n                            }\n                            else {\n                              if ((ushort)wVar9 < 0xd66) goto LAB_00411fe4;\n                              if ((ushort)wVar9 < 0xd70) {\n                                uVar5 = uVar6 - 0xd66;\n                              }\n                              else {\n                                if ((ushort)wVar9 < 0xe50) goto LAB_00411fe4;\n                                if ((ushort)wVar9 < 0xe5a) {\n                                  uVar5 = uVar6 - 0xe50;\n                                }\n                                else {\n                                  if ((ushort)wVar9 < 0xed0) goto LAB_00411fe4;\n                                  if ((ushort)wVar9 < 0xeda) {\n                                    uVar5 = uVar6 - 0xed0;\n                                  }\n                                  else {\n                                    if ((ushort)wVar9 < 0xf20) goto LAB_00411fe4;\n                                    if ((ushort)wVar9 < 0xf2a) {\n                                      uVar5 = uVar6 - 0xf20;\n                                    }\n                                    else {\n                                      if ((ushort)wVar9 < 0x1040) goto LAB_00411fe4;\n                                      if ((ushort)wVar9 < 0x104a) {\n                                        uVar5 = uVar6 - 0x1040;\n                                      }\n                                      else {\n                                        if ((ushort)wVar9 < 0x17e0) goto LAB_00411fe4;\n                                        if ((ushort)wVar9 < 0x17ea) {\n                                          uVar5 = uVar6 - 0x17e0;\n                                        }\n                                        else {\n                                          if (((ushort)wVar9 < 0x1810) || (0x1819 < (ushort)wVar9))\n                                          goto LAB_00411fe4;\n                                          uVar5 = uVar6 - 0x1810;\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            goto LAB_00411fdf;\n          }\nLAB_00411fe4:\n          if ((((ushort)wVar9 < 0x41) || (0x5a < (ushort)wVar9)) &&\n             ((ushort)local_8 < (ushort)(wVar9 + L'\uff9f'))) {\n            uVar5 = 0xffffffff;\n          }\n          else {\n            if ((ushort)(wVar9 + L'\uff9f') <= (ushort)local_8) {\n              uVar6 = uVar6 - 0x20;\n            }\n            uVar5 = uVar6 - 0x37;\n          }\n        }\n        if ((uVar5 == 0xffffffff) || (param_4 <= uVar5)) goto LAB_0041204a;\n        uVar8 = uVar7 | 8;\n        if ((local_c < uVar4) ||\n           ((local_c == uVar4 && (uVar5 <= (uint)(0xffffffff % (ulonglong)param_4))))) {\n          local_c = local_c * param_4 + uVar5;\n        }\n        else {\n          uVar8 = uVar7 | 0xc;\n        }\n        uVar6 = (uint)(ushort)*param_2;\n        param_2 = param_2 + 1;\n        uVar7 = uVar8;\n      } while( true );\n    }\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n  }\n  uVar6 = 0;\nLAB_00411a13:\n  if (param_3 != (undefined4 *)0x0) {\n    *param_3 = param_2;\n  }\n  return uVar6;\nLAB_0041204a:\n  c_string_character_source<wchar_t>::unget((c_string_character_source<wchar_t> *)&param_2,wVar9);\n  uVar6 = local_c;\n  if ((uVar7 & 8) == 0) {\n    uVar6 = 0;\n    param_2 = local_10;\n  }\n  else {\n    bVar1 = is_overflow_condition<unsigned_long>(uVar7,local_c);\n    if (bVar1) {\n      piVar2 = __errno();\n      *piVar2 = 0x22;\n      if ((uVar7 & 1) == 0) {\n        uVar6 = 0xffffffff;\n      }\n      else if ((uVar7 & 2) == 0) {\n        uVar6 = 0x7fffffff;\n      }\n      else {\n        uVar6 = 0x80000000;\n      }\n    }\n    else if ((uVar7 & 2) != 0) {\n      uVar6 = -uVar6;\n    }\n  }\n  if (local_14 != '\\0') {\n    *(uint *)(local_20[0] + 0x350) = *(uint *)(local_20[0] + 0x350) & 0xfffffffd;\n  }\n  goto LAB_00411a13;\n}\n\n"
    },
    {
      "name": "unget",
      "entry": "004120bd",
      "c": "\n/* Library Function - Single Match\n    public: void __thiscall __crt_strtox::c_string_character_source<char>::unget(char)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n__crt_strtox::c_string_character_source<char>::unget\n          (c_string_character_source<char> *this,char param_1)\n\n{\n  int *piVar1;\n  \n  *(int *)this = *(int *)this + -1;\n  if ((param_1 != '\\0') && (**(char **)this != param_1)) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  return;\n}\n\n"
    },
    {
      "name": "unget",
      "entry": "004120e5",
      "c": "\n/* Library Function - Single Match\n    public: void __thiscall __crt_strtox::c_string_character_source<wchar_t>::unget(wchar_t)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n__crt_strtox::c_string_character_source<wchar_t>::unget\n          (c_string_character_source<wchar_t> *this,wchar_t param_1)\n\n{\n  int *piVar1;\n  \n  *(int *)this = *(int *)this + -2;\n  if ((param_1 != L'\\0') && (**(wchar_t **)this != param_1)) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  return;\n}\n\n"
    },
    {
      "name": "__chvalidchk_l",
      "entry": "00412111",
      "c": "\n/* Library Function - Single Match\n    __chvalidchk_l\n   \n   Library: Visual Studio 2015 Release */\n\nushort __cdecl __chvalidchk_l(int param_1,ushort param_2,undefined4 *param_3)\n\n{\n  ushort uVar1;\n  ushort *puVar2;\n  \n  if (param_3 == (undefined4 *)0x0) {\n    puVar2 = ___pctype_func();\n    uVar1 = puVar2[param_1];\n  }\n  else {\n    uVar1 = *(ushort *)(*(int *)*param_3 + param_1 * 2);\n  }\n  return uVar1 & param_2;\n}\n\n"
    },
    {
      "name": "__ischartype_l",
      "entry": "0041213b",
      "c": "\n/* Library Function - Single Match\n    __ischartype_l\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __ischartype_l(int param_1,int param_2,_locale_t param_3)\n\n{\n  if ((param_3 == (_locale_t)0x0) || ((int)param_3->locinfo->lc_codepage < 2)) {\n    __chvalidchk_l(param_1,(ushort)param_2,&param_3->locinfo);\n  }\n  else {\n    __isctype_l(param_1,param_2,param_3);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "_atol",
      "entry": "0041216e",
      "c": "\n/* Library Function - Single Match\n    _atol\n   \n   Library: Visual Studio 2015 Release */\n\nlong __cdecl _atol(char *_Str)\n\n{\n  ulong uVar1;\n  undefined4 auStack_18 [2];\n  undefined4 uStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 1;\n  uStack_10 = 10;\n  make_c_string_character_source<>(auStack_18,_Str,(undefined4 *)0x0);\n  uVar1 = __crt_strtox::\n          parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>(0);\n  return uVar1;\n}\n\n"
    },
    {
      "name": "___acrt_call_reportfault",
      "entry": "00412198",
      "c": "\n/* Library Function - Single Match\n    ___acrt_call_reportfault\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_call_reportfault(int param_1,DWORD param_2,DWORD param_3)\n\n{\n  uint uVar1;\n  BOOL BVar2;\n  LONG LVar3;\n  _EXCEPTION_POINTERS local_32c;\n  EXCEPTION_RECORD local_324;\n  undefined4 local_2d4 [39];\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_1 != -1) {\n    FUN_0040863d();\n  }\n  _memset(&local_324,0,0x50);\n  _memset(local_2d4,0,0x2cc);\n  local_32c.ExceptionRecord = &local_324;\n  local_32c.ContextRecord = (PCONTEXT)local_2d4;\n  local_2d4[0] = 0x10001;\n  local_324.ExceptionCode = param_2;\n  local_324.ExceptionFlags = param_3;\n  BVar2 = IsDebuggerPresent();\n  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n  LVar3 = UnhandledExceptionFilter(&local_32c);\n  if (((LVar3 == 0) && (BVar2 == 0)) && (param_1 != -1)) {\n    FUN_0040863d();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_004122d3",
      "entry": "004122d3",
      "c": "\nvoid __cdecl FUN_004122d3(undefined4 param_1)\n\n{\n  initialize(&DAT_0043b10c,param_1);\n  return;\n}\n\n"
    },
    {
      "name": "__invalid_parameter",
      "entry": "004122e7",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __invalid_parameter\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,\n                   uintptr_t param_5)\n\n{\n  uint uVar1;\n  __acrt_ptd *p_Var2;\n  byte bVar3;\n  code *pcVar4;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  p_Var2 = ___acrt_getptd_noexit();\n  if (((p_Var2 == (__acrt_ptd *)0x0) || (pcVar4 = *(code **)(p_Var2 + 0x35c), pcVar4 == (code *)0x0)\n      ) && (bVar3 = (byte)DAT_0042d008 & 0x1f,\n           pcVar4 = (code *)((DAT_0042d008 ^ _DAT_0043b10c) >> bVar3 |\n                            (DAT_0042d008 ^ _DAT_0043b10c) << 0x20 - bVar3), pcVar4 == (code *)0x0))\n  {\n                    /* WARNING: Subroutine does not return */\n    __invoke_watson(param_1,param_2,param_3,param_4,param_5);\n  }\n  (*(code *)PTR_guard_check_icall_0042118c)(param_1,param_2,param_3,param_4,param_5);\n  (*pcVar4)();\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00412362",
      "entry": "00412362",
      "c": "\nvoid FUN_00412362(void)\n\n{\n  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  return;\n}\n\n"
    },
    {
      "name": "__invoke_watson",
      "entry": "00412372",
      "c": "\n/* Library Function - Single Match\n    __invoke_watson\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)\n\n{\n  code *pcVar1;\n  BOOL BVar2;\n  HANDLE hProcess;\n  UINT uExitCode;\n  \n  BVar2 = IsProcessorFeaturePresent(0x17);\n  if (BVar2 != 0) {\n    pcVar1 = (code *)swi(0x29);\n    (*pcVar1)();\n  }\n  ___acrt_call_reportfault(2,0xc0000417,1);\n  uExitCode = 0xc0000417;\n  hProcess = GetCurrentProcess();\n  TerminateProcess(hProcess,uExitCode);\n  return;\n}\n\n"
    },
    {
      "name": "FID_conflict:___acrt_errno_from_os_error",
      "entry": "004123a5",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    ___acrt_errno_from_os_error\n    __get_errno_from_oserr\n   \n   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,\n   Visual Studio 2019 Release */\n\nint __cdecl FID_conflict____acrt_errno_from_os_error(ulong param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  do {\n    if (param_1 == (&DAT_00426890)[uVar1 * 2]) {\n      return *(int *)(&UNK_00426894 + uVar1 * 8);\n    }\n    uVar1 = uVar1 + 1;\n  } while (uVar1 < 0x2d);\n  if (param_1 - 0x13 < 0x12) {\n    return 0xd;\n  }\n  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;\n}\n\n"
    },
    {
      "name": "___acrt_errno_map_os_error",
      "entry": "004123e8",
      "c": "\n/* Library Function - Single Match\n    ___acrt_errno_map_os_error\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_errno_map_os_error(ulong param_1)\n\n{\n  ulong *puVar1;\n  int iVar2;\n  int *piVar3;\n  \n  puVar1 = ___doserrno();\n  *puVar1 = param_1;\n  iVar2 = FID_conflict____acrt_errno_from_os_error(param_1);\n  piVar3 = __errno();\n  *piVar3 = iVar2;\n  return;\n}\n\n"
    },
    {
      "name": "___doserrno",
      "entry": "0041240b",
      "c": "\n/* Library Function - Single Match\n    ___doserrno\n   \n   Library: Visual Studio 2015 Release */\n\nulong * __cdecl ___doserrno(void)\n\n{\n  __acrt_ptd *p_Var1;\n  \n  p_Var1 = ___acrt_getptd_noexit();\n  if (p_Var1 == (__acrt_ptd *)0x0) {\n    return (ulong *)&DAT_0042d108;\n  }\n  return (ulong *)(p_Var1 + 0x14);\n}\n\n"
    },
    {
      "name": "__errno",
      "entry": "0041241e",
      "c": "\n/* Library Function - Single Match\n    __errno\n   \n   Library: Visual Studio 2015 Release */\n\nint * __cdecl __errno(void)\n\n{\n  __acrt_ptd *p_Var1;\n  \n  p_Var1 = ___acrt_getptd_noexit();\n  if (p_Var1 == (__acrt_ptd *)0x0) {\n    return (int *)&DAT_0042d104;\n  }\n  return (int *)(p_Var1 + 0x10);\n}\n\n"
    },
    {
      "name": "operator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>",
      "entry": "00412431",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_123407a5e2ac06da108355a851863b7a>,class <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> &,class\n   <lambda_ae55bdf541ad94d75914d381c370e64d> >(class <lambda_123407a5e2ac06da108355a851863b7a>\n   &&,class <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> &,class\n   <lambda_ae55bdf541ad94d75914d381c370e64d> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_123407a5e2ac06da108355a851863b7a> *param_1,\n          <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *param_2,\n          <lambda_ae55bdf541ad94d75914d381c370e64d> *param_3)\n\n{\n  uint _FileHandle;\n  int iVar1;\n  int *piVar2;\n  \n  ___acrt_lowio_lock_fh(*(uint *)param_1);\n  _FileHandle = **(uint **)param_2;\n  if ((*(byte *)((&DAT_0043b110)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1)\n      == 0) {\n    piVar2 = __errno();\n    *piVar2 = 9;\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = __close_nolock(_FileHandle);\n  }\n  FUN_004124a7();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_004124a7",
      "entry": "004124a7",
      "c": "\nvoid FUN_004124a7(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_lowio_unlock_fh(**(uint **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>",
      "entry": "004124b3",
      "c": "\n/* Library Function - Single Match\n    int __cdecl __acrt_lowio_lock_fh_and_call<class <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>\n   >(int,class <lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n__acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>\n          (int param_1,<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *param_2)\n\n{\n  int iVar1;\n  int local_10;\n  int local_c;\n  __crt_seh_guarded_call<int> local_5;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  iVar1 = __crt_seh_guarded_call<int>::\n          operator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>\n                    (&local_5,(<lambda_123407a5e2ac06da108355a851863b7a> *)&local_10,param_2,\n                     (<lambda_ae55bdf541ad94d75914d381c370e64d> *)&local_c);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__close",
      "entry": "004124db",
      "c": "\n/* Library Function - Single Match\n    __close\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __close(int _FileHandle)\n\n{\n  ulong *puVar1;\n  int *piVar2;\n  int iVar3;\n  int *local_8;\n  \n  if (_FileHandle == -2) {\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n  }\n  else {\n    if (((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) &&\n       ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) & 1) !=\n        0)) {\n      local_8 = &_FileHandle;\n      iVar3 = __acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>\n                        (_FileHandle,(<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *)&local_8);\n      return iVar3;\n    }\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n    FUN_00412362();\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "__close_nolock",
      "entry": "0041255a",
      "c": "\n/* Library Function - Single Match\n    __close_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __close_nolock(int _FileHandle)\n\n{\n  intptr_t iVar1;\n  intptr_t iVar2;\n  HANDLE hObject;\n  BOOL BVar3;\n  int iVar4;\n  DWORD DVar5;\n  \n  iVar1 = __get_osfhandle(_FileHandle);\n  if (iVar1 != -1) {\n    if (((_FileHandle == 1) && ((*(byte *)(DAT_0043b110 + 0x88) & 1) != 0)) ||\n       ((_FileHandle == 2 && ((*(byte *)(DAT_0043b110 + 0x58) & 1) != 0)))) {\n      iVar1 = __get_osfhandle(2);\n      iVar2 = __get_osfhandle(1);\n      if (iVar2 == iVar1) goto LAB_00412570;\n    }\n    hObject = (HANDLE)__get_osfhandle(_FileHandle);\n    BVar3 = CloseHandle(hObject);\n    if (BVar3 == 0) {\n      DVar5 = GetLastError();\n      goto LAB_004125c2;\n    }\n  }\nLAB_00412570:\n  DVar5 = 0;\nLAB_004125c2:\n  __free_osfhnd(_FileHandle);\n  *(undefined1 *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) = 0;\n  if (DVar5 == 0) {\n    iVar4 = 0;\n  }\n  else {\n    ___acrt_errno_map_os_error(DVar5);\n    iVar4 = -1;\n  }\n  return iVar4;\n}\n\n"
    },
    {
      "name": "__acrt_stdio_allocate_stream",
      "entry": "004125f6",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    class __crt_stdio_stream __cdecl __acrt_stdio_allocate_stream(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 * __cdecl __acrt_stdio_allocate_stream(void)\n\n{\n  undefined4 *puVar1;\n  undefined4 *in_stack_00000004;\n  \n  *in_stack_00000004 = 0;\n  ___acrt_lock(8);\n  puVar1 = (undefined4 *)find_or_allocate_unused_stream_nolock();\n  puVar1 = (undefined4 *)*puVar1;\n  *in_stack_00000004 = puVar1;\n  if (puVar1 != (undefined4 *)0x0) {\n    puVar1[2] = 0;\n    puVar1[7] = 0;\n    *puVar1 = 0;\n    puVar1[1] = 0;\n    puVar1[4] = 0xffffffff;\n  }\n  FUN_0041264c();\n  return in_stack_00000004;\n}\n\n"
    },
    {
      "name": "FUN_0041264c",
      "entry": "0041264c",
      "c": "\nvoid FUN_0041264c(void)\n\n{\n  ___acrt_unlock(8);\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_stdio_free_stream",
      "entry": "00412655",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __acrt_stdio_free_stream(class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __acrt_stdio_free_stream(undefined4 *param_1)\n\n{\n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  param_1[4] = 0xffffffff;\n  param_1[5] = 0;\n  param_1[6] = 0;\n  param_1[7] = 0;\n  LOCK();\n  param_1[3] = 0;\n  UNLOCK();\n  return;\n}\n\n"
    },
    {
      "name": "find_or_allocate_unused_stream_nolock",
      "entry": "00412690",
      "c": "\n/* Library Function - Single Match\n    class __crt_stdio_stream __cdecl find_or_allocate_unused_stream_nolock(void)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl find_or_allocate_unused_stream_nolock(void)\n\n{\n  int *piVar1;\n  int *piVar2;\n  uint uVar3;\n  uint uVar4;\n  LPVOID pvVar5;\n  FILE *_File;\n  int *piVar6;\n  bool bVar7;\n  undefined4 *in_stack_00000004;\n  \n  piVar6 = (int *)(DAT_0043ae98 + 0xc);\n  piVar2 = piVar6 + DAT_0043ae94 + -3;\n  do {\n    if (piVar6 == piVar2) {\nLAB_004126f8:\n      *in_stack_00000004 = 0;\n      return;\n    }\n    _File = (FILE *)*piVar6;\n    if (_File == (FILE *)0x0) {\n      pvVar5 = __calloc_base(1,0x38);\n      *piVar6 = (int)pvVar5;\n      FID_conflict__free((void *)0x0);\n      if (*piVar6 != 0) {\n        *(undefined4 *)(*piVar6 + 0x10) = 0xffffffff;\n        ___acrt_InitializeCriticalSectionEx_12((LPCRITICAL_SECTION)(*piVar6 + 0x20),4000,0);\n        _File = (FILE *)*piVar6;\n        LOCK();\n        _File->_flag = _File->_flag | 0x2000;\n        UNLOCK();\n        __lock_file(_File);\nLAB_00412705:\n        *in_stack_00000004 = _File;\n        return;\n      }\n      goto LAB_004126f8;\n    }\n    if (((uint)_File->_flag >> 0xd & 1) == 0) {\n      __lock_file(_File);\n      piVar1 = &_File->_flag;\n      uVar3 = *piVar1;\n      do {\n        LOCK();\n        uVar4 = *piVar1;\n        bVar7 = uVar3 == uVar4;\n        if (bVar7) {\n          *piVar1 = uVar3 | 0x2000;\n          uVar4 = uVar3;\n        }\n        UNLOCK();\n        uVar3 = uVar4;\n      } while (!bVar7);\n      if ((~(byte)(uVar4 >> 0xd) & 1) != 0) goto LAB_00412705;\n      __unlock_file(_File);\n    }\n    piVar6 = piVar6 + 1;\n  } while( true );\n}\n\n"
    },
    {
      "name": "___acrt_stdio_free_buffer_nolock",
      "entry": "00412753",
      "c": "\n/* Library Function - Single Match\n    ___acrt_stdio_free_buffer_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_stdio_free_buffer_nolock(undefined4 *param_1)\n\n{\n  uint *puVar1;\n  \n  puVar1 = param_1 + 3;\n  if (((*puVar1 >> 0xd & 1) != 0) && ((*puVar1 >> 6 & 1) != 0)) {\n    FID_conflict__free((void *)param_1[1]);\n    LOCK();\n    *puVar1 = *puVar1 & 0xfffffebf;\n    UNLOCK();\n    param_1[1] = 0;\n    *param_1 = 0;\n    param_1[2] = 0;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "translate_text_mode_nolock<char>",
      "entry": "00412791",
      "c": "\n/* Library Function - Single Match\n    int __cdecl translate_text_mode_nolock<char>(int,char * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl translate_text_mode_nolock<char>(int param_1,char *param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  char cVar2;\n  byte bVar3;\n  int iVar4;\n  BOOL BVar5;\n  char *pcVar6;\n  char *pcVar7;\n  int unaff_EDI;\n  int iVar8;\n  DWORD local_1c;\n  HANDLE local_18;\n  int local_14;\n  char *local_10;\n  char *local_c;\n  char local_5;\n  \n  local_14 = param_1 >> 6;\n  iVar8 = (param_1 & 0x3fU) * 0x30;\n  iVar4 = (&DAT_0043b110)[local_14];\n  local_18 = *(HANDLE *)(iVar4 + 0x18 + iVar8);\n  if ((param_3 == 0) || (*param_2 != '\\n')) {\n    pbVar1 = (byte *)(iVar4 + 0x28 + iVar8);\n    *pbVar1 = *pbVar1 & 0xfb;\n  }\n  else {\n    pbVar1 = (byte *)(iVar4 + 0x28 + iVar8);\n    *pbVar1 = *pbVar1 | 4;\n  }\n  local_c = param_2 + param_3;\n  pcVar7 = param_2;\n  if (param_2 < local_c) {\n    local_10 = param_2 + 1;\n    pcVar6 = param_2;\n    do {\n      cVar2 = *pcVar6;\n      if (cVar2 == '\\x1a') {\n        bVar3 = *(byte *)((&DAT_0043b110)[local_14] + 0x28 + iVar8);\n        if ((bVar3 & 0x40) == 0) {\n          *(byte *)((&DAT_0043b110)[local_14] + 0x28 + iVar8) = bVar3 | 2;\n        }\n        else {\n          *pcVar7 = *pcVar6;\n          pcVar7 = pcVar7 + 1;\n        }\n        break;\n      }\n      if (cVar2 == '\\r') {\n        if (local_c <= local_10) {\n          local_10 = local_10 + 1;\n          BVar5 = ReadFile(local_18,&local_5,1,&local_1c,(LPOVERLAPPED)0x0);\n          if ((BVar5 == 0) || (local_1c == 0)) {\nLAB_004128a7:\n            *pcVar7 = '\\r';\n            pcVar7 = pcVar7 + 1;\n          }\n          else if ((*(byte *)((&DAT_0043b110)[local_14] + 0x28 + iVar8) & 0x48) == 0) {\n            if ((local_5 == '\\n') && (pcVar7 == param_2)) {\n              *pcVar7 = '\\n';\n              pcVar7 = pcVar7 + 1;\n            }\n            else {\n              __lseeki64_nolock(param_1,0x1ffffffff,unaff_EDI);\n              if (local_5 != '\\n') goto LAB_004128a7;\n            }\n          }\n          else if (local_5 == '\\n') {\n            *pcVar7 = '\\n';\n          }\n          else {\n            *pcVar7 = '\\r';\n            *(char *)((&DAT_0043b110)[local_14] + 0x2a + iVar8) = local_5;\n          }\n          goto LAB_004128b1;\n        }\n        if (*local_10 == '\\n') {\n          pcVar6 = pcVar6 + 2;\n          *pcVar7 = '\\n';\n          local_10 = local_10 + 2;\n          pcVar7 = pcVar7 + 1;\n        }\n        else {\n          *pcVar7 = '\\r';\n          pcVar7 = pcVar7 + 1;\n          pcVar6 = pcVar6 + 1;\n          local_10 = local_10 + 1;\n        }\n      }\n      else {\n        *pcVar7 = cVar2;\n        pcVar7 = pcVar7 + 1;\n        local_10 = local_10 + 1;\nLAB_004128b1:\n        pcVar6 = pcVar6 + 1;\n      }\n    } while (pcVar6 < local_c);\n  }\n  return (int)pcVar7 - (int)param_2;\n}\n\n"
    },
    {
      "name": "translate_text_mode_nolock<wchar_t>",
      "entry": "004128e8",
      "c": "\n/* Library Function - Single Match\n    int __cdecl translate_text_mode_nolock<wchar_t>(int,wchar_t * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl translate_text_mode_nolock<wchar_t>(int param_1,wchar_t *param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  wchar_t wVar3;\n  int iVar4;\n  BOOL BVar5;\n  wchar_t *pwVar6;\n  wchar_t *pwVar7;\n  wchar_t *pwVar8;\n  int unaff_EDI;\n  int iVar9;\n  DWORD local_1c;\n  HANDLE local_18;\n  wchar_t *local_14;\n  wchar_t *local_10;\n  int local_c;\n  short local_8 [2];\n  \n  local_c = param_1 >> 6;\n  iVar9 = (param_1 & 0x3fU) * 0x30;\n  iVar4 = (&DAT_0043b110)[local_c];\n  local_18 = *(HANDLE *)(iVar4 + 0x18 + iVar9);\n  if ((param_3 == 0) || (*param_2 != L'\\n')) {\n    pbVar1 = (byte *)(iVar4 + 0x28 + iVar9);\n    *pbVar1 = *pbVar1 & 0xfb;\n  }\n  else {\n    pbVar1 = (byte *)(iVar4 + 0x28 + iVar9);\n    *pbVar1 = *pbVar1 | 4;\n  }\n  local_14 = param_2 + param_3;\n  pwVar8 = param_2;\n  if (param_2 < local_14) {\n    local_10 = param_2 + 1;\n    pwVar6 = param_2;\n    do {\n      wVar3 = *pwVar6;\n      if (wVar3 == L'\\x1a') {\n        bVar2 = *(byte *)((&DAT_0043b110)[local_c] + 0x28 + iVar9);\n        if ((bVar2 & 0x40) == 0) {\n          *(byte *)((&DAT_0043b110)[local_c] + 0x28 + iVar9) = bVar2 | 2;\n        }\n        else {\n          *pwVar8 = *pwVar6;\n          pwVar8 = pwVar8 + 1;\n        }\n        break;\n      }\n      if (wVar3 == L'\\r') {\n        if (local_10 < local_14) {\n          if (*local_10 == L'\\n') {\n            pwVar7 = pwVar6 + 2;\n            *pwVar8 = L'\\n';\n            local_10 = local_10 + 2;\n            pwVar8 = pwVar8 + 1;\n            goto LAB_00412a6f;\n          }\n          *pwVar8 = L'\\r';\n          pwVar8 = pwVar8 + 1;\n          local_10 = local_10 + 1;\n        }\n        else {\n          local_10 = local_10 + 1;\n          pwVar7 = pwVar6 + 1;\n          BVar5 = ReadFile(local_18,local_8,2,&local_1c,(LPOVERLAPPED)0x0);\n          if ((BVar5 == 0) || (local_1c == 0)) {\nLAB_00412a60:\n            *pwVar8 = L'\\r';\n            pwVar8 = pwVar8 + 1;\n          }\n          else if ((*(byte *)((&DAT_0043b110)[local_c] + 0x28 + iVar9) & 0x48) == 0) {\n            if ((local_8[0] == 10) && (pwVar8 == param_2)) {\n              *pwVar8 = L'\\n';\n              pwVar8 = pwVar8 + 1;\n              goto LAB_00412a6f;\n            }\n            __lseeki64_nolock(param_1,0x1ffffffff,unaff_EDI);\n            if (local_8[0] != 10) goto LAB_00412a60;\n          }\n          else if (local_8[0] == 10) {\n            *pwVar8 = L'\\n';\n          }\n          else {\n            *pwVar8 = L'\\r';\n            *(char *)((&DAT_0043b110)[local_c] + 0x2a + iVar9) = (char)local_8[0];\n            *(char *)((&DAT_0043b110)[local_c] + 0x2b + iVar9) = (char)((ushort)local_8[0] >> 8);\n            *(undefined1 *)((&DAT_0043b110)[local_c] + 0x2c + iVar9) = 10;\n          }\n        }\n        pwVar7 = pwVar6 + 1;\n      }\n      else {\n        pwVar7 = pwVar6 + 1;\n        *pwVar8 = wVar3;\n        pwVar8 = pwVar8 + 1;\n        local_10 = local_10 + 1;\n      }\nLAB_00412a6f:\n      pwVar6 = pwVar7;\n    } while (pwVar7 < local_14);\n  }\n  return (int)pwVar8 - (int)param_2 & 0xfffffffe;\n}\n\n"
    },
    {
      "name": "translate_ansi_or_utf8_nolock",
      "entry": "00412aa8",
      "c": "\n/* Library Function - Single Match\n    int __cdecl translate_ansi_or_utf8_nolock(int,char * const,unsigned int,wchar_t * const,unsigned\n   int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ntranslate_ansi_or_utf8_nolock(int param_1,char *param_2,uint param_3,wchar_t *param_4,uint param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  int *piVar4;\n  DWORD DVar5;\n  int iVar6;\n  uint uVar7;\n  int unaff_ESI;\n  byte *pbVar8;\n  byte *pbVar9;\n  int iVar10;\n  \n  iVar3 = translate_text_mode_nolock<char>(param_1,param_2,param_3);\n  if (iVar3 == 0) {\n    return 0;\n  }\n  iVar6 = param_1 >> 6;\n  iVar10 = (param_1 & 0x3fU) * 0x30;\n  iVar2 = (&DAT_0043b110)[iVar6];\n  if (*(char *)(iVar2 + 0x29 + iVar10) != '\\0') {\n    pbVar8 = (byte *)(param_2 + iVar3 + -1);\n    bVar1 = *pbVar8;\n    if ((char)bVar1 < '\\0') {\n      uVar7 = 1;\n      while ((((&DAT_0042d110)[bVar1] == '\\0' && (uVar7 < 5)) && (param_2 <= pbVar8))) {\n        pbVar8 = pbVar8 + -1;\n        uVar7 = uVar7 + 1;\n        bVar1 = *pbVar8;\n      }\n      if ((char)(&DAT_0042d110)[*pbVar8] == 0) {\n        piVar4 = __errno();\n        *piVar4 = 0x2a;\n        return -1;\n      }\n      if ((int)(char)(&DAT_0042d110)[*pbVar8] + 1U == uVar7) {\n        pbVar8 = pbVar8 + uVar7;\n      }\n      else if ((*(byte *)(iVar2 + 0x28 + iVar10) & 0x48) == 0) {\n        __lseeki64_nolock(param_1,CONCAT44(1,(int)-uVar7 >> 0x1f),unaff_ESI);\n      }\n      else {\n        pbVar9 = pbVar8 + 1;\n        *(byte *)(iVar2 + 0x2a + iVar10) = *pbVar8;\n        if (1 < uVar7) {\n          bVar1 = *pbVar9;\n          pbVar9 = pbVar8 + 2;\n          *(byte *)((&DAT_0043b110)[iVar6] + 0x2b + iVar10) = bVar1;\n        }\n        if (uVar7 == 3) {\n          bVar1 = *pbVar9;\n          pbVar9 = pbVar9 + 1;\n          *(byte *)((&DAT_0043b110)[iVar6] + 0x2c + iVar10) = bVar1;\n        }\n        pbVar8 = pbVar9 + -uVar7;\n      }\n    }\n    else {\n      pbVar8 = pbVar8 + 1;\n    }\n    iVar3 = MultiByteToWideChar(0xfde9,0,param_2,(int)pbVar8 - (int)param_2,param_4,param_5);\n    if (iVar3 == 0) {\n      DVar5 = GetLastError();\n      ___acrt_errno_map_os_error(DVar5);\n      return -1;\n    }\n    pbVar9 = (byte *)((&DAT_0043b110)[iVar6] + 0x2d + iVar10);\n    *pbVar9 = *pbVar9 ^ ((iVar3 != (int)pbVar8 - (int)param_2) * '\\x02' ^\n                        *(byte *)((&DAT_0043b110)[iVar6] + 0x2d + iVar10)) & 2;\n    return iVar3 * 2;\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "translate_utf16_from_console_nolock",
      "entry": "00412bf8",
      "c": "\n/* Library Function - Single Match\n    int __cdecl translate_utf16_from_console_nolock(int,wchar_t * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl translate_utf16_from_console_nolock(int param_1,wchar_t *param_2,uint param_3)\n\n{\n  wchar_t *pwVar1;\n  byte *pbVar2;\n  wchar_t wVar3;\n  wchar_t *pwVar4;\n  wchar_t *pwVar5;\n  wchar_t *pwVar6;\n  \n  pwVar1 = param_2 + param_3;\n  pwVar6 = param_2;\n  if (param_2 < pwVar1) {\n    pwVar5 = param_2 + 1;\n    pwVar4 = param_2;\n    do {\n      wVar3 = *pwVar4;\n      if (wVar3 == L'\\x1a') {\n        pbVar2 = (byte *)((&DAT_0043b110)[param_1 >> 6] + 0x28 + (param_1 & 0x3fU) * 0x30);\n        *pbVar2 = *pbVar2 | 2;\n        break;\n      }\n      if (((wVar3 == L'\\r') && (pwVar5 < pwVar1)) && (*pwVar5 == L'\\n')) {\n        pwVar4 = pwVar4 + 2;\n        *pwVar6 = L'\\n';\n        pwVar5 = pwVar5 + 2;\n      }\n      else {\n        *pwVar6 = wVar3;\n        pwVar4 = pwVar4 + 1;\n        pwVar5 = pwVar5 + 1;\n      }\n      pwVar6 = pwVar6 + 1;\n    } while (pwVar4 < pwVar1);\n  }\n  return (int)pwVar6 - (int)param_2 & 0xfffffffe;\n}\n\n"
    },
    {
      "name": "__read",
      "entry": "00412c79",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    __read\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __read(int _FileHandle,void *_DstBuf,uint _MaxCharCount)\n\n{\n  ulong *puVar1;\n  int *piVar2;\n  int iVar3;\n  int iVar4;\n  \n  if (_FileHandle == -2) {\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n    return -1;\n  }\n  if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) {\n    iVar3 = (_FileHandle & 0x3fU) * 0x30;\n    if ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + iVar3) & 1) != 0) {\n      if (_MaxCharCount < 0x80000000) {\n        ___acrt_lowio_lock_fh(_FileHandle);\n        iVar4 = -1;\n        if ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + iVar3) & 1) == 0) {\n          piVar2 = __errno();\n          *piVar2 = 9;\n          puVar1 = ___doserrno();\n          *puVar1 = 0;\n        }\n        else {\n          iVar4 = __read_nolock(_FileHandle,_DstBuf,_MaxCharCount);\n        }\n        FUN_00412d63();\n        return iVar4;\n      }\n      puVar1 = ___doserrno();\n      *puVar1 = 0;\n      piVar2 = __errno();\n      *piVar2 = 0x16;\n      goto LAB_00412d7e;\n    }\n  }\n  puVar1 = ___doserrno();\n  *puVar1 = 0;\n  piVar2 = __errno();\n  *piVar2 = 9;\nLAB_00412d7e:\n  FUN_00412362();\n  return -1;\n}\n\n"
    },
    {
      "name": "FUN_00412d63",
      "entry": "00412d63",
      "c": "\nvoid FUN_00412d63(void)\n\n{\n  uint unaff_ESI;\n  \n  ___acrt_lowio_unlock_fh(unaff_ESI);\n  return;\n}\n\n"
    },
    {
      "name": "__read_nolock",
      "entry": "00412d8c",
      "c": "\n/* Library Function - Single Match\n    __read_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __read_nolock(int _FileHandle,void *_DstBuf,uint _MaxCharCount)\n\n{\n  uint uVar1;\n  ulong *puVar2;\n  int *piVar3;\n  wchar_t *pwVar4;\n  int iVar5;\n  BOOL BVar6;\n  ulong uVar7;\n  size_t sVar8;\n  int unaff_ESI;\n  wchar_t *_Memory;\n  int iVar9;\n  uint uVar10;\n  longlong lVar11;\n  DWORD local_2c;\n  wchar_t *local_28;\n  uint local_24;\n  HANDLE local_20;\n  int local_1c;\n  uint local_18;\n  int local_14;\n  size_t local_10;\n  wchar_t *local_c;\n  char local_6;\n  byte local_5;\n  \n  if (_FileHandle == -2) {\n    puVar2 = ___doserrno();\n    *puVar2 = 0;\n    piVar3 = __errno();\n    *piVar3 = 9;\n    return -1;\n  }\n  if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) {\n    local_18 = 1;\n    iVar9 = _FileHandle >> 6;\n    local_1c = (_FileHandle & 0x3fU) * 0x30;\n    iVar5 = (&DAT_0043b110)[iVar9];\n    local_5 = *(byte *)(local_1c + 0x28 + iVar5);\n    local_14 = iVar9;\n    if ((local_5 & 1) != 0) {\n      if (_MaxCharCount < 0x80000000) {\n        if ((_MaxCharCount == 0) || ((local_5 & 2) != 0)) {\n          return 0;\n        }\n        if (_DstBuf != (void *)0x0) {\n          local_20 = *(HANDLE *)(local_1c + 0x18 + iVar5);\n          local_5 = *(char *)(local_1c + 0x29 + iVar5);\n          if (local_5 == '\\x01') {\n            if ((~(byte)_MaxCharCount & 1) == 0) goto LAB_00412e75;\n            local_10 = 4;\n            if (3 < _MaxCharCount >> 1) {\n              local_10 = _MaxCharCount >> 1;\n            }\n            pwVar4 = (wchar_t *)__malloc_base(local_10);\n            FID_conflict__free((void *)0x0);\n            FID_conflict__free((void *)0x0);\n            local_c = pwVar4;\n            if (pwVar4 != (wchar_t *)0x0) {\n              lVar11 = __lseeki64_nolock(_FileHandle,(ulonglong)local_18 << 0x20,unaff_ESI);\n              iVar5 = (&DAT_0043b110)[iVar9];\n              *(int *)(local_1c + 0x20 + iVar5) = (int)lVar11;\n              *(int *)(local_1c + 0x24 + iVar5) = (int)((ulonglong)lVar11 >> 0x20);\n              _Memory = pwVar4;\n              goto LAB_00412f06;\n            }\n            piVar3 = __errno();\n            *piVar3 = 0xc;\n            puVar2 = ___doserrno();\n            *puVar2 = 8;\n          }\n          else if ((local_5 == '\\x02') && ((~_MaxCharCount & 1) == 0)) {\nLAB_00412e75:\n            puVar2 = ___doserrno();\n            *puVar2 = 0;\n            piVar3 = __errno();\n            *piVar3 = 0x16;\n            FUN_00412362();\n            pwVar4 = (wchar_t *)0x0;\n          }\n          else {\n            local_10 = _MaxCharCount;\n            local_c = (wchar_t *)_DstBuf;\n            pwVar4 = (wchar_t *)_DstBuf;\n            _Memory = (wchar_t *)0x0;\nLAB_00412f06:\n            uVar10 = 0;\n            local_24 = (&DAT_0043b110)[local_14];\n            sVar8 = local_10;\n            if ((((*(byte *)(local_1c + 0x28 + local_24) & 0x48) != 0) &&\n                (local_6 = *(char *)(local_1c + 0x2a + local_24), local_6 != '\\n')) &&\n               (local_10 != 0)) {\n              *(char *)pwVar4 = local_6;\n              local_c = (wchar_t *)((int)pwVar4 + 1);\n              sVar8 = local_10 - 1;\n              *(undefined1 *)(local_1c + 0x2a + (&DAT_0043b110)[local_14]) = 10;\n              uVar10 = local_18;\n              if (((local_5 != '\\0') &&\n                  (local_6 = *(char *)(local_1c + 0x2b + (&DAT_0043b110)[local_14]), local_6 != '\\n'\n                  )) && (sVar8 != 0)) {\n                uVar10 = 2;\n                *(char *)local_c = local_6;\n                local_c = pwVar4 + 1;\n                sVar8 = local_10 - 2;\n                *(undefined1 *)(local_1c + 0x2b + (&DAT_0043b110)[local_14]) = 10;\n                if (((local_5 == (char)local_18) &&\n                    (local_6 = *(char *)(local_1c + 0x2c + (&DAT_0043b110)[local_14]),\n                    local_6 != '\\n')) && (sVar8 != 0)) {\n                  uVar10 = 3;\n                  *(char *)local_c = local_6;\n                  local_c = (wchar_t *)((int)pwVar4 + 3);\n                  *(undefined1 *)(local_1c + 0x2c + (&DAT_0043b110)[local_14]) = 10;\n                  sVar8 = local_10 - 3;\n                }\n              }\n            }\n            local_10 = sVar8;\n            local_28 = pwVar4;\n            iVar5 = __isatty(_FileHandle);\n            pwVar4 = _Memory;\n            if (((iVar5 == 0) ||\n                ((*(byte *)(local_1c + 0x28 + (&DAT_0043b110)[local_14]) & 0x80) == 0)) ||\n               (BVar6 = GetConsoleMode(local_20,&local_2c), BVar6 == 0)) {\n              local_18 = local_18 & 0xffffff00;\nLAB_00413074:\n              BVar6 = ReadFile(local_20,local_c,local_10,&local_24,(LPOVERLAPPED)0x0);\n              if ((BVar6 != 0) && (uVar1 = local_24, local_24 <= _MaxCharCount)) {\nLAB_00413099:\n                uVar10 = uVar10 + uVar1;\n                if ((*(byte *)(local_1c + 0x28 + (&DAT_0043b110)[local_14]) & 0x80) != 0) {\n                  if (local_5 == '\\x02') {\n                    if ((char)local_18 == '\\0') {\n                      uVar10 = translate_text_mode_nolock<wchar_t>(_FileHandle,local_28,uVar10 >> 1)\n                      ;\n                    }\n                    else {\n                      uVar10 = translate_utf16_from_console_nolock(_FileHandle,local_28,uVar10 >> 1)\n                      ;\n                    }\n                  }\n                  else {\n                    uVar10 = translate_ansi_or_utf8_nolock\n                                       (_FileHandle,(char *)local_c,uVar10,(wchar_t *)_DstBuf,\n                                        _MaxCharCount >> 1);\n                  }\n                }\n                goto LAB_00413056;\n              }\n              uVar7 = GetLastError();\n              if (uVar7 != 5) {\n                if (uVar7 == 0x6d) {\n                  uVar10 = 0;\n                  goto LAB_00413056;\n                }\n                goto LAB_0041304c;\n              }\n              piVar3 = __errno();\n              *piVar3 = 9;\n              puVar2 = ___doserrno();\n              *puVar2 = 5;\n            }\n            else {\n              if (local_5 != '\\x02') goto LAB_00413074;\n              BVar6 = ReadConsoleW(local_20,local_c,local_10 >> 1,&local_24,\n                                   (PCONSOLE_READCONSOLE_CONTROL)0x0);\n              if (BVar6 != 0) {\n                uVar1 = local_24 * 2;\n                goto LAB_00413099;\n              }\n              uVar7 = GetLastError();\nLAB_0041304c:\n              ___acrt_errno_map_os_error(uVar7);\n            }\n          }\n          uVar10 = 0xffffffff;\n          _Memory = pwVar4;\nLAB_00413056:\n          FID_conflict__free(_Memory);\n          return uVar10;\n        }\n      }\n      puVar2 = ___doserrno();\n      *puVar2 = 0;\n      piVar3 = __errno();\n      *piVar3 = 0x16;\n      goto LAB_00413133;\n    }\n  }\n  puVar2 = ___doserrno();\n  *puVar2 = 0;\n  piVar3 = __errno();\n  *piVar3 = 9;\nLAB_00413133:\n  FUN_00412362();\n  return -1;\n}\n\n"
    },
    {
      "name": "common_refill_and_read_nolock<char>",
      "entry": "00413141",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_refill_and_read_nolock<char>(class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_refill_and_read_nolock<char>(FILE *param_1)\n\n{\n  byte bVar1;\n  int *piVar2;\n  int iVar3;\n  char *pcVar4;\n  uint uVar5;\n  undefined *puVar6;\n  void *_DstBuf;\n  \n  if (param_1 == (FILE *)0x0) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n  }\n  else if ((((uint)param_1->_flag >> 0xd & 1) != 0) && (((uint)param_1->_flag >> 0xc & 1) == 0)) {\n    if (((uint)param_1->_flag >> 1 & 1) == 0) {\n      LOCK();\n      param_1->_flag = param_1->_flag | 1;\n      UNLOCK();\n      if ((param_1->_flag & 0x4c0U) == 0) {\n        ___acrt_stdio_allocate_buffer_nolock(&param_1->_ptr);\n      }\n      param_1->_ptr = (char *)param_1->_cnt;\n      uVar5 = param_1->_bufsiz;\n      _DstBuf = (void *)param_1->_cnt;\n      iVar3 = __fileno(param_1);\n      pcVar4 = (char *)__read(iVar3,_DstBuf,uVar5);\n      param_1->_base = pcVar4;\n      pcVar4 = param_1->_base;\n      if ((pcVar4 != (char *)0x0) && (pcVar4 != (char *)0xffffffff)) {\n        if ((param_1->_flag & 6U) == 0) {\n          iVar3 = __fileno(param_1);\n          if ((iVar3 == -1) || (iVar3 = __fileno(param_1), iVar3 == -2)) {\n            puVar6 = &DAT_0042d210;\n          }\n          else {\n            iVar3 = __fileno(param_1);\n            uVar5 = __fileno(param_1);\n            puVar6 = (undefined *)((uVar5 & 0x3f) * 0x30 + (&DAT_0043b110)[iVar3 >> 6]);\n          }\n          if ((puVar6[0x28] & 0x82) == 0x82) {\n            LOCK();\n            param_1->_flag = param_1->_flag | 0x20;\n            UNLOCK();\n          }\n        }\n        if (((param_1->_bufsiz == 0x200) && (((uint)param_1->_flag >> 6 & 1) != 0)) &&\n           ((param_1->_flag & 0x100U) == 0)) {\n          param_1->_bufsiz = 0x1000;\n        }\n        param_1->_base = param_1->_base + -1;\n        bVar1 = *param_1->_ptr;\n        param_1->_ptr = param_1->_ptr + 1;\n        return (uint)bVar1;\n      }\n      LOCK();\n      param_1->_flag = param_1->_flag | (uint)(pcVar4 != (char *)0x0) * 8 + 8;\n      UNLOCK();\n      param_1->_base = (char *)0x0;\n    }\n    else {\n      LOCK();\n      param_1->_flag = param_1->_flag | 0x10;\n      UNLOCK();\n    }\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "FUN_004132c2",
      "entry": "004132c2",
      "c": "\nvoid FUN_004132c2(void)\n\n{\n  common_refill_and_read_nolock<char>();\n  return;\n}\n\n"
    },
    {
      "name": "common_lseek<__int64>",
      "entry": "004132cd",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    __int64 __cdecl common_lseek<__int64>(int,__int64,int)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl common_lseek<__int64>(int param_1,__int64 param_2,int param_3)\n\n{\n  ulong *puVar1;\n  int *piVar2;\n  int iVar3;\n  __int64 _Var4;\n  int in_stack_ffffffc0;\n  \n  if (param_1 == -2) {\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n  }\n  else {\n    if ((-1 < param_1) && ((uint)param_1 < DAT_0043b310)) {\n      iVar3 = (param_1 & 0x3fU) * 0x30;\n      if ((*(byte *)((&DAT_0043b110)[param_1 >> 6] + 0x28 + iVar3) & 1) != 0) {\n        ___acrt_lowio_lock_fh(param_1);\n        _Var4 = -1;\n        if ((*(byte *)((&DAT_0043b110)[param_1 >> 6] + 0x28 + iVar3) & 1) == 0) {\n          piVar2 = __errno();\n          *piVar2 = 9;\n          puVar1 = ___doserrno();\n          *puVar1 = 0;\n        }\n        else {\n          _Var4 = common_lseek_nolock<__int64>(param_1,param_2,in_stack_ffffffc0);\n        }\n        FUN_004133a5();\n        return _Var4;\n      }\n    }\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n    FUN_00412362();\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "FUN_004133a5",
      "entry": "004133a5",
      "c": "\nvoid FUN_004133a5(void)\n\n{\n  uint unaff_EDI;\n  \n  ___acrt_lowio_unlock_fh(unaff_EDI);\n  return;\n}\n\n"
    },
    {
      "name": "common_lseek_nolock<__int64>",
      "entry": "004133d2",
      "c": "\n/* Library Function - Single Match\n    __int64 __cdecl common_lseek_nolock<__int64>(int,__int64,int)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl common_lseek_nolock<__int64>(int param_1,__int64 param_2,int param_3)\n\n{\n  byte *pbVar1;\n  LARGE_INTEGER liDistanceToMove;\n  HANDLE hFile;\n  int *piVar2;\n  BOOL BVar3;\n  DWORD DVar4;\n  DWORD unaff_EDI;\n  uint local_c;\n  uint local_8;\n  \n  hFile = (HANDLE)__get_osfhandle(param_1);\n  if (hFile == (HANDLE)0xffffffff) {\n    piVar2 = __errno();\n    *piVar2 = 9;\n  }\n  else {\n    liDistanceToMove.s.HighPart = (LONG)&local_c;\n    liDistanceToMove.s.LowPart = (undefined4)param_2;\n    BVar3 = SetFilePointerEx(hFile,liDistanceToMove,param_2._4_4_,unaff_EDI);\n    if (BVar3 == 0) {\n      DVar4 = GetLastError();\n      ___acrt_errno_map_os_error(DVar4);\n    }\n    else if ((local_c & local_8) != 0xffffffff) {\n      pbVar1 = (byte *)((&DAT_0043b110)[param_1 >> 6] + 0x28 + (param_1 & 0x3fU) * 0x30);\n      *pbVar1 = *pbVar1 & 0xfd;\n      goto LAB_0041344a;\n    }\n  }\n  local_c = 0xffffffff;\n  local_8 = 0xffffffff;\nLAB_0041344a:\n  return CONCAT44(local_8,local_c);\n}\n\n"
    },
    {
      "name": "__lseeki64",
      "entry": "00413450",
      "c": "\n/* Library Function - Single Match\n    __lseeki64\n   \n   Library: Visual Studio 2015 Release */\n\nlonglong __cdecl __lseeki64(int _FileHandle,longlong _Offset,int _Origin)\n\n{\n  int unaff_EBP;\n  __int64 _Var1;\n  \n  _Var1 = common_lseek<__int64>(_FileHandle,_Offset,unaff_EBP);\n  return _Var1;\n}\n\n"
    },
    {
      "name": "__lseeki64_nolock",
      "entry": "0041346b",
      "c": "\n/* Library Function - Single Match\n    __lseeki64_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nlonglong __cdecl __lseeki64_nolock(int _FileHandle,longlong _Offset,int _Origin)\n\n{\n  int unaff_EBP;\n  __int64 _Var1;\n  \n  _Var1 = common_lseek_nolock<__int64>(_FileHandle,_Offset,unaff_EBP);\n  return _Var1;\n}\n\n"
    },
    {
      "name": "initialize_inherited_file_handles_nolock",
      "entry": "00413486",
      "c": "\n/* Library Function - Single Match\n    void __cdecl initialize_inherited_file_handles_nolock(void)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl initialize_inherited_file_handles_nolock(void)\n\n{\n  HANDLE hFile;\n  DWORD DVar1;\n  int iVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  _STARTUPINFOW local_4c;\n  byte *local_8;\n  \n  GetStartupInfoW(&local_4c);\n  if ((local_4c.cbReserved2 != 0) && ((uint *)local_4c.lpReserved2 != (uint *)0x0)) {\n    uVar4 = *(uint *)local_4c.lpReserved2;\n    puVar3 = (uint *)((int)local_4c.lpReserved2 + 4);\n    local_8 = (byte *)((int)puVar3 + uVar4);\n    if (0x1fff < (int)uVar4) {\n      uVar4 = 0x2000;\n    }\n    ___acrt_lowio_ensure_fh_exists(uVar4);\n    if ((int)DAT_0043b310 < (int)uVar4) {\n      uVar4 = DAT_0043b310;\n    }\n    uVar5 = 0;\n    if (uVar4 != 0) {\n      do {\n        hFile = *(HANDLE *)local_8;\n        if ((((hFile != (HANDLE)0xffffffff) && (hFile != (HANDLE)0xfffffffe)) &&\n            ((*puVar3 & 1) != 0)) &&\n           (((*puVar3 & 8) != 0 || (DVar1 = GetFileType(hFile), DVar1 != 0)))) {\n          iVar2 = (uVar5 & 0x3f) * 0x30 + (&DAT_0043b110)[(int)uVar5 >> 6];\n          *(undefined4 *)(iVar2 + 0x18) = *(undefined4 *)local_8;\n          *(byte *)(iVar2 + 0x28) = (byte)*puVar3;\n        }\n        uVar5 = uVar5 + 1;\n        local_8 = local_8 + 4;\n        puVar3 = (uint *)((int)puVar3 + 1);\n      } while (uVar5 != uVar4);\n    }\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041353c",
      "entry": "0041353c",
      "c": "\nvoid FUN_0041353c(void)\n\n{\n  HANDLE hFile;\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  DWORD nStdHandle;\n  \n  uVar3 = 0;\n  do {\n    iVar2 = (uVar3 & 0x3f) * 0x30 + (&DAT_0043b110)[(int)uVar3 >> 6];\n    if ((*(int *)(iVar2 + 0x18) == -1) || (*(int *)(iVar2 + 0x18) == -2)) {\n      *(undefined1 *)(iVar2 + 0x28) = 0x81;\n      if (uVar3 == 0) {\n        nStdHandle = 0xfffffff6;\n      }\n      else if (uVar3 == 1) {\n        nStdHandle = 0xfffffff5;\n      }\n      else {\n        nStdHandle = 0xfffffff4;\n      }\n      hFile = GetStdHandle(nStdHandle);\n      if ((hFile == (HANDLE)0xffffffff) || (hFile == (HANDLE)0x0)) {\n        uVar1 = 0;\n      }\n      else {\n        uVar1 = GetFileType(hFile);\n      }\n      if (uVar1 == 0) {\n        *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 0x40;\n        *(undefined4 *)(iVar2 + 0x18) = 0xfffffffe;\n        if (DAT_0043ae98 != 0) {\n          *(undefined4 *)(*(int *)(DAT_0043ae98 + uVar3 * 4) + 0x10) = 0xfffffffe;\n        }\n      }\n      else {\n        *(HANDLE *)(iVar2 + 0x18) = hFile;\n        if ((uVar1 & 0xff) == 2) {\n          *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 0x40;\n        }\n        else if ((uVar1 & 0xff) == 3) {\n          *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 8;\n        }\n      }\n    }\n    else {\n      *(byte *)(iVar2 + 0x28) = *(byte *)(iVar2 + 0x28) | 0x80;\n    }\n    uVar3 = uVar3 + 1;\n  } while (uVar3 != 3);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041363f",
      "entry": "0041363f",
      "c": "\nvoid FUN_0041363f(void)\n\n{\n  ___acrt_unlock(7);\n  return;\n}\n\n"
    },
    {
      "name": "write_double_translated_ansi_nolock",
      "entry": "00413674",
      "c": "\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_double_translated_ansi_nolock(int,char\n   const * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl write_double_translated_ansi_nolock(int param_1,char *param_2,uint param_3)\n\n{\n  byte bVar1;\n  HANDLE hFile;\n  byte *pbVar2;\n  UINT CodePage;\n  ushort *puVar3;\n  int iVar4;\n  uint uVar5;\n  BOOL BVar6;\n  DWORD DVar7;\n  int iVar8;\n  int iVar9;\n  byte *pbVar10;\n  int in_stack_00000010;\n  byte *_SrcCh;\n  size_t _SrcSizeInBytes;\n  uint local_24;\n  undefined2 local_20;\n  wchar_t local_1c [2];\n  CHAR local_18 [8];\n  byte local_10;\n  undefined1 local_f;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  iVar8 = (int)param_2 >> 6;\n  iVar9 = ((uint)param_2 & 0x3f) * 0x30;\n  hFile = *(HANDLE *)((&DAT_0043b110)[iVar8] + 0x18 + iVar9);\n  pbVar2 = (byte *)(in_stack_00000010 + param_3);\n  CodePage = GetConsoleCP();\n  *(undefined4 *)param_1 = 0;\n  *(undefined4 *)(param_1 + 4) = 0;\n  *(undefined4 *)(param_1 + 8) = 0;\n  pbVar10 = (byte *)param_3;\n  if (param_3 < pbVar2) {\n    do {\n      local_1c[0] = L'\\0';\n      local_20 = CONCAT11(*pbVar10,(undefined1)local_20);\n      iVar4 = (&DAT_0043b110)[iVar8];\n      bVar1 = *(byte *)(iVar4 + 0x2d + iVar9);\n      if ((bVar1 & 4) == 0) {\n        puVar3 = ___pctype_func();\n        if ((puVar3[*pbVar10] & 0x8000) == 0) {\n          _SrcSizeInBytes = 1;\n          _SrcCh = pbVar10;\n          goto LAB_00413748;\n        }\n        if (pbVar2 <= pbVar10) {\n          *(byte *)((&DAT_0043b110)[iVar8] + 0x2e + iVar9) = *pbVar10;\n          pbVar10 = (byte *)((&DAT_0043b110)[iVar8] + 0x2d + iVar9);\n          *pbVar10 = *pbVar10 | 4;\n          *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 1;\n          break;\n        }\n        iVar4 = _mbtowc(local_1c,(char *)pbVar10,2);\n        if (iVar4 == -1) break;\n        pbVar10 = pbVar10 + 1;\n      }\n      else {\n        local_10 = *(byte *)(iVar4 + 0x2e + iVar9);\n        uVar5 = CONCAT11(*pbVar10,bVar1) & 0xfffffffb;\n        _SrcSizeInBytes = 2;\n        local_f = (undefined1)(uVar5 >> 8);\n        *(char *)(iVar4 + 0x2d + iVar9) = (char)uVar5;\n        _SrcCh = &local_10;\nLAB_00413748:\n        iVar4 = _mbtowc(local_1c,(char *)_SrcCh,_SrcSizeInBytes);\n        if (iVar4 == -1) break;\n      }\n      pbVar10 = pbVar10 + 1;\n      uVar5 = WideCharToMultiByte(CodePage,0,local_1c,1,local_18,5,(LPCSTR)0x0,(LPBOOL)0x0);\n      if (uVar5 == 0) break;\n      BVar6 = WriteFile(hFile,local_18,uVar5,&local_24,(LPOVERLAPPED)0x0);\n      if (BVar6 == 0) {\nLAB_0041380c:\n        DVar7 = GetLastError();\n        *(DWORD *)param_1 = DVar7;\n        break;\n      }\n      *(byte **)(param_1 + 4) = pbVar10 + (*(int *)(param_1 + 8) - param_3);\n      if (local_24 < uVar5) break;\n      if (local_20._1_1_ == '\\n') {\n        local_20 = 0xd;\n        BVar6 = WriteFile(hFile,&local_20,1,&local_24,(LPOVERLAPPED)0x0);\n        if (BVar6 == 0) goto LAB_0041380c;\n        if (local_24 == 0) break;\n        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;\n        *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 1;\n      }\n    } while (pbVar10 < pbVar2);\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "write_double_translated_unicode_nolock",
      "entry": "00413827",
      "c": "\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_double_translated_unicode_nolock(char\n   const * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl write_double_translated_unicode_nolock(char *param_1,uint param_2)\n\n{\n  wchar_t _WCh;\n  wchar_t wVar1;\n  wint_t wVar2;\n  wchar_t *pwVar3;\n  DWORD DVar4;\n  int in_stack_0000000c;\n  \n  param_1[0] = '\\0';\n  param_1[1] = '\\0';\n  param_1[2] = '\\0';\n  param_1[3] = '\\0';\n  param_1[4] = '\\0';\n  param_1[5] = '\\0';\n  param_1[6] = '\\0';\n  param_1[7] = '\\0';\n  param_1[8] = '\\0';\n  param_1[9] = '\\0';\n  param_1[10] = '\\0';\n  param_1[0xb] = '\\0';\n  pwVar3 = (wchar_t *)(in_stack_0000000c + param_2);\n  if (param_2 < pwVar3) {\n    do {\n      _WCh = *(wchar_t *)param_2;\n      wVar1 = __putwch_nolock(_WCh);\n      if (wVar1 != _WCh) {\nLAB_00413883:\n        DVar4 = GetLastError();\n        *(DWORD *)param_1 = DVar4;\n        return param_1;\n      }\n      *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 2;\n      if (_WCh == L'\\n') {\n        wVar2 = __putwch_nolock(L'\\r');\n        if (wVar2 != 0xd) goto LAB_00413883;\n        *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + 1;\n        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;\n      }\n      param_2 = param_2 + 2;\n    } while (param_2 < pwVar3);\n  }\n  return param_1;\n}\n\n"
    },
    {
      "name": "write_requires_double_translation_nolock",
      "entry": "00413894",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl write_requires_double_translation_nolock(int)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl write_requires_double_translation_nolock(int param_1)\n\n{\n  int iVar1;\n  __acrt_ptd *p_Var2;\n  BOOL BVar3;\n  int iVar4;\n  bool bVar5;\n  DWORD local_8;\n  \n  iVar1 = __isatty(param_1);\n  if (iVar1 == 0) {\n    bVar5 = false;\n  }\n  else {\n    iVar4 = param_1 >> 6;\n    iVar1 = (param_1 & 0x3fU) * 0x30;\n    if (((*(byte *)((&DAT_0043b110)[iVar4] + 0x28 + iVar1) & 0x80) == 0) ||\n       ((p_Var2 = ___acrt_getptd(), *(int *)(*(int *)(p_Var2 + 0x4c) + 0xa8) == 0 &&\n        (*(char *)((&DAT_0043b110)[iVar4] + 0x29 + iVar1) == '\\0')))) {\n      bVar5 = false;\n    }\n    else {\n      BVar3 = GetConsoleMode(*(HANDLE *)((&DAT_0043b110)[iVar4] + 0x18 + iVar1),&local_8);\n      bVar5 = BVar3 != 0;\n    }\n  }\n  return bVar5;\n}\n\n"
    },
    {
      "name": "write_text_ansi_nolock",
      "entry": "0041390a",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *\n   const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl write_text_ansi_nolock(int param_1,char *param_2,uint param_3)\n\n{\n  char cVar1;\n  HANDLE hFile;\n  BOOL BVar2;\n  DWORD DVar3;\n  char *pcVar4;\n  int in_stack_00000010;\n  uint local_1410;\n  char *local_140c;\n  char local_1408 [5120];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  hFile = *(HANDLE *)((&DAT_0043b110)[(int)param_2 >> 6] + 0x18 + ((uint)param_2 & 0x3f) * 0x30);\n  *(undefined4 *)param_1 = 0;\n  local_140c = (char *)(in_stack_00000010 + param_3);\n  *(undefined4 *)(param_1 + 4) = 0;\n  *(undefined4 *)(param_1 + 8) = 0;\n  do {\n    if (local_140c <= param_3) break;\n    pcVar4 = local_1408;\n    do {\n      if (local_140c <= param_3) break;\n      cVar1 = *(char *)param_3;\n      param_3 = param_3 + 1;\n      if (cVar1 == '\\n') {\n        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;\n        *pcVar4 = '\\r';\n        pcVar4 = pcVar4 + 1;\n      }\n      *pcVar4 = cVar1;\n      pcVar4 = pcVar4 + 1;\n    } while (pcVar4 < local_1408 + 0x13ff);\n    BVar2 = WriteFile(hFile,local_1408,(int)pcVar4 - (int)local_1408,&local_1410,(LPOVERLAPPED)0x0);\n    if (BVar2 == 0) {\n      DVar3 = GetLastError();\n      *(DWORD *)param_1 = DVar3;\n      break;\n    }\n    *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + local_1410;\n  } while ((uint)((int)pcVar4 - (int)local_1408) <= local_1410);\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "write_text_utf16le_nolock",
      "entry": "004139e9",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_text_utf16le_nolock(int,char const *\n   const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl write_text_utf16le_nolock(int param_1,char *param_2,uint param_3)\n\n{\n  short sVar1;\n  HANDLE hFile;\n  BOOL BVar2;\n  DWORD DVar3;\n  short *psVar4;\n  int in_stack_00000010;\n  uint local_1410;\n  short *local_140c;\n  short local_1408 [2560];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  hFile = *(HANDLE *)((&DAT_0043b110)[(int)param_2 >> 6] + 0x18 + ((uint)param_2 & 0x3f) * 0x30);\n  local_140c = (short *)(in_stack_00000010 + param_3);\n  *(undefined4 *)param_1 = 0;\n  *(undefined4 *)(param_1 + 4) = 0;\n  *(undefined4 *)(param_1 + 8) = 0;\n  do {\n    if (local_140c <= param_3) break;\n    psVar4 = local_1408;\n    do {\n      if (local_140c <= param_3) break;\n      sVar1 = *(short *)param_3;\n      param_3 = param_3 + 2;\n      if (sVar1 == 10) {\n        *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 2;\n        *psVar4 = 0xd;\n        psVar4 = psVar4 + 1;\n      }\n      *psVar4 = sVar1;\n      psVar4 = psVar4 + 1;\n    } while (psVar4 < local_1408 + 0x9ff);\n    BVar2 = WriteFile(hFile,local_1408,(int)psVar4 - (int)local_1408,&local_1410,(LPOVERLAPPED)0x0);\n    if (BVar2 == 0) {\n      DVar3 = GetLastError();\n      *(DWORD *)param_1 = DVar3;\n      break;\n    }\n    *(int *)(param_1 + 4) = *(int *)(param_1 + 4) + local_1410;\n  } while ((uint)((int)psVar4 - (int)local_1408) <= local_1410);\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "write_text_utf8_nolock",
      "entry": "00413ad7",
      "c": "\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *\n   const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl write_text_utf8_nolock(int param_1,char *param_2,uint param_3)\n\n{\n  WCHAR WVar1;\n  HANDLE hFile;\n  WCHAR *pWVar2;\n  uint uVar3;\n  BOOL BVar4;\n  DWORD DVar5;\n  uint uVar6;\n  WCHAR *pWVar7;\n  int in_stack_00000010;\n  DWORD local_1414;\n  WCHAR *local_1410;\n  CHAR local_140c [3416];\n  WCHAR local_6b4 [854];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  hFile = *(HANDLE *)((&DAT_0043b110)[(int)param_2 >> 6] + 0x18 + ((uint)param_2 & 0x3f) * 0x30);\n  local_1410 = (WCHAR *)(in_stack_00000010 + param_3);\n  *(undefined4 *)param_1 = 0;\n  *(undefined4 *)(param_1 + 4) = 0;\n  *(undefined4 *)(param_1 + 8) = 0;\n  pWVar7 = (WCHAR *)param_3;\n  if (param_3 < local_1410) {\n    do {\n      uVar6 = 0;\n      pWVar2 = local_6b4;\n      do {\n        if (local_1410 <= pWVar7) break;\n        WVar1 = *pWVar7;\n        pWVar7 = pWVar7 + 1;\n        if (WVar1 == L'\\n') {\n          *pWVar2 = L'\\r';\n          pWVar2 = pWVar2 + 1;\n        }\n        *pWVar2 = WVar1;\n        pWVar2 = pWVar2 + 1;\n      } while (pWVar2 < local_6b4 + 0x354);\n      uVar3 = WideCharToMultiByte(0xfde9,0,local_6b4,(int)pWVar2 - (int)local_6b4 >> 1,local_140c,\n                                  0xd55,(LPCSTR)0x0,(LPBOOL)0x0);\n      if (uVar3 == 0) {\nLAB_00413be9:\n        DVar5 = GetLastError();\n        *(DWORD *)param_1 = DVar5;\n        break;\n      }\n      do {\n        BVar4 = WriteFile(hFile,local_140c + uVar6,uVar3 - uVar6,&local_1414,(LPOVERLAPPED)0x0);\n        if (BVar4 == 0) goto LAB_00413be9;\n        uVar6 = uVar6 + local_1414;\n      } while (uVar6 < uVar3);\n      *(uint *)(param_1 + 4) = (int)pWVar7 - param_3;\n    } while (pWVar7 < local_1410);\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "__write",
      "entry": "00413c04",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    __write\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __write(int _FileHandle,void *_Buf,uint _MaxCharCount)\n\n{\n  ulong *puVar1;\n  int *piVar2;\n  int iVar3;\n  int iVar4;\n  \n  if (_FileHandle == -2) {\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n  }\n  else {\n    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) {\n      iVar3 = (_FileHandle & 0x3fU) * 0x30;\n      if ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + iVar3) & 1) != 0) {\n        ___acrt_lowio_lock_fh(_FileHandle);\n        iVar4 = -1;\n        if ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + iVar3) & 1) == 0) {\n          piVar2 = __errno();\n          *piVar2 = 9;\n          puVar1 = ___doserrno();\n          *puVar1 = 0;\n        }\n        else {\n          iVar4 = __write_nolock(_FileHandle,_Buf,_MaxCharCount);\n        }\n        FUN_00413cc6();\n        return iVar4;\n      }\n    }\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 9;\n    FUN_00412362();\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "FUN_00413cc6",
      "entry": "00413cc6",
      "c": "\nvoid FUN_00413cc6(void)\n\n{\n  uint unaff_ESI;\n  \n  ___acrt_lowio_unlock_fh(unaff_ESI);\n  return;\n}\n\n"
    },
    {
      "name": "__write_nolock",
      "entry": "00413cef",
      "c": "\n/* Library Function - Single Match\n    __write_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __write_nolock(int _FileHandle,void *_Buf,uint _MaxCharCount)\n\n{\n  ulong uVar1;\n  char cVar2;\n  bool bVar3;\n  ulong *puVar4;\n  int *piVar5;\n  BOOL BVar6;\n  int iVar7;\n  int unaff_EBX;\n  int iVar8;\n  ulong local_18;\n  DWORD local_14 [2];\n  uint local_c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_c = _MaxCharCount;\n  if (_MaxCharCount == 0) goto LAB_00413eeb;\n  if (_Buf == (void *)0x0) {\n    puVar4 = ___doserrno();\n    *puVar4 = 0;\n    piVar5 = __errno();\n    *piVar5 = 0x16;\n    FUN_00412362();\n    goto LAB_00413eeb;\n  }\n  iVar8 = _FileHandle >> 6;\n  iVar7 = (_FileHandle & 0x3fU) * 0x30;\n  cVar2 = *(char *)((&DAT_0043b110)[iVar8] + 0x29 + iVar7);\n  if (((cVar2 == '\\x02') || (cVar2 == '\\x01')) && ((~_MaxCharCount & 1) == 0)) {\n    puVar4 = ___doserrno();\n    *puVar4 = 0;\n    piVar5 = __errno();\n    *piVar5 = 0x16;\n    FUN_00412362();\n    goto LAB_00413eeb;\n  }\n  if ((*(byte *)((&DAT_0043b110)[iVar8] + 0x28 + iVar7) & 0x20) != 0) {\n    __lseeki64_nolock(_FileHandle,0x200000000,unaff_EBX);\n  }\n  bVar3 = write_requires_double_translation_nolock(_FileHandle);\n  if (bVar3) {\n    if (cVar2 == '\\0') {\n      puVar4 = (ulong *)write_double_translated_ansi_nolock\n                                  ((int)&local_18,(char *)_FileHandle,(uint)_Buf);\n      goto LAB_00413e77;\n    }\n    if ((byte)(cVar2 - 1U) < 2) {\n      puVar4 = (ulong *)write_double_translated_unicode_nolock((char *)&local_18,(uint)_Buf);\n      goto LAB_00413e77;\n    }\n  }\n  else {\n    if ((*(byte *)((&DAT_0043b110)[iVar8] + 0x28 + iVar7) & 0x80) == 0) {\n      local_18 = 0;\n      local_14[0] = 0;\n      local_14[1] = 0;\n      BVar6 = WriteFile(*(HANDLE *)((&DAT_0043b110)[iVar8] + 0x18 + iVar7),_Buf,local_c,local_14,\n                        (LPOVERLAPPED)0x0);\n      if (BVar6 == 0) {\n        local_18 = GetLastError();\n      }\n      puVar4 = &local_18;\n    }\n    else if (cVar2 == '\\0') {\n      puVar4 = (ulong *)write_text_ansi_nolock((int)&local_18,(char *)_FileHandle,(uint)_Buf);\n    }\n    else if (cVar2 == '\\x01') {\n      puVar4 = (ulong *)write_text_utf8_nolock((int)&local_18,(char *)_FileHandle,(uint)_Buf);\n    }\n    else {\n      if (cVar2 != '\\x02') goto LAB_00413eb2;\n      puVar4 = (ulong *)write_text_utf16le_nolock((int)&local_18,(char *)_FileHandle,(uint)_Buf);\n    }\nLAB_00413e77:\n    uVar1 = *puVar4;\n    if (puVar4[1] != 0) goto LAB_00413eeb;\n    if (uVar1 != 0) {\n      if (uVar1 == 5) {\n        piVar5 = __errno();\n        *piVar5 = 9;\n        puVar4 = ___doserrno();\n        *puVar4 = 5;\n      }\n      else {\n        ___acrt_errno_map_os_error(uVar1);\n      }\n      goto LAB_00413eeb;\n    }\n  }\nLAB_00413eb2:\n                    /* WARNING: Load size is inaccurate */\n  if (((*(byte *)((&DAT_0043b110)[iVar8] + 0x28 + iVar7) & 0x40) == 0) || (*_Buf != '\\x1a')) {\n    piVar5 = __errno();\n    *piVar5 = 0x1c;\n    puVar4 = ___doserrno();\n    *puVar4 = 0;\n  }\nLAB_00413eeb:\n  iVar7 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar7;\n}\n\n"
    },
    {
      "name": "common_flush_and_write_nolock<char>",
      "entry": "00413efb",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_flush_and_write_nolock<char>(int,class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_flush_and_write_nolock<char>(uint param_1,FILE *param_2)\n\n{\n  bool bVar1;\n  int iVar2;\n  int *piVar3;\n  FILE *pFVar4;\n  \n  iVar2 = __fileno(param_2);\n  if ((param_2->_flag & 6U) == 0) {\n    piVar3 = __errno();\n    *piVar3 = 9;\n  }\n  else {\n    if (((uint)param_2->_flag >> 0xc & 1) == 0) {\n      if ((param_2->_flag & 1U) != 0) {\n        param_2->_base = (char *)0x0;\n        if (((uint)param_2->_flag >> 3 & 1) == 0) goto LAB_00413f25;\n        param_2->_ptr = (char *)param_2->_cnt;\n        LOCK();\n        param_2->_flag = param_2->_flag & 0xfffffffe;\n        UNLOCK();\n      }\n      LOCK();\n      param_2->_flag = param_2->_flag | 2;\n      UNLOCK();\n      LOCK();\n      param_2->_flag = param_2->_flag & 0xfffffff7;\n      UNLOCK();\n      param_2->_base = (char *)0x0;\n      if (((param_2->_flag & 0x4c0U) == 0) &&\n         (((pFVar4 = (FILE *)___acrt_iob_func(1), param_2 != pFVar4 &&\n           (pFVar4 = (FILE *)___acrt_iob_func(2), param_2 != pFVar4)) ||\n          (iVar2 = __isatty(iVar2), iVar2 == 0)))) {\n        ___acrt_stdio_allocate_buffer_nolock(&param_2->_ptr);\n      }\n      bVar1 = write_buffer_nolock<char>(param_1,param_2);\n      if (!bVar1) {\n        LOCK();\n        param_2->_flag = param_2->_flag | 0x10;\n        UNLOCK();\n        return -1;\n      }\n      return param_1 & 0xff;\n    }\n    piVar3 = __errno();\n    *piVar3 = 0x22;\n  }\nLAB_00413f25:\n  LOCK();\n  param_2->_flag = param_2->_flag | 0x10;\n  UNLOCK();\n  return -1;\n}\n\n"
    },
    {
      "name": "write_buffer_nolock<char>",
      "entry": "0041400c",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl write_buffer_nolock<char>(char,class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl write_buffer_nolock<char>(undefined1 param_1,FILE *param_2)\n\n{\n  uint _FileHandle;\n  undefined *puVar1;\n  int iVar2;\n  uint _MaxCharCount;\n  int unaff_EDI;\n  uint uVar3;\n  char cVar4;\n  longlong lVar5;\n  \n  _FileHandle = __fileno(param_2);\n  if ((param_2->_flag & 0xc0U) == 0) {\n    iVar2 = __write(_FileHandle,&param_1,1);\n    cVar4 = '\\x01' - (iVar2 != 1);\n  }\n  else {\n    uVar3 = 0;\n    _MaxCharCount = (int)param_2->_ptr - param_2->_cnt;\n    param_2->_ptr = (char *)(param_2->_cnt + 1);\n    param_2->_base = (char *)(param_2->_bufsiz + -1);\n    if ((int)_MaxCharCount < 1) {\n      if ((_FileHandle == 0xffffffff) || (_FileHandle == 0xfffffffe)) {\n        puVar1 = &DAT_0042d210;\n      }\n      else {\n        puVar1 = (undefined *)((_FileHandle & 0x3f) * 0x30 + (&DAT_0043b110)[(int)_FileHandle >> 6])\n        ;\n      }\n      if (((puVar1[0x28] & 0x20) != 0) &&\n         (lVar5 = __lseeki64(_FileHandle,0x200000000,unaff_EDI), lVar5 == -1)) {\n        LOCK();\n        param_2->_flag = param_2->_flag | 0x10;\n        UNLOCK();\n        return true;\n      }\n    }\n    else {\n      uVar3 = __write(_FileHandle,(void *)param_2->_cnt,_MaxCharCount);\n    }\n    *(undefined1 *)param_2->_cnt = param_1;\n    cVar4 = uVar3 == _MaxCharCount;\n  }\n  return (bool)cVar4;\n}\n\n"
    },
    {
      "name": "FUN_004140d8",
      "entry": "004140d8",
      "c": "\nvoid FUN_004140d8(void)\n\n{\n  common_flush_and_write_nolock<char>();\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_stdio_begin_temporary_buffering_nolock",
      "entry": "004140e3",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___acrt_stdio_begin_temporary_buffering_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___acrt_stdio_begin_temporary_buffering_nolock(FILE *param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  FILE *pFVar3;\n  LPVOID pvVar4;\n  char *pcVar5;\n  int *piVar6;\n  \n  iVar2 = __fileno(param_1);\n  iVar2 = __isatty(iVar2);\n  if (iVar2 == 0) {\n    return 0;\n  }\n  pFVar3 = (FILE *)___acrt_iob_func(1);\n  if (param_1 == pFVar3) {\n    piVar6 = &DAT_0043b314;\n  }\n  else {\n    pFVar3 = (FILE *)___acrt_iob_func(2);\n    if (param_1 != pFVar3) goto LAB_00414191;\n    piVar6 = &DAT_0043b318;\n  }\n  _DAT_0043ae9c = _DAT_0043ae9c + 1;\n  piVar1 = &param_1->_flag;\n  pFVar3 = (FILE *)*piVar1;\n  if (((uint)pFVar3 & 0x4c0) != 0) {\nLAB_00414191:\n    return (uint)pFVar3 & 0xffffff00;\n  }\n  LOCK();\n  *piVar1 = *piVar1 | 0x282;\n  UNLOCK();\n  iVar2 = *piVar6;\n  if (iVar2 == 0) {\n    pvVar4 = __malloc_base(0x1000);\n    *piVar6 = (int)pvVar4;\n    FID_conflict__free((void *)0x0);\n    iVar2 = *piVar6;\n    if (iVar2 == 0) {\n      param_1->_base = (char *)0x2;\n      param_1->_cnt = (int)&param_1->_charbuf;\n      param_1->_ptr = (char *)&param_1->_charbuf;\n      param_1->_bufsiz = 2;\n      pcVar5 = (char *)0x0;\n      goto LAB_0041418d;\n    }\n  }\n  param_1->_cnt = iVar2;\n  pcVar5 = (char *)*piVar6;\n  param_1->_ptr = pcVar5;\n  param_1->_base = (char *)0x1000;\n  param_1->_bufsiz = 0x1000;\nLAB_0041418d:\n  return CONCAT31((int3)((uint)pcVar5 >> 8),1);\n}\n\n"
    },
    {
      "name": "___acrt_stdio_end_temporary_buffering_nolock",
      "entry": "00414198",
      "c": "\n/* Library Function - Single Match\n    ___acrt_stdio_end_temporary_buffering_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_stdio_end_temporary_buffering_nolock(char param_1,FILE *param_2)\n\n{\n  int *piVar1;\n  \n  if ((param_1 != '\\0') && (piVar1 = &param_2->_flag, ((uint)*piVar1 >> 9 & 1) != 0)) {\n    ___acrt_stdio_flush_nolock(param_2);\n    LOCK();\n    *piVar1 = *piVar1 & 0xfffffd7f;\n    UNLOCK();\n    param_2->_bufsiz = 0;\n    param_2->_cnt = 0;\n    param_2->_ptr = (char *)0x0;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "try_get_CompareStringEx",
      "entry": "004141d1",
      "c": "\n/* Library Function - Single Match\n    int (__stdcall*__cdecl try_get_CompareStringEx(void))(wchar_t const *,unsigned long,wchar_t\n   const *,int,wchar_t const *,int,struct _nlsversioninfo *,void *,long)\n   \n   Library: Visual Studio 2015 Release */\n\n_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long *\n__cdecl try_get_CompareStringEx(void)\n\n{\n  _func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long\n  *p_Var1;\n  \n  p_Var1 = (_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long\n            *)try_get_function(1,\"CompareStringEx\",(module_id *)&DAT_00426eac,\n                               (module_id *)\"CompareStringEx\");\n  return p_Var1;\n}\n\n"
    },
    {
      "name": "try_get_function",
      "entry": "004141eb",
      "c": "\n/* Library Function - Single Match\n    void * __cdecl try_get_function(enum `anonymous namespace'::function_id,char const * const,enum\n   A0x9b56aee1::module_id const * const,enum A0x9b56aee1::module_id const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid * __cdecl\ntry_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)\n\n{\n  uint *puVar1;\n  HMODULE hModule;\n  FARPROC pFVar2;\n  byte bVar3;\n  void *pvVar4;\n  \n  puVar1 = &DAT_0043b370 + param_1;\n  bVar3 = (byte)DAT_0042d008 & 0x1f;\n  pvVar4 = (void *)((DAT_0042d008 ^ *puVar1) >> bVar3 | (DAT_0042d008 ^ *puVar1) << 0x20 - bVar3);\n  if (pvVar4 != (void *)0xffffffff) {\n    if (pvVar4 != (void *)0x0) {\n      return pvVar4;\n    }\n    if (param_3 != param_4) {\n      do {\n        hModule = try_get_module(*param_3);\n        if (hModule != (HMODULE)0x0) goto LAB_00414243;\n        param_3 = param_3 + 1;\n      } while (param_3 != param_4);\n    }\n    hModule = (HMODULE)0x0;\nLAB_00414243:\n    if ((hModule != (HMODULE)0x0) &&\n       (pFVar2 = GetProcAddress(hModule,param_2), pFVar2 != (FARPROC)0x0)) {\n      pvVar4 = __crt_fast_encode_pointer<void*>(pFVar2);\n      LOCK();\n      *puVar1 = (uint)pvVar4;\n      UNLOCK();\n      return pFVar2;\n    }\n    bVar3 = 0x20 - ((byte)DAT_0042d008 & 0x1f) & 0x1f;\n    LOCK();\n    *puVar1 = (0xffffffffU >> bVar3 | -1 << 0x20 - bVar3) ^ DAT_0042d008;\n    UNLOCK();\n  }\n  return (void *)0x0;\n}\n\n"
    },
    {
      "name": "try_get_module",
      "entry": "00414287",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    struct HINSTANCE__ * __cdecl try_get_module(enum `anonymous namespace'::module_id)\n    struct HINSTANCE__ * __cdecl try_get_module(enum `anonymous namespace'::module_id)\n   \n   Library: Visual Studio 2015 Release */\n\nHMODULE __cdecl try_get_module(int param_1)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  LPCWSTR lpLibFileName;\n  HMODULE hLibModule;\n  DWORD DVar3;\n  \n  puVar1 = &DAT_0043b320 + param_1;\n  uVar2 = *puVar1;\n  if (uVar2 == 0) {\n    lpLibFileName = (LPCWSTR)(&PTR_u_api_ms_win_appmodel_runtime_l1_1_004269f8)[param_1];\n    hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0x800);\n    if (hLibModule == (HMODULE)0x0) {\n      DVar3 = GetLastError();\n      if (DVar3 == 0x57) {\n        hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0);\n      }\n      else {\n        hLibModule = (HMODULE)0x0;\n      }\n      if (hLibModule == (HMODULE)0x0) {\n        LOCK();\n        *puVar1 = 0xffffffff;\n        UNLOCK();\n        return (HMODULE)0x0;\n      }\n    }\n    LOCK();\n    uVar2 = *puVar1;\n    *puVar1 = (uint)hLibModule;\n    UNLOCK();\n    if (uVar2 != 0) {\n      FreeLibrary(hLibModule);\n    }\n  }\n  else {\n    hLibModule = (HMODULE)(-(uint)(uVar2 != 0xffffffff) & uVar2);\n  }\n  return hLibModule;\n}\n\n"
    },
    {
      "name": "___acrt_AreFileApisANSI@0",
      "entry": "00414302",
      "c": "\n/* Library Function - Single Match\n    ___acrt_AreFileApisANSI@0\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_AreFileApisANSI_0(void)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(0,\"AreFileApisANSI\",(module_id *)&DAT_00426e98,\n                                    (module_id *)\"AreFileApisANSI\");\n  if (pcVar2 != (code *)0x0) {\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_CompareStringEx@36",
      "entry": "00414350",
      "c": "\n/* Library Function - Single Match\n    ___acrt_CompareStringEx@36\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_CompareStringEx_36\n               (wchar_t *param_1,ulong param_2,wchar_t *param_3,int param_4,wchar_t *param_5,\n               int param_6,_nlsversioninfo *param_7,void *param_8,long param_9)\n\n{\n  uint uVar1;\n  _func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long\n  *p_Var2;\n  LCID Locale;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  p_Var2 = try_get_CompareStringEx();\n  if (p_Var2 == (_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long\n                 *)0x0) {\n    Locale = ___acrt_LocaleNameToLCID_8(param_1,0);\n    CompareStringW(Locale,param_2,param_3,param_4,param_5,param_6);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    (*p_Var2)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_FlsAlloc@4",
      "entry": "004143c4",
      "c": "\n/* Library Function - Single Match\n    ___acrt_FlsAlloc@4\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_FlsAlloc_4(undefined4 param_1)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(3,\"FlsAlloc\",(module_id *)&DAT_00426ec4,\n                                    (module_id *)&DAT_00426ecc);\n  if (pcVar2 == (code *)0x0) {\n    TlsAlloc();\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)(param_1);\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_FlsFree@4",
      "entry": "0041441a",
      "c": "\n/* Library Function - Single Match\n    ___acrt_FlsFree@4\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_FlsFree_4(DWORD param_1)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(4,\"FlsFree\",(module_id *)&DAT_00426ecc,\n                                    (module_id *)&DAT_00426ed4);\n  if (pcVar2 == (code *)0x0) {\n    TlsFree(param_1);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_FlsGetValue@4",
      "entry": "00414470",
      "c": "\n/* Library Function - Single Match\n    ___acrt_FlsGetValue@4\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_FlsGetValue_4(DWORD param_1)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(5,\"FlsGetValue\",(module_id *)&DAT_00426ed4,\n                                    (module_id *)&DAT_00426edc);\n  if (pcVar2 == (code *)0x0) {\n    TlsGetValue(param_1);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_FlsSetValue@8",
      "entry": "004144c6",
      "c": "\n/* Library Function - Single Match\n    ___acrt_FlsSetValue@8\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_FlsSetValue_8(DWORD param_1,LPVOID param_2)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(6,\"FlsSetValue\",(module_id *)&DAT_00426edc,\n                                    (module_id *)&DAT_00426ee4);\n  if (pcVar2 == (code *)0x0) {\n    TlsSetValue(param_1,param_2);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_GetFileInformationByHandleEx@16",
      "entry": "0041451f",
      "c": "\n/* Library Function - Single Match\n    ___acrt_GetFileInformationByHandleEx@16\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_GetFileInformationByHandleEx_16\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(0xb,\"GetFileInformationByHandleEx\",(module_id *)&DAT_00426f00,\n                                    (module_id *)\"GetFileInformationByHandleEx\");\n  if (pcVar2 == (code *)0x0) {\n    SetLastError(0x78);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)(param_1,param_2,param_3,param_4);\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_InitializeCriticalSectionEx@12",
      "entry": "00414582",
      "c": "\n/* Library Function - Single Match\n    ___acrt_InitializeCriticalSectionEx@12\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_InitializeCriticalSectionEx_12\n               (LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(0x14,\"InitializeCriticalSectionEx\",(module_id *)&DAT_00426f28,\n                                    (module_id *)&DAT_00426f30);\n  if (pcVar2 == (code *)0x0) {\n    InitializeCriticalSectionAndSpinCount(param_1,param_2);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)(param_1,param_2,param_3);\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_LCMapStringEx@36",
      "entry": "004145e4",
      "c": "\n/* Library Function - Single Match\n    ___acrt_LCMapStringEx@36\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_LCMapStringEx_36\n               (wchar_t *param_1,DWORD param_2,LPCWSTR param_3,int param_4,LPWSTR param_5,\n               int param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  LCID Locale;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(0x16,\"LCMapStringEx\",(module_id *)&DAT_00426f30,\n                                    (module_id *)\"LCMapStringEx\");\n  if (pcVar2 == (code *)0x0) {\n    Locale = ___acrt_LocaleNameToLCID_8(param_1,0);\n    LCMapStringW(Locale,param_2,param_3,param_4,param_5,param_6);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)\n              (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_LocaleNameToLCID@8",
      "entry": "0041466c",
      "c": "\n/* Library Function - Single Match\n    ___acrt_LocaleNameToLCID@8\n   \n   Library: Visual Studio 2015 Release */\n\nvoid ___acrt_LocaleNameToLCID_8(wchar_t *param_1,undefined4 param_2)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)try_get_function(0x18,\"LocaleNameToLCID\",(module_id *)&DAT_00426f48,\n                                    (module_id *)\"LocaleNameToLCID\");\n  if (pcVar2 == (code *)0x0) {\n    ___acrt_DownlevelLocaleNameToLCID(param_1);\n  }\n  else {\n    (*(code *)PTR_guard_check_icall_0042118c)(param_1,param_2);\n    (*pcVar2)();\n  }\n  __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_is_packaged_app",
      "entry": "004146ee",
      "c": "\n/* Library Function - Single Match\n    ___acrt_is_packaged_app\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __fastcall ___acrt_is_packaged_app(undefined4 param_1)\n\n{\n  code *pcVar1;\n  int iVar2;\n  undefined4 local_c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_c = param_1;\n  if (DAT_0043b3f0 == 0) {\n    pcVar1 = (code *)try_get_function(8,\"GetCurrentPackageId\",(module_id *)&DAT_00426ee4,\n                                      (module_id *)\"GetCurrentPackageId\");\n    if (pcVar1 != (code *)0x0) {\n      local_c = 0;\n      (*(code *)PTR_guard_check_icall_0042118c)(&local_c,0);\n      iVar2 = (*pcVar1)();\n      if (iVar2 == 0x7a) {\n        LOCK();\n        DAT_0043b3f0 = 1;\n        UNLOCK();\n        goto LAB_00414767;\n      }\n    }\n    LOCK();\n    DAT_0043b3f0 = 2;\n    UNLOCK();\n  }\nLAB_00414767:\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_uninitialize_winapi_thunks",
      "entry": "00414775",
      "c": "\n/* Library Function - Single Match\n    ___acrt_uninitialize_winapi_thunks\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined1 __cdecl ___acrt_uninitialize_winapi_thunks(char param_1)\n\n{\n  int *piVar1;\n  \n  if (param_1 == '\\0') {\n    piVar1 = &DAT_0043b320;\n    do {\n      if (*piVar1 != 0) {\n        if (*piVar1 != -1) {\n          FreeLibrary((HMODULE)*piVar1);\n        }\n        *piVar1 = 0;\n      }\n      piVar1 = piVar1 + 1;\n    } while (piVar1 != &DAT_0043b370);\n  }\n  return 1;\n}\n\n"
    },
    {
      "name": "FUN_004147ab",
      "entry": "004147ab",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n\nint FUN_004147ab(void)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 local_20;\n  \n  local_20 = 0;\n  ___acrt_lock(8);\n  for (iVar2 = 3; iVar2 != DAT_0043ae94; iVar2 = iVar2 + 1) {\n    iVar1 = *(int *)(DAT_0043ae98 + iVar2 * 4);\n    if (iVar1 != 0) {\n      if ((*(uint *)(iVar1 + 0xc) >> 0xd & 1) != 0) {\n        iVar1 = _fclose(*(FILE **)(DAT_0043ae98 + iVar2 * 4));\n        if (iVar1 != -1) {\n          local_20 = local_20 + 1;\n        }\n      }\n      DeleteCriticalSection((LPCRITICAL_SECTION)(*(int *)(DAT_0043ae98 + iVar2 * 4) + 0x20));\n      FID_conflict__free(*(void **)(DAT_0043ae98 + iVar2 * 4));\n      *(undefined4 *)(DAT_0043ae98 + iVar2 * 4) = 0;\n    }\n  }\n  FUN_00414842();\n  return local_20;\n}\n\n"
    },
    {
      "name": "FUN_00414842",
      "entry": "00414842",
      "c": "\nvoid FUN_00414842(void)\n\n{\n  ___acrt_unlock(8);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041484b",
      "entry": "0041484b",
      "c": "\nundefined ** FUN_0041484b(void)\n\n{\n  return &PTR_s_No_error_00426f68;\n}\n\n"
    },
    {
      "name": "FUN_00414851",
      "entry": "00414851",
      "c": "\nundefined * FUN_00414851(void)\n\n{\n  return &DAT_00427350;\n}\n\n"
    },
    {
      "name": "__isdigit_l",
      "entry": "00414857",
      "c": "\n/* Library Function - Single Match\n    __isdigit_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __isdigit_l(int _C,_locale_t _Locale)\n\n{\n  int iVar1;\n  int local_14;\n  localeinfo_struct local_10;\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);\n  iVar1 = __ischartype_l(_C,4,&local_10);\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "_isdigit",
      "entry": "0041488f",
      "c": "\n/* Library Function - Single Match\n    _isdigit\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _isdigit(int _C)\n\n{\n  int iVar1;\n  \n  if (DAT_0043b0e8 != 0) {\n    iVar1 = __isdigit_l(_C,(_locale_t)0x0);\n    return iVar1;\n  }\n  return *(ushort *)(PTR_DAT_0042d248 + _C * 2) & 4;\n}\n\n"
    },
    {
      "name": "common_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>",
      "entry": "004148bc",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_tox_l<&bool __cdecl internal_isupper_l(int,struct __crt_locale_pointers *\n   const),&int __cdecl internal_map_lower(int,struct __crt_locale_pointers * const)>(int,unsigned\n   long,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>\n          (int param_1,ulong param_2,__crt_locale_pointers *param_3)\n\n{\n  byte bVar1;\n  bool bVar2;\n  int iVar3;\n  int *piVar4;\n  int local_20;\n  localeinfo_struct local_1c;\n  char local_14;\n  uint local_10;\n  byte local_c [4];\n  undefined2 local_8;\n  undefined1 local_6;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_20,param_3);\n  if ((uint)param_1 < 0x100) {\n    bVar2 = internal_isupper_l(param_1,(__crt_locale_pointers *)&local_1c);\n    if (bVar2) {\n      bVar1 = (local_1c.locinfo)->pclmap[param_1];\n      if (local_14 == '\\0') {\n        return (uint)bVar1;\n      }\n      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;\n      return (uint)bVar1;\n    }\n    if (local_14 == '\\0') {\n      return param_1;\n    }\n    *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;\n    return param_1;\n  }\n  local_8 = 0;\n  local_6 = 0;\n  if (1 < (int)(local_1c.locinfo)->lc_codepage) {\n    local_10 = param_1 >> 8;\n    iVar3 = __isleadbyte_l(local_10 & 0xff,&local_1c);\n    if (iVar3 != 0) {\n      local_8 = CONCAT11((byte)param_1,(char)local_10);\n      local_6 = 0;\n      iVar3 = 2;\n      goto LAB_0041497c;\n    }\n  }\n  piVar4 = __errno();\n  *piVar4 = 0x2a;\n  iVar3 = 1;\n  local_8 = (ushort)(byte)param_1;\nLAB_0041497c:\n  local_c[0] = 0;\n  local_c[1] = 0;\n  local_c[2] = 0;\n  iVar3 = ___acrt_LCMapStringA\n                    ((__crt_locale_pointers *)&local_1c,(local_1c.locinfo)->locale_name[2],param_2,\n                     (char *)&local_8,iVar3,(char *)local_c,3,(local_1c.locinfo)->lc_collate_cp,1);\n  if (iVar3 == 0) {\n    if (local_14 != '\\0') {\n      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;\n    }\n  }\n  else if (iVar3 == 1) {\n    param_1 = (int)local_c[0];\n    if (local_14 != '\\0') {\n      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;\n    }\n  }\n  else {\n    param_1 = (int)CONCAT11(local_c[0],local_c[1]);\n    if (local_14 != '\\0') {\n      *(uint *)(local_20 + 0x350) = *(uint *)(local_20 + 0x350) & 0xfffffffd;\n    }\n  }\n  return param_1;\n}\n\n"
    },
    {
      "name": "internal_isupper_l",
      "entry": "00414a06",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl internal_isupper_l(int,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl internal_isupper_l(int param_1,__crt_locale_pointers *param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = __ischartype_l(param_1,1,(_locale_t)param_2);\n  return iVar1 != 0;\n}\n\n"
    },
    {
      "name": "__tolower_l",
      "entry": "00414a23",
      "c": "\n/* Library Function - Single Match\n    __tolower_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __tolower_l(int _C,_locale_t _Locale)\n\n{\n  int iVar1;\n  \n  iVar1 = common_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>\n                    (_C,0x100,(__crt_locale_pointers *)_Locale);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "_tolower",
      "entry": "00414a3d",
      "c": "\n/* Library Function - Single Match\n    _tolower\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _tolower(int _C)\n\n{\n  if (DAT_0043b0e8 == 0) {\n    if (_C - 0x41U < 0x1a) {\n      _C = _C + 0x20;\n    }\n  }\n  else {\n    _C = __tolower_l(_C,(_locale_t)0x0);\n  }\n  return _C;\n}\n\n"
    },
    {
      "name": "_strtol",
      "entry": "00414a6d",
      "c": "\n/* Library Function - Single Match\n    _strtol\n   \n   Library: Visual Studio 2015 Release */\n\nlong __cdecl _strtol(char *_Str,char **_EndPtr,int _Radix)\n\n{\n  ulong uVar1;\n  undefined4 auStack_18 [2];\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 1;\n  iStack_10 = _Radix;\n  make_c_string_character_source<>(auStack_18,_Str,_EndPtr);\n  uVar1 = __crt_strtox::\n          parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>(0);\n  return uVar1;\n}\n\n"
    },
    {
      "name": "_wcstol",
      "entry": "00414a99",
      "c": "\n/* Library Function - Single Match\n    _wcstol\n   \n   Library: Visual Studio 2015 Release */\n\nlong __cdecl _wcstol(wchar_t *_Str,wchar_t **_EndPtr,int _Radix)\n\n{\n  ulong uVar1;\n  undefined4 auStack_18 [2];\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 1;\n  iStack_10 = _Radix;\n  make_c_string_character_source<>(auStack_18,_Str,_EndPtr);\n  uVar1 = __crt_strtox::\n          parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>(0);\n  return uVar1;\n}\n\n"
    },
    {
      "name": "__mbtowc_l",
      "entry": "00414ac5",
      "c": "\n/* Library Function - Single Match\n    __mbtowc_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __mbtowc_l(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  int local_14;\n  localeinfo_struct local_10;\n  char local_8;\n  \n  if ((_SrcCh == (char *)0x0) || (_SrcSizeInBytes == 0)) {\n    return 0;\n  }\n  if (*_SrcCh == '\\0') {\n    if (_DstCh == (wchar_t *)0x0) {\n      return 0;\n    }\n    *_DstCh = L'\\0';\n    return 0;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);\n  if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n    if (_DstCh != (wchar_t *)0x0) {\n      *_DstCh = (ushort)(byte)*_SrcCh;\n    }\n    uVar3 = 1;\n    goto LAB_00414ba7;\n  }\n  iVar1 = __isleadbyte_l((uint)(byte)*_SrcCh,&local_10);\n  if (iVar1 == 0) {\n    uVar3 = 1;\n    iVar1 = MultiByteToWideChar((local_10.locinfo)->lc_collate_cp,9,_SrcCh,1,_DstCh,\n                                (uint)(_DstCh != (wchar_t *)0x0));\n    if (iVar1 != 0) goto LAB_00414ba7;\nLAB_00414b99:\n    piVar2 = __errno();\n    uVar3 = 0xffffffff;\n    *piVar2 = 0x2a;\n  }\n  else {\n    if ((int)(local_10.locinfo)->lc_codepage < 2) {\nLAB_00414b66:\n      uVar3 = (local_10.locinfo)->lc_codepage;\nLAB_00414b69:\n      if ((_SrcSizeInBytes < uVar3) || (_SrcCh[1] == '\\0')) goto LAB_00414b99;\n    }\n    else {\n      uVar3 = (local_10.locinfo)->lc_codepage;\n      if ((int)_SrcSizeInBytes < (int)uVar3) goto LAB_00414b69;\n      iVar1 = MultiByteToWideChar((local_10.locinfo)->lc_collate_cp,9,_SrcCh,\n                                  (local_10.locinfo)->lc_codepage,_DstCh,\n                                  (uint)(_DstCh != (wchar_t *)0x0));\n      if (iVar1 == 0) goto LAB_00414b66;\n    }\n    uVar3 = (local_10.locinfo)->lc_codepage;\n  }\nLAB_00414ba7:\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n    return uVar3;\n  }\n  return uVar3;\n}\n\n"
    },
    {
      "name": "_mbtowc",
      "entry": "00414bbf",
      "c": "\n/* Library Function - Single Match\n    _mbtowc\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _mbtowc(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes)\n\n{\n  int iVar1;\n  \n  iVar1 = __mbtowc_l(_DstCh,_SrcCh,_SrcSizeInBytes,(_locale_t)0x0);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__wctomb_s_l",
      "entry": "00414bd9",
      "c": "\n/* Library Function - Single Match\n    __wctomb_s_l\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl\n__wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale)\n\n{\n  int *piVar1;\n  int iVar2;\n  DWORD DVar3;\n  errno_t eVar4;\n  int local_18;\n  int local_14;\n  char local_c;\n  BOOL local_8;\n  \n  if ((_MbCh == (char *)0x0) && (_SizeInBytes != 0)) {\n    if (_SizeConverted != (int *)0x0) {\n      *_SizeConverted = 0;\n    }\n    return 0;\n  }\n  if (_SizeConverted != (int *)0x0) {\n    *_SizeConverted = -1;\n  }\n  if (0x7fffffff < _SizeInBytes) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0x16;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18,(__crt_locale_pointers *)_Locale);\n  eVar4 = 0;\n  if (*(int *)(local_14 + 0xa8) == 0) {\n    if ((ushort)_WCh < 0x100) {\n      if (_MbCh != (char *)0x0) {\n        if (_SizeInBytes == 0) goto LAB_00414ce6;\n        *_MbCh = (char)_WCh;\n      }\n      if (_SizeConverted != (int *)0x0) {\n        *_SizeConverted = 1;\n      }\n      goto LAB_00414c66;\n    }\n    if ((_MbCh != (char *)0x0) && (_SizeInBytes != 0)) {\n      _memset(_MbCh,0,_SizeInBytes);\n    }\n  }\n  else {\n    local_8 = 0;\n    iVar2 = WideCharToMultiByte(*(UINT *)(local_14 + 8),0,&_WCh,1,_MbCh,_SizeInBytes,(LPCSTR)0x0,\n                                &local_8);\n    if (iVar2 == 0) {\n      DVar3 = GetLastError();\n      if (DVar3 == 0x7a) {\n        if ((_MbCh != (char *)0x0) && (_SizeInBytes != 0)) {\n          _memset(_MbCh,0,_SizeInBytes);\n        }\nLAB_00414ce6:\n        piVar1 = __errno();\n        eVar4 = 0x22;\n        *piVar1 = 0x22;\n        FUN_00412362();\n        goto LAB_00414c66;\n      }\n    }\n    else if (local_8 == 0) {\n      if (_SizeConverted != (int *)0x0) {\n        *_SizeConverted = iVar2;\n      }\n      goto LAB_00414c66;\n    }\n  }\n  piVar1 = __errno();\n  eVar4 = 0x2a;\n  *piVar1 = 0x2a;\nLAB_00414c66:\n  if (local_c != '\\0') {\n    *(uint *)(local_18 + 0x350) = *(uint *)(local_18 + 0x350) & 0xfffffffd;\n  }\n  return eVar4;\n}\n\n"
    },
    {
      "name": "_wctomb_s",
      "entry": "00414cfa",
      "c": "\n/* Library Function - Single Match\n    _wctomb_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl _wctomb_s(int *_SizeConverted,char *_MbCh,rsize_t _SizeInBytes,wchar_t _WCh)\n\n{\n  errno_t eVar1;\n  \n  eVar1 = __wctomb_s_l(_SizeConverted,_MbCh,_SizeInBytes,_WCh,(_locale_t)0x0);\n  return eVar1;\n}\n\n"
    },
    {
      "name": "operator()<>",
      "entry": "00414d17",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Multiple Matches With Same Base Name\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_3518db117f0e7cdb002338c5d3c47b6c>,class <lambda_b2ea41f6bbb362cd97d94c6828d90b61> &,class\n   <lambda_abdedf541bb04549bc734292b4a045d4> >(class <lambda_3518db117f0e7cdb002338c5d3c47b6c>\n   &&,class <lambda_b2ea41f6bbb362cd97d94c6828d90b61> &,class\n   <lambda_abdedf541bb04549bc734292b4a045d4> &&)\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_a7e850c220f1c8d1e6efeecdedd162c6>,class <lambda_46720907175c18b6c9d2717bc0d2d362> &,class\n   <lambda_9048902d66e8d99359bc9897bbb930a8> >(class <lambda_a7e850c220f1c8d1e6efeecdedd162c6>\n   &&,class <lambda_46720907175c18b6c9d2717bc0d2d362> &,class\n   <lambda_9048902d66e8d99359bc9897bbb930a8> &&)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid operator()<>(int *param_1,undefined4 *param_2)\n\n{\n  ___acrt_lock(*param_1);\n  replace_current_thread_locale_nolock\n            (*(__acrt_ptd **)*param_2,(__crt_locale_data *)**(undefined4 **)param_2[1]);\n  FUN_00414d5b();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00414d5b",
      "entry": "00414d5b",
      "c": "\nvoid FUN_00414d5b(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "operator()<>",
      "entry": "00414d67",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Multiple Matches With Same Base Name\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_38edbb1296d33220d7e4dd0ed76b244a>,class <lambda_5ce1d447e08cb34b2473517608e21441> &,class\n   <lambda_fb385d3da700c9147fc39e65dd577a8c> >(class <lambda_38edbb1296d33220d7e4dd0ed76b244a>\n   &&,class <lambda_5ce1d447e08cb34b2473517608e21441> &,class\n   <lambda_fb385d3da700c9147fc39e65dd577a8c> &&)\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_51b6e8b1eb166f2a3faf91f424b38130>,class <lambda_6250bd4b2a391816dd638c3bf72b0bcb> &,class\n   <lambda_0b5a4a3e68152e1d9b943535f5f47bed> >(class <lambda_51b6e8b1eb166f2a3faf91f424b38130>\n   &&,class <lambda_6250bd4b2a391816dd638c3bf72b0bcb> &,class\n   <lambda_0b5a4a3e68152e1d9b943535f5f47bed> &&)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid operator()<>(int *param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  int *_Memory;\n  \n  ___acrt_lock(*param_1);\n  _Memory = *(int **)(*(int *)*param_2 + 0x48);\n  if (_Memory != (int *)0x0) {\n    LOCK();\n    iVar1 = *_Memory;\n    *_Memory = iVar1 + -1;\n    UNLOCK();\n    if ((iVar1 + -1 == 0) && (_Memory != &DAT_0042d610)) {\n      FID_conflict__free(_Memory);\n    }\n  }\n  FUN_00414dbc();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00414dbc",
      "entry": "00414dbc",
      "c": "\nvoid FUN_00414dbc(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "operator()<>",
      "entry": "00414dc8",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Multiple Matches With Same Base Name\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_5b71d36f03204c0beab531769a5b5694>,class <lambda_be2b3da3f62db62e9dad5dc70221a656> &,class\n   <lambda_8f9ce462984622f9bf76b59e2aaaf805> >(class <lambda_5b71d36f03204c0beab531769a5b5694>\n   &&,class <lambda_be2b3da3f62db62e9dad5dc70221a656> &,class\n   <lambda_8f9ce462984622f9bf76b59e2aaaf805> &&)\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_6affb1475c98b40b75cdec977db92e3c>,class <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104> &,class\n   <lambda_608742c3c92a14382c1684fc64f96c88> >(class <lambda_6affb1475c98b40b75cdec977db92e3c>\n   &&,class <lambda_b8d4b9c228a6ecc3f80208dbb4b4a104> &,class\n   <lambda_608742c3c92a14382c1684fc64f96c88> &&)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid operator()<>(int *param_1,undefined4 *param_2)\n\n{\n  ___acrt_lock(*param_1);\n  replace_current_thread_locale_nolock(*(__acrt_ptd **)*param_2,(__crt_locale_data *)0x0);\n  FUN_00414e07();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00414e07",
      "entry": "00414e07",
      "c": "\nvoid FUN_00414e07(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "operator()<>",
      "entry": "00414e13",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Multiple Matches With Same Base Name\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_15ade71b0218206bbe3333a0c9b79046>,class <lambda_da44e0f8b0f19ba52fefafb335991732> &,class\n   <lambda_207f2d024fc103971653565357d6cd41> >(class <lambda_15ade71b0218206bbe3333a0c9b79046>\n   &&,class <lambda_da44e0f8b0f19ba52fefafb335991732> &,class\n   <lambda_207f2d024fc103971653565357d6cd41> &&)\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_9df27f884b057bc3edfc946cb5b7cf47>,class <lambda_e69574bed617af4e071282c136b37893> &,class\n   <lambda_cc0d902bcbbeb830f749456577db4721> >(class <lambda_9df27f884b057bc3edfc946cb5b7cf47>\n   &&,class <lambda_e69574bed617af4e071282c136b37893> &,class\n   <lambda_cc0d902bcbbeb830f749456577db4721> &&)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid operator()<>(int *param_1,undefined4 *param_2)\n\n{\n  ___acrt_lock(*param_1);\n  LOCK();\n  **(int **)(*(int *)*param_2 + 0x48) = **(int **)(*(int *)*param_2 + 0x48) + 1;\n  UNLOCK();\n  FUN_00414e4f();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00414e4f",
      "entry": "00414e4f",
      "c": "\nvoid FUN_00414e4f(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>",
      "entry": "00414e5b",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __acrt_lock_and_call<class <lambda_6250bd4b2a391816dd638c3bf72b0bcb> >(enum\n   __acrt_lock_id,class <lambda_6250bd4b2a391816dd638c3bf72b0bcb> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>\n          (__acrt_lock_id param_1,<lambda_6250bd4b2a391816dd638c3bf72b0bcb> *param_2)\n\n{\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  operator()<>((int *)&local_10,(undefined4 *)param_2);\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>",
      "entry": "00414e83",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __acrt_lock_and_call<class <lambda_b2ea41f6bbb362cd97d94c6828d90b61> >(enum\n   __acrt_lock_id,class <lambda_b2ea41f6bbb362cd97d94c6828d90b61> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>\n          (__acrt_lock_id param_1,<lambda_b2ea41f6bbb362cd97d94c6828d90b61> *param_2)\n\n{\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  operator()<>((int *)&local_10,(undefined4 *)param_2);\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>",
      "entry": "00414eab",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __acrt_lock_and_call<class <lambda_be2b3da3f62db62e9dad5dc70221a656> >(enum\n   __acrt_lock_id,class <lambda_be2b3da3f62db62e9dad5dc70221a656> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>\n          (__acrt_lock_id param_1,<lambda_be2b3da3f62db62e9dad5dc70221a656> *param_2)\n\n{\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  operator()<>((int *)&local_10,(undefined4 *)param_2);\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>",
      "entry": "00414ed3",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __acrt_lock_and_call<class <lambda_e69574bed617af4e071282c136b37893> >(enum\n   __acrt_lock_id,class <lambda_e69574bed617af4e071282c136b37893> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>\n          (__acrt_lock_id param_1,<lambda_e69574bed617af4e071282c136b37893> *param_2)\n\n{\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  operator()<>((int *)&local_10,(undefined4 *)param_2);\n  return;\n}\n\n"
    },
    {
      "name": "construct_ptd",
      "entry": "00414efb",
      "c": "\n/* Library Function - Single Match\n    void __cdecl construct_ptd(struct __acrt_ptd * const,struct __crt_locale_data * * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl construct_ptd(__acrt_ptd *param_1,__crt_locale_data **param_2)\n\n{\n  __acrt_ptd **local_c;\n  __acrt_ptd **local_8;\n  \n  *(undefined4 *)(param_1 + 0x18) = 1;\n  *(undefined **)param_1 = &DAT_00426750;\n  *(undefined4 *)(param_1 + 0x350) = 1;\n  *(undefined4 **)(param_1 + 0x48) = &DAT_0042d610;\n  *(undefined2 *)(param_1 + 0x6c) = 0x43;\n  *(undefined2 *)(param_1 + 0x172) = 0x43;\n  *(undefined4 *)(param_1 + 0x34c) = 0;\n  local_8 = &param_1;\n  __acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>\n            (5,(<lambda_e69574bed617af4e071282c136b37893> *)&local_8);\n  local_c = &param_1;\n  local_8 = (__acrt_ptd **)&param_2;\n  __acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>\n            (4,(<lambda_b2ea41f6bbb362cd97d94c6828d90b61> *)&local_c);\n  return;\n}\n\n"
    },
    {
      "name": "destroy_fls",
      "entry": "00414f74",
      "c": "\n/* Library Function - Single Match\n    void __stdcall destroy_fls(void *)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid destroy_fls(void *param_1)\n\n{\n  if (param_1 != (void *)0x0) {\n    destroy_ptd((__acrt_ptd *)param_1);\n    FID_conflict__free(param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "destroy_ptd",
      "entry": "00414f95",
      "c": "\n/* Library Function - Single Match\n    void __cdecl destroy_ptd(struct __acrt_ptd * const)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl destroy_ptd(__acrt_ptd *param_1)\n\n{\n  __acrt_ptd **local_8;\n  \n  if (*(undefined **)param_1 != &DAT_00426750) {\n    FID_conflict__free(*(undefined **)param_1);\n  }\n  FID_conflict__free(*(void **)(param_1 + 0x3c));\n  FID_conflict__free(*(void **)(param_1 + 0x30));\n  FID_conflict__free(*(void **)(param_1 + 0x34));\n  FID_conflict__free(*(void **)(param_1 + 0x38));\n  FID_conflict__free(*(void **)(param_1 + 0x28));\n  FID_conflict__free(*(void **)(param_1 + 0x2c));\n  FID_conflict__free(*(void **)(param_1 + 0x40));\n  FID_conflict__free(*(void **)(param_1 + 0x44));\n  FID_conflict__free(*(void **)(param_1 + 0x360));\n  local_8 = &param_1;\n  __acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>\n            (5,(<lambda_6250bd4b2a391816dd638c3bf72b0bcb> *)&local_8);\n  local_8 = &param_1;\n  __acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>\n            (4,(<lambda_be2b3da3f62db62e9dad5dc70221a656> *)&local_8);\n  return;\n}\n\n"
    },
    {
      "name": "replace_current_thread_locale_nolock",
      "entry": "0041503e",
      "c": "\n/* Library Function - Single Match\n    void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd * const,struct\n   __crt_locale_data * const)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl replace_current_thread_locale_nolock(__acrt_ptd *param_1,__crt_locale_data *param_2)\n\n{\n  undefined **ppuVar1;\n  \n  if (*(int *)(param_1 + 0x4c) != 0) {\n    ___acrt_release_locale_ref(*(int *)(param_1 + 0x4c));\n    ppuVar1 = *(undefined ***)(param_1 + 0x4c);\n    if (((ppuVar1 != DAT_0043b3f8) && (ppuVar1 != &PTR_DAT_0042d248)) &&\n       (ppuVar1[3] == (undefined *)0x0)) {\n      ___acrt_free_locale(ppuVar1);\n    }\n  }\n  *(__crt_locale_data **)(param_1 + 0x4c) = param_2;\n  if (param_2 != (__crt_locale_data *)0x0) {\n    ___acrt_add_locale_ref((int)param_2);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_getptd",
      "entry": "00415089",
      "c": "\n/* Library Function - Single Match\n    ___acrt_getptd\n   \n   Library: Visual Studio 2015 Release */\n\n__acrt_ptd * ___acrt_getptd(void)\n\n{\n  DWORD dwErrCode;\n  __acrt_ptd *_Memory;\n  int iVar1;\n  \n  dwErrCode = GetLastError();\n  if ((DAT_0042d240 != 0xffffffff) &&\n     (_Memory = (__acrt_ptd *)___acrt_FlsGetValue_4(DAT_0042d240), _Memory != (__acrt_ptd *)0x0)) {\nLAB_004150f4:\n    SetLastError(dwErrCode);\n    return _Memory;\n  }\n  _Memory = (__acrt_ptd *)__calloc_base(1,0x364);\n  if ((_Memory == (__acrt_ptd *)0x0) ||\n     (iVar1 = ___acrt_FlsSetValue_8(DAT_0042d240,_Memory), iVar1 == 0)) {\n    FID_conflict__free(_Memory);\n  }\n  else {\n    construct_ptd(_Memory,(__crt_locale_data **)&DAT_0043b3f8);\n    FID_conflict__free((void *)0x0);\n    if (_Memory != (__acrt_ptd *)0x0) goto LAB_004150f4;\n  }\n  SetLastError(dwErrCode);\n                    /* WARNING: Subroutine does not return */\n  _abort();\n}\n\n"
    },
    {
      "name": "___acrt_getptd_noexit",
      "entry": "0041510d",
      "c": "\n/* Library Function - Single Match\n    ___acrt_getptd_noexit\n   \n   Library: Visual Studio 2015 Release */\n\n__acrt_ptd * ___acrt_getptd_noexit(void)\n\n{\n  DWORD dwErrCode;\n  __acrt_ptd *_Memory;\n  int iVar1;\n  \n  dwErrCode = GetLastError();\n  if ((DAT_0042d240 != 0xffffffff) &&\n     (_Memory = (__acrt_ptd *)___acrt_FlsGetValue_4(DAT_0042d240), _Memory != (__acrt_ptd *)0x0)) {\nLAB_00415183:\n    SetLastError(dwErrCode);\n    return _Memory;\n  }\n  _Memory = (__acrt_ptd *)__calloc_base(1,0x364);\n  if (_Memory == (__acrt_ptd *)0x0) {\n    _Memory = (__acrt_ptd *)0x0;\n  }\n  else {\n    iVar1 = ___acrt_FlsSetValue_8(DAT_0042d240,_Memory);\n    if (iVar1 != 0) {\n      construct_ptd(_Memory,(__crt_locale_data **)&DAT_0043b3f8);\n      FID_conflict__free((void *)0x0);\n      if (_Memory != (__acrt_ptd *)0x0) goto LAB_00415183;\n      goto LAB_0041517a;\n    }\n  }\n  FID_conflict__free(_Memory);\nLAB_0041517a:\n  SetLastError(dwErrCode);\n  return (__acrt_ptd *)0x0;\n}\n\n"
    },
    {
      "name": "FUN_004151be",
      "entry": "004151be",
      "c": "\nundefined4 FUN_004151be(void)\n\n{\n  DWORD DVar1;\n  \n  DVar1 = DAT_0042d240;\n  if (DAT_0042d240 != 0xffffffff) {\n    DVar1 = ___acrt_FlsFree_4(DAT_0042d240);\n    DAT_0042d240 = 0xffffffff;\n  }\n  return CONCAT31((int3)(DVar1 >> 8),1);\n}\n\n"
    },
    {
      "name": "___acrt_update_locale_info",
      "entry": "004151d8",
      "c": "\n/* Library Function - Single Match\n    ___acrt_update_locale_info\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_update_locale_info(int param_1,int *param_2)\n\n{\n  undefined **ppuVar1;\n  \n  if ((*param_2 != DAT_0043b3f8) && ((*(uint *)(param_1 + 0x350) & DAT_0042d30c) == 0)) {\n    ppuVar1 = ___acrt_update_thread_locale_data();\n    *param_2 = (int)ppuVar1;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_update_multibyte_info",
      "entry": "00415205",
      "c": "\n/* Library Function - Single Match\n    ___acrt_update_multibyte_info\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_update_multibyte_info(int param_1,int *param_2)\n\n{\n  int *piVar1;\n  \n  if (((undefined *)*param_2 != PTR_DAT_0042d830) &&\n     ((*(uint *)(param_1 + 0x350) & DAT_0042d30c) == 0)) {\n    piVar1 = ___acrt_update_thread_multibyte_data();\n    *param_2 = (int)piVar1;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_fp_classify",
      "entry": "00415232",
      "c": "\n/* Library Function - Single Match\n    enum __acrt_fp_class __cdecl __acrt_fp_classify(double const &)\n   \n   Library: Visual Studio 2015 Release */\n\n__acrt_fp_class __cdecl __acrt_fp_classify(double *param_1)\n\n{\n  uint uVar1;\n  undefined4 uStack_14;\n  \n  uVar1 = *(uint *)((int)param_1 + 4);\n  if ((uVar1 >> 0x14 & 0x7ff) == 0x7ff) {\n    if (*(int *)param_1 == 0 && (uVar1 & 0xfffff) == 0) {\n      uStack_14 = 1;\n    }\n    else if ((((uVar1 & 0x80000000) == 0) || (*(int *)param_1 != 0)) ||\n            ((uVar1 & 0xfffff) != 0x80000)) {\n      if ((uVar1 & 0x80000) == 0) {\n        uStack_14 = 3;\n      }\n      else {\n        uStack_14 = 2;\n      }\n    }\n    else {\n      uStack_14 = 4;\n    }\n  }\n  else {\n    uStack_14 = 0;\n  }\n  return uStack_14;\n}\n\n"
    },
    {
      "name": "__acrt_fp_is_negative",
      "entry": "0041529e",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __acrt_fp_is_negative(double const &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __acrt_fp_is_negative(double *param_1)\n\n{\n  return ((ulonglong)*param_1 & 0x8000000000000000) != 0;\n}\n\n"
    },
    {
      "name": "fp_format_a",
      "entry": "004152bc",
      "c": "\n/* Library Function - Single Match\n    int __cdecl fp_format_a(double const * const,char *,unsigned int,char * const,unsigned\n   int,int,bool,unsigned int,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nfp_format_a(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,\n           bool param_7,uint param_8,__crt_locale_pointers *param_9)\n\n{\n  int *piVar1;\n  int iVar2;\n  undefined1 (*pauVar3) [16];\n  uint uVar4;\n  char *pcVar5;\n  uint uVar6;\n  uint extraout_ECX;\n  uint extraout_ECX_00;\n  uint extraout_ECX_01;\n  uint uVar7;\n  char *_Dst;\n  char *pcVar8;\n  bool bVar9;\n  ulonglong uVar10;\n  undefined8 uVar11;\n  int local_34;\n  int local_30;\n  char local_28;\n  undefined4 local_24;\n  int local_20;\n  char *local_1c;\n  uint local_14;\n  uint local_10;\n  int local_c;\n  uint local_8;\n  \n  if (param_6 < 0) {\n    param_6 = 0;\n  }\n  *param_2 = '\\0';\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_34,param_9);\n  if (param_3 <= param_6 + 0xbU) {\n    piVar1 = __errno();\n    iVar2 = 0x22;\n    *piVar1 = 0x22;\n    FUN_00412362();\n    goto LAB_004155a6;\n  }\n  local_24 = *(undefined4 *)param_1;\n  if ((*(uint *)((int)param_1 + 4) >> 0x14 & 0x7ff) == 0x7ff) {\n    iVar2 = fp_format_e(param_1,param_2,param_3,param_4,param_5,param_6,false,param_8,\n                        (__crt_locale_pointers *)0x0);\n    if (iVar2 == 0) {\n      pauVar3 = FUN_00408b50((undefined1 (*) [16])param_2,0x65);\n      if (pauVar3 != (undefined1 (*) [16])0x0) {\n        (*pauVar3)[0] = (!param_7 - 1U & 0xe0) + 0x70;\n        (*pauVar3)[3] = 0;\n      }\n      iVar2 = 0;\n    }\n    else {\n      *param_2 = '\\0';\n    }\n    goto LAB_004155a6;\n  }\n  if ((*(uint *)((int)param_1 + 4) & 0x80000000) != 0) {\n    *param_2 = '-';\n    param_2 = param_2 + 1;\n  }\n  local_10 = 0x3ff;\n  iVar2 = (!param_7 - 1 & 0xffffffe0) + 0x27;\n  if (((ulonglong)*param_1 & 0x7ff0000000000000) == 0) {\n    *param_2 = '0';\n    if (*(int *)param_1 == 0 && ((ulonglong)*param_1 & 0xfffff00000000) == 0) {\n      local_10 = 0;\n    }\n    else {\n      local_10 = 0x3fe;\n    }\n  }\n  else {\n    *param_2 = '1';\n  }\n  local_1c = param_2 + 1;\n  _Dst = param_2 + 2;\n  if (param_6 == 0) {\n    *local_1c = '\\0';\n  }\n  else {\n    *local_1c = *(char *)**(undefined4 **)(local_30 + 0x88);\n  }\n  local_20 = iVar2;\n  if ((((ulonglong)*param_1 & 0xfffff00000000) != 0) || (local_14 = 0, *(int *)param_1 != 0)) {\n    local_8 = 0;\n    local_c = 0x30;\n    local_14 = 0xf0000;\n    do {\n      if (param_6 < 1) break;\n      uVar10 = __aullshr((byte)local_c,*(uint *)((int)param_1 + 4) & local_14 & 0xfffff);\n      uVar4 = (uint)(ushort)((short)uVar10 + 0x30);\n      if (0x39 < uVar4) {\n        uVar4 = uVar4 + iVar2;\n      }\n      *_Dst = (char)uVar4;\n      _Dst = _Dst + 1;\n      local_8 = local_8 >> 4 | local_14 << 0x1c;\n      local_14 = local_14 >> 4;\n      local_c = local_c + -4;\n      param_6 = param_6 - 1;\n    } while (-1 < (short)local_c);\n    if ((-1 < (short)local_c) &&\n       (uVar10 = __aullshr((byte)local_c,*(uint *)((int)param_1 + 4) & local_14 & 0xfffff),\n       pcVar8 = _Dst, 8 < (ushort)uVar10)) {\n      while( true ) {\n        pcVar5 = pcVar8 + -1;\n        if ((*pcVar5 != 'f') && (*pcVar5 != 'F')) break;\n        *pcVar5 = '0';\n        pcVar8 = pcVar5;\n      }\n      if (pcVar5 == local_1c) {\n        pcVar8[-2] = pcVar8[-2] + '\\x01';\n      }\n      else if (*pcVar5 == '9') {\n        *pcVar5 = (char)local_20 + ':';\n      }\n      else {\n        *pcVar5 = *pcVar5 + '\\x01';\n      }\n    }\n  }\n  if (0 < param_6) {\n    _memset(_Dst,0x30,param_6);\n    _Dst = _Dst + param_6;\n  }\n  if (*local_1c == '\\0') {\n    _Dst = local_1c;\n  }\n  *_Dst = (!param_7 - 1U & 0xe0) + 0x70;\n  uVar10 = __aullshr(0x34,*(uint *)((int)param_1 + 4));\n  uVar4 = (uint)uVar10 & 0x7ff;\n  uVar6 = uVar4 - local_10;\n  uVar4 = (uint)(uVar4 < local_10);\n  uVar7 = -uVar4;\n  if (uVar4 == 0) {\n    _Dst[1] = '+';\n  }\n  else {\n    _Dst[1] = '-';\n    bVar9 = uVar6 != 0;\n    uVar6 = -uVar6;\n    uVar7 = -(uVar7 + bVar9);\n  }\n  pcVar5 = _Dst + 2;\n  *pcVar5 = '0';\n  pcVar8 = pcVar5;\n  if (-1 < (int)uVar7) {\n    if (((int)uVar7 < 1) && (uVar6 < 1000)) {\nLAB_00415559:\n      if (((int)uVar7 < 0) || (((int)uVar7 < 1 && (uVar6 < 100)))) goto LAB_00415577;\n    }\n    else {\n      uVar11 = __alldvrm(uVar6,uVar7,1000,0);\n      local_20 = (int)((ulonglong)uVar11 >> 0x20);\n      *pcVar5 = (char)uVar11 + '0';\n      pcVar8 = _Dst + 3;\n      uVar6 = extraout_ECX;\n      if (pcVar8 == pcVar5) goto LAB_00415559;\n    }\n    uVar11 = __alldvrm(uVar6,uVar7,100,0);\n    local_20 = (int)((ulonglong)uVar11 >> 0x20);\n    *pcVar8 = (char)uVar11 + '0';\n    pcVar8 = pcVar8 + 1;\n    uVar6 = extraout_ECX_00;\n  }\nLAB_00415577:\n  if ((pcVar8 != pcVar5) || ((-1 < (int)uVar7 && ((0 < (int)uVar7 || (9 < uVar6)))))) {\n    uVar11 = __alldvrm(uVar6,uVar7,10,0);\n    *pcVar8 = (char)uVar11 + '0';\n    pcVar8 = pcVar8 + 1;\n    uVar6 = extraout_ECX_01;\n  }\n  iVar2 = 0;\n  *pcVar8 = (char)uVar6 + '0';\n  pcVar8[1] = '\\0';\nLAB_004155a6:\n  if (local_28 != '\\0') {\n    *(uint *)(local_34 + 0x350) = *(uint *)(local_34 + 0x350) & 0xfffffffd;\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "fp_format_e",
      "entry": "004155bf",
      "c": "\n/* Library Function - Single Match\n    int __cdecl fp_format_e(double const * const,char * const,unsigned int,char * const,unsigned\n   int,int,bool,unsigned int,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nfp_format_e(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,\n           bool param_7,uint param_8,__crt_locale_pointers *param_9)\n\n{\n  int iVar1;\n  uint uVar2;\n  int local_10 [3];\n  \n  ___acrt_fltout(*(int *)param_1,*(uint *)((int)param_1 + 4),param_6 + 1,local_10,param_4,param_5);\n  uVar2 = 0xffffffff;\n  if (param_3 != 0xffffffff) {\n    uVar2 = (param_3 - (local_10[0] == 0x2d)) - (uint)(0 < param_6);\n  }\n  iVar1 = ___acrt_fp_strflt_to_string\n                    ((uint *)(param_2 + (uint)(0 < param_6) + (uint)(local_10[0] == 0x2d)),uVar2,\n                     param_6 + 1,(int)local_10);\n  if (iVar1 == 0) {\n    iVar1 = fp_format_e_internal\n                      (param_2,param_3,param_6,param_7,param_8,(_strflt *)local_10,false,param_9);\n  }\n  else {\n    *param_2 = '\\0';\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "fp_format_e_internal",
      "entry": "0041565a",
      "c": "\n/* Library Function - Single Match\n    int __cdecl fp_format_e_internal(char * const,unsigned int,int,bool,unsigned int,struct _strflt\n   * const,bool,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nfp_format_e_internal\n          (char *param_1,uint param_2,int param_3,bool param_4,uint param_5,_strflt *param_6,\n          bool param_7,__crt_locale_pointers *param_8)\n\n{\n  int *piVar1;\n  char *_SizeInBytes;\n  errno_t eVar2;\n  int iVar3;\n  int iVar4;\n  char *pcVar5;\n  int local_14;\n  int local_10;\n  char local_8;\n  \n  iVar4 = param_3;\n  if (param_3 < 1) {\n    iVar4 = 0;\n  }\n  if (iVar4 + 9U < param_2) {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_8);\n    if (param_7) {\n      shift_bytes(param_1,param_2,param_1 + (*(int *)param_6 == 0x2d),(uint)(0 < param_3));\n    }\n    pcVar5 = param_1;\n    if (*(int *)param_6 == 0x2d) {\n      *param_1 = '-';\n      pcVar5 = param_1 + 1;\n    }\n    if (0 < param_3) {\n      *pcVar5 = pcVar5[1];\n      pcVar5 = pcVar5 + 1;\n      *pcVar5 = *(char *)**(undefined4 **)(local_10 + 0x88);\n    }\n    pcVar5 = pcVar5 + (uint)!param_7 + param_3;\n    _SizeInBytes = (char *)0xffffffff;\n    if (param_2 != 0xffffffff) {\n      _SizeInBytes = param_1 + (param_2 - (int)pcVar5);\n    }\n    eVar2 = _strcpy_s(pcVar5,(rsize_t)_SizeInBytes,\"e+000\");\n    if (eVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    if (param_4) {\n      *pcVar5 = 'E';\n    }\n    if (**(char **)(param_6 + 8) != '0') {\n      iVar4 = *(int *)(param_6 + 4) + -1;\n      if (iVar4 < 0) {\n        iVar4 = -iVar4;\n        pcVar5[1] = '-';\n      }\n      if (99 < iVar4) {\n        iVar3 = iVar4 / 100;\n        iVar4 = iVar4 % 100;\n        pcVar5[2] = pcVar5[2] + (char)iVar3;\n      }\n      if (9 < iVar4) {\n        iVar3 = iVar4 / 10;\n        iVar4 = iVar4 % 10;\n        pcVar5[3] = pcVar5[3] + (char)iVar3;\n      }\n      pcVar5[4] = pcVar5[4] + (char)iVar4;\n    }\n    if ((param_5 == 2) && ((char)*(uint *)(pcVar5 + 2) == '0')) {\n      FUN_00420380((uint *)(pcVar5 + 2),(uint *)(pcVar5 + 3),3);\n    }\n    if (local_8 != '\\0') {\n      *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n    }\n    iVar4 = 0;\n  }\n  else {\n    piVar1 = __errno();\n    iVar4 = 0x22;\n    *piVar1 = 0x22;\n    FUN_00412362();\n  }\n  return iVar4;\n}\n\n"
    },
    {
      "name": "fp_format_f",
      "entry": "004157a5",
      "c": "\n/* Library Function - Single Match\n    int __cdecl fp_format_f(double const * const,char * const,unsigned int,char * const,unsigned\n   int,int,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nfp_format_f(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,\n           __crt_locale_pointers *param_7)\n\n{\n  int iVar1;\n  uint uVar2;\n  int local_10;\n  int local_c;\n  undefined4 uStack_8;\n  \n  local_10 = 0;\n  local_c = 0;\n  uStack_8 = 0;\n  ___acrt_fltout(*(int *)param_1,*(uint *)((int)param_1 + 4),param_6,&local_10,param_4,param_5);\n  uVar2 = 0xffffffff;\n  if (param_3 != 0xffffffff) {\n    uVar2 = param_3 - (local_10 == 0x2d);\n  }\n  iVar1 = ___acrt_fp_strflt_to_string\n                    ((uint *)(param_2 + (local_10 == 0x2d)),uVar2,local_c + param_6,(int)&local_10);\n  if (iVar1 == 0) {\n    iVar1 = fp_format_f_internal(param_2,param_3,param_6,(_strflt *)&local_10,false,param_7);\n  }\n  else {\n    *param_2 = '\\0';\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "fp_format_f_internal",
      "entry": "00415832",
      "c": "\n/* Library Function - Single Match\n    int __cdecl fp_format_f_internal(char * const,unsigned int,int,struct _strflt *\n   const,bool,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nfp_format_f_internal\n          (char *param_1,uint param_2,int param_3,_strflt *param_4,bool param_5,\n          __crt_locale_pointers *param_6)\n\n{\n  int iVar1;\n  int iVar2;\n  char *pcVar3;\n  int local_14;\n  int local_10;\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_6);\n  iVar1 = *(int *)(param_4 + 4);\n  if ((param_5) && (iVar1 + -1 == param_3)) {\n    iVar2 = *(int *)param_4;\n    (param_1 + (uint)(iVar2 == 0x2d) + iVar1 + -1)[0] = '0';\n    (param_1 + (uint)(iVar2 == 0x2d) + iVar1 + -1)[1] = '\\0';\n  }\n  pcVar3 = param_1;\n  if (*(int *)param_4 == 0x2d) {\n    *param_1 = '-';\n    pcVar3 = param_1 + 1;\n  }\n  if (*(int *)(param_4 + 4) < 1) {\n    shift_bytes(param_1,param_2,pcVar3,1);\n    *pcVar3 = '0';\n    pcVar3 = pcVar3 + 1;\n  }\n  else {\n    pcVar3 = pcVar3 + *(int *)(param_4 + 4);\n  }\n  if (0 < param_3) {\n    shift_bytes(param_1,param_2,pcVar3,1);\n    *pcVar3 = *(char *)**(undefined4 **)(local_10 + 0x88);\n    iVar1 = *(int *)(param_4 + 4);\n    if (iVar1 < 0) {\n      if ((param_5) || (-iVar1 < param_3)) {\n        param_3 = -iVar1;\n      }\n      shift_bytes(param_1,param_2,pcVar3 + 1,param_3);\n      _memset(pcVar3 + 1,0x30,param_3);\n    }\n  }\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "fp_format_g",
      "entry": "00415909",
      "c": "\n/* Library Function - Single Match\n    int __cdecl fp_format_g(double const * const,char * const,unsigned int,char * const,unsigned\n   int,int,bool,unsigned int,struct __crt_locale_pointers * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nfp_format_g(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,\n           bool param_7,uint param_8,__crt_locale_pointers *param_9)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  int iVar3;\n  uint *puVar4;\n  bool bVar5;\n  int local_14;\n  int local_10;\n  undefined4 uStack_c;\n  int local_8;\n  \n  local_14 = 0;\n  local_10 = 0;\n  uStack_c = 0;\n  ___acrt_fltout(*(int *)param_1,*(uint *)((int)param_1 + 4),param_6,&local_14,param_4,param_5);\n  bVar5 = local_14 == 0x2d;\n  local_8 = local_10 + -1;\n  uVar2 = 0xffffffff;\n  if (param_3 != 0xffffffff) {\n    uVar2 = param_3 - bVar5;\n  }\n  iVar3 = ___acrt_fp_strflt_to_string((uint *)(param_2 + bVar5),uVar2,param_6,(int)&local_14);\n  if (iVar3 == 0) {\n    iVar3 = local_10 + -1;\n    if ((iVar3 < -4) || (param_6 <= iVar3)) {\n      iVar3 = fp_format_e_internal\n                        (param_2,param_3,param_6,param_7,param_8,(_strflt *)&local_14,true,param_9);\n    }\n    else {\n      puVar1 = (uint *)(param_2 + bVar5);\n      if (local_8 < iVar3) {\n        do {\n          puVar4 = puVar1;\n          puVar1 = (uint *)((int)puVar4 + 1);\n        } while ((char)*puVar4 != '\\0');\n        *(undefined1 *)((int)puVar4 + -1) = 0;\n      }\n      iVar3 = fp_format_f_internal(param_2,param_3,param_6,(_strflt *)&local_14,true,param_9);\n    }\n  }\n  else {\n    *param_2 = '\\0';\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "fp_format_nan_or_infinity",
      "entry": "004159d1",
      "c": "\n/* Library Function - Single Match\n    int __cdecl fp_format_nan_or_infinity(enum __acrt_fp_class,bool,char *,unsigned int,bool)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nfp_format_nan_or_infinity\n          (__acrt_fp_class param_1,bool param_2,char *param_3,uint param_4,bool param_5)\n\n{\n  char *pcVar1;\n  char cVar2;\n  int iVar3;\n  errno_t eVar4;\n  uint uVar5;\n  char *pcVar6;\n  undefined *local_48 [4];\n  undefined *local_38;\n  undefined *local_34;\n  undefined *local_30;\n  undefined *local_2c;\n  char *local_28;\n  undefined *local_24;\n  char *local_20;\n  undefined *local_1c;\n  char *local_18;\n  undefined *local_14;\n  char *local_10;\n  undefined *local_c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_4 < param_2 + 4) {\n    *param_3 = '\\0';\n  }\n  else {\n    if (param_2) {\n      *param_3 = '-';\n      param_3 = param_3 + 1;\n      param_4 = param_4 - 1;\n      *param_3 = '\\0';\n    }\n    local_28 = \"NAN(SNAN)\";\n    local_48[0] = &DAT_00427354;\n    local_48[1] = &DAT_00427354;\n    local_48[2] = &DAT_00427358;\n    local_48[3] = &DAT_00427358;\n    local_20 = \"nan(snan)\";\n    local_30 = &DAT_00427360;\n    uVar5 = param_5 - 1 & 2;\n    local_2c = &DAT_00427360;\n    local_1c = &DAT_00427360;\n    local_c = &DAT_00427360;\n    local_18 = \"NAN(IND)\";\n    local_38 = &DAT_0042735c;\n    local_34 = &DAT_0042735c;\n    local_24 = &DAT_0042735c;\n    local_14 = &DAT_0042735c;\n    local_10 = \"nan(ind)\";\n    pcVar6 = local_48[param_1 * 4 + -4 + uVar5];\n    pcVar1 = pcVar6 + 1;\n    do {\n      cVar2 = *pcVar6;\n      pcVar6 = pcVar6 + 1;\n    } while (cVar2 != '\\0');\n    eVar4 = _strcpy_s(param_3,param_4,\n                      local_48[((param_1 * 4 + -3) -\n                               (uint)((uint)((int)pcVar6 - (int)pcVar1) < param_4)) + uVar5]);\n    if (eVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n  }\n  iVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "shift_bytes",
      "entry": "00415ac9",
      "c": "\n/* Library Function - Single Match\n    void __cdecl shift_bytes(char * const,unsigned int,char * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl shift_bytes(char *param_1,uint param_2,char *param_3,int param_4)\n\n{\n  char cVar1;\n  char *pcVar2;\n  \n  if (param_4 != 0) {\n    pcVar2 = param_3;\n    do {\n      cVar1 = *pcVar2;\n      pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    FUN_00420380((uint *)(param_3 + param_4),(uint *)param_3,\n                 (uint)(pcVar2 + (1 - (int)(param_3 + 1))));\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_fp_format",
      "entry": "00415afd",
      "c": "\n/* Library Function - Single Match\n    ___acrt_fp_format\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n___acrt_fp_format(double *param_1,char *param_2,uint param_3,char *param_4,uint param_5,int param_6,\n                 int param_7,uint param_8,undefined4 param_9,__crt_locale_pointers *param_10)\n\n{\n  bool bVar1;\n  int *piVar2;\n  __acrt_fp_class _Var3;\n  int iVar4;\n  uint uVar5;\n  bool local_8;\n  \n  if (param_2 == (char *)0x0) {\n    piVar2 = __errno();\n    iVar4 = 0x16;\n    *piVar2 = 0x16;\n    FUN_00412362();\n  }\n  else if (((param_3 == 0) || (param_4 == (char *)0x0)) || (param_5 == 0)) {\n    piVar2 = __errno();\n    iVar4 = 0x16;\n    *piVar2 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    if (((param_6 == 0x41) || (param_6 == 0x45)) ||\n       ((param_6 == 0x46 || (local_8 = false, param_6 == 0x47)))) {\n      local_8 = true;\n    }\n    if (((param_8 & 8) == 0) && (_Var3 = __acrt_fp_classify(param_1), _Var3 != 0)) {\n      bVar1 = __acrt_fp_is_negative(param_1);\n      iVar4 = fp_format_nan_or_infinity(_Var3,bVar1,param_2,param_3,local_8);\n    }\n    else {\n      if ((param_8 & 0x10) == 0) {\n        uVar5 = 2;\n      }\n      else {\n        uVar5 = 3;\n      }\n      if (param_6 < 0x62) {\n        if ((param_6 == 0x61) || (param_6 == 0x41)) {\n          iVar4 = fp_format_a(param_1,param_2,param_3,param_4,param_5,param_7,local_8,uVar5,param_10\n                             );\n          return iVar4;\n        }\n        iVar4 = param_6 + -0x45;\n      }\n      else {\n        iVar4 = param_6 + -0x65;\n      }\n      if (iVar4 == 0) {\n        iVar4 = fp_format_e(param_1,param_2,param_3,param_4,param_5,param_7,local_8,uVar5,param_10);\n      }\n      else if (iVar4 == 1) {\n        iVar4 = fp_format_f(param_1,param_2,param_3,param_4,param_5,param_7,param_10);\n      }\n      else {\n        iVar4 = fp_format_g(param_1,param_2,param_3,param_4,param_5,param_7,local_8,uVar5,param_10);\n      }\n    }\n  }\n  return iVar4;\n}\n\n"
    },
    {
      "name": "__fputc_nolock",
      "entry": "00415c47",
      "c": "\n/* Library Function - Single Match\n    __fputc_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl __fputc_nolock(byte param_1,int *param_2)\n\n{\n  int *piVar1;\n  uint uVar2;\n  \n  piVar1 = param_2 + 2;\n  *piVar1 = *piVar1 + -1;\n  if (*piVar1 < 0) {\n    uVar2 = FUN_004140d8();\n    return uVar2;\n  }\n  *(byte *)*param_2 = param_1;\n  *param_2 = *param_2 + 1;\n  return (uint)param_1;\n}\n\n"
    },
    {
      "name": "__get_printf_count_output",
      "entry": "00415c70",
      "c": "\n/* Library Function - Single Match\n    __get_printf_count_output\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl __get_printf_count_output(void)\n\n{\n  return (uint)(DAT_0043b3f4 == (DAT_0042d008 | 1));\n}\n\n"
    },
    {
      "name": "___acrt_strtok_s_novalidation",
      "entry": "00415c85",
      "c": "\n/* Library Function - Single Match\n    ___acrt_strtok_s_novalidation\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_strtok_s_novalidation(byte *param_1,byte *param_2,undefined4 *param_3)\n\n{\n  code *pcVar1;\n  uint uVar2;\n  byte bVar3;\n  bool bVar4;\n  byte abStack_28 [32];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  uVar2 = 0;\n  bVar4 = true;\n  do {\n    if (!bVar4) {\n      ___report_rangecheckfailure();\n      pcVar1 = (code *)swi(3);\n      (*pcVar1)();\n      return;\n    }\n    abStack_28[uVar2] = 0;\n    uVar2 = uVar2 + 1;\n    bVar4 = uVar2 < 0x20;\n  } while ((int)uVar2 < 0x20);\n  do {\n    bVar3 = *param_2;\n    param_2 = param_2 + 1;\n    abStack_28[bVar3 >> 3] = abStack_28[bVar3 >> 3] | (byte)(1 << (bVar3 & 7));\n  } while (bVar3 != 0);\n  if (param_1 == (byte *)0x0) {\n    param_1 = (byte *)*param_3;\n  }\n  if ((abStack_28[*param_1 >> 3] & (byte)(1 << (*param_1 & 7))) != 0) {\n    bVar3 = *param_1;\n    do {\n      if (bVar3 == 0) break;\n      param_1 = param_1 + 1;\n      bVar3 = *param_1;\n    } while ((abStack_28[bVar3 >> 3] & (byte)(1 << (bVar3 & 7))) != 0);\n  }\n  do {\n    if (*param_1 == 0) {\nLAB_00415d3f:\n      *param_3 = param_1;\n      __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n      return;\n    }\n    if ((abStack_28[*param_1 >> 3] & (byte)(1 << (*param_1 & 7))) != 0) {\n      *param_1 = 0;\n      param_1 = param_1 + 1;\n      goto LAB_00415d3f;\n    }\n    param_1 = param_1 + 1;\n  } while( true );\n}\n\n"
    },
    {
      "name": "get_drive_number_from_path",
      "entry": "00415d64",
      "c": "\n/* Library Function - Single Match\n    int __cdecl get_drive_number_from_path(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl get_drive_number_from_path(wchar_t *param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)(ushort)*param_1;\n  if ((*param_1 != L'\\0') && (param_1[1] == L':')) {\n    if ((0x60 < uVar1) && (uVar1 < 0x7b)) {\n      uVar1 = uVar1 - 0x20;\n    }\n    return uVar1 - 0x40;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "__getdrive",
      "entry": "00415d91",
      "c": "\n/* Library Function - Single Match\n    __getdrive\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __getdrive(void)\n\n{\n  DWORD DVar1;\n  wchar_t *lpBuffer;\n  int *piVar2;\n  int iVar3;\n  WCHAR local_214;\n  undefined1 local_212 [522];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_214 = L'\\0';\n  _memset(local_212,0,0x208);\n  DVar1 = GetCurrentDirectoryW(0x105,&local_214);\n  if (DVar1 < 0x105) {\n    get_drive_number_from_path(&local_214);\n    goto LAB_00415e31;\n  }\n  lpBuffer = (wchar_t *)__calloc_base(DVar1 + 1,2);\n  if (lpBuffer == (wchar_t *)0x0) {\nLAB_00415e10:\n    piVar2 = __errno();\n    *piVar2 = 0xc;\n  }\n  else {\n    DVar1 = GetCurrentDirectoryW(DVar1 + 1,lpBuffer);\n    if (DVar1 == 0) goto LAB_00415e10;\n    get_drive_number_from_path(lpBuffer);\n  }\n  FID_conflict__free(lpBuffer);\nLAB_00415e31:\n  iVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "_wcspbrk",
      "entry": "00415e40",
      "c": "\n/* Library Function - Single Match\n    _wcspbrk\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl _wcspbrk(wchar_t *_Str,wchar_t *_Control)\n\n{\n  wchar_t *pwVar1;\n  wchar_t wVar2;\n  \n  if (*_Str != L'\\0') {\n    do {\n      if (*_Control != L'\\0') {\n        pwVar1 = _Control;\n        wVar2 = *_Control;\n        do {\n          if (wVar2 == *_Str) {\n            return _Str;\n          }\n          pwVar1 = pwVar1 + 1;\n          wVar2 = *pwVar1;\n        } while (wVar2 != L'\\0');\n      }\n      _Str = _Str + 1;\n    } while (*_Str != L'\\0');\n  }\n  return (wchar_t *)0x0;\n}\n\n"
    },
    {
      "name": "__wcsicmp",
      "entry": "00415e85",
      "c": "\n/* Library Function - Single Match\n    __wcsicmp\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __wcsicmp(wchar_t *_Str1,wchar_t *_Str2)\n\n{\n  wchar_t wVar1;\n  int *piVar2;\n  int iVar3;\n  wchar_t wVar4;\n  \n  if (DAT_0043b0e8 != 0) {\n    iVar3 = __wcsicmp_l(_Str1,_Str2,(_locale_t)0x0);\n    return iVar3;\n  }\n  if ((_Str1 != (wchar_t *)0x0) && (_Str2 != (wchar_t *)0x0)) {\n    iVar3 = (int)_Str1 - (int)_Str2;\n    do {\n      wVar4 = *(wchar_t *)(iVar3 + (int)_Str2);\n      if ((0x40 < (ushort)wVar4) && ((ushort)wVar4 < 0x5b)) {\n        wVar4 = wVar4 + L' ';\n      }\n      wVar1 = *_Str2;\n      if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {\n        wVar1 = wVar1 + L' ';\n      }\n      _Str2 = _Str2 + 1;\n    } while ((wVar4 != L'\\0') && (wVar4 == wVar1));\n    return (uint)(ushort)wVar4 - (uint)(ushort)wVar1;\n  }\n  piVar2 = __errno();\n  *piVar2 = 0x16;\n  FUN_00412362();\n  return 0x7fffffff;\n}\n\n"
    },
    {
      "name": "__wcsicmp_l",
      "entry": "00415f1a",
      "c": "\n/* Library Function - Single Match\n    __wcsicmp_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __wcsicmp_l(wchar_t *_Str1,wchar_t *_Str2,_locale_t _Locale)\n\n{\n  wchar_t wVar1;\n  wchar_t wVar2;\n  int *piVar3;\n  int iVar4;\n  int local_14;\n  localeinfo_struct local_10;\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);\n  if ((_Str1 == (wchar_t *)0x0) || (_Str2 == (wchar_t *)0x0)) {\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    FUN_00412362();\n    iVar4 = 0x7fffffff;\n  }\n  else {\n    if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n      iVar4 = (int)_Str1 - (int)_Str2;\n      do {\n        wVar1 = *(wchar_t *)(iVar4 + (int)_Str2);\n        if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {\n          wVar1 = wVar1 + L' ';\n        }\n        wVar2 = *_Str2;\n        if ((0x40 < (ushort)wVar2) && ((ushort)wVar2 < 0x5b)) {\n          wVar2 = wVar2 + L' ';\n        }\n        _Str2 = _Str2 + 1;\n      } while ((wVar1 != L'\\0') && (wVar1 == wVar2));\n    }\n    else {\n      do {\n        wVar1 = __towlower_l(*_Str1,&local_10);\n        _Str1 = _Str1 + 1;\n        wVar2 = __towlower_l(*_Str2,&local_10);\n        _Str2 = _Str2 + 1;\n        if (wVar1 == L'\\0') break;\n      } while (wVar1 == wVar2);\n    }\n    iVar4 = (uint)(ushort)wVar1 - (uint)(ushort)wVar2;\n  }\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return iVar4;\n}\n\n"
    },
    {
      "name": "___acrt_copy_path_to_wide_string",
      "entry": "00415ffa",
      "c": "\n/* Library Function - Single Match\n    ___acrt_copy_path_to_wide_string\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl ___acrt_copy_path_to_wide_string(LPCSTR param_1,undefined4 *param_2)\n\n{\n  int *piVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int cchWideChar;\n  DWORD DVar4;\n  LPWSTR lpWideCharStr;\n  LPWSTR _Memory;\n  \n  if (param_1 == (LPCSTR)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    uVar2 = 0;\n  }\n  else if (param_2 == (undefined4 *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    uVar2 = 0;\n  }\n  else {\n    iVar3 = ___acrt_AreFileApisANSI_0();\n    uVar2 = 0;\n    *param_2 = 0;\n    cchWideChar = MultiByteToWideChar((uint)(iVar3 == 0),0,param_1,-1,(LPWSTR)0x0,0);\n    if (cchWideChar == 0) {\n      DVar4 = GetLastError();\n      ___acrt_errno_map_os_error(DVar4);\n      uVar2 = 0;\n    }\n    else {\n      lpWideCharStr = (LPWSTR)__malloc_base(cchWideChar * 2);\n      _Memory = lpWideCharStr;\n      if (lpWideCharStr != (LPWSTR)0x0) {\n        iVar3 = MultiByteToWideChar((uint)(iVar3 == 0),0,param_1,-1,lpWideCharStr,cchWideChar);\n        if (iVar3 == 0) {\n          DVar4 = GetLastError();\n          ___acrt_errno_map_os_error(DVar4);\n        }\n        else {\n          _Memory = (LPWSTR)0x0;\n          uVar2 = 1;\n          *param_2 = lpWideCharStr;\n        }\n      }\n      FID_conflict__free(_Memory);\n    }\n  }\n  return uVar2;\n}\n\n"
    },
    {
      "name": "__crt_time_elapsed_leap_years<int>",
      "entry": "004160c1",
      "c": "\n/* Library Function - Single Match\n    int __cdecl __crt_time_elapsed_leap_years<int>(int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __crt_time_elapsed_leap_years<int>(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = param_1 + -1;\n  return ((int)(iVar1 + (iVar1 >> 0x1f & 3U)) >> 2) + -0x11 + ((param_1 + 299) / 400 - iVar1 / 100);\n}\n\n"
    },
    {
      "name": "__crt_time_is_leap_year<int>",
      "entry": "004160fb",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __crt_time_is_leap_year<int>(int)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __crt_time_is_leap_year<int>(int param_1)\n\n{\n  uint uVar1;\n  bool bVar2;\n  \n  uVar1 = param_1 & 0x80000003;\n  bVar2 = uVar1 == 0;\n  if ((int)uVar1 < 0) {\n    bVar2 = (uVar1 - 1 | 0xfffffffc) == 0xffffffff;\n  }\n  if (bVar2) {\n    if (param_1 % 100 != 0) {\n      return true;\n    }\n  }\n  return (bool)('\\x01' - ((param_1 + 0x76c) % 400 != 0));\n}\n\n"
    },
    {
      "name": "common_loctotime_t<__int64>",
      "entry": "0041613c",
      "c": "\n/* Library Function - Single Match\n    __int64 __cdecl common_loctotime_t<__int64>(int,int,int,int,int,int,int)\n   \n   Library: Visual Studio 2015 Release */\n\n__int64 __cdecl\ncommon_loctotime_t<__int64>\n          (int param_1,int param_2,int param_3,int param_4,int param_5,int param_6,int param_7)\n\n{\n  int iVar1;\n  uint uVar2;\n  longlong lVar3;\n  bool bVar4;\n  errno_t eVar5;\n  int iVar6;\n  int *piVar7;\n  uint uVar8;\n  int iVar9;\n  __int64 _Var10;\n  long local_40 [2];\n  int local_38;\n  int local_34;\n  int local_30;\n  tm local_2c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  uVar8 = param_1 - 0x76c;\n  if ((((0x45 < (int)uVar8) && (-1 < (int)uVar8)) && (uVar8 < 0x44d)) && (param_2 - 1U < 0xc)) {\n    iVar1 = param_2 + -1;\n    bVar4 = __crt_time_is_day_valid(uVar8,iVar1,param_3);\n    if (((bVar4) && ((uint)param_4 < 0x18)) && (((uint)param_5 < 0x3c && ((uint)param_6 < 0x3c)))) {\n      iVar9 = *(int *)(&DAT_0042ab38 + param_2 * 4) + param_3;\n      bVar4 = __crt_time_is_leap_year<int>(uVar8);\n      if ((bVar4) && (2 < param_2)) {\n        iVar9 = iVar9 + 1;\n      }\n      ___tzset();\n      local_38 = 0;\n      local_40[1] = 0;\n      local_40[0] = 0;\n      eVar5 = __get_daylight(&local_38);\n      if (((eVar5 != 0) || (eVar5 = __get_dstbias(local_40 + 1), eVar5 != 0)) ||\n         (eVar5 = __get_timezone(local_40), eVar5 != 0)) {\n                    /* WARNING: Subroutine does not return */\n        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n      }\n      iVar6 = __crt_time_elapsed_leap_years<int>(uVar8);\n      lVar3 = (longlong)iVar9 * 0x15180 + (longlong)iVar6 * 0x15180 +\n              (longlong)(int)uVar8 * 0x1e13380 + (longlong)param_4 * 0xe10 +\n              (longlong)param_5 * 0x3c + (longlong)local_40[0] + (longlong)param_6;\n      uVar2 = (uint)lVar3;\n      local_34 = uVar2 + 0x7c6beb00;\n      local_30 = (int)((ulonglong)lVar3 >> 0x20) - (uint)(uVar2 < 0x83941500);\n      if (param_7 != 1) {\n        local_2c.tm_hour = param_4;\n        local_2c.tm_min = param_5;\n        local_2c.tm_sec = param_6;\n        local_2c.tm_mon = iVar1;\n        local_2c.tm_year = uVar8;\n        local_2c.tm_yday = iVar9;\n        if ((param_7 == -1) && (local_38 != 0)) {\n          __isindst(&local_2c);\n        }\n      }\n      goto LAB_00416302;\n    }\n  }\n  piVar7 = __errno();\n  *piVar7 = 0x16;\nLAB_00416302:\n  _Var10 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return _Var10;\n}\n\n"
    },
    {
      "name": "__crt_time_is_day_valid",
      "entry": "0041631e",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __crt_time_is_day_valid(int,int,int)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __crt_time_is_day_valid(int param_1,int param_2,int param_3)\n\n{\n  bool bVar1;\n  \n  if (param_3 < 1) {\n    return false;\n  }\n  if ((*(int *)(&DAT_0042ab40 + param_2 * 4) - *(int *)(&DAT_0042ab3c + param_2 * 4) < param_3) &&\n     (((bVar1 = __crt_time_is_leap_year<int>(param_1), !bVar1 || (param_2 != 1)) || (0x1d < param_3)\n      ))) {\n    return false;\n  }\n  return true;\n}\n\n"
    },
    {
      "name": "FUN_00416365",
      "entry": "00416365",
      "c": "\n__int64 __cdecl\nFUN_00416365(int param_1,int param_2,int param_3,int param_4,int param_5,int param_6,int param_7)\n\n{\n  __int64 _Var1;\n  \n  _Var1 = common_loctotime_t<__int64>(param_1,param_2,param_3,param_4,param_5,param_6,param_7);\n  return _Var1;\n}\n\n"
    },
    {
      "name": "operator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>",
      "entry": "00416370",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_d92cfe8357b99225085016881b624cb0>,class <lambda_b721fa326cdb32351d23dfa67958c160> &,class\n   <lambda_42d75b0848218ec137fa420c8ba9fdf9> >(class <lambda_d92cfe8357b99225085016881b624cb0>\n   &&,class <lambda_b721fa326cdb32351d23dfa67958c160> &,class\n   <lambda_42d75b0848218ec137fa420c8ba9fdf9> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_d92cfe8357b99225085016881b624cb0> *param_1,\n          <lambda_b721fa326cdb32351d23dfa67958c160> *param_2,\n          <lambda_42d75b0848218ec137fa420c8ba9fdf9> *param_3)\n\n{\n  int iVar1;\n  \n  __lock_file(*(FILE **)param_1);\n  iVar1 = <lambda_b721fa326cdb32351d23dfa67958c160>::operator()(param_2);\n  FUN_004163b5();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_004163b5",
      "entry": "004163b5",
      "c": "\nvoid FUN_004163b5(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file((FILE *)**(undefined4 **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>",
      "entry": "004163c1",
      "c": "\n/* Library Function - Single Match\n    int __cdecl __acrt_lock_stream_and_call<class <lambda_b721fa326cdb32351d23dfa67958c160> >(struct\n   _iobuf * const,class <lambda_b721fa326cdb32351d23dfa67958c160> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n__acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>\n          (_iobuf *param_1,<lambda_b721fa326cdb32351d23dfa67958c160> *param_2)\n\n{\n  int iVar1;\n  _iobuf *local_10;\n  _iobuf *local_c;\n  __crt_seh_guarded_call<int> local_5;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  iVar1 = __crt_seh_guarded_call<int>::\n          operator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>\n                    (&local_5,(<lambda_d92cfe8357b99225085016881b624cb0> *)&local_10,param_2,\n                     (<lambda_42d75b0848218ec137fa420c8ba9fdf9> *)&local_c);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "operator()",
      "entry": "004163e9",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    public: int __thiscall <lambda_b721fa326cdb32351d23dfa67958c160>::operator()(void)const \n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n<lambda_b721fa326cdb32351d23dfa67958c160>::operator()\n          (<lambda_b721fa326cdb32351d23dfa67958c160> *this)\n\n{\n  LPVOID pvVar1;\n  int iVar2;\n  uint uVar3;\n  undefined4 uVar4;\n  \n  uVar3 = **(uint **)this & 0xfffffffe;\n  ___acrt_stdio_flush_nolock((FILE *)**(undefined4 **)(this + 4));\n  ___acrt_stdio_free_buffer_nolock((undefined4 *)**(undefined4 **)(this + 4));\n  LOCK();\n  *(uint *)(**(int **)(this + 4) + 0xc) = *(uint *)(**(int **)(this + 4) + 0xc) & 0xfffff81f;\n  UNLOCK();\n  if ((**(byte **)(this + 8) & 4) == 0) {\n    pvVar1 = (LPVOID)**(int **)(this + 0xc);\n    if (pvVar1 == (LPVOID)0x0) {\n      pvVar1 = __malloc_base(uVar3);\n      FID_conflict__free((void *)0x0);\n      if (pvVar1 == (LPVOID)0x0) {\n        _DAT_0043ae9c = _DAT_0043ae9c + 1;\n        return -1;\n      }\n      uVar4 = 0x140;\n    }\n    else {\n      uVar4 = 0x180;\n    }\n    iVar2 = **(int **)(this + 4);\n  }\n  else {\n    uVar4 = 0x400;\n    uVar3 = 2;\n    pvVar1 = (LPVOID)(**(int **)(this + 4) + 0x14);\n    iVar2 = **(int **)(this + 4);\n  }\n  iVar2 = set_buffer(iVar2,pvVar1,uVar3,uVar4);\n  return iVar2;\n}\n\n"
    },
    {
      "name": "set_buffer",
      "entry": "00416483",
      "c": "\n/* Library Function - Single Match\n    int __cdecl set_buffer(class __crt_stdio_stream,char * const,unsigned int,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl set_buffer(undefined4 *param_1,undefined4 param_2,undefined4 param_3,uint param_4)\n\n{\n  LOCK();\n  param_1[3] = param_1[3] | param_4;\n  UNLOCK();\n  param_1[6] = param_3;\n  *param_1 = param_2;\n  param_1[1] = param_2;\n  param_1[2] = 0;\n  return 0;\n}\n\n"
    },
    {
      "name": "_setvbuf",
      "entry": "004164b6",
      "c": "\n/* Library Function - Single Match\n    _setvbuf\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _setvbuf(FILE *_File,char *_Buf,int _Mode,size_t _Size)\n\n{\n  int *piVar1;\n  int iVar2;\n  size_t *local_18;\n  FILE **local_14;\n  int *local_10;\n  char **local_c;\n  FILE *local_8;\n  \n  local_8 = _File;\n  if (_File == (FILE *)0x0) {\nLAB_004164c8:\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    iVar2 = -1;\n  }\n  else {\n    if (_Mode == 4) {\nLAB_004164ee:\n      if ((_Mode == 0) || (_Mode == 0x40)) goto LAB_004164f7;\n    }\n    else {\n      if (_Mode != 0) {\n        if (_Mode != 0x40) goto LAB_004164c8;\n        goto LAB_004164ee;\n      }\nLAB_004164f7:\n      if (0x7ffffffd < _Size - 2) goto LAB_004164c8;\n    }\n    local_18 = &_Size;\n    local_14 = &local_8;\n    local_10 = &_Mode;\n    local_c = &_Buf;\n    iVar2 = __acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>\n                      (_File,(<lambda_b721fa326cdb32351d23dfa67958c160> *)&local_18);\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "common_getdcwd<char>",
      "entry": "0041652c",
      "c": "\n/* Library Function - Single Match\n    char * __cdecl common_getdcwd<char>(int,char * const,int,int,char const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl\ncommon_getdcwd<char>(int param_1,char *param_2,int param_3,int param_4,char *param_5,int param_6)\n\n{\n  int *piVar1;\n  int iVar2;\n  ulong *puVar3;\n  char *pcVar4;\n  undefined4 local_8;\n  \n  if (param_3 < 0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return (char *)0x0;\n  }\n  if (param_1 == 0) {\n    param_1 = __getdrive();\n  }\n  else {\n    iVar2 = is_valid_drive(param_1);\n    if (iVar2 == 0) {\n      puVar3 = ___doserrno();\n      *puVar3 = 0xf;\n      piVar1 = __errno();\n      *piVar1 = 0xd;\n      goto LAB_004165b5;\n    }\n  }\n  if (param_1 == 0) {\n    local_8 = CONCAT22(local_8._2_2_,0x2e);\n  }\n  else {\n    local_8 = CONCAT31(0x2e3a,(char)param_1 + '@');\n  }\n  if (param_2 == (char *)0x0) {\n    pcVar4 = common_getdcwd_dynamic_buffer<char>((char *)&local_8,param_3,param_4,param_5,param_6);\n    return pcVar4;\n  }\n  if (0 < param_3) {\n    *param_2 = '\\0';\n    pcVar4 = common_getdcwd_user_buffer<char>((char *)&local_8,param_2,param_3);\n    return pcVar4;\n  }\n  piVar1 = __errno();\n  *piVar1 = 0x16;\nLAB_004165b5:\n  FUN_00412362();\n  return (char *)0x0;\n}\n\n"
    },
    {
      "name": "common_getdcwd<wchar_t>",
      "entry": "004165ed",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl common_getdcwd<wchar_t>(int,wchar_t * const,int,int,char const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl\ncommon_getdcwd<wchar_t>\n          (int param_1,wchar_t *param_2,int param_3,int param_4,char *param_5,int param_6)\n\n{\n  int *piVar1;\n  int iVar2;\n  ulong *puVar3;\n  wchar_t *pwVar4;\n  wchar_t local_10;\n  undefined2 local_e;\n  undefined2 local_c;\n  undefined2 local_a;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_3 < 0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    goto LAB_004166ca;\n  }\n  if (param_1 == 0) {\n    param_1 = __getdrive();\nLAB_00416654:\n    if (param_1 == 0) {\n      local_10 = L'.';\n      local_e = 0;\n    }\n    else {\n      local_10 = (short)param_1 + L'@';\n      local_e = 0x3a;\n      local_c = 0x2e;\n      local_a = 0;\n    }\n    if (param_2 == (wchar_t *)0x0) {\n      common_getdcwd_dynamic_buffer<wchar_t>(&local_10,param_3,param_4,param_5,param_6);\n      goto LAB_004166ca;\n    }\n    if (0 < param_3) {\n      *param_2 = L'\\0';\n      common_getdcwd_user_buffer<wchar_t>(&local_10,param_2,param_3);\n      goto LAB_004166ca;\n    }\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n  }\n  else {\n    iVar2 = is_valid_drive(param_1);\n    if (iVar2 != 0) goto LAB_00416654;\n    puVar3 = ___doserrno();\n    *puVar3 = 0xf;\n    piVar1 = __errno();\n    *piVar1 = 0xd;\n  }\n  FUN_00412362();\nLAB_004166ca:\n  pwVar4 = (wchar_t *)__security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return pwVar4;\n}\n\n"
    },
    {
      "name": "common_getdcwd_dynamic_buffer<char>",
      "entry": "004166da",
      "c": "\n/* Library Function - Single Match\n    char * __cdecl common_getdcwd_dynamic_buffer<char>(char * const,unsigned int,int,char const *\n   const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl\ncommon_getdcwd_dynamic_buffer<char>\n          (char *param_1,uint param_2,int param_3,char *param_4,int param_5)\n\n{\n  DWORD DVar1;\n  char *pcVar2;\n  char *pcVar3;\n  ulong *puVar4;\n  int *piVar5;\n  char *pcVar6;\n  char *pcVar7;\n  \n  DVar1 = GetFullPathNameA(param_1,0,(LPSTR)0x0,(LPSTR *)0x0);\n  if (DVar1 == 0) {\n    DVar1 = GetLastError();\n    ___acrt_errno_map_os_error(DVar1);\n    pcVar2 = (char *)0x0;\n  }\n  else {\n    if (param_2 <= DVar1) {\n      param_2 = DVar1;\n    }\n    pcVar3 = (char *)FUN_0040e228(param_2,1);\n    pcVar7 = pcVar3;\n    pcVar2 = (char *)0x0;\n    if (pcVar3 == (char *)0x0) {\n      puVar4 = ___doserrno();\n      *puVar4 = 8;\n      piVar5 = __errno();\n      *piVar5 = 0xc;\n    }\n    else {\n      pcVar6 = common_getdcwd_user_buffer<char>(param_1,pcVar3,param_2);\n      if (pcVar6 != (char *)0x0) {\n        pcVar7 = (char *)0x0;\n        pcVar2 = pcVar3;\n      }\n    }\n    FID_conflict__free(pcVar7);\n  }\n  return pcVar2;\n}\n\n"
    },
    {
      "name": "common_getdcwd_dynamic_buffer<wchar_t>",
      "entry": "0041675b",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl common_getdcwd_dynamic_buffer<wchar_t>(wchar_t * const,unsigned int,int,char\n   const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl\ncommon_getdcwd_dynamic_buffer<wchar_t>\n          (wchar_t *param_1,uint param_2,int param_3,char *param_4,int param_5)\n\n{\n  DWORD DVar1;\n  wchar_t *pwVar2;\n  wchar_t *pwVar3;\n  ulong *puVar4;\n  int *piVar5;\n  wchar_t *pwVar6;\n  wchar_t *pwVar7;\n  \n  DVar1 = GetFullPathNameW(param_1,0,(LPWSTR)0x0,(LPWSTR *)0x0);\n  if (DVar1 == 0) {\n    DVar1 = GetLastError();\n    ___acrt_errno_map_os_error(DVar1);\n    pwVar2 = (wchar_t *)0x0;\n  }\n  else {\n    if (param_2 <= DVar1) {\n      param_2 = DVar1;\n    }\n    pwVar3 = (wchar_t *)FUN_0040e228(param_2,2);\n    pwVar7 = pwVar3;\n    pwVar2 = (wchar_t *)0x0;\n    if (pwVar3 == (wchar_t *)0x0) {\n      puVar4 = ___doserrno();\n      *puVar4 = 8;\n      piVar5 = __errno();\n      *piVar5 = 0xc;\n    }\n    else {\n      pwVar6 = common_getdcwd_user_buffer<wchar_t>(param_1,pwVar3,param_2);\n      if (pwVar6 != (wchar_t *)0x0) {\n        pwVar7 = (wchar_t *)0x0;\n        pwVar2 = pwVar3;\n      }\n    }\n    FID_conflict__free(pwVar7);\n  }\n  return pwVar2;\n}\n\n"
    },
    {
      "name": "common_getdcwd_user_buffer<char>",
      "entry": "004167dc",
      "c": "\n/* Library Function - Single Match\n    char * __cdecl common_getdcwd_user_buffer<char>(char * const,char * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl common_getdcwd_user_buffer<char>(char *param_1,char *param_2,uint param_3)\n\n{\n  int *piVar1;\n  DWORD DVar2;\n  \n  if (param_3 == 0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    DVar2 = GetFullPathNameA(param_1,param_3,param_2,(LPSTR *)0x0);\n    if (DVar2 < param_3) {\n      if (DVar2 != 0) {\n        return param_2;\n      }\n      DVar2 = GetLastError();\n      ___acrt_errno_map_os_error(DVar2);\n    }\n    else {\n      piVar1 = __errno();\n      *piVar1 = 0x22;\n    }\n  }\n  return (char *)0x0;\n}\n\n"
    },
    {
      "name": "common_getdcwd_user_buffer<wchar_t>",
      "entry": "00416836",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl common_getdcwd_user_buffer<wchar_t>(wchar_t * const,wchar_t * const,unsigned\n   int)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl\ncommon_getdcwd_user_buffer<wchar_t>(wchar_t *param_1,wchar_t *param_2,uint param_3)\n\n{\n  int *piVar1;\n  DWORD DVar2;\n  \n  if (param_3 == 0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    DVar2 = GetFullPathNameW(param_1,param_3,param_2,(LPWSTR *)0x0);\n    if (DVar2 < param_3) {\n      if (DVar2 != 0) {\n        return param_2;\n      }\n      DVar2 = GetLastError();\n      ___acrt_errno_map_os_error(DVar2);\n    }\n    else {\n      piVar1 = __errno();\n      *piVar1 = 0x22;\n    }\n  }\n  return (wchar_t *)0x0;\n}\n\n"
    },
    {
      "name": "is_valid_drive",
      "entry": "00416890",
      "c": "\n/* Library Function - Single Match\n    int __cdecl is_valid_drive(unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl is_valid_drive(uint param_1)\n\n{\n  ulong *puVar1;\n  int *piVar2;\n  int iVar3;\n  WCHAR local_10;\n  undefined2 local_e;\n  undefined2 local_c;\n  undefined2 local_a;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_1 < 0x1b) {\n    if (param_1 != 0) {\n      local_10 = (short)param_1 + L'@';\n      local_e = 0x3a;\n      local_c = 0x5c;\n      local_a = 0;\n      GetDriveTypeW(&local_10);\n    }\n  }\n  else {\n    puVar1 = ___doserrno();\n    *puVar1 = 0xf;\n    piVar2 = __errno();\n    *piVar2 = 0xd;\n    FUN_00412362();\n  }\n  iVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "__getcwd",
      "entry": "0041690e",
      "c": "\n/* Library Function - Single Match\n    __getcwd\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl __getcwd(char *_DstBuf,int _SizeInBytes)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = common_getdcwd<char>(0,_DstBuf,_SizeInBytes,1,(char *)0x0,0);\n  return pcVar1;\n}\n\n"
    },
    {
      "name": "__wgetcwd",
      "entry": "0041692a",
      "c": "\n/* Library Function - Single Match\n    __wgetcwd\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl __wgetcwd(wchar_t *_DstBuf,int _SizeInWords)\n\n{\n  wchar_t *pwVar1;\n  \n  pwVar1 = common_getdcwd<wchar_t>(0,_DstBuf,_SizeInWords,1,(char *)0x0,0);\n  return pwVar1;\n}\n\n"
    },
    {
      "name": "__acrt_stdio_parse_mode<wchar_t>",
      "entry": "00416946",
      "c": "\n/* Library Function - Single Match\n    struct __acrt_stdio_stream_mode __cdecl __acrt_stdio_parse_mode<wchar_t>(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl __acrt_stdio_parse_mode<wchar_t>(wchar_t *param_1)\n\n{\n  short sVar1;\n  wchar_t wVar2;\n  undefined1 uVar3;\n  uint uVar4;\n  int iVar5;\n  int *piVar6;\n  char cVar7;\n  wchar_t *pwVar8;\n  wchar_t *pwVar9;\n  short *in_stack_00000008;\n  bool local_8;\n  bool local_7;\n  char local_6;\n  byte local_5;\n  \n  param_1[0] = L'\\0';\n  param_1[1] = L'\\0';\n  param_1[2] = L'\\0';\n  param_1[3] = L'\\0';\n  param_1[4] = L'\\0';\n  param_1[5] = L'\\0';\n  *(undefined4 *)(param_1 + 2) = DAT_0043b0f0;\n  for (; *in_stack_00000008 == 0x20; in_stack_00000008 = in_stack_00000008 + 1) {\n  }\n  sVar1 = *in_stack_00000008;\n  cVar7 = '\\0';\n  if (sVar1 == 0x61) {\n    param_1[0] = L'\u0109';\n    param_1[1] = L'\\0';\nLAB_004169af:\n    param_1[2] = L'\\x02';\n    param_1[3] = L'\\0';\n  }\n  else {\n    if (sVar1 != 0x72) {\n      if (sVar1 != 0x77) goto LAB_00416b71;\n      param_1[0] = L'\u0301';\n      param_1[1] = L'\\0';\n      goto LAB_004169af;\n    }\n    param_1[0] = L'\\0';\n    param_1[1] = L'\\0';\n    param_1[2] = L'\\x01';\n    param_1[3] = L'\\0';\n  }\n  pwVar9 = in_stack_00000008 + 1;\n  local_7 = false;\n  local_8 = false;\n  local_6 = '\\0';\n  uVar4 = 1;\n  local_5 = 0;\nLAB_004169c4:\n  uVar3 = (undefined1)uVar4;\n  wVar2 = *pwVar9;\n  if (wVar2 == L'\\0') {\n    uVar4 = (uint)local_5 << 8;\n    goto LAB_00416ab0;\n  }\n  if ((ushort)wVar2 < 0x54) {\n    if (wVar2 == L'S') {\n      uVar4 = (uint)CONCAT11(local_5,uVar3);\n      if (cVar7 != '\\0') goto LAB_00416a22;\n      *(uint *)param_1 = *(uint *)param_1 | 0x20;\nLAB_00416a3c:\n      cVar7 = '\\x01';\n      local_6 = '\\x01';\n      uVar4 = CONCAT31((int3)(uVar4 >> 8),1);\n      goto LAB_00416a99;\n    }\n    if (wVar2 == L' ') goto LAB_00416a96;\n    if (wVar2 == L'+') {\n      uVar3 = __acrt_stdio_parse_mode_plus((__acrt_stdio_stream_mode *)param_1,&local_8);\n      cVar7 = local_6;\n    }\n    else {\n      if (wVar2 == L',') {\n        uVar4 = (uint)CONCAT11(1,uVar3);\n        local_5 = 1;\nLAB_00416a22:\n        uVar4 = uVar4 & 0xffffff00;\n        goto LAB_00416a99;\n      }\n      if (wVar2 == L'D') {\n        uVar3 = __acrt_stdio_parse_mode_D((__acrt_stdio_stream_mode *)param_1);\n        cVar7 = local_6;\n      }\n      else {\n        if (wVar2 != L'N') {\n          if (wVar2 == L'R') {\n            uVar4 = (uint)CONCAT11(local_5,uVar3);\n            if (cVar7 == '\\0') {\n              *(uint *)param_1 = *(uint *)param_1 | 0x10;\n              goto LAB_00416a3c;\n            }\n            goto LAB_00416a22;\n          }\n          goto LAB_00416b71;\n        }\n        *(uint *)param_1 = *(uint *)param_1 | 0x80;\n        uVar3 = 1;\n      }\n    }\n  }\n  else if (wVar2 == L'T') {\n    uVar3 = __acrt_stdio_parse_mode_T((__acrt_stdio_stream_mode *)param_1);\n    cVar7 = local_6;\n  }\n  else if (wVar2 == L'b') {\n    uVar4 = FID_conflict___acrt_stdio_parse_mode_b((uint *)param_1);\n    uVar3 = (undefined1)uVar4;\n    cVar7 = local_6;\n  }\n  else if (wVar2 == L'c') {\n    uVar3 = __acrt_stdio_parse_mode_c((__acrt_stdio_stream_mode *)param_1,&local_7);\n    cVar7 = local_6;\n  }\n  else if (wVar2 == L'n') {\n    uVar3 = __acrt_stdio_parse_mode_n((__acrt_stdio_stream_mode *)param_1,&local_7);\n    cVar7 = local_6;\n  }\n  else {\n    if (wVar2 != L't') goto LAB_00416b71;\n    uVar4 = FID_conflict___acrt_stdio_parse_mode_b((uint *)param_1);\n    uVar3 = (undefined1)uVar4;\n    cVar7 = local_6;\n  }\nLAB_00416a96:\n  uVar4 = (uint)CONCAT11(local_5,uVar3);\nLAB_00416a99:\n  pwVar9 = pwVar9 + ((char)uVar4 != '\\0');\n  if ((char)uVar4 == '\\0') goto LAB_00416ab0;\n  goto LAB_004169c4;\nLAB_00416ab0:\n  cVar7 = (char)(uVar4 >> 8);\n  if (cVar7 == '\\0') goto LAB_00416ab7;\n  do {\n    pwVar9 = pwVar9 + 1;\nLAB_00416ab7:\n  } while (*pwVar9 == L' ');\n  if (cVar7 != '\\0') {\n    iVar5 = _wcsncmp(pwVar9,L\"ccs\",3);\n    if (iVar5 != 0) goto LAB_00416b71;\n    for (pwVar9 = pwVar9 + 3; *pwVar9 == L' '; pwVar9 = pwVar9 + 1) {\n    }\n    if (*pwVar9 != L'=') goto LAB_00416b71;\n    do {\n      pwVar8 = pwVar9;\n      pwVar9 = pwVar8 + 1;\n    } while (*pwVar9 == L' ');\n    iVar5 = __wcsnicmp(pwVar9,L\"UTF-8\",5);\n    if (iVar5 == 0) {\n      pwVar9 = pwVar8 + 6;\n      *(uint *)param_1 = *(uint *)param_1 | 0x40000;\n    }\n    else {\n      iVar5 = __wcsnicmp(pwVar9,L\"UTF-16LEUNICODE\",8);\n      if (iVar5 == 0) {\n        pwVar9 = pwVar8 + 9;\n        *(uint *)param_1 = *(uint *)param_1 | 0x20000;\n      }\n      else {\n        iVar5 = __wcsnicmp(pwVar9,L\"UNICODE\",7);\n        if (iVar5 != 0) goto LAB_00416b71;\n        pwVar9 = pwVar8 + 8;\n        *(uint *)param_1 = *(uint *)param_1 | 0x10000;\n      }\n    }\n    for (; *pwVar9 == L' '; pwVar9 = pwVar9 + 1) {\n    }\n  }\n  if (*pwVar9 == L'\\0') {\n    *(undefined1 *)(param_1 + 4) = 1;\n    return param_1;\n  }\nLAB_00416b71:\n  piVar6 = __errno();\n  *piVar6 = 0x16;\n  FUN_00412362();\n  return param_1;\n}\n\n"
    },
    {
      "name": "common_openfile<wchar_t>",
      "entry": "00416b8a",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    struct _iobuf * __cdecl common_openfile<wchar_t>(wchar_t const * const,wchar_t const *\n   const,int,class __crt_stdio_stream)\n   \n   Library: Visual Studio 2015 Release */\n\n_iobuf * __cdecl\ncommon_openfile<wchar_t>(char *param_1,undefined4 param_2,int param_3,_iobuf *param_4)\n\n{\n  int *piVar1;\n  errno_t eVar2;\n  wchar_t local_20 [6];\n  int local_14;\n  uint local_10;\n  int local_c;\n  int local_8;\n  \n  piVar1 = (int *)__acrt_stdio_parse_mode<wchar_t>(local_20);\n  local_14 = *piVar1;\n  local_10 = piVar1[1];\n  local_c = piVar1[2];\n  if (((char)local_c != '\\0') &&\n     (eVar2 = FID_conflict___sopen_s(&local_8,param_1,local_14,param_3,0x180), eVar2 == 0)) {\n    _DAT_0043ae9c = _DAT_0043ae9c + 1;\n    LOCK();\n    param_4->_flag = param_4->_flag | local_10;\n    UNLOCK();\n    param_4->_base = (char *)0x0;\n    param_4->_tmpfname = (char *)0x0;\n    param_4->_cnt = 0;\n    param_4->_ptr = (char *)0x0;\n    param_4->_file = local_8;\n    return param_4;\n  }\n  return (_iobuf *)0x0;\n}\n\n"
    },
    {
      "name": "__acrt_stdio_parse_mode_D",
      "entry": "00416c0f",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __acrt_stdio_parse_mode_D(struct __acrt_stdio_stream_mode &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __acrt_stdio_parse_mode_D(__acrt_stdio_stream_mode *param_1)\n\n{\n  if ((*(uint *)param_1 & 0x40) != 0) {\n    return false;\n  }\n  *(uint *)param_1 = *(uint *)param_1 | 0x40;\n  return true;\n}\n\n"
    },
    {
      "name": "__acrt_stdio_parse_mode_T",
      "entry": "00416c2a",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __acrt_stdio_parse_mode_T(struct __acrt_stdio_stream_mode &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __acrt_stdio_parse_mode_T(__acrt_stdio_stream_mode *param_1)\n\n{\n  if ((*(uint *)param_1 & 0x1000) != 0) {\n    return false;\n  }\n  *(uint *)param_1 = *(uint *)param_1 | 0x1000;\n  return true;\n}\n\n"
    },
    {
      "name": "FID_conflict:__acrt_stdio_parse_mode_b",
      "entry": "00416c49",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    bool __cdecl __acrt_stdio_parse_mode_b(struct __acrt_stdio_stream_mode &)\n    bool __cdecl __acrt_stdio_parse_mode_t(struct __acrt_stdio_stream_mode &)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl FID_conflict___acrt_stdio_parse_mode_b(uint *param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = *param_1;\n  if ((uVar1 & 0xc000) != 0) {\n    return uVar1 & 0xffffff00;\n  }\n  *param_1 = uVar1 | 0x8000;\n  return CONCAT31((int3)((uVar1 | 0x8000) >> 8),1);\n}\n\n"
    },
    {
      "name": "__acrt_stdio_parse_mode_c",
      "entry": "00416c69",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __acrt_stdio_parse_mode_c(struct __acrt_stdio_stream_mode &,bool &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __acrt_stdio_parse_mode_c(__acrt_stdio_stream_mode *param_1,bool *param_2)\n\n{\n  if (*param_2 != false) {\n    return false;\n  }\n  *param_2 = true;\n  *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 0x800;\n  return true;\n}\n\n"
    },
    {
      "name": "__acrt_stdio_parse_mode_n",
      "entry": "00416c8b",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __acrt_stdio_parse_mode_n(struct __acrt_stdio_stream_mode &,bool &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __acrt_stdio_parse_mode_n(__acrt_stdio_stream_mode *param_1,bool *param_2)\n\n{\n  if (*param_2 != false) {\n    return false;\n  }\n  *param_2 = true;\n  *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) & 0xfffff7ff;\n  return true;\n}\n\n"
    },
    {
      "name": "__acrt_stdio_parse_mode_plus",
      "entry": "00416cad",
      "c": "\n/* Library Function - Single Match\n    bool __cdecl __acrt_stdio_parse_mode_plus(struct __acrt_stdio_stream_mode &,bool &)\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __acrt_stdio_parse_mode_plus(__acrt_stdio_stream_mode *param_1,bool *param_2)\n\n{\n  if (*param_2 == false) {\n    *param_2 = true;\n    if ((*(uint *)param_1 & 2) == 0) {\n      *(uint *)param_1 = *(uint *)param_1 & 0xfffffffe | 2;\n      *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) & 0xfffffffc | 4;\n      return true;\n    }\n  }\n  return false;\n}\n\n"
    },
    {
      "name": "FID_conflict:__acrt_stdio_parse_mode_b",
      "entry": "00416ce2",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    bool __cdecl __acrt_stdio_parse_mode_b(struct __acrt_stdio_stream_mode &)\n    bool __cdecl __acrt_stdio_parse_mode_t(struct __acrt_stdio_stream_mode &)\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl FID_conflict___acrt_stdio_parse_mode_b(uint *param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = *param_1;\n  if ((uVar1 & 0xc000) != 0) {\n    return uVar1 & 0xffffff00;\n  }\n  *param_1 = uVar1 | 0x4000;\n  return CONCAT31((int3)((uVar1 | 0x4000) >> 8),1);\n}\n\n"
    },
    {
      "name": "FUN_00416d02",
      "entry": "00416d02",
      "c": "\nvoid FUN_00416d02(void)\n\n{\n  common_openfile<wchar_t>();\n  return;\n}\n\n"
    },
    {
      "name": "__isleadbyte_l",
      "entry": "00416d0d",
      "c": "\n/* Library Function - Single Match\n    __isleadbyte_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __isleadbyte_l(int _C,_locale_t _Locale)\n\n{\n  ushort uVar1;\n  int local_14;\n  int *local_10;\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);\n  uVar1 = *(ushort *)(*local_10 + (_C & 0xffU) * 2);\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return uVar1 & 0x8000;\n}\n\n"
    },
    {
      "name": "___acrt_lock",
      "entry": "00416d87",
      "c": "\n/* Library Function - Single Match\n    ___acrt_lock\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_lock(int param_1)\n\n{\n  EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_0043b400 + param_1 * 0x18));\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00416d9e",
      "entry": "00416d9e",
      "c": "\nundefined4 FUN_00416d9e(void)\n\n{\n  undefined4 in_EAX;\n  undefined4 extraout_EAX;\n  int iVar1;\n  LPCRITICAL_SECTION lpCriticalSection;\n  \n  if (DAT_0043b538 != 0) {\n    lpCriticalSection = (LPCRITICAL_SECTION)(&DAT_0043b3e8 + DAT_0043b538 * 0x18);\n    iVar1 = DAT_0043b538;\n    do {\n      DeleteCriticalSection(lpCriticalSection);\n      DAT_0043b538 = DAT_0043b538 + -1;\n      lpCriticalSection = lpCriticalSection + -1;\n      iVar1 = iVar1 + -1;\n      in_EAX = extraout_EAX;\n    } while (iVar1 != 0);\n  }\n  return CONCAT31((int3)((uint)in_EAX >> 8),1);\n}\n\n"
    },
    {
      "name": "___acrt_unlock",
      "entry": "00416dcf",
      "c": "\n/* Library Function - Single Match\n    ___acrt_unlock\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_unlock(int param_1)\n\n{\n  LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_0043b400 + param_1 * 0x18));\n  return;\n}\n\n"
    },
    {
      "name": "operator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>",
      "entry": "00416de6",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    public: int __thiscall __crt_seh_guarded_call<int>::operator()<class\n   <lambda_61cee617f5178ae960314fd4d05640a0>,class <lambda_6978c1fb23f02e42e1d9e99668cc68aa> &,class\n   <lambda_9cd88cf8ad10232537feb2133f08c833> >(class <lambda_61cee617f5178ae960314fd4d05640a0>\n   &&,class <lambda_6978c1fb23f02e42e1d9e99668cc68aa> &,class\n   <lambda_9cd88cf8ad10232537feb2133f08c833> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_61cee617f5178ae960314fd4d05640a0> *param_1,\n          <lambda_6978c1fb23f02e42e1d9e99668cc68aa> *param_2,\n          <lambda_9cd88cf8ad10232537feb2133f08c833> *param_3)\n\n{\n  uint _FileHandle;\n  HANDLE hFile;\n  BOOL BVar1;\n  ulong *puVar2;\n  DWORD DVar3;\n  int *piVar4;\n  int iVar5;\n  \n  iVar5 = 0;\n  ___acrt_lowio_lock_fh(*(uint *)param_1);\n  _FileHandle = **(uint **)param_2;\n  if ((*(byte *)((&DAT_0043b110)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1)\n      != 0) {\n    hFile = (HANDLE)__get_osfhandle(_FileHandle);\n    BVar1 = FlushFileBuffers(hFile);\n    if (BVar1 != 0) goto LAB_00416e56;\n    puVar2 = ___doserrno();\n    DVar3 = GetLastError();\n    *puVar2 = DVar3;\n  }\n  piVar4 = __errno();\n  *piVar4 = 9;\n  iVar5 = -1;\nLAB_00416e56:\n  FUN_00416e72();\n  return iVar5;\n}\n\n"
    },
    {
      "name": "FUN_00416e72",
      "entry": "00416e72",
      "c": "\nvoid FUN_00416e72(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_lowio_unlock_fh(**(uint **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>",
      "entry": "00416e7e",
      "c": "\n/* Library Function - Single Match\n    int __cdecl __acrt_lowio_lock_fh_and_call<class <lambda_6978c1fb23f02e42e1d9e99668cc68aa>\n   >(int,class <lambda_6978c1fb23f02e42e1d9e99668cc68aa> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n__acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>\n          (int param_1,<lambda_6978c1fb23f02e42e1d9e99668cc68aa> *param_2)\n\n{\n  int iVar1;\n  int local_10;\n  int local_c;\n  __crt_seh_guarded_call<int> local_5;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  iVar1 = __crt_seh_guarded_call<int>::\n          operator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>\n                    (&local_5,(<lambda_61cee617f5178ae960314fd4d05640a0> *)&local_10,param_2,\n                     (<lambda_9cd88cf8ad10232537feb2133f08c833> *)&local_c);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__commit",
      "entry": "00416ea6",
      "c": "\n/* Library Function - Single Match\n    __commit\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __commit(int _FileHandle)\n\n{\n  int *piVar1;\n  int iVar2;\n  int *local_8;\n  \n  if (_FileHandle == -2) {\n    piVar1 = __errno();\n    *piVar1 = 9;\n  }\n  else {\n    if (((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) &&\n       ((*(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) & 1) !=\n        0)) {\n      local_8 = &_FileHandle;\n      iVar2 = __acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>\n                        (_FileHandle,(<lambda_6978c1fb23f02e42e1d9e99668cc68aa> *)&local_8);\n      return iVar2;\n    }\n    piVar1 = __errno();\n    *piVar1 = 9;\n    FUN_00412362();\n  }\n  return -1;\n}\n\n"
    },
    {
      "name": "_wcscpy_s",
      "entry": "00416f15",
      "c": "\n/* Library Function - Single Match\n    _wcscpy_s\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nerrno_t __cdecl _wcscpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)\n\n{\n  wchar_t wVar1;\n  int *piVar2;\n  wchar_t *pwVar3;\n  int iVar4;\n  \n  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {\n    if (_Src != (wchar_t *)0x0) {\n      pwVar3 = _Dst;\n      do {\n        wVar1 = *(wchar_t *)(((int)_Src - (int)_Dst) + (int)pwVar3);\n        *pwVar3 = wVar1;\n        pwVar3 = pwVar3 + 1;\n        if (wVar1 == L'\\0') break;\n        _SizeInWords = _SizeInWords - 1;\n      } while (_SizeInWords != 0);\n      if (_SizeInWords != 0) {\n        return 0;\n      }\n      *_Dst = L'\\0';\n      piVar2 = __errno();\n      iVar4 = 0x22;\n      goto LAB_00416f3c;\n    }\n    *_Dst = L'\\0';\n  }\n  piVar2 = __errno();\n  iVar4 = 0x16;\nLAB_00416f3c:\n  *piVar2 = iVar4;\n  FUN_00412362();\n  return iVar4;\n}\n\n"
    },
    {
      "name": "common_set_variable_in_environment_nolock<char>",
      "entry": "00416f79",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_set_variable_in_environment_nolock<char>(char * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_set_variable_in_environment_nolock<char>(char *param_1,int param_2)\n\n{\n  uint uVar1;\n  char cVar2;\n  int *piVar3;\n  uint *puVar4;\n  char **ppcVar5;\n  uint uVar6;\n  char *_Dst;\n  errno_t eVar7;\n  BOOL BVar8;\n  char *pcVar9;\n  int iVar10;\n  char *pcVar11;\n  bool bVar12;\n  \n  if (param_1 == (char *)0x0) {\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    return -1;\n  }\n  puVar4 = FUN_00408a20((uint *)param_1,'=');\n  pcVar11 = param_1;\n  if ((puVar4 == (uint *)0x0) || (puVar4 == (uint *)param_1)) {\nLAB_00416ffc:\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n  }\n  else {\n    bVar12 = *(char *)((int)puVar4 + 1) == '\\0';\n    if (DAT_0043b0cc == DAT_0043b0d8) {\n      DAT_0043b0cc = copy_environment<char>(DAT_0043b0cc);\n    }\n    iVar10 = 0;\n    if (DAT_0043b0cc == (char **)0x0) {\n      if ((param_2 != 0) && (DAT_0043b0d0 != (LPVOID)0x0)) {\n        ppcVar5 = common_get_or_create_environment_nolock<char>();\n        if (ppcVar5 != (char **)0x0) goto LAB_00417070;\n        goto LAB_00416ffc;\n      }\n      if (bVar12) {\n        iVar10 = 0;\n        goto LAB_0041700a;\n      }\n      DAT_0043b0cc = (char **)__calloc_base(1,4);\n      FID_conflict__free((void *)0x0);\n      if (DAT_0043b0cc != (char **)0x0) {\n        if (DAT_0043b0d0 == (LPVOID)0x0) {\n          DAT_0043b0d0 = __calloc_base(1,4);\n          FID_conflict__free((void *)0x0);\n          if (DAT_0043b0d0 == (LPVOID)0x0) goto LAB_00417007;\n        }\nLAB_00417070:\n        if (DAT_0043b0cc != (char **)0x0) goto LAB_00417074;\n      }\n    }\n    else {\nLAB_00417074:\n      ppcVar5 = DAT_0043b0cc;\n      uVar6 = find_in_environment_nolock<char>(param_1,(int)puVar4 - (int)param_1);\n      if ((-1 < (int)uVar6) && (*ppcVar5 != (char *)0x0)) {\n        FID_conflict__free(ppcVar5[uVar6]);\n        if (bVar12) {\n          for (; ppcVar5[uVar6] != (char *)0x0; uVar6 = uVar6 + 1) {\n            ppcVar5[uVar6] = ppcVar5[uVar6 + 1];\n          }\n          ppcVar5 = (char **)FUN_00419319(ppcVar5,uVar6,4);\n          FID_conflict__free((void *)0x0);\n          if (ppcVar5 != (char **)0x0) {\nLAB_00417123:\n            DAT_0043b0cc = ppcVar5;\n          }\n        }\n        else {\n          ppcVar5[uVar6] = param_1;\n          pcVar11 = (char *)0x0;\n        }\n        if (param_2 != 0) {\n          pcVar9 = param_1;\n          do {\n            cVar2 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n          } while (cVar2 != '\\0');\n          _Dst = (char *)__calloc_base((uint)(pcVar9 + (2 - (int)(param_1 + 1))),1);\n          if (_Dst != (char *)0x0) {\n            eVar7 = _strcpy_s(_Dst,(rsize_t)(pcVar9 + (2 - (int)(param_1 + 1))),param_1);\n            if (eVar7 != 0) {\n                    /* WARNING: Subroutine does not return */\n              __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n            }\n            (_Dst + (int)puVar4 + (1 - (int)param_1))[-1] = '\\0';\n            BVar8 = SetEnvironmentVariableA\n                              (_Dst,(LPCSTR)(~-(uint)bVar12 &\n                                            (uint)(_Dst + (int)puVar4 + (1 - (int)param_1))));\n            if (BVar8 == 0) {\n              piVar3 = __errno();\n              iVar10 = -1;\n              *piVar3 = 0x2a;\n            }\n          }\n          FID_conflict__free(_Dst);\n        }\n        goto LAB_0041700a;\n      }\n      if (bVar12) goto LAB_0041700a;\n      uVar1 = -uVar6 + 2;\n      if ((-uVar6 <= uVar1) && (uVar1 < 0x3fffffff)) {\n        ppcVar5 = (char **)FUN_00419319(ppcVar5,uVar1,4);\n        FID_conflict__free((void *)0x0);\n        if (ppcVar5 != (char **)0x0) {\n          ppcVar5[-uVar6] = param_1;\n          ppcVar5[1 - uVar6] = (char *)0x0;\n          pcVar11 = (char *)0x0;\n          goto LAB_00417123;\n        }\n      }\n    }\n  }\nLAB_00417007:\n  iVar10 = -1;\nLAB_0041700a:\n  FID_conflict__free(pcVar11);\n  return iVar10;\n}\n\n"
    },
    {
      "name": "common_set_variable_in_environment_nolock<wchar_t>",
      "entry": "004171b4",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_set_variable_in_environment_nolock<wchar_t>(wchar_t * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_set_variable_in_environment_nolock<wchar_t>(wchar_t *param_1,int param_2)\n\n{\n  uint uVar1;\n  wchar_t wVar2;\n  int *piVar3;\n  wchar_t *pwVar4;\n  wchar_t **ppwVar5;\n  uint uVar6;\n  errno_t eVar7;\n  BOOL BVar8;\n  uint uVar9;\n  int iVar10;\n  wchar_t *pwVar11;\n  bool bVar12;\n  \n  if (param_1 == (wchar_t *)0x0) {\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    return -1;\n  }\n  pwVar4 = (wchar_t *)FUN_004202c6((ushort *)param_1,0x3d);\n  pwVar11 = param_1;\n  if ((pwVar4 == (wchar_t *)0x0) || (pwVar4 == param_1)) {\nLAB_00417238:\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n  }\n  else {\n    iVar10 = 0;\n    bVar12 = pwVar4[1] == L'\\0';\n    if (DAT_0043b0d0 == DAT_0043b0d4) {\n      DAT_0043b0d0 = copy_environment<wchar_t>(DAT_0043b0d0);\n    }\n    if (DAT_0043b0d0 == (wchar_t **)0x0) {\n      if ((param_2 == 0) || (DAT_0043b0cc == (LPVOID)0x0)) {\n        if (bVar12) goto LAB_00417246;\n        if (DAT_0043b0cc == (LPVOID)0x0) {\n          DAT_0043b0cc = __calloc_base(1,4);\n          FID_conflict__free((void *)0x0);\n          if (DAT_0043b0cc == (LPVOID)0x0) goto LAB_00417243;\n          if (DAT_0043b0d0 != (wchar_t **)0x0) goto LAB_004172a8;\n        }\n        DAT_0043b0d0 = (wchar_t **)__calloc_base(1,4);\n        FID_conflict__free((void *)0x0);\n      }\n      else {\n        ppwVar5 = common_get_or_create_environment_nolock<wchar_t>();\n        if (ppwVar5 == (wchar_t **)0x0) goto LAB_00417238;\n      }\n      if (DAT_0043b0d0 == (wchar_t **)0x0) goto LAB_00417243;\n    }\nLAB_004172a8:\n    ppwVar5 = DAT_0043b0d0;\n    uVar9 = (int)pwVar4 - (int)param_1 >> 1;\n    uVar6 = find_in_environment_nolock<wchar_t>(param_1,uVar9);\n    if ((-1 < (int)uVar6) && (*ppwVar5 != (wchar_t *)0x0)) {\n      FID_conflict__free(ppwVar5[uVar6]);\n      if (bVar12) {\n        for (; ppwVar5[uVar6] != (wchar_t *)0x0; uVar6 = uVar6 + 1) {\n          ppwVar5[uVar6] = ppwVar5[uVar6 + 1];\n        }\n        ppwVar5 = (wchar_t **)FUN_00419319(ppwVar5,uVar6,4);\n        FID_conflict__free((void *)0x0);\n        if (ppwVar5 != (wchar_t **)0x0) {\nLAB_0041735c:\n          DAT_0043b0d0 = ppwVar5;\n        }\n      }\n      else {\n        ppwVar5[uVar6] = param_1;\n        pwVar11 = (wchar_t *)0x0;\n      }\n      if (param_2 != 0) {\n        pwVar4 = param_1;\n        do {\n          wVar2 = *pwVar4;\n          pwVar4 = pwVar4 + 1;\n        } while (wVar2 != L'\\0');\n        uVar6 = ((int)pwVar4 - (int)(param_1 + 1) >> 1) + 2;\n        pwVar4 = (wchar_t *)__calloc_base(uVar6,2);\n        if (pwVar4 != (wchar_t *)0x0) {\n          eVar7 = _wcscpy_s(pwVar4,uVar6,param_1);\n          if (eVar7 != 0) {\n                    /* WARNING: Subroutine does not return */\n            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n          }\n          (pwVar4 + uVar9 + 1)[-1] = L'\\0';\n          BVar8 = SetEnvironmentVariableW\n                            (pwVar4,(LPCWSTR)(~-(uint)bVar12 & (uint)(pwVar4 + uVar9 + 1)));\n          if (BVar8 == 0) {\n            piVar3 = __errno();\n            iVar10 = -1;\n            *piVar3 = 0x2a;\n          }\n        }\n        FID_conflict__free(pwVar4);\n      }\n      goto LAB_00417246;\n    }\n    if (bVar12) goto LAB_00417246;\n    uVar1 = -uVar6 + 2;\n    if ((-uVar6 <= uVar1) && (uVar1 < 0x3fffffff)) {\n      ppwVar5 = (wchar_t **)FUN_00419319(ppwVar5,uVar1,4);\n      FID_conflict__free((void *)0x0);\n      if (ppwVar5 != (wchar_t **)0x0) {\n        ppwVar5[-uVar6] = param_1;\n        ppwVar5[1 - uVar6] = (wchar_t *)0x0;\n        pwVar11 = (wchar_t *)0x0;\n        goto LAB_0041735c;\n      }\n    }\n  }\nLAB_00417243:\n  iVar10 = -1;\nLAB_00417246:\n  FID_conflict__free(pwVar11);\n  return iVar10;\n}\n\n"
    },
    {
      "name": "copy_environment<char>",
      "entry": "004173f1",
      "c": "\n/* Library Function - Single Match\n    char * * __cdecl copy_environment<char>(char * * const)\n   \n   Library: Visual Studio 2015 Release */\n\nchar ** __cdecl copy_environment<char>(char **param_1)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char **ppcVar3;\n  LPVOID pvVar4;\n  errno_t eVar5;\n  int iVar6;\n  char *pcVar7;\n  \n  if (param_1 == (char **)0x0) {\n    ppcVar3 = (char **)0x0;\n  }\n  else {\n    iVar6 = 0;\n    pcVar2 = *param_1;\n    ppcVar3 = param_1;\n    while (pcVar2 != (char *)0x0) {\n      ppcVar3 = ppcVar3 + 1;\n      iVar6 = iVar6 + 1;\n      pcVar2 = *ppcVar3;\n    }\n    ppcVar3 = (char **)__calloc_base(iVar6 + 1,4);\n    if (ppcVar3 == (char **)0x0) {\nLAB_00417490:\n                    /* WARNING: Subroutine does not return */\n      _abort();\n    }\n    if (*param_1 != (char *)0x0) {\n      iVar6 = (int)ppcVar3 - (int)param_1;\n      do {\n        pcVar7 = *param_1;\n        pcVar2 = pcVar7 + 1;\n        do {\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + 1;\n        } while (cVar1 != '\\0');\n        pvVar4 = __calloc_base((uint)(pcVar7 + (1 - (int)pcVar2)),1);\n        *(LPVOID *)(iVar6 + (int)param_1) = pvVar4;\n        FID_conflict__free((void *)0x0);\n        if (*(int *)(iVar6 + (int)param_1) == 0) goto LAB_00417490;\n        eVar5 = _strcpy_s(*(char **)(iVar6 + (int)param_1),(rsize_t)(pcVar7 + (1 - (int)pcVar2)),\n                          *param_1);\n        if (eVar5 != 0) {\n                    /* WARNING: Subroutine does not return */\n          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        param_1 = param_1 + 1;\n      } while (*param_1 != (char *)0x0);\n    }\n    FID_conflict__free((void *)0x0);\n  }\n  return ppcVar3;\n}\n\n"
    },
    {
      "name": "copy_environment<wchar_t>",
      "entry": "004174a2",
      "c": "\n/* Library Function - Single Match\n    wchar_t * * __cdecl copy_environment<wchar_t>(wchar_t * * const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t ** __cdecl copy_environment<wchar_t>(wchar_t **param_1)\n\n{\n  uint _SizeInWords;\n  wchar_t wVar1;\n  wchar_t *pwVar2;\n  wchar_t **ppwVar3;\n  LPVOID pvVar4;\n  errno_t eVar5;\n  int iVar6;\n  wchar_t *pwVar7;\n  \n  if (param_1 == (wchar_t **)0x0) {\n    ppwVar3 = (wchar_t **)0x0;\n  }\n  else {\n    iVar6 = 0;\n    pwVar2 = *param_1;\n    ppwVar3 = param_1;\n    while (pwVar2 != (wchar_t *)0x0) {\n      ppwVar3 = ppwVar3 + 1;\n      iVar6 = iVar6 + 1;\n      pwVar2 = *ppwVar3;\n    }\n    ppwVar3 = (wchar_t **)__calloc_base(iVar6 + 1,4);\n    if (ppwVar3 == (wchar_t **)0x0) {\nLAB_0041754e:\n                    /* WARNING: Subroutine does not return */\n      _abort();\n    }\n    if (*param_1 != (wchar_t *)0x0) {\n      iVar6 = (int)ppwVar3 - (int)param_1;\n      do {\n        pwVar7 = *param_1;\n        pwVar2 = pwVar7 + 1;\n        do {\n          wVar1 = *pwVar7;\n          pwVar7 = pwVar7 + 1;\n        } while (wVar1 != L'\\0');\n        _SizeInWords = ((int)pwVar7 - (int)pwVar2 >> 1) + 1;\n        pvVar4 = __calloc_base(_SizeInWords,2);\n        *(LPVOID *)(iVar6 + (int)param_1) = pvVar4;\n        FID_conflict__free((void *)0x0);\n        if (*(int *)(iVar6 + (int)param_1) == 0) goto LAB_0041754e;\n        eVar5 = _wcscpy_s(*(wchar_t **)(iVar6 + (int)param_1),_SizeInWords,*param_1);\n        if (eVar5 != 0) {\n                    /* WARNING: Subroutine does not return */\n          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        param_1 = param_1 + 1;\n      } while (*param_1 != (wchar_t *)0x0);\n    }\n    FID_conflict__free((void *)0x0);\n  }\n  return ppwVar3;\n}\n\n"
    },
    {
      "name": "find_in_environment_nolock<char>",
      "entry": "00417560",
      "c": "\n/* Library Function - Single Match\n    int __cdecl find_in_environment_nolock<char>(char const * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl find_in_environment_nolock<char>(char *param_1,uint param_2)\n\n{\n  int *piVar1;\n  int iVar2;\n  int *piVar3;\n  \n  piVar1 = DAT_0043b0cc;\n  iVar2 = *DAT_0043b0cc;\n  piVar3 = DAT_0043b0cc;\n  while( true ) {\n    if (iVar2 == 0) {\n      return -((int)piVar3 - (int)piVar1 >> 2);\n    }\n    iVar2 = __strnicoll(param_1,(char *)*piVar3,param_2);\n    if ((iVar2 == 0) &&\n       ((*(char *)(param_2 + *piVar3) == '=' || (*(char *)(param_2 + *piVar3) == '\\0')))) break;\n    piVar3 = piVar3 + 1;\n    iVar2 = *piVar3;\n  }\n  return (int)piVar3 - (int)piVar1 >> 2;\n}\n\n"
    },
    {
      "name": "find_in_environment_nolock<wchar_t>",
      "entry": "004175b4",
      "c": "\n/* Library Function - Single Match\n    int __cdecl find_in_environment_nolock<wchar_t>(wchar_t const * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl find_in_environment_nolock<wchar_t>(wchar_t *param_1,uint param_2)\n\n{\n  short sVar1;\n  int *piVar2;\n  int iVar3;\n  int *piVar4;\n  \n  piVar2 = DAT_0043b0d0;\n  iVar3 = *DAT_0043b0d0;\n  piVar4 = DAT_0043b0d0;\n  while( true ) {\n    if (iVar3 == 0) {\n      return -((int)piVar4 - (int)piVar2 >> 2);\n    }\n    iVar3 = __wcsnicoll(param_1,(wchar_t *)*piVar4,param_2);\n    if ((iVar3 == 0) && ((sVar1 = *(short *)(*piVar4 + param_2 * 2), sVar1 == 0x3d || (sVar1 == 0)))\n       ) break;\n    piVar4 = piVar4 + 1;\n    iVar3 = *piVar4;\n  }\n  return (int)piVar4 - (int)piVar2 >> 2;\n}\n\n"
    },
    {
      "name": "FUN_0041760b",
      "entry": "0041760b",
      "c": "\nvoid __cdecl FUN_0041760b(char *param_1,int param_2)\n\n{\n  common_set_variable_in_environment_nolock<char>(param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00417616",
      "entry": "00417616",
      "c": "\nvoid __cdecl FUN_00417616(wchar_t *param_1,int param_2)\n\n{\n  common_set_variable_in_environment_nolock<wchar_t>(param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "common_xtox<unsigned_long,wchar_t>",
      "entry": "00417621",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_xtox<unsigned long,wchar_t>(unsigned long,wchar_t * const,unsigned\n   int,unsigned int,bool)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_xtox<unsigned_long,wchar_t>\n          (ulong param_1,wchar_t *param_2,uint param_3,uint param_4,bool param_5)\n\n{\n  short sVar1;\n  wchar_t *pwVar2;\n  wchar_t wVar3;\n  int *piVar4;\n  int iVar5;\n  uint uVar6;\n  wchar_t *pwVar7;\n  wchar_t *pwVar8;\n  \n  pwVar7 = param_2;\n  if (param_5) {\n    *param_2 = L'-';\n    pwVar7 = param_2 + 1;\n    param_1 = -param_1;\n  }\n  uVar6 = (uint)param_5;\n  pwVar2 = pwVar7;\n  do {\n    pwVar8 = pwVar2;\n    sVar1 = (short)(param_1 % param_4);\n    wVar3 = sVar1 + L'W';\n    if (param_1 % param_4 < 10) {\n      wVar3 = sVar1 + L'0';\n    }\n    *pwVar8 = wVar3;\n    uVar6 = uVar6 + 1;\n  } while ((param_1 / param_4 != 0) &&\n          (param_1 = param_1 / param_4, pwVar2 = pwVar8 + 1, uVar6 < param_3));\n  if (uVar6 < param_3) {\n    pwVar8[1] = L'\\0';\n    do {\n      wVar3 = *pwVar8;\n      *pwVar8 = *pwVar7;\n      pwVar8 = pwVar8 + -1;\n      *pwVar7 = wVar3;\n      pwVar7 = pwVar7 + 1;\n    } while (pwVar7 < pwVar8);\n    iVar5 = 0;\n  }\n  else {\n    *param_2 = L'\\0';\n    piVar4 = __errno();\n    iVar5 = 0x22;\n    *piVar4 = 0x22;\n    FUN_00412362();\n  }\n  return iVar5;\n}\n\n"
    },
    {
      "name": "common_xtox_s<unsigned_long,wchar_t>",
      "entry": "004176af",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_xtox_s<unsigned long,wchar_t>(unsigned long,wchar_t * const,unsigned\n   int,unsigned int,bool)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_xtox_s<unsigned_long,wchar_t>\n          (ulong param_1,wchar_t *param_2,uint param_3,uint param_4,bool param_5)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if ((param_2 != (wchar_t *)0x0) && (param_3 != 0)) {\n    *param_2 = L'\\0';\n    if (param_3 <= param_5 + 1) {\n      piVar1 = __errno();\n      iVar2 = 0x22;\n      goto LAB_004176c3;\n    }\n    if (param_4 - 2 < 0x23) {\n      iVar2 = common_xtox<unsigned_long,wchar_t>(param_1,param_2,param_3,param_4,param_5);\n      return iVar2;\n    }\n  }\n  piVar1 = __errno();\n  iVar2 = 0x16;\nLAB_004176c3:\n  *piVar1 = iVar2;\n  FUN_00412362();\n  return iVar2;\n}\n\n"
    },
    {
      "name": "__ultow_s",
      "entry": "0041770e",
      "c": "\n/* Library Function - Single Match\n    __ultow_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl __ultow_s(ulong _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix)\n\n{\n  int iVar1;\n  \n  iVar1 = common_xtox_s<unsigned_long,wchar_t>(_Val,_DstBuf,_SizeInWords,_Radix,false);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "common_dupenv_s<wchar_t>",
      "entry": "0041772b",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    int __cdecl common_dupenv_s<wchar_t>(wchar_t * * const,unsigned int * const,wchar_t const *\n   const,int,char const * const,int)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nint __cdecl\ncommon_dupenv_s<wchar_t>\n          (wchar_t **param_1,uint *param_2,wchar_t *param_3,int param_4,char *param_5,int param_6)\n\n{\n  int iVar1;\n  \n  ___acrt_lock(0xb);\n  iVar1 = common_dupenv_s_nolock<wchar_t>(param_1,param_2,param_3,param_4,param_5,param_6);\n  FUN_0041777d();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0041777d",
      "entry": "0041777d",
      "c": "\nvoid FUN_0041777d(void)\n\n{\n  ___acrt_unlock(0xb);\n  return;\n}\n\n"
    },
    {
      "name": "common_dupenv_s_nolock<wchar_t>",
      "entry": "00417786",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_dupenv_s_nolock<wchar_t>(wchar_t * * const,unsigned int * const,wchar_t const\n   * const,int,char const * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_dupenv_s_nolock<wchar_t>\n          (wchar_t **param_1,uint *param_2,wchar_t *param_3,int param_4,char *param_5,int param_6)\n\n{\n  uint _SizeInWords;\n  wchar_t wVar1;\n  int *piVar2;\n  wchar_t *_Src;\n  wchar_t *pwVar3;\n  errno_t eVar4;\n  \n  if (param_1 != (wchar_t **)0x0) {\n    *param_1 = (wchar_t *)0x0;\n    if (param_2 != (uint *)0x0) {\n      *param_2 = 0;\n    }\n    if (param_3 != (wchar_t *)0x0) {\n      _Src = common_getenv_nolock<wchar_t>(param_3);\n      if (_Src != (wchar_t *)0x0) {\n        pwVar3 = _Src;\n        do {\n          wVar1 = *pwVar3;\n          pwVar3 = pwVar3 + 1;\n        } while (wVar1 != L'\\0');\n        _SizeInWords = ((int)pwVar3 - (int)(_Src + 1) >> 1) + 1;\n        pwVar3 = (wchar_t *)FUN_0040e228(_SizeInWords,2);\n        *param_1 = pwVar3;\n        if (pwVar3 == (wchar_t *)0x0) {\n          piVar2 = __errno();\n          *piVar2 = 0xc;\n          return 0xc;\n        }\n        eVar4 = _wcscpy_s(pwVar3,_SizeInWords,_Src);\n        if (eVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        if (param_2 != (uint *)0x0) {\n          *param_2 = _SizeInWords;\n        }\n      }\n      return 0;\n    }\n  }\n  piVar2 = __errno();\n  *piVar2 = 0x16;\n  FUN_00412362();\n  return 0x16;\n}\n\n"
    },
    {
      "name": "common_getenv_nolock<char>",
      "entry": "00417834",
      "c": "\n/* Library Function - Single Match\n    char * __cdecl common_getenv_nolock<char>(char const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nchar * __cdecl common_getenv_nolock<char>(char *param_1)\n\n{\n  char cVar1;\n  char **ppcVar2;\n  int iVar3;\n  char *pcVar4;\n  char *pcVar5;\n  uint _MaxCount;\n  \n  ppcVar2 = common_get_or_create_environment_nolock<char>();\n  if ((ppcVar2 != (char **)0x0) && (param_1 != (char *)0x0)) {\n    pcVar5 = param_1;\n    do {\n      cVar1 = *pcVar5;\n      pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    _MaxCount = (int)pcVar5 - (int)(param_1 + 1);\n    for (; *ppcVar2 != (char *)0x0; ppcVar2 = ppcVar2 + 1) {\n      pcVar5 = *ppcVar2;\n      pcVar4 = pcVar5;\n      do {\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n      } while (cVar1 != '\\0');\n      if (((_MaxCount < (uint)((int)pcVar4 - (int)(pcVar5 + 1))) && (pcVar5[_MaxCount] == '=')) &&\n         (iVar3 = __strnicoll(pcVar5,param_1,_MaxCount), iVar3 == 0)) {\n        return *ppcVar2 + _MaxCount + 1;\n      }\n    }\n  }\n  return (char *)0x0;\n}\n\n"
    },
    {
      "name": "common_getenv_nolock<wchar_t>",
      "entry": "004178a4",
      "c": "\n/* Library Function - Single Match\n    wchar_t * __cdecl common_getenv_nolock<wchar_t>(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl common_getenv_nolock<wchar_t>(wchar_t *param_1)\n\n{\n  wchar_t wVar1;\n  wchar_t **ppwVar2;\n  int iVar3;\n  wchar_t *pwVar4;\n  wchar_t *pwVar5;\n  uint _MaxCount;\n  \n  ppwVar2 = common_get_or_create_environment_nolock<wchar_t>();\n  if ((ppwVar2 != (wchar_t **)0x0) && (param_1 != (wchar_t *)0x0)) {\n    pwVar5 = param_1;\n    do {\n      wVar1 = *pwVar5;\n      pwVar5 = pwVar5 + 1;\n    } while (wVar1 != L'\\0');\n    _MaxCount = (int)pwVar5 - (int)(param_1 + 1) >> 1;\n    pwVar5 = *ppwVar2;\n    while (pwVar5 != (wchar_t *)0x0) {\n      pwVar5 = *ppwVar2;\n      pwVar4 = pwVar5;\n      do {\n        wVar1 = *pwVar4;\n        pwVar4 = pwVar4 + 1;\n      } while (wVar1 != L'\\0');\n      if (((_MaxCount < (uint)((int)pwVar4 - (int)(pwVar5 + 1) >> 1)) && (pwVar5[_MaxCount] == L'=')\n          ) && (iVar3 = __wcsnicoll(pwVar5,param_1,_MaxCount), iVar3 == 0)) {\n        return *ppwVar2 + _MaxCount + 1;\n      }\n      ppwVar2 = ppwVar2 + 1;\n      pwVar5 = *ppwVar2;\n    }\n  }\n  return (wchar_t *)0x0;\n}\n\n"
    },
    {
      "name": "common_getenv_s<char>",
      "entry": "0041792e",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    int __cdecl common_getenv_s<char>(unsigned int * const,char * const,unsigned int,char const *\n   const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_getenv_s<char>(uint *param_1,char *param_2,uint param_3,char *param_4)\n\n{\n  int iVar1;\n  \n  ___acrt_lock(0xb);\n  iVar1 = common_getenv_s_nolock<char>(param_1,param_2,param_3,param_4);\n  FUN_0041797a();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0041797a",
      "entry": "0041797a",
      "c": "\nvoid FUN_0041797a(void)\n\n{\n  ___acrt_unlock(0xb);\n  return;\n}\n\n"
    },
    {
      "name": "common_getenv_s_nolock<char>",
      "entry": "00417983",
      "c": "\n/* WARNING: Removing unreachable block (ram,0x004179e6) */\n/* WARNING: Removing unreachable block (ram,0x004179ea) */\n/* WARNING: Removing unreachable block (ram,0x00417a0b) */\n/* WARNING: Removing unreachable block (ram,0x00417a1e) */\n/* Library Function - Single Match\n    int __cdecl common_getenv_s_nolock<char>(unsigned int * const,char * const,unsigned int,char\n   const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_getenv_s_nolock<char>(uint *param_1,char *param_2,uint param_3,char *param_4)\n\n{\n  char *pcVar1;\n  char cVar2;\n  int *piVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  if (param_1 == (uint *)0x0) {\n    piVar3 = __errno();\n    iVar5 = 0x16;\n    *piVar3 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    *param_1 = 0;\n    if (param_3 == 0) {\n      if (param_2 != (char *)0x0) {\n        *param_2 = '\\0';\n      }\n      pcVar4 = common_getenv_nolock<char>(param_4);\n      if (pcVar4 != (char *)0x0) {\n        pcVar1 = pcVar4 + 1;\n        do {\n          cVar2 = *pcVar4;\n          pcVar4 = pcVar4 + 1;\n        } while (cVar2 != '\\0');\n        *param_1 = (uint)(pcVar4 + (1 - (int)pcVar1));\n      }\n      iVar5 = 0;\n    }\n    else {\n      piVar3 = __errno();\n      iVar5 = 0x16;\n      *piVar3 = 0x16;\n      FUN_00412362();\n    }\n  }\n  return iVar5;\n}\n\n"
    },
    {
      "name": "FID_conflict:__dupenv_s",
      "entry": "00417a2b",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    __dupenv_s\n    __wdupenv_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl\nFID_conflict___dupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,wchar_t *_VarName)\n\n{\n  int iVar1;\n  \n  iVar1 = common_dupenv_s<wchar_t>(_Buffer,_BufferSizeInWords,_VarName,1,(char *)0x0,0);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_00417a49",
      "entry": "00417a49",
      "c": "\nvoid __cdecl FUN_00417a49(uint *param_1,char *param_2,uint param_3,char *param_4)\n\n{\n  common_getenv_s<char>(param_1,param_2,param_3,param_4);\n  return;\n}\n\n"
    },
    {
      "name": "_wcscat_s",
      "entry": "00417a54",
      "c": "\n/* Library Function - Single Match\n    _wcscat_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl _wcscat_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)\n\n{\n  wchar_t wVar1;\n  int *piVar2;\n  wchar_t *pwVar3;\n  int iVar4;\n  int iStack_14;\n  \n  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {\n    pwVar3 = _Dst;\n    if (_Src != (wchar_t *)0x0) {\n      do {\n        if (*pwVar3 == L'\\0') break;\n        pwVar3 = pwVar3 + 1;\n        _SizeInWords = _SizeInWords - 1;\n      } while (_SizeInWords != 0);\n      if (_SizeInWords != 0) {\n        iVar4 = (int)_Src - (int)pwVar3;\n        do {\n          wVar1 = *(wchar_t *)(iVar4 + (int)pwVar3);\n          *pwVar3 = wVar1;\n          pwVar3 = pwVar3 + 1;\n          if (wVar1 == L'\\0') break;\n          _SizeInWords = _SizeInWords - 1;\n        } while (_SizeInWords != 0);\n        if (_SizeInWords != 0) {\n          return 0;\n        }\n        *_Dst = L'\\0';\n        piVar2 = __errno();\n        iStack_14 = 0x22;\n        goto LAB_00417a7d;\n      }\n    }\n    *_Dst = L'\\0';\n  }\n  piVar2 = __errno();\n  iStack_14 = 0x16;\nLAB_00417a7d:\n  *piVar2 = iStack_14;\n  FUN_00412362();\n  return iStack_14;\n}\n\n"
    },
    {
      "name": "__waccess_s",
      "entry": "00417ac9",
      "c": "\n/* Library Function - Single Match\n    __waccess_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl __waccess_s(wchar_t *_Filename,int _AccessMode)\n\n{\n  ulong *puVar1;\n  int *piVar2;\n  BOOL BVar3;\n  DWORD DVar4;\n  errno_t eVar5;\n  byte local_2c [36];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (_Filename == (wchar_t *)0x0) {\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n  }\n  else if ((_AccessMode & 0xfffffff9U) == 0) {\n    BVar3 = GetFileAttributesExW(_Filename,GetFileExInfoStandard,local_2c);\n    if (BVar3 == 0) {\n      DVar4 = GetLastError();\n      ___acrt_errno_map_os_error(DVar4);\n    }\n    else {\n      if ((((local_2c[0] & 0x10) != 0) || ((local_2c[0] & 1) == 0)) ||\n         (((uint)_AccessMode >> 1 & 1) == 0)) goto LAB_00417b7a;\n      puVar1 = ___doserrno();\n      *puVar1 = 5;\n      piVar2 = __errno();\n      *piVar2 = 0xd;\n    }\n    __errno();\n  }\n  else {\n    puVar1 = ___doserrno();\n    *puVar1 = 0;\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n  }\nLAB_00417b7a:\n  eVar5 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return eVar5;\n}\n\n"
    },
    {
      "name": "FUN_00417c02",
      "entry": "00417c02",
      "c": "\nvoid FUN_00417c02(void)\n\n{\n  int unaff_EBP;\n  \n  __unlock_file(*(FILE **)(unaff_EBP + -0x24));\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00417c21",
      "entry": "00417c21",
      "c": "\nvoid FUN_00417c21(void)\n\n{\n  ___acrt_unlock(8);\n  return;\n}\n\n"
    },
    {
      "name": "common_tcsncpy_s<wchar_t>",
      "entry": "00417c2a",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_tcsncpy_s<wchar_t>(wchar_t * const,unsigned int,wchar_t const *\n   const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_tcsncpy_s<wchar_t>(wchar_t *param_1,uint param_2,wchar_t *param_3,uint param_4)\n\n{\n  wchar_t wVar1;\n  int *piVar2;\n  uint uVar3;\n  uint uVar4;\n  wchar_t *pwVar5;\n  int iVar6;\n  \n  if (param_4 == 0) {\n    if (param_1 == (wchar_t *)0x0) {\n      if (param_2 == 0) {\n        return 0;\n      }\n    }\n    else {\nLAB_00417c4c:\n      if (param_2 != 0) {\n        if (param_4 == 0) {\n          *param_1 = L'\\0';\n          return 0;\n        }\n        if (param_3 != (wchar_t *)0x0) {\n          uVar3 = param_4;\n          uVar4 = param_2;\n          pwVar5 = param_1;\n          if (param_4 == 0xffffffff) {\n            do {\n              wVar1 = *(wchar_t *)(((int)param_3 - (int)param_1) + (int)pwVar5);\n              *pwVar5 = wVar1;\n              pwVar5 = pwVar5 + 1;\n              if (wVar1 == L'\\0') break;\n              uVar4 = uVar4 - 1;\n            } while (uVar4 != 0);\n          }\n          else {\n            do {\n              wVar1 = *(wchar_t *)(((int)param_3 - (int)param_1) + (int)pwVar5);\n              *pwVar5 = wVar1;\n              pwVar5 = pwVar5 + 1;\n              if ((wVar1 == L'\\0') || (uVar4 = uVar4 - 1, uVar4 == 0)) break;\n              uVar3 = uVar3 - 1;\n            } while (uVar3 != 0);\n            if (uVar3 == 0) {\n              *pwVar5 = L'\\0';\n            }\n          }\n          if (uVar4 != 0) {\n            return 0;\n          }\n          if (param_4 == 0xffffffff) {\n            param_1[param_2 - 1] = L'\\0';\n            return 0x50;\n          }\n          *param_1 = L'\\0';\n          piVar2 = __errno();\n          iVar6 = 0x22;\n          goto LAB_00417c71;\n        }\n        *param_1 = L'\\0';\n      }\n    }\n  }\n  else if (param_1 != (wchar_t *)0x0) goto LAB_00417c4c;\n  piVar2 = __errno();\n  iVar6 = 0x16;\nLAB_00417c71:\n  *piVar2 = iVar6;\n  FUN_00412362();\n  return iVar6;\n}\n\n"
    },
    {
      "name": "FUN_00417cf7",
      "entry": "00417cf7",
      "c": "\nvoid __cdecl FUN_00417cf7(wchar_t *param_1,uint param_2,wchar_t *param_3,uint param_4)\n\n{\n  common_tcsncpy_s<wchar_t>(param_1,param_2,param_3,param_4);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_00417d02",
      "entry": "00417d02",
      "c": "\nuint __cdecl FUN_00417d02(uint param_1,uint param_2)\n\n{\n  if (param_1 < param_2) {\n    return 0xffffffff;\n  }\n  return (uint)(param_2 < param_1);\n}\n\n"
    },
    {
      "name": "common_expand_argv_wildcards<wchar_t>",
      "entry": "00417d1a",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_expand_argv_wildcards<wchar_t>(wchar_t * * const,wchar_t * * * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_expand_argv_wildcards<wchar_t>(wchar_t **param_1,wchar_t ***param_2)\n\n{\n  short *psVar1;\n  wchar_t **ppwVar2;\n  short sVar3;\n  undefined4 *puVar4;\n  int *piVar5;\n  wchar_t *pwVar6;\n  wchar_t **ppwVar7;\n  int iVar8;\n  short *psVar9;\n  undefined4 *puVar10;\n  uint uVar11;\n  undefined4 *puVar12;\n  undefined4 *local_2c;\n  undefined4 *local_28;\n  undefined4 local_24;\n  undefined4 local_20;\n  wchar_t **local_1c;\n  uint local_18;\n  uint local_14;\n  int local_10;\n  undefined2 local_c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_2 == (wchar_t ***)0x0) {\n    piVar5 = __errno();\n    *piVar5 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    *param_2 = (wchar_t **)0x0;\n    local_20 = 0;\n    local_2c = (undefined4 *)0x0;\n    local_28 = (undefined4 *)0x0;\n    local_24 = 0;\n    pwVar6 = *param_1;\n    puVar12 = local_2c;\n    puVar4 = local_28;\n    while (local_2c = puVar12, local_28 = puVar4, pwVar6 != (wchar_t *)0x0) {\n      local_10 = 0x3f002a;\n      local_c = 0;\n      pwVar6 = _wcspbrk(*param_1,(wchar_t *)&local_10);\n      if (pwVar6 == (wchar_t *)0x0) {\n        iVar8 = copy_and_add_argument_to_buffer<wchar_t>\n                          (*param_1,(wchar_t *)0x0,0,(argument_list<wchar_t> *)&local_2c);\n      }\n      else {\n        iVar8 = expand_argument_wildcards<wchar_t>\n                          (*param_1,pwVar6,(argument_list<wchar_t> *)&local_2c);\n      }\n      if (iVar8 != 0) goto LAB_00417ebf;\n      param_1 = param_1 + 1;\n      puVar12 = local_2c;\n      puVar4 = local_28;\n      pwVar6 = *param_1;\n    }\n    local_18 = 0;\n    local_14 = 0;\n    local_1c = (wchar_t **)(((int)puVar4 - (int)puVar12 >> 2) + 1);\n    uVar11 = ~-(uint)(puVar4 < puVar12) & ((int)puVar4 - (int)puVar12) + 3U >> 2;\n    if (uVar11 != 0) {\n      local_18 = 0;\n      puVar10 = puVar12;\n      do {\n        psVar9 = (short *)*puVar10;\n        psVar1 = psVar9 + 1;\n        do {\n          sVar3 = *psVar9;\n          psVar9 = psVar9 + 1;\n        } while (sVar3 != (short)local_20);\n        puVar10 = puVar10 + 1;\n        local_18 = local_18 + 1 + ((int)psVar9 - (int)psVar1 >> 1);\n        local_14 = local_14 + 1;\n      } while (local_14 != uVar11);\n    }\n    ppwVar7 = (wchar_t **)___acrt_allocate_buffer_for_argv((uint)local_1c,local_18,2);\n    if (ppwVar7 != (wchar_t **)0x0) {\n      ppwVar2 = ppwVar7 + (int)local_1c;\n      local_1c = ppwVar2;\n      if (puVar12 != puVar4) {\n        local_10 = (int)ppwVar7 - (int)puVar12;\n        do {\n          psVar9 = (short *)*puVar12;\n          psVar1 = psVar9 + 1;\n          do {\n            sVar3 = *psVar9;\n            psVar9 = psVar9 + 1;\n          } while (sVar3 != (short)local_20);\n          local_14 = ((int)psVar9 - (int)psVar1 >> 1) + 1;\n          iVar8 = FUN_00417cf7((wchar_t *)local_1c,local_18 - ((int)local_1c - (int)ppwVar2 >> 1),\n                               (wchar_t *)*puVar12,local_14);\n          if (iVar8 != 0) {\n                    /* WARNING: Subroutine does not return */\n            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n          }\n          *(wchar_t ***)(local_10 + (int)puVar12) = local_1c;\n          puVar12 = puVar12 + 1;\n          local_1c = (wchar_t **)((int)local_1c + local_14 * 2);\n        } while (puVar12 != puVar4);\n      }\n      *param_2 = ppwVar7;\n    }\n    FID_conflict__free((void *)0x0);\nLAB_00417ebf:\n    _anon_FD16DE3C::argument_list<wchar_t>::~argument_list<wchar_t>\n              ((argument_list<wchar_t> *)&local_2c);\n  }\n  iVar8 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar8;\n}\n\n"
    },
    {
      "name": "copy_and_add_argument_to_buffer<wchar_t>",
      "entry": "00417ee7",
      "c": "\n/* Library Function - Single Match\n    int __cdecl copy_and_add_argument_to_buffer<wchar_t>(wchar_t const * const,wchar_t const *\n   const,unsigned int,class `anonymous namespace'::argument_list<wchar_t> &)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncopy_and_add_argument_to_buffer<wchar_t>\n          (wchar_t *param_1,wchar_t *param_2,uint param_3,argument_list<wchar_t> *param_4)\n\n{\n  wchar_t wVar1;\n  wchar_t *pwVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  pwVar2 = param_1;\n  do {\n    wVar1 = *pwVar2;\n    pwVar2 = pwVar2 + 1;\n  } while (wVar1 != L'\\0');\n  uVar4 = ((int)pwVar2 - (int)(param_1 + 1) >> 1) + 1;\n  if (-param_3 - 1 < uVar4) {\n    iVar3 = 0xc;\n  }\n  else {\n    uVar5 = param_3 + 1 + uVar4;\n    pwVar2 = (wchar_t *)__calloc_base(uVar5,2);\n    if (param_3 != 0) {\n      iVar3 = FUN_00417cf7(pwVar2,uVar5,param_2,param_3);\n      if (iVar3 != 0) goto LAB_00417f78;\n    }\n    iVar3 = FUN_00417cf7(pwVar2 + param_3,uVar5 - param_3,param_1,uVar4);\n    if (iVar3 != 0) {\nLAB_00417f78:\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    iVar3 = append(param_4,pwVar2);\n    FID_conflict__free((void *)0x0);\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "expand_argument_wildcards<wchar_t>",
      "entry": "00417f85",
      "c": "\n/* Library Function - Single Match\n    int __cdecl expand_argument_wildcards<wchar_t>(wchar_t * const,wchar_t * const,class `anonymous\n   namespace'::argument_list<wchar_t> &)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nexpand_argument_wildcards<wchar_t>\n          (wchar_t *param_1,wchar_t *param_2,argument_list<wchar_t> *param_3)\n\n{\n  wchar_t wVar1;\n  byte bVar2;\n  HANDLE hFindFile;\n  int iVar3;\n  int iVar4;\n  BOOL BVar5;\n  _WIN32_FIND_DATAW local_258;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  for (; (((param_2 != param_1 && (wVar1 = *param_2, wVar1 != L'/')) && (wVar1 != L'\\\\')) &&\n         (wVar1 != L':')); param_2 = param_2 + -1) {\n  }\n  wVar1 = *param_2;\n  if ((wVar1 == L':') && (param_2 != param_1 + 1)) {\n    copy_and_add_argument_to_buffer<wchar_t>(param_1,(wchar_t *)0x0,0,param_3);\n  }\n  else {\n    if ((wVar1 == L'/') || ((wVar1 == L'\\\\' || (wVar1 == L':')))) {\n      bVar2 = 1;\n    }\n    else {\n      bVar2 = 0;\n    }\n    _memset(&local_258,0,0x250);\n    hFindFile = FindFirstFileExW(param_1,FindExInfoStandard,&local_258,FindExSearchNameMatch,\n                                 (LPVOID)0x0,0);\n    if (hFindFile == (HANDLE)0xffffffff) {\n      copy_and_add_argument_to_buffer<wchar_t>(param_1,(wchar_t *)0x0,0,param_3);\n    }\n    else {\n      iVar3 = *(int *)(param_3 + 4) - *(int *)param_3 >> 2;\n      do {\n        if (((local_258.cFileName[0] != L'.') ||\n            ((local_258.cFileName[1] != L'\\0' &&\n             ((local_258.cFileName[1] != L'.' || (local_258.cFileName[2] != L'\\0')))))) &&\n           (iVar4 = copy_and_add_argument_to_buffer<wchar_t>\n                              (local_258.cFileName,param_1,\n                               -(uint)bVar2 & ((int)param_2 - (int)param_1 >> 1) + 1U,param_3),\n           iVar4 != 0)) goto LAB_00418076;\n        BVar5 = FindNextFileW(hFindFile,&local_258);\n      } while (BVar5 != 0);\n      iVar4 = *(int *)(param_3 + 4) - *(int *)param_3 >> 2;\n      if (iVar3 != iVar4) {\n        _qsort((void *)(*(int *)param_3 + iVar3 * 4),iVar4 - iVar3,4,FUN_00417d02);\n      }\n    }\nLAB_00418076:\n    if (hFindFile != (HANDLE)0xffffffff) {\n      FindClose(hFindFile);\n    }\n  }\n  iVar3 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "~argument_list<wchar_t>",
      "entry": "0041813b",
      "c": "\n/* Library Function - Single Match\n    public: __thiscall `anonymous namespace'::argument_list<wchar_t>::~argument_list<wchar_t>(void)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n_anon_FD16DE3C::argument_list<wchar_t>::~argument_list<wchar_t>(argument_list<wchar_t> *this)\n\n{\n  undefined4 *puVar1;\n  \n  for (puVar1 = *(undefined4 **)this; puVar1 != *(undefined4 **)(this + 4); puVar1 = puVar1 + 1) {\n    FID_conflict__free((void *)*puVar1);\n  }\n  FID_conflict__free(*(void **)this);\n  return;\n}\n\n"
    },
    {
      "name": "append",
      "entry": "00418160",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    public: int __thiscall `anonymous namespace'::argument_list<wchar_t>::append(wchar_t * const)\n    public: int __thiscall `anonymous namespace'::argument_list<wchar_t>::append(wchar_t * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __thiscall append(void *this,void *param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = expand_if_necessary((int *)this);\n  if (iVar1 == 0) {\n    **(undefined4 **)((int)this + 4) = param_1;\n    *(int *)((int)this + 4) = *(int *)((int)this + 4) + 4;\n    iVar1 = 0;\n  }\n  else {\n    FID_conflict__free(param_1);\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "expand_if_necessary",
      "entry": "00418195",
      "c": "\n/* Library Function - Multiple Matches With Same Base Name\n    private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)\n    private: int __thiscall `anonymous namespace'::argument_list<char>::expand_if_necessary(void)\n    private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)\n    private: int __thiscall `anonymous namespace'::argument_list<wchar_t>::expand_if_necessary(void)\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __fastcall expand_if_necessary(int *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  LPVOID pvVar3;\n  uint uVar4;\n  \n  if (param_1[1] == param_1[2]) {\n    if (*param_1 == 0) {\n      pvVar3 = __calloc_base(4,4);\n      *param_1 = (int)pvVar3;\n      FID_conflict__free((void *)0x0);\n      iVar1 = *param_1;\n      if (iVar1 != 0) {\n        param_1[1] = iVar1;\n        param_1[2] = iVar1 + 0x10;\n        goto LAB_004181a3;\n      }\n    }\n    else {\n      uVar4 = param_1[2] - *param_1 >> 2;\n      if (uVar4 < 0x80000000) {\n        pvVar3 = FUN_00419319((LPCVOID)*param_1,uVar4 * 2,4);\n        if (pvVar3 == (LPVOID)0x0) {\n          uVar2 = 0xc;\n        }\n        else {\n          *param_1 = (int)pvVar3;\n          param_1[1] = (int)((int)pvVar3 + uVar4 * 4);\n          param_1[2] = (int)((int)pvVar3 + uVar4 * 8);\n          uVar2 = 0;\n        }\n        FID_conflict__free((void *)0x0);\n        return uVar2;\n      }\n    }\n    uVar2 = 0xc;\n  }\n  else {\nLAB_004181a3:\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n"
    },
    {
      "name": "FUN_0041821c",
      "entry": "0041821c",
      "c": "\nvoid __cdecl FUN_0041821c(wchar_t **param_1,wchar_t ***param_2)\n\n{\n  common_expand_argv_wildcards<wchar_t>(param_1,param_2);\n  return;\n}\n\n"
    },
    {
      "name": "operator()<class_<lambda_978dc153c237d78434369da87b74ff60>,class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>&,class_<lambda_4a8533e2866a575feecb8298ce776b0d>_>",
      "entry": "00418227",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    public: void __thiscall __crt_seh_guarded_call<void>::operator()<class\n   <lambda_978dc153c237d78434369da87b74ff60>,class <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> &,class\n   <lambda_4a8533e2866a575feecb8298ce776b0d> >(class <lambda_978dc153c237d78434369da87b74ff60>\n   &&,class <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> &,class\n   <lambda_4a8533e2866a575feecb8298ce776b0d> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_978dc153c237d78434369da87b74ff60>,class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>&,class_<lambda_4a8533e2866a575feecb8298ce776b0d>_>\n          (__crt_seh_guarded_call<void> *this,<lambda_978dc153c237d78434369da87b74ff60> *param_1,\n          <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> *param_2,\n          <lambda_4a8533e2866a575feecb8298ce776b0d> *param_3)\n\n{\n  ___acrt_lock(*(int *)param_1);\n  <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>::operator()(param_2);\n  FUN_0041825e();\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041825e",
      "entry": "0041825e",
      "c": "\nvoid FUN_0041825e(void)\n\n{\n  int unaff_EBP;\n  \n  ___acrt_unlock(**(int **)(unaff_EBP + 0x10));\n  return;\n}\n\n"
    },
    {
      "name": "__acrt_lock_and_call<class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>_>",
      "entry": "0041826a",
      "c": "\n/* Library Function - Single Match\n    void __cdecl __acrt_lock_and_call<class <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> >(enum\n   __acrt_lock_id,class <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> &&)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>_>\n          (__acrt_lock_id param_1,<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> *param_2)\n\n{\n  __acrt_lock_id local_10;\n  __acrt_lock_id local_c;\n  __crt_seh_guarded_call<void> local_5;\n  \n  local_c = param_1;\n  local_10 = param_1;\n  __crt_seh_guarded_call<void>::\n  operator()<class_<lambda_978dc153c237d78434369da87b74ff60>,class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>&,class_<lambda_4a8533e2866a575feecb8298ce776b0d>_>\n            (&local_5,(<lambda_978dc153c237d78434369da87b74ff60> *)&local_10,param_2,\n             (<lambda_4a8533e2866a575feecb8298ce776b0d> *)&local_c);\n  return;\n}\n\n"
    },
    {
      "name": "operator()",
      "entry": "00418292",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    public: void __thiscall <lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>::operator()(void)const \n   \n   Library: Visual Studio 2015 Release */\n\nvoid __thiscall\n<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>::operator()\n          (<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> *this)\n\n{\n  int iVar1;\n  \n  _DAT_0043b544 = *(undefined4 *)(*(int *)(**(int **)this + 0x48) + 4);\n  _DAT_0043b548 = *(undefined4 *)(*(int *)(**(int **)this + 0x48) + 8);\n  _DAT_0043b540 = *(undefined4 *)(*(int *)(**(int **)this + 0x48) + 0x21c);\n  _memcpy_s(&DAT_0043b54c,0xc,(void *)(*(int *)(**(int **)this + 0x48) + 0xc),0xc);\n  _memcpy_s(&DAT_0042d408,0x101,(void *)(*(int *)(**(int **)this + 0x48) + 0x18),0x101);\n  _memcpy_s(&DAT_0042d510,0x100,(void *)(*(int *)(**(int **)this + 0x48) + 0x119),0x100);\n  LOCK();\n  iVar1 = *(int *)PTR_DAT_0042d830;\n  *(int *)PTR_DAT_0042d830 = iVar1 + -1;\n  UNLOCK();\n  if ((iVar1 + -1 == 0) && ((undefined4 *)PTR_DAT_0042d830 != &DAT_0042d610)) {\n    FID_conflict__free(PTR_DAT_0042d830);\n  }\n  PTR_DAT_0042d830 = *(undefined **)(**(int **)this + 0x48);\n  LOCK();\n  **(int **)(**(int **)this + 0x48) = **(int **)(**(int **)this + 0x48) + 1;\n  UNLOCK();\n  return;\n}\n\n"
    },
    {
      "name": "CPtoLocaleName",
      "entry": "00418356",
      "c": "\n/* Library Function - Single Match\n    wchar_t const * __cdecl CPtoLocaleName(int)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl CPtoLocaleName(int param_1)\n\n{\n  if (param_1 == 0x3a4) {\n    return (wchar_t *)PTR_u_ja_JP_00427890;\n  }\n  if (param_1 == 0x3a8) {\n    return (wchar_t *)PTR_u_zh_CN_00427894;\n  }\n  if (param_1 == 0x3b5) {\n    return (wchar_t *)PTR_u_ko_KR_00427898;\n  }\n  if (param_1 != 0x3b6) {\n    return (wchar_t *)0x0;\n  }\n  return (wchar_t *)PTR_u_zh_TW_0042789c;\n}\n\n"
    },
    {
      "name": "getSystemCP",
      "entry": "00418394",
      "c": "\n/* Library Function - Single Match\n    int __cdecl getSystemCP(int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl getSystemCP(int param_1)\n\n{\n  int local_14;\n  int local_10;\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)0x0);\n  DAT_0043b558 = 0;\n  if (param_1 == -2) {\n    DAT_0043b558 = 1;\n    param_1 = GetOEMCP();\n  }\n  else if (param_1 == -3) {\n    DAT_0043b558 = 1;\n    param_1 = GetACP();\n  }\n  else if (param_1 == -4) {\n    DAT_0043b558 = 1;\n    param_1 = *(UINT *)(local_10 + 8);\n  }\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return param_1;\n}\n\n"
    },
    {
      "name": "setSBCS",
      "entry": "00418407",
      "c": "\n/* Library Function - Single Match\n    void __cdecl setSBCS(struct __crt_multibyte_data *)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl setSBCS(__crt_multibyte_data *param_1)\n\n{\n  int iVar1;\n  __crt_multibyte_data *p_Var2;\n  \n  p_Var2 = param_1 + 0x18;\n  _memset(p_Var2,0,0x101);\n  *(undefined4 *)(param_1 + 4) = 0;\n  *(undefined4 *)(param_1 + 8) = 0;\n  *(undefined4 *)(param_1 + 0x21c) = 0;\n  iVar1 = 0x101;\n  *(undefined4 *)(param_1 + 0xc) = 0;\n  *(undefined4 *)(param_1 + 0x10) = 0;\n  *(undefined4 *)(param_1 + 0x14) = 0;\n  do {\n    *p_Var2 = p_Var2[(int)&DAT_0042d610 - (int)param_1];\n    p_Var2 = p_Var2 + 1;\n    iVar1 = iVar1 + -1;\n  } while (iVar1 != 0);\n  p_Var2 = param_1 + 0x119;\n  iVar1 = 0x100;\n  do {\n    *p_Var2 = p_Var2[(int)&DAT_0042d610 - (int)param_1];\n    p_Var2 = p_Var2 + 1;\n    iVar1 = iVar1 + -1;\n  } while (iVar1 != 0);\n  return;\n}\n\n"
    },
    {
      "name": "setSBUpLow",
      "entry": "0041846c",
      "c": "\n/* Library Function - Single Match\n    void __cdecl setSBUpLow(struct __crt_multibyte_data *)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl setSBUpLow(__crt_multibyte_data *param_1)\n\n{\n  byte bVar1;\n  __crt_multibyte_data _Var2;\n  BOOL BVar3;\n  uint uVar4;\n  BYTE *pBVar5;\n  __crt_multibyte_data *p_Var6;\n  _cpinfo local_71c;\n  WORD local_708 [512];\n  __crt_multibyte_data local_308 [256];\n  __crt_multibyte_data local_208 [256];\n  CHAR local_108 [256];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  BVar3 = GetCPInfo(*(UINT *)(param_1 + 4),&local_71c);\n  if (BVar3 == 0) {\n    uVar4 = 0;\n    do {\n      p_Var6 = param_1 + uVar4 + 0x119;\n      if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) + 0x20 < (__crt_multibyte_data *)0x1a) {\n        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);\n        _Var2 = (__crt_multibyte_data)((char)uVar4 + ' ');\nLAB_004185d8:\n        *p_Var6 = _Var2;\n      }\n      else {\n        if (p_Var6 + (-0x61 - (int)(param_1 + 0x119)) < (__crt_multibyte_data *)0x1a) {\n          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);\n          _Var2 = (__crt_multibyte_data)((char)uVar4 + -0x20);\n          goto LAB_004185d8;\n        }\n        *p_Var6 = (__crt_multibyte_data)0x0;\n      }\n      uVar4 = uVar4 + 1;\n    } while (uVar4 < 0x100);\n  }\n  else {\n    uVar4 = 0;\n    do {\n      local_108[uVar4] = (CHAR)uVar4;\n      uVar4 = uVar4 + 1;\n    } while (uVar4 < 0x100);\n    pBVar5 = local_71c.LeadByte;\n    local_108[0] = ' ';\n    while (local_71c.LeadByte[0] != 0) {\n      bVar1 = pBVar5[1];\n      for (uVar4 = (uint)local_71c.LeadByte[0]; (uVar4 <= bVar1 && (uVar4 < 0x100));\n          uVar4 = uVar4 + 1) {\n        local_108[uVar4] = ' ';\n      }\n      pBVar5 = pBVar5 + 2;\n      local_71c.LeadByte[0] = *pBVar5;\n    }\n    ___acrt_GetStringTypeA\n              ((__crt_locale_pointers *)0x0,1,local_108,0x100,local_708,*(UINT *)(param_1 + 4),0);\n    ___acrt_LCMapStringA\n              ((__crt_locale_pointers *)0x0,*(wchar_t **)(param_1 + 0x21c),0x100,local_108,0x100,\n               (char *)local_208,0x100,*(int *)(param_1 + 4),0);\n    ___acrt_LCMapStringA\n              ((__crt_locale_pointers *)0x0,*(wchar_t **)(param_1 + 0x21c),0x200,local_108,0x100,\n               (char *)local_308,0x100,*(int *)(param_1 + 4),0);\n    uVar4 = 0;\n    do {\n      if ((local_708[uVar4] & 1) == 0) {\n        if ((local_708[uVar4] & 2) != 0) {\n          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);\n          _Var2 = local_308[uVar4];\n          goto LAB_0041857f;\n        }\n        param_1[uVar4 + 0x119] = (__crt_multibyte_data)0x0;\n      }\n      else {\n        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);\n        _Var2 = local_208[uVar4];\nLAB_0041857f:\n        param_1[uVar4 + 0x119] = _Var2;\n      }\n      uVar4 = uVar4 + 1;\n    } while (uVar4 < 0x100);\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "setmbcp_internal",
      "entry": "00418600",
      "c": "\n/* Library Function - Single Match\n    int __cdecl setmbcp_internal(int,bool)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl setmbcp_internal(int param_1,bool param_2)\n\n{\n  int iVar1;\n  __crt_multibyte_data *p_Var2;\n  int *piVar3;\n  int iVar4;\n  undefined4 *puVar5;\n  __crt_multibyte_data *p_Var6;\n  __acrt_ptd **local_10 [2];\n  __acrt_ptd *local_8;\n  \n  local_8 = ___acrt_getptd();\n  ___acrt_update_thread_multibyte_data();\n  local_10[0] = (__acrt_ptd **)getSystemCP(param_1);\n  if (local_10[0] == *(__acrt_ptd ***)(*(int *)(local_8 + 0x48) + 4)) {\n    return 0;\n  }\n  p_Var2 = (__crt_multibyte_data *)__malloc_base(0x220);\n  if (p_Var2 != (__crt_multibyte_data *)0x0) {\n    puVar5 = *(undefined4 **)(local_8 + 0x48);\n    p_Var6 = p_Var2;\n    for (iVar4 = 0x88; iVar4 != 0; iVar4 = iVar4 + -1) {\n      *(undefined4 *)p_Var6 = *puVar5;\n      puVar5 = puVar5 + 1;\n      p_Var6 = p_Var6 + 4;\n    }\n    *(undefined4 *)p_Var2 = 0;\n    iVar4 = __setmbcp_nolock((int)local_10[0],p_Var2);\n    if (iVar4 != -1) {\n      if (!param_2) {\n        ___acrt_set_locale_changed();\n      }\n      piVar3 = *(int **)(local_8 + 0x48);\n      LOCK();\n      iVar1 = *piVar3;\n      *piVar3 = *piVar3 + -1;\n      UNLOCK();\n      if ((iVar1 == 1) && (*(undefined4 **)(local_8 + 0x48) != &DAT_0042d610)) {\n        FID_conflict__free(*(void **)(local_8 + 0x48));\n      }\n      *(undefined4 *)p_Var2 = 1;\n      p_Var6 = (__crt_multibyte_data *)0x0;\n      *(__crt_multibyte_data **)(local_8 + 0x48) = p_Var2;\n      if ((((byte)local_8[0x350] & 2) == 0) && (((byte)DAT_0042d30c & 1) == 0)) {\n        local_10[0] = &local_8;\n        __acrt_lock_and_call<class_<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c>_>\n                  (5,(<lambda_ad1ced32f4ac17aa236e5ef05d6b3b7c> *)local_10);\n        if (param_2) {\n          PTR_DAT_0042d304 = PTR_DAT_0042d830;\n        }\n      }\n      goto LAB_00418677;\n    }\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n  }\n  iVar4 = -1;\n  p_Var6 = p_Var2;\nLAB_00418677:\n  FID_conflict__free(p_Var6);\n  return iVar4;\n}\n\n"
    },
    {
      "name": "___acrt_initialize_multibyte",
      "entry": "00418701",
      "c": "\n/* Library Function - Single Match\n    ___acrt_initialize_multibyte\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 ___acrt_initialize_multibyte(void)\n\n{\n  int in_EAX;\n  \n  if (DAT_0043b55c == '\\0') {\n    in_EAX = setmbcp_internal(-3,true);\n    DAT_0043b55c = '\\x01';\n  }\n  return CONCAT31((int3)((uint)in_EAX >> 8),1);\n}\n\n"
    },
    {
      "name": "___acrt_update_thread_multibyte_data",
      "entry": "0041871f",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    ___acrt_update_thread_multibyte_data\n   \n   Library: Visual Studio 2015 Release */\n\nint * ___acrt_update_thread_multibyte_data(void)\n\n{\n  int iVar1;\n  __acrt_ptd *p_Var2;\n  int *_Memory;\n  \n  p_Var2 = ___acrt_getptd();\n  if (((*(uint *)(p_Var2 + 0x350) & DAT_0042d30c) == 0) || (*(int *)(p_Var2 + 0x4c) == 0)) {\n    ___acrt_lock(5);\n    _Memory = *(int **)(p_Var2 + 0x48);\n    if (_Memory != (int *)PTR_DAT_0042d830) {\n      if (_Memory != (int *)0x0) {\n        LOCK();\n        iVar1 = *_Memory;\n        *_Memory = iVar1 + -1;\n        UNLOCK();\n        if ((iVar1 + -1 == 0) && (_Memory != &DAT_0042d610)) {\n          FID_conflict__free(_Memory);\n        }\n      }\n      *(undefined **)(p_Var2 + 0x48) = PTR_DAT_0042d830;\n      _Memory = (int *)PTR_DAT_0042d830;\n      LOCK();\n      *(int *)PTR_DAT_0042d830 = *(int *)PTR_DAT_0042d830 + 1;\n      UNLOCK();\n    }\n    FUN_004187b0();\n  }\n  else {\n    _Memory = *(int **)(p_Var2 + 0x48);\n  }\n  if (_Memory == (int *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    _abort();\n  }\n  return _Memory;\n}\n\n"
    },
    {
      "name": "FUN_004187b0",
      "entry": "004187b0",
      "c": "\nvoid FUN_004187b0(void)\n\n{\n  ___acrt_unlock(5);\n  return;\n}\n\n"
    },
    {
      "name": "__setmbcp_nolock",
      "entry": "004187c1",
      "c": "\n/* Library Function - Single Match\n    __setmbcp_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __setmbcp_nolock(int param_1,__crt_multibyte_data *param_2)\n\n{\n  byte bVar1;\n  undefined2 uVar2;\n  uint uVar3;\n  uint uVar4;\n  BOOL BVar5;\n  BYTE *pBVar6;\n  __crt_multibyte_data *p_Var7;\n  wchar_t *pwVar8;\n  byte *pbVar9;\n  int iVar10;\n  byte *pbVar11;\n  undefined2 *puVar12;\n  uint uVar13;\n  int local_20;\n  _cpinfo local_1c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  uVar3 = getSystemCP(param_1);\n  if (uVar3 != 0) {\n    uVar13 = 0;\n    uVar4 = 0;\n    local_20 = 0;\nLAB_004187ff:\n    if (*(uint *)((int)&DAT_0042d318 + uVar4) != uVar3) goto code_r0x0041880b;\n    _memset(param_2 + 0x18,0,0x101);\n    pbVar9 = (byte *)(local_20 * 0x30 + 0x42d328);\n    do {\n      bVar1 = *pbVar9;\n      pbVar11 = pbVar9;\n      while ((bVar1 != 0 && (bVar1 = pbVar11[1], bVar1 != 0))) {\n        for (uVar4 = (uint)*pbVar11; (uVar4 <= bVar1 && (uVar4 < 0x100)); uVar4 = uVar4 + 1) {\n          param_2[uVar4 + 0x19] =\n               (__crt_multibyte_data)((byte)param_2[uVar4 + 0x19] | (&DAT_0042d314)[uVar13]);\n          bVar1 = pbVar11[1];\n        }\n        pbVar11 = pbVar11 + 2;\n        bVar1 = *pbVar11;\n      }\n      uVar13 = uVar13 + 1;\n      pbVar9 = pbVar9 + 8;\n    } while (uVar13 < 4);\n    *(uint *)(param_2 + 4) = uVar3;\n    *(undefined4 *)(param_2 + 8) = 1;\n    pwVar8 = CPtoLocaleName(uVar3);\n    *(wchar_t **)(param_2 + 0x21c) = pwVar8;\n    p_Var7 = param_2 + 0xc;\n    puVar12 = (undefined2 *)(local_20 * 0x30 + 0x42d31c);\n    iVar10 = 6;\n    do {\n      uVar2 = *puVar12;\n      puVar12 = puVar12 + 1;\n      *(undefined2 *)p_Var7 = uVar2;\n      p_Var7 = p_Var7 + 2;\n      iVar10 = iVar10 + -1;\n    } while (iVar10 != 0);\n    goto LAB_00418998;\n  }\n  setSBCS(param_2);\nLAB_004189a2:\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\ncode_r0x0041880b:\n  local_20 = local_20 + 1;\n  uVar4 = uVar4 + 0x30;\n  if (0xef < uVar4) goto code_r0x00418819;\n  goto LAB_004187ff;\ncode_r0x00418819:\n  if (((uVar3 != 65000) && (uVar3 != 0xfde9)) &&\n     (BVar5 = IsValidCodePage(uVar3 & 0xffff), BVar5 != 0)) {\n    BVar5 = GetCPInfo(uVar3,&local_1c);\n    if (BVar5 == 0) {\n      if (DAT_0043b558 != 0) {\n        setSBCS(param_2);\n      }\n    }\n    else {\n      _memset(param_2 + 0x18,0,0x101);\n      *(uint *)(param_2 + 4) = uVar3;\n      *(undefined4 *)(param_2 + 0x21c) = 0;\n      if (local_1c.MaxCharSize < 2) {\n        *(undefined4 *)(param_2 + 8) = 0;\n      }\n      else {\n        pBVar6 = local_1c.LeadByte;\n        while ((local_1c.LeadByte[0] != 0 && (bVar1 = pBVar6[1], bVar1 != 0))) {\n          for (uVar3 = (uint)*pBVar6; uVar3 <= bVar1; uVar3 = uVar3 + 1) {\n            param_2[uVar3 + 0x19] = (__crt_multibyte_data)((byte)param_2[uVar3 + 0x19] | 4);\n          }\n          pBVar6 = pBVar6 + 2;\n          local_1c.LeadByte[0] = *pBVar6;\n        }\n        p_Var7 = param_2 + 0x1a;\n        iVar10 = 0xfe;\n        do {\n          *p_Var7 = (__crt_multibyte_data)((byte)*p_Var7 | 8);\n          p_Var7 = p_Var7 + 1;\n          iVar10 = iVar10 + -1;\n        } while (iVar10 != 0);\n        pwVar8 = CPtoLocaleName(*(int *)(param_2 + 4));\n        *(wchar_t **)(param_2 + 0x21c) = pwVar8;\n        *(undefined4 *)(param_2 + 8) = 1;\n      }\n      *(undefined4 *)(param_2 + 0xc) = 0;\n      *(undefined4 *)(param_2 + 0x10) = 0;\n      *(undefined4 *)(param_2 + 0x14) = 0;\nLAB_00418998:\n      setSBUpLow(param_2);\n    }\n  }\n  goto LAB_004189a2;\n}\n\n"
    },
    {
      "name": "_memcpy_s",
      "entry": "004189b2",
      "c": "\n/* Library Function - Single Match\n    _memcpy_s\n   \n   Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */\n\nerrno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)\n\n{\n  errno_t eVar1;\n  int *piVar2;\n  \n  if (_MaxCount == 0) {\n    eVar1 = 0;\n  }\n  else if (_Dst == (void *)0x0) {\n    piVar2 = __errno();\n    eVar1 = 0x16;\n    *piVar2 = 0x16;\n    FUN_00412362();\n  }\n  else if ((_Src == (void *)0x0) || (_DstSize < _MaxCount)) {\n    _memset(_Dst,0,_DstSize);\n    if (_Src == (void *)0x0) {\n      piVar2 = __errno();\n      eVar1 = 0x16;\n    }\n    else {\n      if (_MaxCount <= _DstSize) {\n        return 0x16;\n      }\n      piVar2 = __errno();\n      eVar1 = 0x22;\n    }\n    *piVar2 = eVar1;\n    FUN_00412362();\n  }\n  else {\n    FUN_00408c90((uint *)_Dst,(uint *)_Src,_MaxCount);\n    eVar1 = 0;\n  }\n  return eVar1;\n}\n\n"
    },
    {
      "name": "find_end_of_double_null_terminated_sequence",
      "entry": "00418a33",
      "c": "\n/* Library Function - Single Match\n    wchar_t const * __cdecl find_end_of_double_null_terminated_sequence(wchar_t const * const)\n   \n   Library: Visual Studio 2015 Release */\n\nwchar_t * __cdecl find_end_of_double_null_terminated_sequence(wchar_t *param_1)\n\n{\n  wchar_t wVar1;\n  wchar_t *pwVar2;\n  \n  wVar1 = *param_1;\n  while (wVar1 != L'\\0') {\n    pwVar2 = param_1;\n    do {\n      wVar1 = *pwVar2;\n      pwVar2 = pwVar2 + 1;\n    } while (wVar1 != L'\\0');\n    param_1 = param_1 + ((int)pwVar2 - (int)(param_1 + 1) >> 1) + 1;\n    wVar1 = *param_1;\n  }\n  return param_1 + 1;\n}\n\n"
    },
    {
      "name": "___dcrt_get_narrow_environment_from_os",
      "entry": "00418a6a",
      "c": "\n/* Library Function - Single Match\n    ___dcrt_get_narrow_environment_from_os\n   \n   Library: Visual Studio 2015 Release */\n\nLPSTR ___dcrt_get_narrow_environment_from_os(void)\n\n{\n  LPWCH lpWideCharStr;\n  wchar_t *pwVar1;\n  size_t cbMultiByte;\n  LPSTR lpMultiByteStr;\n  int iVar2;\n  LPSTR pCVar3;\n  \n  lpWideCharStr = GetEnvironmentStringsW();\n  if (lpWideCharStr != (LPWCH)0x0) {\n    pwVar1 = find_end_of_double_null_terminated_sequence(lpWideCharStr);\n    iVar2 = (int)pwVar1 - (int)lpWideCharStr >> 1;\n    cbMultiByte = WideCharToMultiByte(0,0,lpWideCharStr,iVar2,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);\n    if (cbMultiByte != 0) {\n      lpMultiByteStr = (LPSTR)__malloc_base(cbMultiByte);\n      if (lpMultiByteStr == (LPSTR)0x0) {\nLAB_00418acc:\n        pCVar3 = (LPSTR)0x0;\n      }\n      else {\n        iVar2 = WideCharToMultiByte(0,0,lpWideCharStr,iVar2,lpMultiByteStr,cbMultiByte,(LPCSTR)0x0,\n                                    (LPBOOL)0x0);\n        if (iVar2 == 0) goto LAB_00418acc;\n        pCVar3 = lpMultiByteStr;\n        lpMultiByteStr = (LPSTR)0x0;\n      }\n      FID_conflict__free(lpMultiByteStr);\n      goto LAB_00418ad9;\n    }\n  }\n  pCVar3 = (LPSTR)0x0;\nLAB_00418ad9:\n  if (lpWideCharStr != (LPWCH)0x0) {\n    FreeEnvironmentStringsW(lpWideCharStr);\n  }\n  return pCVar3;\n}\n\n"
    },
    {
      "name": "___dcrt_get_wide_environment_from_os",
      "entry": "00418aed",
      "c": "\n/* Library Function - Single Match\n    ___dcrt_get_wide_environment_from_os\n   \n   Library: Visual Studio 2015 Release */\n\nuint * ___dcrt_get_wide_environment_from_os(void)\n\n{\n  size_t sVar1;\n  LPWCH pWVar2;\n  wchar_t *pwVar3;\n  uint *puVar4;\n  \n  pWVar2 = GetEnvironmentStringsW();\n  if (pWVar2 == (LPWCH)0x0) {\n    puVar4 = (uint *)0x0;\n  }\n  else {\n    pwVar3 = find_end_of_double_null_terminated_sequence(pWVar2);\n    sVar1 = ((int)pwVar3 - (int)pWVar2 >> 1) * 2;\n    puVar4 = (uint *)__malloc_base(sVar1);\n    if (puVar4 != (uint *)0x0) {\n      FUN_00408c90(puVar4,(uint *)pWVar2,sVar1);\n    }\n    FID_conflict__free((void *)0x0);\n    FreeEnvironmentStringsW(pWVar2);\n  }\n  return puVar4;\n}\n\n"
    },
    {
      "name": "___pctype_func",
      "entry": "00418b3d",
      "c": "\n/* Library Function - Single Match\n    ___pctype_func\n   \n   Library: Visual Studio 2015 Release */\n\nushort * __cdecl ___pctype_func(void)\n\n{\n  __acrt_ptd *p_Var1;\n  undefined4 *local_8;\n  \n  p_Var1 = ___acrt_getptd();\n  local_8 = *(undefined4 **)(p_Var1 + 0x4c);\n  ___acrt_update_locale_info((int)p_Var1,(int *)&local_8);\n  return (ushort *)*local_8;\n}\n\n"
    },
    {
      "name": "____lc_codepage_func",
      "entry": "00418b63",
      "c": "\n/* Library Function - Single Match\n    ____lc_codepage_func\n   \n   Library: Visual Studio 2015 Release */\n\nUINT __cdecl ____lc_codepage_func(void)\n\n{\n  __acrt_ptd *p_Var1;\n  int local_8;\n  \n  p_Var1 = ___acrt_getptd();\n  local_8 = *(int *)(p_Var1 + 0x4c);\n  ___acrt_update_locale_info((int)p_Var1,&local_8);\n  return *(UINT *)(local_8 + 8);\n}\n\n"
    },
    {
      "name": "___acrt_locale_free_monetary",
      "entry": "00418b8a",
      "c": "\n/* Library Function - Single Match\n    ___acrt_locale_free_monetary\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl ___acrt_locale_free_monetary(int param_1)\n\n{\n  if (param_1 != 0) {\n    if (*(undefined **)(param_1 + 0xc) != PTR_DAT_0042d84c) {\n      FID_conflict__free(*(undefined **)(param_1 + 0xc));\n    }\n    if (*(undefined **)(param_1 + 0x10) != PTR_DAT_0042d850) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x10));\n    }\n    if (*(undefined **)(param_1 + 0x14) != PTR_DAT_0042d854) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x14));\n    }\n    if (*(undefined **)(param_1 + 0x18) != PTR_DAT_0042d858) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x18));\n    }\n    if (*(undefined **)(param_1 + 0x1c) != PTR_DAT_0042d85c) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x1c));\n    }\n    if (*(undefined **)(param_1 + 0x20) != PTR_DAT_0042d860) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x20));\n    }\n    if (*(undefined **)(param_1 + 0x24) != PTR_DAT_0042d864) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x24));\n    }\n    if (*(undefined **)(param_1 + 0x38) != PTR_DAT_0042d878) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x38));\n    }\n    if (*(undefined **)(param_1 + 0x3c) != PTR_DAT_0042d87c) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x3c));\n    }\n    if (*(undefined **)(param_1 + 0x40) != PTR_DAT_0042d880) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x40));\n    }\n    if (*(undefined **)(param_1 + 0x44) != PTR_DAT_0042d884) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x44));\n    }\n    if (*(undefined **)(param_1 + 0x48) != PTR_DAT_0042d888) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x48));\n    }\n    if (*(undefined **)(param_1 + 0x4c) != PTR_DAT_0042d88c) {\n      FID_conflict__free(*(undefined **)(param_1 + 0x4c));\n    }\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_locale_free_numeric",
      "entry": "00418c88",
      "c": "\n/* Library Function - Single Match\n    ___acrt_locale_free_numeric\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl ___acrt_locale_free_numeric(undefined4 *param_1)\n\n{\n  if (param_1 != (undefined4 *)0x0) {\n    if ((undefined *)*param_1 != PTR_DAT_0042d840) {\n      FID_conflict__free((undefined *)*param_1);\n    }\n    if ((undefined *)param_1[1] != PTR_DAT_0042d844) {\n      FID_conflict__free((undefined *)param_1[1]);\n    }\n    if ((undefined *)param_1[2] != PTR_DAT_0042d848) {\n      FID_conflict__free((undefined *)param_1[2]);\n    }\n    if ((undefined *)param_1[0xc] != PTR_DAT_0042d870) {\n      FID_conflict__free((undefined *)param_1[0xc]);\n    }\n    if ((undefined *)param_1[0xd] != PTR_DAT_0042d874) {\n      FID_conflict__free((undefined *)param_1[0xd]);\n    }\n  }\n  return;\n}\n\n"
    },
    {
      "name": "free_crt_array_internal",
      "entry": "00418cf1",
      "c": "\n/* Library Function - Single Match\n    void __cdecl free_crt_array_internal(void const * * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl free_crt_array_internal(void **param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar2 = 0;\n  uVar1 = ~-(uint)(param_1 + param_2 < param_1) &\n          (uint)((int)(param_1 + param_2) + (3 - (int)param_1)) >> 2;\n  if (uVar1 != 0) {\n    do {\n      FID_conflict__free(*param_1);\n      uVar2 = uVar2 + 1;\n      param_1 = param_1 + 1;\n    } while (uVar2 != uVar1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_locale_free_time",
      "entry": "00418d2d",
      "c": "\n/* Library Function - Single Match\n    ___acrt_locale_free_time\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_locale_free_time(void **param_1)\n\n{\n  if (param_1 != (void **)0x0) {\n    free_crt_array_internal(param_1,7);\n    free_crt_array_internal(param_1 + 7,7);\n    free_crt_array_internal(param_1 + 0xe,0xc);\n    free_crt_array_internal(param_1 + 0x1a,0xc);\n    free_crt_array_internal(param_1 + 0x26,2);\n    FID_conflict__free(param_1[0x28]);\n    FID_conflict__free(param_1[0x29]);\n    FID_conflict__free(param_1[0x2a]);\n    free_crt_array_internal(param_1 + 0x2d,7);\n    free_crt_array_internal(param_1 + 0x34,7);\n    free_crt_array_internal(param_1 + 0x3b,0xc);\n    free_crt_array_internal(param_1 + 0x47,0xc);\n    free_crt_array_internal(param_1 + 0x53,2);\n    FID_conflict__free(param_1[0x55]);\n    FID_conflict__free(param_1[0x56]);\n    FID_conflict__free(param_1[0x57]);\n    FID_conflict__free(param_1[0x58]);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "_wcsncmp",
      "entry": "00418e11",
      "c": "\n/* Library Function - Single Match\n    _wcsncmp\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _wcsncmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)\n\n{\n  if (_MaxCount != 0) {\n    for (; ((_MaxCount = _MaxCount - 1, _MaxCount != 0 && (*_Str1 != L'\\0')) && (*_Str1 == *_Str2));\n        _Str1 = _Str1 + 1) {\n      _Str2 = _Str2 + 1;\n    }\n    return (uint)(ushort)*_Str1 - (uint)(ushort)*_Str2;\n  }\n  return _MaxCount;\n}\n\n"
    },
    {
      "name": "___acrt_GetStringTypeA",
      "entry": "00418e4b",
      "c": "\n/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    ___acrt_GetStringTypeA\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___acrt_GetStringTypeA\n          (__crt_locale_pointers *param_1,DWORD param_2,LPCSTR param_3,int param_4,LPWORD param_5,\n          UINT param_6,int param_7)\n\n{\n  uint _Size;\n  LPCWSTR lpWideCharStr;\n  int cchSrc;\n  LPCWSTR pWVar1;\n  int local_1c;\n  int local_18;\n  char local_10;\n  int local_c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,param_1);\n  if (param_6 == 0) {\n    param_6 = *(UINT *)(local_18 + 8);\n  }\n  local_c = MultiByteToWideChar(param_6,(uint)(param_7 != 0) * 8 + 1,param_3,param_4,(LPWSTR)0x0,0);\n  if (local_c == 0) goto LAB_00418f42;\n  _Size = local_c * 2;\n  if ((_Size + 8 & -(uint)(_Size < _Size + 8)) == 0) {\n    lpWideCharStr = (LPCWSTR)0x0;\nLAB_00418f03:\n    if (lpWideCharStr != (LPCWSTR)0x0) {\n      _memset(lpWideCharStr,0,_Size);\n      cchSrc = MultiByteToWideChar(param_6,1,param_3,param_4,lpWideCharStr,local_c);\n      if (cchSrc != 0) {\n        GetStringTypeW(param_2,lpWideCharStr,cchSrc,param_5);\n      }\n    }\n  }\n  else if ((-(uint)(_Size < _Size + 8) & _Size + 8) < 0x401) {\n    pWVar1 = (LPCWSTR)&stack0xffffffd8;\n    lpWideCharStr = (LPCWSTR)&stack0xffffffd8;\n    if (&stack0x00000000 != (undefined1 *)0x28) {\nLAB_00418efc:\n      lpWideCharStr = pWVar1 + 4;\n      goto LAB_00418f03;\n    }\n  }\n  else {\n    lpWideCharStr = (LPCWSTR)__malloc_base(-(uint)(_Size < _Size + 8) & _Size + 8);\n    if (lpWideCharStr != (LPCWSTR)0x0) {\n      lpWideCharStr[0] = L'\\xdddd';\n      lpWideCharStr[1] = L'\\0';\n      pWVar1 = lpWideCharStr;\n      goto LAB_00418efc;\n    }\n  }\n  __freea_crt((int)lpWideCharStr);\nLAB_00418f42:\n  if (local_10 != '\\0') {\n    *(uint *)(local_1c + 0x350) = *(uint *)(local_1c + 0x350) & 0xfffffffd;\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "__freea_crt",
      "entry": "00418f68",
      "c": "\n/* Library Function - Single Match\n    __freea_crt\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __freea_crt(int param_1)\n\n{\n  if ((param_1 != 0) && (*(int *)(param_1 + -8) == 0xdddd)) {\n    FID_conflict__free((int *)(param_1 + -8));\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_add_locale_ref",
      "entry": "00418f88",
      "c": "\n/* Library Function - Single Match\n    ___acrt_add_locale_ref\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl ___acrt_add_locale_ref(int param_1)\n\n{\n  int *piVar1;\n  undefined4 *puVar2;\n  int iVar3;\n  \n  LOCK();\n  *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + 1;\n  UNLOCK();\n  piVar1 = *(int **)(param_1 + 0x7c);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  piVar1 = *(int **)(param_1 + 0x84);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  piVar1 = *(int **)(param_1 + 0x80);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  piVar1 = *(int **)(param_1 + 0x8c);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  puVar2 = (undefined4 *)(param_1 + 0x28);\n  iVar3 = 6;\n  do {\n    if (((undefined *)puVar2[-2] != &DAT_0042d308) &&\n       (piVar1 = (int *)*puVar2, piVar1 != (int *)0x0)) {\n      LOCK();\n      *piVar1 = *piVar1 + 1;\n      UNLOCK();\n    }\n    if ((puVar2[-3] != 0) && (piVar1 = (int *)puVar2[-1], piVar1 != (int *)0x0)) {\n      LOCK();\n      *piVar1 = *piVar1 + 1;\n      UNLOCK();\n    }\n    puVar2 = puVar2 + 4;\n    iVar3 = iVar3 + -1;\n  } while (iVar3 != 0);\n  ___acrt_locale_add_lc_time_reference(*(undefined ***)(param_1 + 0x9c));\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_free_locale",
      "entry": "00419005",
      "c": "\n/* Library Function - Single Match\n    ___acrt_free_locale\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl ___acrt_free_locale(void *param_1)\n\n{\n  int *piVar1;\n  undefined4 *puVar2;\n  undefined4 *puVar3;\n  int local_8;\n  \n  if ((((*(undefined ***)((int)param_1 + 0x88) != (undefined **)0x0) &&\n       (*(undefined ***)((int)param_1 + 0x88) != &PTR_DAT_0042d840)) &&\n      (*(int **)((int)param_1 + 0x7c) != (int *)0x0)) && (**(int **)((int)param_1 + 0x7c) == 0)) {\n    piVar1 = *(int **)((int)param_1 + 0x84);\n    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {\n      FID_conflict__free(piVar1);\n      ___acrt_locale_free_monetary(*(int *)((int)param_1 + 0x88));\n    }\n    piVar1 = *(int **)((int)param_1 + 0x80);\n    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {\n      FID_conflict__free(piVar1);\n      ___acrt_locale_free_numeric(*(undefined4 **)((int)param_1 + 0x88));\n    }\n    FID_conflict__free(*(void **)((int)param_1 + 0x7c));\n    FID_conflict__free(*(void **)((int)param_1 + 0x88));\n  }\n  if ((*(int **)((int)param_1 + 0x8c) != (int *)0x0) && (**(int **)((int)param_1 + 0x8c) == 0)) {\n    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x90) + -0xfe));\n    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x94) + -0x80));\n    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x98) + -0x80));\n    FID_conflict__free(*(void **)((int)param_1 + 0x8c));\n  }\n  ___acrt_locale_free_lc_time_if_unreferenced(*(undefined ***)((int)param_1 + 0x9c));\n  puVar2 = (undefined4 *)((int)param_1 + 0xa0);\n  local_8 = 6;\n  puVar3 = (undefined4 *)((int)param_1 + 0x28);\n  do {\n    if ((((undefined *)puVar3[-2] != &DAT_0042d308) &&\n        (piVar1 = (int *)*puVar3, piVar1 != (int *)0x0)) && (*piVar1 == 0)) {\n      FID_conflict__free(piVar1);\n      FID_conflict__free((void *)*puVar2);\n    }\n    if (((puVar3[-3] != 0) && (piVar1 = (int *)puVar3[-1], piVar1 != (int *)0x0)) && (*piVar1 == 0))\n    {\n      FID_conflict__free(piVar1);\n    }\n    puVar2 = puVar2 + 1;\n    puVar3 = puVar3 + 4;\n    local_8 = local_8 + -1;\n  } while (local_8 != 0);\n  FID_conflict__free(param_1);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_locale_add_lc_time_reference",
      "entry": "0041914f",
      "c": "\n/* Library Function - Single Match\n    ___acrt_locale_add_lc_time_reference\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined * __cdecl ___acrt_locale_add_lc_time_reference(undefined **param_1)\n\n{\n  undefined **ppuVar1;\n  undefined *puVar2;\n  \n  if ((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_004276f8)) {\n    LOCK();\n    ppuVar1 = param_1 + 0x2c;\n    puVar2 = *ppuVar1;\n    *ppuVar1 = *ppuVar1 + 1;\n    UNLOCK();\n    return puVar2 + 1;\n  }\n  return (undefined *)0x7fffffff;\n}\n\n"
    },
    {
      "name": "___acrt_locale_free_lc_time_if_unreferenced",
      "entry": "00419178",
      "c": "\n/* Library Function - Single Match\n    ___acrt_locale_free_lc_time_if_unreferenced\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nvoid __cdecl ___acrt_locale_free_lc_time_if_unreferenced(undefined **param_1)\n\n{\n  if (((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_004276f8)) &&\n     (param_1[0x2c] == (undefined *)0x0)) {\n    ___acrt_locale_free_time(param_1);\n    FID_conflict__free(param_1);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_locale_release_lc_time_reference",
      "entry": "004191a8",
      "c": "\n/* Library Function - Single Match\n    ___acrt_locale_release_lc_time_reference\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined * __cdecl ___acrt_locale_release_lc_time_reference(undefined **param_1)\n\n{\n  undefined **ppuVar1;\n  undefined *puVar2;\n  \n  if ((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_004276f8)) {\n    LOCK();\n    ppuVar1 = param_1 + 0x2c;\n    puVar2 = *ppuVar1;\n    *ppuVar1 = *ppuVar1 + -1;\n    UNLOCK();\n    return puVar2 + -1;\n  }\n  return (undefined *)0x7fffffff;\n}\n\n"
    },
    {
      "name": "___acrt_release_locale_ref",
      "entry": "004191d1",
      "c": "\n/* Library Function - Single Match\n    ___acrt_release_locale_ref\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl ___acrt_release_locale_ref(int param_1)\n\n{\n  int *piVar1;\n  undefined4 *puVar2;\n  int iVar3;\n  \n  if (param_1 != 0) {\n    LOCK();\n    *(int *)(param_1 + 0xc) = *(int *)(param_1 + 0xc) + -1;\n    UNLOCK();\n    piVar1 = *(int **)(param_1 + 0x7c);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    piVar1 = *(int **)(param_1 + 0x84);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    piVar1 = *(int **)(param_1 + 0x80);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    piVar1 = *(int **)(param_1 + 0x8c);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    puVar2 = (undefined4 *)(param_1 + 0x28);\n    iVar3 = 6;\n    do {\n      if (((undefined *)puVar2[-2] != &DAT_0042d308) &&\n         (piVar1 = (int *)*puVar2, piVar1 != (int *)0x0)) {\n        LOCK();\n        *piVar1 = *piVar1 + -1;\n        UNLOCK();\n      }\n      if ((puVar2[-3] != 0) && (piVar1 = (int *)puVar2[-1], piVar1 != (int *)0x0)) {\n        LOCK();\n        *piVar1 = *piVar1 + -1;\n        UNLOCK();\n      }\n      puVar2 = puVar2 + 4;\n      iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    ___acrt_locale_release_lc_time_reference(*(undefined ***)(param_1 + 0x9c));\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_update_thread_locale_data",
      "entry": "00419252",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    ___acrt_update_thread_locale_data\n   \n   Library: Visual Studio 2015 Release */\n\nundefined ** ___acrt_update_thread_locale_data(void)\n\n{\n  __acrt_ptd *p_Var1;\n  undefined **ppuVar2;\n  \n  p_Var1 = ___acrt_getptd();\n  if (((*(uint *)(p_Var1 + 0x350) & DAT_0042d30c) == 0) ||\n     (ppuVar2 = *(undefined ***)(p_Var1 + 0x4c), ppuVar2 == (undefined **)0x0)) {\n    ___acrt_lock(4);\n    ppuVar2 = __updatetlocinfoEx_nolock((undefined4 *)(p_Var1 + 0x4c),DAT_0043b3f8);\n    FUN_004192b8();\n    if (ppuVar2 == (undefined **)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _abort();\n    }\n  }\n  return ppuVar2;\n}\n\n"
    },
    {
      "name": "FUN_004192b8",
      "entry": "004192b8",
      "c": "\nvoid FUN_004192b8(void)\n\n{\n  ___acrt_unlock(4);\n  return;\n}\n\n"
    },
    {
      "name": "__updatetlocinfoEx_nolock",
      "entry": "004192c9",
      "c": "\n/* Library Function - Single Match\n    __updatetlocinfoEx_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nundefined ** __cdecl __updatetlocinfoEx_nolock(undefined4 *param_1,undefined **param_2)\n\n{\n  undefined **ppuVar1;\n  \n  if ((param_2 == (undefined **)0x0) || (param_1 == (undefined4 *)0x0)) {\n    param_2 = (undefined **)0x0;\n  }\n  else {\n    ppuVar1 = (undefined **)*param_1;\n    if (ppuVar1 != param_2) {\n      *param_1 = param_2;\n      ___acrt_add_locale_ref((int)param_2);\n      if (((ppuVar1 != (undefined **)0x0) &&\n          (___acrt_release_locale_ref((int)ppuVar1), ppuVar1[3] == (undefined *)0x0)) &&\n         (ppuVar1 != &PTR_DAT_0042d248)) {\n        ___acrt_free_locale(ppuVar1);\n      }\n    }\n  }\n  return param_2;\n}\n\n"
    },
    {
      "name": "FUN_00419319",
      "entry": "00419319",
      "c": "\nLPVOID __cdecl FUN_00419319(LPCVOID param_1,uint param_2,uint param_3)\n\n{\n  int *piVar1;\n  LPVOID pvVar2;\n  SIZE_T SVar3;\n  uint uVar4;\n  \n  if ((param_2 == 0) || (param_3 <= 0xffffffe0 / param_2)) {\n    if (param_1 == (LPCVOID)0x0) {\n      SVar3 = 0;\n    }\n    else {\n      SVar3 = FUN_0041d73f(param_1);\n    }\n    uVar4 = param_2 * param_3;\n    pvVar2 = __realloc_base(param_1,uVar4);\n    if ((pvVar2 != (LPVOID)0x0) && (SVar3 < uVar4)) {\n      _memset((void *)((int)pvVar2 + SVar3),0,uVar4 - SVar3);\n    }\n  }\n  else {\n    piVar1 = __errno();\n    *piVar1 = 0xc;\n    pvVar2 = (LPVOID)0x0;\n  }\n  return pvVar2;\n}\n\n"
    },
    {
      "name": "___acrt_execute_initializers",
      "entry": "004193ac",
      "c": "\n/* Library Function - Single Match\n    ___acrt_execute_initializers\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_execute_initializers(undefined4 *param_1,undefined4 *param_2)\n\n{\n  undefined4 *puVar1;\n  code *pcVar2;\n  char cVar3;\n  uint uVar4;\n  undefined4 *puVar5;\n  \n  uVar4 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  puVar5 = param_1;\n  if (param_1 != param_2) {\n    do {\n      pcVar2 = (code *)*puVar5;\n      if (pcVar2 != (code *)0x0) {\n        (*(code *)PTR_guard_check_icall_0042118c)();\n        cVar3 = (*pcVar2)();\n        if (cVar3 == '\\0') break;\n      }\n      puVar5 = puVar5 + 2;\n    } while (puVar5 != param_2);\n    if ((puVar5 != param_2) && (puVar5 != param_1)) {\n      puVar5 = puVar5 + -1;\n      do {\n        if ((puVar5[-1] != 0) && (pcVar2 = (code *)*puVar5, pcVar2 != (code *)0x0)) {\n          (*(code *)PTR_guard_check_icall_0042118c)(0);\n          (*pcVar2)();\n        }\n        puVar1 = puVar5 + -1;\n        puVar5 = puVar5 + -2;\n      } while (puVar1 != param_1);\n    }\n  }\n  __security_check_cookie(uVar4 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_execute_uninitializers",
      "entry": "0041942f",
      "c": "\n/* Library Function - Single Match\n    ___acrt_execute_uninitializers\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_execute_uninitializers(undefined4 *param_1,undefined4 *param_2)\n\n{\n  undefined4 *puVar1;\n  code *pcVar2;\n  uint uVar3;\n  undefined4 *puVar4;\n  \n  uVar3 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_1 != param_2) {\n    puVar4 = param_2 + -1;\n    do {\n      pcVar2 = (code *)*puVar4;\n      if (pcVar2 != (code *)0x0) {\n        (*(code *)PTR_guard_check_icall_0042118c)(0);\n        (*pcVar2)();\n      }\n      puVar1 = puVar4 + -1;\n      puVar4 = puVar4 + -2;\n    } while (puVar1 != param_1);\n  }\n  __security_check_cookie(uVar3 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041947c",
      "entry": "0041947c",
      "c": "\nvoid __cdecl FUN_0041947c(undefined4 param_1)\n\n{\n  initialize(&DAT_0043b568,param_1);\n  return;\n}\n\n"
    },
    {
      "name": "__callnewh",
      "entry": "00419490",
      "c": "\n/* Library Function - Single Match\n    __callnewh\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __callnewh(size_t _Size)\n\n{\n  uint uVar1;\n  code *pcVar2;\n  int iVar3;\n  \n  uVar1 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  pcVar2 = (code *)__query_new_handler();\n  if (pcVar2 != (code *)0x0) {\n    (*(code *)PTR_guard_check_icall_0042118c)(_Size);\n    (*pcVar2)();\n  }\n  iVar3 = __security_check_cookie(uVar1 ^ (uint)&stack0xfffffffc);\n  return iVar3;\n}\n\n"
    },
    {
      "name": "__query_new_handler",
      "entry": "004194d4",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __query_new_handler\n   \n   Library: Visual Studio 2015 Release */\n\nuint __query_new_handler(void)\n\n{\n  byte bVar1;\n  uint uVar2;\n  \n  ___acrt_lock(0);\n  bVar1 = (byte)DAT_0042d008 & 0x1f;\n  uVar2 = DAT_0042d008 ^ _DAT_0043b568;\n  FUN_0041951d();\n  return uVar2 >> bVar1 | uVar2 << 0x20 - bVar1;\n}\n\n"
    },
    {
      "name": "FUN_0041951d",
      "entry": "0041951d",
      "c": "\nvoid FUN_0041951d(void)\n\n{\n  ___acrt_unlock(0);\n  return;\n}\n\n"
    },
    {
      "name": "___hw_cw_sse2",
      "entry": "00419526",
      "c": "\n/* Library Function - Single Match\n    ___hw_cw_sse2\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___hw_cw_sse2(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = 0;\n  if ((param_1 & 0x10) != 0) {\n    uVar1 = 0x80;\n  }\n  if ((param_1 & 8) != 0) {\n    uVar1 = uVar1 | 0x200;\n  }\n  if ((param_1 & 4) != 0) {\n    uVar1 = uVar1 | 0x400;\n  }\n  if ((param_1 & 2) != 0) {\n    uVar1 = uVar1 | 0x800;\n  }\n  if ((param_1 & 1) != 0) {\n    uVar1 = uVar1 | 0x1000;\n  }\n  if ((param_1 & 0x80000) != 0) {\n    uVar1 = uVar1 | 0x100;\n  }\n  uVar2 = param_1 & 0x300;\n  if (uVar2 != 0) {\n    if (uVar2 == 0x100) {\n      uVar1 = uVar1 | 0x2000;\n    }\n    else if (uVar2 == 0x200) {\n      uVar1 = uVar1 | 0x4000;\n    }\n    else if (uVar2 == 0x300) {\n      uVar1 = uVar1 | 0x6000;\n    }\n  }\n  uVar2 = param_1 & 0x3000000;\n  if (uVar2 == 0x1000000) {\n    uVar1 = uVar1 | 0x8040;\n  }\n  else {\n    if (uVar2 == 0x2000000) {\n      return uVar1 | 0x40;\n    }\n    if (uVar2 == 0x3000000) {\n      return uVar1 | 0x8000;\n    }\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "__clearfp",
      "entry": "004195d1",
      "c": "\n/* Library Function - Single Match\n    __clearfp\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl __clearfp(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ushort in_FPUStatusWord;\n  \n  if (DAT_0043adbc < 1) {\n    uVar1 = 0;\n    if ((in_FPUStatusWord & 0x3f) != 0) {\n      if ((in_FPUStatusWord & 1) != 0) {\n        uVar1 = 0x10;\n      }\n      if ((in_FPUStatusWord & 4) != 0) {\n        uVar1 = uVar1 | 8;\n      }\n      if ((in_FPUStatusWord & 8) != 0) {\n        uVar1 = uVar1 | 4;\n      }\n      if ((in_FPUStatusWord & 0x10) != 0) {\n        uVar1 = uVar1 | 2;\n      }\n      if ((in_FPUStatusWord & 0x20) != 0) {\n        uVar1 = uVar1 | 1;\n      }\n      if ((in_FPUStatusWord & 2) != 0) {\n        uVar1 = uVar1 | 0x80000;\n      }\n    }\n  }\n  else {\n    uVar1 = 0;\n    uVar2 = 0;\n    if ((in_FPUStatusWord & 0x3f) != 0) {\n      if ((in_FPUStatusWord & 1) != 0) {\n        uVar2 = 0x10;\n      }\n      if ((in_FPUStatusWord & 4) != 0) {\n        uVar2 = uVar2 | 8;\n      }\n      if ((in_FPUStatusWord & 8) != 0) {\n        uVar2 = uVar2 | 4;\n      }\n      if ((in_FPUStatusWord & 0x10) != 0) {\n        uVar2 = uVar2 | 2;\n      }\n      if ((in_FPUStatusWord & 0x20) != 0) {\n        uVar2 = uVar2 | 1;\n      }\n      if ((in_FPUStatusWord & 2) != 0) {\n        uVar2 = uVar2 | 0x80000;\n      }\n    }\n    if ((MXCSR & 0x3f) != 0) {\n      if ((MXCSR & 1) != 0) {\n        uVar1 = 0x10;\n      }\n      if ((MXCSR & 4) != 0) {\n        uVar1 = uVar1 | 8;\n      }\n      if ((MXCSR & 8) != 0) {\n        uVar1 = uVar1 | 4;\n      }\n      if ((MXCSR & 0x10) != 0) {\n        uVar1 = uVar1 | 2;\n      }\n      if ((MXCSR & 0x20) != 0) {\n        uVar1 = uVar1 | 1;\n      }\n      if ((MXCSR & 2) != 0) {\n        uVar1 = uVar1 | 0x80000;\n      }\n    }\n    uVar1 = uVar1 | uVar2;\n    MXCSR = MXCSR & 0xffffffc0;\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "__control87",
      "entry": "004196af",
      "c": "\n/* Library Function - Single Match\n    __control87\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl __control87(uint _NewValue,uint _Mask)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ushort uVar3;\n  uint uVar4;\n  ushort in_FPUControlWord;\n  \n  uVar1 = 0;\n  if ((in_FPUControlWord & 1) != 0) {\n    uVar1 = 0x10;\n  }\n  if ((in_FPUControlWord & 4) != 0) {\n    uVar1 = uVar1 | 8;\n  }\n  if ((in_FPUControlWord & 8) != 0) {\n    uVar1 = uVar1 | 4;\n  }\n  if ((in_FPUControlWord & 0x10) != 0) {\n    uVar1 = uVar1 | 2;\n  }\n  if ((in_FPUControlWord & 0x20) != 0) {\n    uVar1 = uVar1 | 1;\n  }\n  if ((in_FPUControlWord & 2) != 0) {\n    uVar1 = uVar1 | 0x80000;\n  }\n  uVar3 = in_FPUControlWord & 0xc00;\n  if ((in_FPUControlWord & 0xc00) != 0) {\n    if (uVar3 == 0x400) {\n      uVar1 = uVar1 | 0x100;\n    }\n    else if (uVar3 == 0x800) {\n      uVar1 = uVar1 | 0x200;\n    }\n    else if (uVar3 == 0xc00) {\n      uVar1 = uVar1 | 0x300;\n    }\n  }\n  if ((in_FPUControlWord & 0x300) == 0) {\n    uVar1 = uVar1 | 0x20000;\n  }\n  else if ((in_FPUControlWord & 0x300) == 0x200) {\n    uVar1 = uVar1 | 0x10000;\n  }\n  if ((in_FPUControlWord & 0x1000) != 0) {\n    uVar1 = uVar1 | 0x40000;\n  }\n  uVar4 = ~_Mask & uVar1 | _NewValue & _Mask;\n  if (uVar4 != uVar1) {\n    uVar1 = __hw_cw(uVar4);\n    uVar4 = 0;\n    if ((uVar1 & 1) != 0) {\n      uVar4 = 0x10;\n    }\n    if ((uVar1 & 4) != 0) {\n      uVar4 = uVar4 | 8;\n    }\n    if ((uVar1 & 8) != 0) {\n      uVar4 = uVar4 | 4;\n    }\n    if ((uVar1 & 0x10) != 0) {\n      uVar4 = uVar4 | 2;\n    }\n    if ((uVar1 & 0x20) != 0) {\n      uVar4 = uVar4 | 1;\n    }\n    if ((uVar1 & 2) != 0) {\n      uVar4 = uVar4 | 0x80000;\n    }\n    uVar2 = uVar1 & 0xc00;\n    if ((uVar1 & 0xc00) != 0) {\n      if (uVar2 == 0x400) {\n        uVar4 = uVar4 | 0x100;\n      }\n      else if (uVar2 == 0x800) {\n        uVar4 = uVar4 | 0x200;\n      }\n      else if (uVar2 == 0xc00) {\n        uVar4 = uVar4 | 0x300;\n      }\n    }\n    if ((uVar1 & 0x300) == 0) {\n      uVar4 = uVar4 | 0x20000;\n    }\n    else if ((uVar1 & 0x300) == 0x200) {\n      uVar4 = uVar4 | 0x10000;\n    }\n    if ((uVar1 & 0x1000) != 0) {\n      uVar4 = uVar4 | 0x40000;\n    }\n  }\n  uVar1 = uVar4;\n  if (0 < DAT_0043adbc) {\n    uVar2 = 0;\n    if ((char)MXCSR < '\\0') {\n      uVar2 = 0x10;\n    }\n    if ((MXCSR & 0x200) != 0) {\n      uVar2 = uVar2 | 8;\n    }\n    if ((MXCSR & 0x400) != 0) {\n      uVar2 = uVar2 | 4;\n    }\n    if ((MXCSR & 0x800) != 0) {\n      uVar2 = uVar2 | 2;\n    }\n    if ((MXCSR & 0x1000) != 0) {\n      uVar2 = uVar2 | 1;\n    }\n    if ((MXCSR & 0x100) != 0) {\n      uVar2 = uVar2 | 0x80000;\n    }\n    uVar1 = MXCSR & 0x6000;\n    if (uVar1 != 0) {\n      if (uVar1 == 0x2000) {\n        uVar2 = uVar2 | 0x100;\n      }\n      else if (uVar1 == 0x4000) {\n        uVar2 = uVar2 | 0x200;\n      }\n      else if (uVar1 == 0x6000) {\n        uVar2 = uVar2 | 0x300;\n      }\n    }\n    uVar1 = MXCSR & 0x8040;\n    if (uVar1 == 0x40) {\n      uVar2 = uVar2 | 0x2000000;\n    }\n    else if (uVar1 == 0x8000) {\n      uVar2 = uVar2 | 0x3000000;\n    }\n    else if (uVar1 == 0x8040) {\n      uVar2 = uVar2 | 0x1000000;\n    }\n    uVar1 = ~(_Mask & 0x308031f) & uVar2 | _Mask & 0x308031f & _NewValue;\n    if (uVar1 != uVar2) {\n      uVar1 = ___hw_cw_sse2(uVar1);\n      ___set_fpsr_sse2(uVar1);\n      uVar2 = 0;\n      if ((char)MXCSR < '\\0') {\n        uVar2 = 0x10;\n      }\n      if ((MXCSR & 0x200) != 0) {\n        uVar2 = uVar2 | 8;\n      }\n      if ((MXCSR & 0x400) != 0) {\n        uVar2 = uVar2 | 4;\n      }\n      if ((MXCSR & 0x800) != 0) {\n        uVar2 = uVar2 | 2;\n      }\n      if ((MXCSR & 0x1000) != 0) {\n        uVar2 = uVar2 | 1;\n      }\n      if ((MXCSR & 0x100) != 0) {\n        uVar2 = uVar2 | 0x80000;\n      }\n      uVar1 = MXCSR & 0x6000;\n      if (uVar1 != 0) {\n        if (uVar1 == 0x2000) {\n          uVar2 = uVar2 | 0x100;\n        }\n        else if (uVar1 == 0x4000) {\n          uVar2 = uVar2 | 0x200;\n        }\n        else if (uVar1 == 0x6000) {\n          uVar2 = uVar2 | 0x300;\n        }\n      }\n      uVar1 = MXCSR & 0x8040;\n      if (uVar1 == 0x40) {\n        uVar2 = uVar2 | 0x2000000;\n      }\n      else if (uVar1 == 0x8000) {\n        uVar2 = uVar2 | 0x3000000;\n      }\n      else if (uVar1 == 0x8040) {\n        uVar2 = uVar2 | 0x1000000;\n      }\n    }\n    uVar1 = uVar2 | uVar4;\n    if (((uVar2 ^ uVar4) & 0x8031f) != 0) {\n      uVar1 = uVar1 | 0x80000000;\n    }\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "__hw_cw",
      "entry": "004199b1",
      "c": "\n/* Library Function - Single Match\n    __hw_cw\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl __hw_cw(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = (uint)((param_1 & 0x10) != 0);\n  if ((param_1 & 8) != 0) {\n    uVar1 = uVar1 | 4;\n  }\n  if ((param_1 & 4) != 0) {\n    uVar1 = uVar1 | 8;\n  }\n  if ((param_1 & 2) != 0) {\n    uVar1 = uVar1 | 0x10;\n  }\n  if ((param_1 & 1) != 0) {\n    uVar1 = uVar1 | 0x20;\n  }\n  if ((param_1 & 0x80000) != 0) {\n    uVar1 = uVar1 | 2;\n  }\n  uVar2 = param_1 & 0x300;\n  if (uVar2 != 0) {\n    if (uVar2 == 0x100) {\n      uVar1 = uVar1 | 0x400;\n    }\n    else if (uVar2 == 0x200) {\n      uVar1 = uVar1 | 0x800;\n    }\n    else if (uVar2 == 0x300) {\n      uVar1 = uVar1 | 0xc00;\n    }\n  }\n  if ((param_1 & 0x30000) == 0) {\n    uVar1 = uVar1 | 0x300;\n  }\n  else if ((param_1 & 0x30000) == 0x10000) {\n    uVar1 = uVar1 | 0x200;\n  }\n  if ((param_1 & 0x40000) != 0) {\n    uVar1 = uVar1 | 0x1000;\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "_iswctype",
      "entry": "00419a4a",
      "c": "\n/* Library Function - Single Match\n    _iswctype\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _iswctype(wint_t _C,wctype_t _Type)\n\n{\n  uint uVar1;\n  BOOL BVar2;\n  uint in_ECX;\n  WCHAR local_c;\n  undefined2 uStack_a;\n  uint local_8;\n  \n  if (_C == 0xffff) {\nLAB_00419a5f:\n    uVar1 = 0;\n  }\n  else {\n    if (_C < 0x100) {\n      local_8._0_2_ = *(ushort *)(PTR_DAT_0042d834 + (uint)_C * 2);\n    }\n    else {\n      _local_c = CONCAT22((short)(in_ECX >> 0x10),_C);\n      local_8 = in_ECX & 0xffff0000;\n      BVar2 = GetStringTypeW(1,&local_c,1,(LPWORD)&local_8);\n      if (BVar2 == 0) goto LAB_00419a5f;\n    }\n    uVar1 = (uint)((ushort)local_8 & _Type);\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "__isctype_l",
      "entry": "00419aa9",
      "c": "\n/* Library Function - Single Match\n    __isctype_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __isctype_l(int _C,int _Type,_locale_t _Locale)\n\n{\n  int iVar1;\n  int local_24;\n  localeinfo_struct local_20;\n  char local_18;\n  CHAR local_14;\n  CHAR local_13;\n  undefined1 local_12;\n  WORD local_10 [4];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_24,(__crt_locale_pointers *)_Locale);\n  if (0x100 < _C + 1U) {\n    iVar1 = __isleadbyte_l(_C >> 8 & 0xff,&local_20);\n    if (iVar1 == 0) {\n      local_13 = '\\0';\n      iVar1 = 1;\n      local_14 = (CHAR)_C;\n    }\n    else {\n      local_12 = 0;\n      iVar1 = 2;\n      local_14 = (CHAR)((uint)_C >> 8);\n      local_13 = (CHAR)_C;\n    }\n    local_10[0] = 0;\n    local_10[1] = 0;\n    local_10[2] = 0;\n    iVar1 = ___acrt_GetStringTypeA\n                      ((__crt_locale_pointers *)&local_20,1,&local_14,iVar1,local_10,\n                       (local_20.locinfo)->lc_collate_cp,1);\n    if (iVar1 == 0) {\n      if (local_18 != '\\0') {\n        *(uint *)(local_24 + 0x350) = *(uint *)(local_24 + 0x350) & 0xfffffffd;\n      }\n      goto LAB_00419b6c;\n    }\n  }\n  if (local_18 != '\\0') {\n    *(uint *)(local_24 + 0x350) = *(uint *)(local_24 + 0x350) & 0xfffffffd;\n  }\nLAB_00419b6c:\n  iVar1 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__isatty",
      "entry": "00419b7b",
      "c": "\n/* Library Function - Single Match\n    __isatty\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __isatty(int _FileHandle)\n\n{\n  int *piVar1;\n  \n  if (_FileHandle == -2) {\n    piVar1 = __errno();\n    *piVar1 = 9;\n  }\n  else {\n    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_0043b310)) {\n      return *(byte *)((&DAT_0043b110)[_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3fU) * 0x30) &\n             0x40;\n    }\n    piVar1 = __errno();\n    *piVar1 = 9;\n    FUN_00412362();\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "___acrt_stdio_allocate_buffer_nolock",
      "entry": "00419bd1",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    ___acrt_stdio_allocate_buffer_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___acrt_stdio_allocate_buffer_nolock(undefined4 *param_1)\n\n{\n  uint *puVar1;\n  LPVOID pvVar2;\n  \n  _DAT_0043ae9c = _DAT_0043ae9c + 1;\n  pvVar2 = __malloc_base(0x1000);\n  param_1[1] = pvVar2;\n  FID_conflict__free((void *)0x0);\n  puVar1 = param_1 + 3;\n  if (param_1[1] == 0) {\n    LOCK();\n    *puVar1 = *puVar1 | 0x400;\n    UNLOCK();\n    param_1[6] = 2;\n    param_1[1] = param_1 + 5;\n  }\n  else {\n    LOCK();\n    *puVar1 = *puVar1 | 0x40;\n    UNLOCK();\n    param_1[6] = 0x1000;\n  }\n  param_1[2] = 0;\n  *param_1 = param_1[1];\n  return;\n}\n\n"
    },
    {
      "name": "__putwch_nolock",
      "entry": "00419c2e",
      "c": "\n/* Library Function - Single Match\n    __putwch_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nwint_t __cdecl __putwch_nolock(wchar_t _WCh)\n\n{\n  BOOL BVar1;\n  DWORD local_8;\n  \n  if (DAT_0042d934 == (HANDLE)0xfffffffe) {\n    ___dcrt_lowio_initialize_console_output();\n  }\n  if ((DAT_0042d934 == (HANDLE)0xffffffff) ||\n     (BVar1 = WriteConsoleW(DAT_0042d934,&_WCh,1,&local_8,(LPVOID)0x0), BVar1 == 0)) {\n    _WCh = L'\\xffff';\n  }\n  return _WCh;\n}\n\n"
    },
    {
      "name": "GetTableIndexFromLocaleName",
      "entry": "00419c73",
      "c": "\n/* Library Function - Single Match\n    int __cdecl GetTableIndexFromLocaleName(wchar_t const *)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl GetTableIndexFromLocaleName(wchar_t *param_1)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int iVar3;\n  ushort uVar4;\n  ushort *puVar5;\n  int local_10;\n  int local_c;\n  int local_8;\n  \n  local_10 = 0;\n  local_c = 0xe3;\n  while( true ) {\n    local_8 = 0x55;\n    iVar2 = (local_c + local_10) / 2;\n    puVar5 = (ushort *)(&PTR_DAT_00429200)[iVar2 * 2];\n    iVar3 = (int)param_1 - (int)puVar5;\n    do {\n      uVar4 = *(ushort *)(iVar3 + (int)puVar5);\n      if ((0x40 < uVar4) && (uVar4 < 0x5b)) {\n        uVar4 = uVar4 + 0x20;\n      }\n      uVar1 = *puVar5;\n      if ((0x40 < uVar1) && (uVar1 < 0x5b)) {\n        uVar1 = uVar1 + 0x20;\n      }\n      puVar5 = puVar5 + 1;\n      local_8 = local_8 + -1;\n    } while (((local_8 != 0) && (uVar4 != 0)) && (uVar4 == uVar1));\n    if ((uint)uVar4 == (uint)uVar1) break;\n    if ((int)((uint)uVar4 - (uint)uVar1) < 0) {\n      local_c = iVar2 + -1;\n    }\n    else {\n      local_10 = iVar2 + 1;\n    }\n    if (local_c < local_10) {\n      return -1;\n    }\n  }\n  return *(int *)(&DAT_00429204 + iVar2 * 8);\n}\n\n"
    },
    {
      "name": "___acrt_DownlevelLocaleNameToLCID",
      "entry": "00419d2f",
      "c": "\n/* Library Function - Single Match\n    ___acrt_DownlevelLocaleNameToLCID\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl ___acrt_DownlevelLocaleNameToLCID(wchar_t *param_1)\n\n{\n  uint uVar1;\n  \n  if (param_1 != (wchar_t *)0x0) {\n    uVar1 = GetTableIndexFromLocaleName(param_1);\n    if ((-1 < (int)uVar1) && (uVar1 < 0xe4)) {\n      return *(undefined4 *)(&DAT_004280e0 + uVar1 * 8);\n    }\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "__acrt_LCMapStringA_stat",
      "entry": "00419d5b",
      "c": "\n/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    int __cdecl __acrt_LCMapStringA_stat(struct __crt_locale_pointers *,wchar_t const *,unsigned\n   long,char const *,int,char *,int,int,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n__acrt_LCMapStringA_stat\n          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,\n          char *param_6,int param_7,int param_8,int param_9)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  int iVar4;\n  LPCWSTR pWVar5;\n  LPCWSTR lpWideCharStr;\n  LPCWSTR pWVar6;\n  \n  uVar2 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  iVar4 = param_5;\n  if (0 < param_5) {\n    iVar3 = ___strncnt(param_4,param_5);\n    iVar4 = iVar3 + 1;\n    if (param_5 <= iVar3) {\n      iVar4 = iVar3;\n    }\n  }\n  if (param_8 == 0) {\n    param_8 = *(int *)(*(int *)param_1 + 8);\n  }\n  iVar3 = MultiByteToWideChar(param_8,(uint)(param_9 != 0) * 8 + 1,param_4,iVar4,(LPWSTR)0x0,0);\n  if (iVar3 == 0) goto LAB_00419f53;\n  uVar1 = iVar3 * 2;\n  if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) {\n    lpWideCharStr = (LPCWSTR)0x0;\nLAB_00419e28:\n    if (((lpWideCharStr != (LPCWSTR)0x0) &&\n        (iVar4 = MultiByteToWideChar(param_8,1,param_4,iVar4,lpWideCharStr,iVar3), iVar4 != 0)) &&\n       (iVar4 = ___acrt_LCMapStringEx_36(param_2,param_3,lpWideCharStr,iVar3,(LPWSTR)0x0,0,0,0,0),\n       iVar4 != 0)) {\n      if ((param_3 & 0x400) == 0) {\n        uVar1 = iVar4 * 2;\n        if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) {\n          pWVar5 = (LPCWSTR)0x0;\nLAB_00419f05:\n          if ((pWVar5 != (LPCWSTR)0x0) &&\n             (iVar3 = ___acrt_LCMapStringEx_36\n                                (param_2,param_3,lpWideCharStr,iVar3,pWVar5,iVar4,0,0,0), iVar3 != 0\n             )) {\n            if (param_7 == 0) {\n              param_7 = 0;\n              param_6 = (LPSTR)0x0;\n            }\n            iVar4 = WideCharToMultiByte(param_8,0,pWVar5,iVar4,param_6,param_7,(LPCSTR)0x0,\n                                        (LPBOOL)0x0);\n            if (iVar4 != 0) {\n              __freea_crt((int)pWVar5);\n              goto LAB_00419f4a;\n            }\n          }\n        }\n        else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) {\n          pWVar6 = (LPCWSTR)&stack0xffffffe8;\n          pWVar5 = (LPCWSTR)&stack0xffffffe8;\n          if (&stack0x00000000 != (undefined1 *)0x18) {\nLAB_00419efe:\n            pWVar5 = pWVar6 + 4;\n            goto LAB_00419f05;\n          }\n        }\n        else {\n          pWVar5 = (LPCWSTR)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8);\n          if (pWVar5 != (LPCWSTR)0x0) {\n            pWVar5[0] = L'\\xdddd';\n            pWVar5[1] = L'\\0';\n            pWVar6 = pWVar5;\n            goto LAB_00419efe;\n          }\n        }\n        __freea_crt((int)pWVar5);\n      }\n      else if ((param_7 != 0) && (iVar4 <= param_7)) {\n        ___acrt_LCMapStringEx_36(param_2,param_3,lpWideCharStr,iVar3,(LPWSTR)param_6,param_7,0,0,0);\n      }\n    }\n  }\n  else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) {\n    pWVar5 = (LPCWSTR)&stack0xffffffe8;\n    lpWideCharStr = (LPCWSTR)&stack0xffffffe8;\n    if (&stack0x00000000 != (undefined1 *)0x18) {\nLAB_00419e21:\n      lpWideCharStr = pWVar5 + 4;\n      goto LAB_00419e28;\n    }\n  }\n  else {\n    pWVar5 = (LPCWSTR)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8);\n    lpWideCharStr = pWVar5;\n    if (pWVar5 != (LPCWSTR)0x0) {\n      pWVar5[0] = L'\\xdddd';\n      pWVar5[1] = L'\\0';\n      goto LAB_00419e21;\n    }\n  }\nLAB_00419f4a:\n  __freea_crt((int)lpWideCharStr);\nLAB_00419f53:\n  iVar4 = __security_check_cookie(uVar2 ^ (uint)&stack0xfffffffc);\n  return iVar4;\n}\n\n"
    },
    {
      "name": "___acrt_LCMapStringA",
      "entry": "00419f78",
      "c": "\n/* Library Function - Single Match\n    ___acrt_LCMapStringA\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___acrt_LCMapStringA\n          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,\n          char *param_6,int param_7,int param_8,int param_9)\n\n{\n  int local_14;\n  __crt_locale_pointers local_10 [8];\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_1);\n  __acrt_LCMapStringA_stat(local_10,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9)\n  ;\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___acrt_fp_strflt_to_string",
      "entry": "00419fc3",
      "c": "\n/* Library Function - Single Match\n    ___acrt_fp_strflt_to_string\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl ___acrt_fp_strflt_to_string(uint *param_1,uint param_2,int param_3,int param_4)\n\n{\n  uint uVar1;\n  int *piVar2;\n  char *pcVar3;\n  uint *puVar4;\n  char cVar5;\n  char *pcVar6;\n  int iVar7;\n  \n  if ((param_1 != (uint *)0x0) && (param_2 != 0)) {\n    *(undefined1 *)param_1 = 0;\n    iVar7 = param_3;\n    if (param_3 < 1) {\n      iVar7 = 0;\n    }\n    if (param_2 <= iVar7 + 1U) {\n      piVar2 = __errno();\n      iVar7 = 0x22;\n      goto LAB_00419fd7;\n    }\n    if (param_4 != 0) {\n      pcVar3 = (char *)((int)param_1 + 1);\n      pcVar6 = *(char **)(param_4 + 8);\n      *(undefined1 *)param_1 = 0x30;\n      if (0 < param_3) {\n        do {\n          cVar5 = *pcVar6;\n          if (cVar5 == '\\0') {\n            cVar5 = '0';\n          }\n          else {\n            pcVar6 = pcVar6 + 1;\n          }\n          *pcVar3 = cVar5;\n          pcVar3 = pcVar3 + 1;\n          param_3 = param_3 + -1;\n        } while (0 < param_3);\n      }\n      *pcVar3 = '\\0';\n      if ((-1 < param_3) && ('4' < *pcVar6)) {\n        while (pcVar3 = pcVar3 + -1, *pcVar3 == '9') {\n          *pcVar3 = '0';\n        }\n        *pcVar3 = *pcVar3 + '\\x01';\n      }\n      if ((char)*param_1 == '1') {\n        *(int *)(param_4 + 4) = *(int *)(param_4 + 4) + 1;\n      }\n      else {\n        puVar4 = (uint *)((int)param_1 + 1);\n        do {\n          uVar1 = *puVar4;\n          puVar4 = (uint *)((int)puVar4 + 1);\n        } while ((char)uVar1 != '\\0');\n        FUN_00420380(param_1,(uint *)((int)param_1 + 1),\n                     (uint)((int)puVar4 + (1 - ((int)param_1 + 2))));\n      }\n      return 0;\n    }\n  }\n  piVar2 = __errno();\n  iVar7 = 0x16;\nLAB_00419fd7:\n  *piVar2 = iVar7;\n  FUN_00412362();\n  return iVar7;\n}\n\n"
    },
    {
      "name": "scoped_fp_state_reset",
      "entry": "0041a07f",
      "c": "\n/* Library Function - Single Match\n    public: __thiscall `anonymous namespace'::scoped_fp_state_reset::scoped_fp_state_reset(void)\n   \n   Library: Visual Studio 2015 Release */\n\nscoped_fp_state_reset * __thiscall\n_anon_3568B024::scoped_fp_state_reset::scoped_fp_state_reset(scoped_fp_state_reset *this)\n\n{\n  fegetenv((uint *)this);\n  if (((byte)*(undefined4 *)this & 0x1f) == 0x1f) {\n    this[8] = (scoped_fp_state_reset)0x0;\n  }\n  else {\n    feholdexcept((uint *)this);\n    this[8] = (scoped_fp_state_reset)0x1;\n  }\n  return this;\n}\n\n"
    },
    {
      "name": "divide",
      "entry": "0041a0b0",
      "c": "\n/* WARNING: Removing unreachable block (ram,0x0041a417) */\n/* WARNING: Removing unreachable block (ram,0x0041a3f2) */\n/* Library Function - Single Match\n    unsigned __int64 __cdecl __crt_strtox::divide(struct __crt_strtox::big_integer &,struct\n   __crt_strtox::big_integer const &)\n   \n   Library: Visual Studio 2015 Release */\n\n__uint64 __cdecl __crt_strtox::divide(big_integer *param_1,big_integer *param_2)\n\n{\n  int iVar1;\n  ulonglong uVar2;\n  uint uVar3;\n  uint extraout_ECX;\n  uint extraout_ECX_00;\n  uint uVar4;\n  uint uVar5;\n  big_integer *pbVar6;\n  uint uVar7;\n  big_integer *pbVar8;\n  uint uVar9;\n  undefined4 uVar10;\n  bool bVar11;\n  undefined8 uVar12;\n  longlong lVar13;\n  ulonglong uVar14;\n  undefined1 local_21c [460];\n  big_integer *local_50;\n  undefined4 local_4c;\n  undefined8 local_48;\n  int local_40;\n  uint local_3c;\n  uint local_38;\n  uint local_34;\n  uint local_2c;\n  int local_28;\n  uint local_24;\n  int local_20;\n  int local_1c;\n  uint local_18;\n  big_integer *local_14;\n  uint local_10;\n  uint local_c;\n  uint local_8;\n  \n  iVar1 = *(int *)param_1;\n  if (iVar1 == 0) {\n    return 0;\n  }\n  local_3c = *(uint *)param_2;\n  if (local_3c == 0) {\n    return 0;\n  }\n  local_10 = iVar1 - 1;\n  uVar7 = local_3c - 1;\n  if (uVar7 == 0) {\n    local_2c = *(uint *)(param_2 + 4);\n    if (local_2c == 1) {\n      uVar7 = *(uint *)(param_1 + 4);\n      *(undefined4 *)param_1 = 0;\n      _memcpy_s(param_1 + 4,0x1cc,local_21c,0);\n      return (__uint64)uVar7;\n    }\n    if (local_10 == 0) {\n      uVar7 = *(uint *)(param_1 + 4);\n      *(undefined4 *)param_1 = 0;\n      _memcpy_s(param_1 + 4,0x1cc,local_21c,0);\n      uVar5 = uVar7 % local_2c;\n      *(uint *)(param_1 + 4) = uVar5;\n      *(uint *)param_1 = (uint)(uVar5 != 0);\n      return (ulonglong)uVar7 / (ulonglong)local_2c;\n    }\n    uVar7 = 0;\n    local_c = 0;\n    local_8 = 0;\n    local_14 = (big_integer *)0x0;\n    if (local_10 != 0xffffffff) {\n      pbVar6 = param_1 + iVar1 * 4;\n      local_20 = iVar1;\n      do {\n        uVar12 = __aulldvrm(*(uint *)pbVar6,uVar7,local_2c,0);\n        local_48 = CONCAT44((int)((ulonglong)uVar12 >> 0x20),(undefined4)local_48);\n        pbVar6 = pbVar6 + -4;\n        local_14 = param_1;\n        local_8 = local_c;\n        local_20 = local_20 + -1;\n        uVar7 = extraout_ECX;\n        local_c = (int)uVar12;\n      } while (local_20 != 0);\n      local_20 = 0;\n    }\n    *(undefined4 *)param_1 = 0;\n    _memcpy_s(param_1 + 4,0x1cc,local_21c,0);\n    *(uint *)(param_1 + 4) = uVar7;\n    *(big_integer **)(param_1 + 8) = local_14;\n    *(uint *)param_1 = (local_14 != (big_integer *)0x0) + 1;\n    return CONCAT44(local_8,local_c);\n  }\n  if (uVar7 <= local_10) {\n    local_20 = local_10 - uVar7;\n    if (local_20 <= (int)local_10) {\n      pbVar6 = param_1 + iVar1 * 4;\n      pbVar8 = param_2 + (local_10 - local_20) * 4 + 4;\n      uVar7 = local_10;\n      do {\n        if (*(int *)pbVar8 != *(int *)pbVar6) {\n          if (*(uint *)(param_1 + uVar7 * 4 + 4) <= *(uint *)(param_2 + (uVar7 - local_20) * 4 + 4))\n          goto LAB_0041a266;\n          break;\n        }\n        uVar7 = uVar7 - 1;\n        pbVar8 = pbVar8 + -4;\n        pbVar6 = pbVar6 + -4;\n      } while (local_20 <= (int)uVar7);\n    }\n    local_20 = local_20 + 1;\nLAB_0041a266:\n    if (local_20 != 0) {\n      local_38 = *(uint *)(param_2 + local_3c * 4);\n      local_24 = *(uint *)(param_2 + local_3c * 4 + -4);\n      local_28 = 0x1f;\n      if (local_38 != 0) {\n        for (; local_38 >> local_28 == 0; local_28 = local_28 + -1) {\n        }\n      }\n      if (local_38 == 0) {\n        local_28 = 0x20;\n      }\n      else {\n        local_28 = 0x1f - local_28;\n      }\n      local_40 = 0x20 - local_28;\n      if (local_28 != 0) {\n        uVar7 = local_24 >> ((byte)local_40 & 0x1f);\n        local_24 = local_24 << ((byte)local_28 & 0x1f);\n        local_38 = local_38 << ((byte)local_28 & 0x1f) | uVar7;\n        if (2 < local_3c) {\n          local_24 = local_24 | *(uint *)(param_2 + local_3c * 4 + -8) >> ((byte)local_40 & 0x1f);\n        }\n      }\n      local_4c = 0;\n      local_20 = local_20 + -1;\n      if (local_20 < 0) {\n        uVar10 = 0;\n        local_4c = 0;\n      }\n      else {\n        local_14 = param_1 + local_20 * 4 + 4;\n        local_c = local_20 + local_3c;\n        local_50 = param_1 + local_c * 4 + -4;\n        uVar10 = local_4c;\n        do {\n          local_4c = uVar10;\n          if (local_10 < local_c) {\n            local_34 = 0;\n          }\n          else {\n            local_34 = *(uint *)(local_50 + 8);\n          }\n          uVar7 = *(uint *)(local_50 + 4);\n          local_18 = *(uint *)local_50;\n          local_2c = 0;\n          local_8 = local_34;\n          if (local_28 != 0) {\n            uVar7 = local_18 >> ((byte)local_40 & 0x1f);\n            lVar13 = __allshl((byte)local_28,local_34);\n            local_8 = (uint)((ulonglong)lVar13 >> 0x20);\n            uVar7 = uVar7 | (uint)lVar13;\n            local_18 = local_18 << ((byte)local_28 & 0x1f);\n            if (2 < local_c) {\n              local_18 = local_18 |\n                         *(uint *)(param_1 + (local_3c + local_20) * 4 + -8) >>\n                         ((byte)local_40 & 0x1f);\n            }\n          }\n          local_48 = __aulldvrm(uVar7,local_8,local_38,0);\n          local_1c = (int)(local_48 >> 0x20);\n          local_8 = (uint)local_48;\n          local_2c = 0;\n          uVar14 = (ulonglong)extraout_ECX_00;\n          if (local_1c != 0) {\n            lVar13 = __allmul((uint)(local_48 - 0xffffffff),(int)(local_48 - 0xffffffff >> 0x20),\n                              local_38,0);\n            uVar14 = lVar13 + uVar14;\n            local_2c = (uint)(uVar14 >> 0x20);\n            local_48 = 0xffffffff;\n          }\n          local_1c = (int)(local_48 >> 0x20);\n          uVar7 = (uint)uVar14;\n          uVar2 = local_48;\n          if ((int)(uVar14 >> 0x20) == 0) {\n            while( true ) {\n              uVar5 = (uint)local_48;\n              local_8 = local_18;\n              uVar14 = __allmul(local_24,0,uVar5,(int)(local_48 >> 0x20));\n              if (uVar14 <= CONCAT44(uVar7,local_8)) break;\n              bVar11 = uVar5 != 0;\n              uVar5 = uVar5 - 1;\n              local_1c = local_1c + -1 + (uint)bVar11;\n              bVar11 = CARRY4(uVar7,local_38);\n              uVar7 = uVar7 + local_38;\n              local_48 = CONCAT44(local_1c,uVar5);\n              if (local_2c + bVar11 != 0) break;\n              local_2c = 0;\n            }\n            uVar2 = CONCAT44(local_1c,uVar5);\n          }\n          if (uVar2 != 0) {\n            uVar5 = 0;\n            uVar7 = 0;\n            if (local_3c != 0) {\n              pbVar8 = param_2 + 4;\n              local_10 = local_3c;\n              pbVar6 = local_14;\n              do {\n                lVar13 = (local_48 & 0xffffffff) * (ulonglong)*(uint *)pbVar8;\n                uVar3 = (uint)lVar13;\n                uVar9 = uVar5 + uVar3;\n                uVar5 = uVar7 + (int)((ulonglong)lVar13 >> 0x20) + local_48._4_4_ * *(uint *)pbVar8\n                        + (uint)CARRY4(uVar5,uVar3);\n                uVar7 = 0;\n                if (*(uint *)pbVar6 < uVar9) {\n                  bVar11 = 0xfffffffe < uVar5;\n                  uVar5 = uVar5 + 1;\n                  uVar7 = (uint)bVar11;\n                }\n                *(uint *)pbVar6 = *(uint *)pbVar6 - uVar9;\n                pbVar6 = pbVar6 + 4;\n                pbVar8 = pbVar8 + 4;\n                local_10 = local_10 - 1;\n              } while (local_10 != 0);\n            }\n            if ((uVar7 != 0) || (local_34 < uVar5)) {\n              if (local_3c != 0) {\n                uVar5 = 0;\n                pbVar8 = local_14;\n                uVar7 = local_3c;\n                pbVar6 = param_2;\n                do {\n                  pbVar6 = pbVar6 + 4;\n                  uVar3 = *(uint *)pbVar8;\n                  uVar9 = *(uint *)pbVar6;\n                  uVar4 = uVar3 + *(uint *)pbVar6;\n                  *(uint *)pbVar8 = uVar4 + uVar5;\n                  uVar5 = (uint)CARRY4(uVar3,uVar9) + (uint)CARRY4(uVar4,uVar5);\n                  uVar7 = uVar7 - 1;\n                  pbVar8 = pbVar8 + 4;\n                } while (uVar7 != 0);\n              }\n              uVar2 = uVar2 - 1;\n            }\n            local_10 = local_c - 1;\n          }\n          local_1c = (int)(uVar2 >> 0x20);\n          uVar10 = (undefined4)uVar2;\n          local_14 = local_14 + -4;\n          local_20 = local_20 + -1;\n          local_50 = local_50 + -4;\n          local_c = local_c - 1;\n        } while (-1 < local_20);\n      }\n      uVar7 = local_10 + 1;\n      if (uVar7 < *(uint *)param_1) {\n        pbVar6 = param_1 + (local_10 + 2) * 4;\n        uVar5 = uVar7;\n        do {\n          *(undefined4 *)pbVar6 = 0;\n          pbVar6 = pbVar6 + 4;\n          uVar5 = uVar5 + 1;\n        } while (uVar5 < *(uint *)param_1);\n      }\n      *(uint *)param_1 = uVar7;\n      while ((uVar7 != 0 && (*(int *)(param_1 + *(int *)param_1 * 4) == 0))) {\n        uVar7 = *(int *)param_1 - 1;\n        *(uint *)param_1 = uVar7;\n      }\n      return CONCAT44(local_4c,uVar10);\n    }\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "___acrt_fltout",
      "entry": "0041a55e",
      "c": "\n/* Library Function - Single Match\n    ___acrt_fltout\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___acrt_fltout(int param_1,uint param_2,int param_3,int *param_4,char *param_5,rsize_t param_6)\n\n{\n  byte bVar1;\n  ulonglong uVar2;\n  bool bVar3;\n  int *piVar4;\n  char cVar5;\n  __acrt_fp_class _Var6;\n  rsize_t rVar7;\n  uint uVar8;\n  errno_t eVar9;\n  uint uVar10;\n  int iVar11;\n  undefined4 extraout_EDX;\n  uint *puVar12;\n  int iVar13;\n  uint *puVar14;\n  uint *puVar15;\n  uint *puVar16;\n  char *pcVar17;\n  uint *puVar18;\n  uint uVar19;\n  float10 fVar20;\n  ulonglong uVar21;\n  longlong lVar22;\n  __uint64 _Var23;\n  char *_Src;\n  double dVar24;\n  uint local_964 [115];\n  scoped_fp_state_reset local_798 [8];\n  char local_790;\n  int local_788;\n  int *local_784;\n  char *local_780;\n  char *local_77c;\n  uint local_778;\n  uint *local_774;\n  uint local_770;\n  undefined8 local_76c;\n  uint *local_764;\n  uint *local_760;\n  uint *local_75c;\n  uint *local_758;\n  uint *local_754;\n  uint *local_750;\n  undefined1 local_749;\n  uint *local_748;\n  uint local_744 [115];\n  uint *local_578;\n  uint local_574 [115];\n  uint *local_3a8;\n  uint local_3a4 [115];\n  uint *local_1d8;\n  uint local_1d4 [115];\n  uint local_8;\n  \n  pcVar17 = param_5;\n  piVar4 = param_4;\n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_784 = param_4;\n  local_780 = param_5;\n  _anon_3568B024::scoped_fp_state_reset::scoped_fp_state_reset(local_798);\n  uVar10 = param_2;\n  iVar11 = param_1;\n  cVar5 = '-';\n  if ((param_2 & 0x80000000) == 0) {\n    cVar5 = ' ';\n  }\n  *piVar4 = (int)cVar5;\n  piVar4[2] = (int)pcVar17;\n  if (((param_2 & 0x7ff00000) == 0) && (param_1 == 0 && (param_2 & 0xfffff) == 0)) {\n    _Src = \"0\";\n    local_784[1] = 0;\n  }\n  else {\n    _Var6 = __acrt_fp_classify((double *)&param_1);\n    if (_Var6 != 0) {\n      local_784[1] = 1;\n    }\n    if (_Var6 == 1) {\n      _Src = \"1#INF\";\n    }\n    else if (_Var6 == 2) {\n      _Src = \"1#QNAN\";\n    }\n    else if (_Var6 == 3) {\n      _Src = \"1#SNAN\";\n    }\n    else {\n      if (_Var6 != 4) {\n        param_2 = uVar10 & 0x7fffffff;\n        local_788 = 0;\n        local_77c = (char *)(param_3 + 1);\n        uVar21 = CONCAT44(uVar10,iVar11) & 0x7fffffffffffffff;\n        local_76c._4_4_ = (uint)(uVar21 >> 0x20);\n        uVar10 = local_76c._4_4_ >> 0x14;\n        if (uVar10 != 0) {\n          iVar13 = 0x100000;\n        }\n        else {\n          iVar13 = 0;\n        }\n        local_76c._0_4_ = (uint)uVar21;\n        uVar8 = (uint)local_76c;\n        uVar19 = (local_76c._4_4_ & 0xfffff) + iVar13;\n        puVar14 = (uint *)(uVar10 + ((uVar10 == 0) - 0x433));\n        param_1 = iVar11;\n        local_76c = uVar21;\n        local_750 = puVar14;\n        fVar20 = (float10)FUN_0041da50();\n        dVar24 = (double)fVar20;\n        FUN_0041db60(dVar24);\n        uVar21 = FUN_00420170((int)((ulonglong)dVar24 >> 0x20),extraout_EDX);\n        local_770 = (uint)uVar21;\n        if ((local_770 == 0x7fffffff) || (local_770 == 0x80000000)) {\n          local_770 = 0;\n        }\n        local_1d4[0] = uVar8;\n        local_1d4[1] = uVar19;\n        uVar10 = (uint)(uVar19 != 0);\n        puVar12 = (uint *)(uVar10 + 1);\n        local_1d8 = puVar12;\n        if ((int)puVar14 < 0) {\n          if (puVar14 == (uint *)0xfffffc02) {\nLAB_0041ac00:\n            uVar10 = local_1d4[uVar10];\n            local_76c = local_76c & 0xffffffff;\n            iVar11 = 0x1f;\n            if (uVar10 != 0) {\n              for (; uVar10 >> iVar11 == 0; iVar11 = iVar11 + -1) {\n              }\n            }\n            if (uVar10 == 0) {\n              iVar11 = 0;\n            }\n            else {\n              iVar11 = iVar11 + 1;\n            }\n            local_749 = iVar11 == 0x20;\n            if ((puVar12 == (uint *)0x73) && ((bool)local_749)) {\n              bVar3 = true;\n            }\n            else {\n              bVar3 = false;\n            }\n            if (((uint *)0x73 < puVar12) || (bVar3)) {\n              local_578 = (uint *)0x0;\n              local_1d8 = (uint *)0x0;\n              _memcpy_s(local_1d4,0x1cc,local_574,0);\n            }\n            else {\n              puVar15 = (uint *)0x72;\n              if (puVar12 < (uint *)0x72) {\n                puVar15 = puVar12;\n              }\n              if (puVar15 != (uint *)0xffffffff) {\n                puVar18 = local_1d4 + (int)puVar15;\n                puVar16 = puVar15;\n                local_758 = puVar18;\n                do {\n                  if (puVar16 < puVar12) {\n                    local_754 = (uint *)*puVar18;\n                  }\n                  else {\n                    local_754 = (uint *)0x0;\n                  }\n                  if ((uint *)((int)puVar16 + -1) < puVar12) {\n                    uVar10 = puVar18[-1];\n                  }\n                  else {\n                    uVar10 = 0;\n                  }\n                  puVar18 = puVar18 + -1;\n                  puVar16 = (uint *)((int)puVar16 + -1);\n                  *local_758 = uVar10 >> 0x1f ^ (int)local_754 * 2;\n                  local_758 = local_758 + -1;\n                  puVar12 = local_1d8;\n                  puVar14 = local_750;\n                } while (puVar16 != (uint *)0xffffffff);\n              }\n              local_1d8 = puVar15;\n              if ((bool)local_749) {\n                local_1d8 = (uint *)((int)puVar15 + 1);\n              }\n            }\n            uVar10 = 1U - (int)puVar14 >> 5;\n            _memset(local_574,0,uVar10 * 4);\n            local_574[uVar10] = 1 << ((byte)(1U - (int)puVar14) & 0x1f);\n          }\n          else {\n            local_574[0] = 0;\n            puVar15 = (uint *)0x2;\n            local_574[1] = 0x100000;\n            local_578 = (uint *)0x2;\n            if (puVar12 != (uint *)0x2) goto LAB_0041ac00;\n            iVar11 = 0;\n            do {\n              if (*(int *)((int)local_574 + iVar11) != *(int *)((int)local_1d4 + iVar11))\n              goto LAB_0041ac00;\n              iVar11 = iVar11 + 4;\n            } while (iVar11 != 8);\n            local_76c = local_76c & 0xffffffff;\n            iVar11 = 0x1f;\n            if (uVar19 != 0) {\n              for (; uVar19 >> iVar11 == 0; iVar11 = iVar11 + -1) {\n              }\n            }\n            if (uVar19 == 0) {\n              iVar11 = 0;\n            }\n            else {\n              iVar11 = iVar11 + 1;\n            }\n            local_749 = 0x20U - iVar11 < 2;\n            puVar14 = local_1d4 + 2;\n            local_758 = puVar14;\n            do {\n              if (puVar15 < puVar12) {\n                local_754 = (uint *)*puVar14;\n              }\n              else {\n                local_754 = (uint *)0x0;\n              }\n              if ((uint *)((int)puVar15 + -1) < puVar12) {\n                uVar10 = puVar14[-1];\n              }\n              else {\n                uVar10 = 0;\n              }\n              puVar14 = puVar14 + -1;\n              puVar15 = (uint *)((int)puVar15 + -1);\n              *local_758 = uVar10 >> 0x1e ^ (int)local_754 << 2;\n              local_758 = local_758 + -1;\n              puVar12 = local_1d8;\n            } while (puVar15 != (uint *)0xffffffff);\n            local_1d8 = (uint *)((byte)local_749 + 2);\n            local_75c = (uint *)(2 - (int)local_750);\n            uVar10 = (uint)local_75c >> 5;\n            _memset(local_574,0,uVar10 * 4);\n            local_574[uVar10] = 1 << ((byte)local_75c & 0x1f);\n          }\n          local_578 = (uint *)(uVar10 + 1);\n          local_3a8 = local_578;\n          _memcpy_s(local_3a4,0x1cc,local_574,(int)local_578 * 4);\n        }\n        else {\n          local_574[0] = 0;\n          local_574[1] = 0x100000;\n          local_578 = (uint *)0x2;\n          if (puVar12 == (uint *)0x2) {\n            iVar11 = 0;\n            do {\n              if (*(int *)((int)local_574 + iVar11) != *(int *)((int)local_1d4 + iVar11))\n              goto LAB_0041a910;\n              iVar11 = iVar11 + 4;\n            } while (iVar11 != 8);\n            local_760 = (uint *)((int)local_750 + 2U & 0x1f);\n            local_774 = (uint *)(0x20 - (int)local_760);\n            puVar14 = (uint *)((int)local_750 + 2U >> 5);\n            local_754 = puVar14;\n            lVar22 = __allshl((byte)local_774,0);\n            local_76c = local_76c & 0xffffffff;\n            local_75c = (uint *)((int)lVar22 + -1);\n            iVar11 = 0x1f;\n            if (uVar19 != 0) {\n              for (; uVar19 >> iVar11 == 0; iVar11 = iVar11 + -1) {\n              }\n            }\n            local_778 = ~(uint)local_75c;\n            if (uVar19 == 0) {\n              iVar11 = 0;\n            }\n            else {\n              iVar11 = iVar11 + 1;\n            }\n            local_758 = (uint *)((int)puVar14 + 2);\n            local_749 = (uint *)(0x20 - iVar11) < local_760;\n            if ((local_758 == (uint *)0x73) && ((bool)local_749)) {\n              bVar3 = true;\n            }\n            else {\n              bVar3 = false;\n            }\n            if ((0x73 < local_758) || (bVar3)) {\n              local_578 = (uint *)0x0;\n              local_1d8 = (uint *)0x0;\n              _memcpy_s(local_1d4,0x1cc,local_574,0);\n            }\n            else {\n              if (0x71 < local_758) {\n                local_758 = (uint *)0x72;\n              }\n              local_764 = local_758;\n              if (local_758 != (uint *)0xffffffff) {\n                puVar15 = (uint *)((int)local_758 - (int)local_754);\n                local_750 = local_1d4 + (int)puVar15;\n                do {\n                  puVar14 = local_754;\n                  if (local_764 < local_754) break;\n                  if (puVar15 < puVar12) {\n                    uVar10 = *local_750;\n                  }\n                  else {\n                    uVar10 = 0;\n                  }\n                  if ((uint *)((int)puVar15 + -1) < puVar12) {\n                    uVar19 = local_750[-1];\n                  }\n                  else {\n                    uVar19 = 0;\n                  }\n                  local_1d4[(int)local_764] =\n                       (uVar19 & local_778) >> ((byte)local_774 & 0x1f) |\n                       (uVar10 & (uint)local_75c) << ((byte)local_760 & 0x1f);\n                  local_764 = (uint *)((int)local_764 + -1);\n                  puVar15 = (uint *)((int)puVar15 + -1);\n                  local_750 = local_750 + -1;\n                  puVar12 = local_1d8;\n                } while (local_764 != (uint *)0xffffffff);\n              }\n              if (puVar14 != (uint *)0x0) {\n                puVar12 = local_1d4;\n                for (; puVar14 != (uint *)0x0; puVar14 = (uint *)((int)puVar14 + -1)) {\n                  *puVar12 = 0;\n                  puVar12 = puVar12 + 1;\n                }\n              }\n              local_1d8 = local_758;\n              if ((bool)local_749) {\n                local_1d8 = (uint *)((int)local_758 + 1);\n              }\n            }\n            local_574[0] = 4;\n          }\n          else {\nLAB_0041a910:\n            local_754 = (uint *)((int)local_750 + 1U & 0x1f);\n            local_774 = (uint *)(0x20 - (int)local_754);\n            puVar14 = (uint *)((int)local_750 + 1U >> 5);\n            local_750 = puVar14;\n            lVar22 = __allshl((byte)local_774,0);\n            uVar10 = local_1d4[uVar10];\n            local_75c = (uint *)((int)lVar22 + -1);\n            local_76c = local_76c & 0xffffffff;\n            iVar11 = 0x1f;\n            if (uVar10 != 0) {\n              for (; uVar10 >> iVar11 == 0; iVar11 = iVar11 + -1) {\n              }\n            }\n            local_778 = ~(uint)local_75c;\n            if (uVar10 == 0) {\n              iVar11 = 0;\n            }\n            else {\n              iVar11 = iVar11 + 1;\n            }\n            local_764 = (uint *)((int)puVar12 + (int)puVar14);\n            local_749 = (uint *)(0x20 - iVar11) < local_754;\n            if ((local_764 == (uint *)0x73) && ((bool)local_749)) {\n              bVar3 = true;\n            }\n            else {\n              bVar3 = false;\n            }\n            if (((uint *)0x73 < local_764) || (bVar3)) {\n              local_578 = (uint *)0x0;\n              local_1d8 = (uint *)0x0;\n              _memcpy_s(local_1d4,0x1cc,local_574,0);\n            }\n            else {\n              if ((uint *)0x71 < local_764) {\n                local_764 = (uint *)0x72;\n              }\n              local_758 = local_764;\n              if (local_764 != (uint *)0xffffffff) {\n                puVar15 = (uint *)((int)local_764 - (int)local_750);\n                local_760 = local_1d4 + (int)puVar15;\n                do {\n                  puVar14 = local_750;\n                  if (local_758 < local_750) break;\n                  if (puVar15 < puVar12) {\n                    uVar10 = *local_760;\n                  }\n                  else {\n                    uVar10 = 0;\n                  }\n                  if ((uint *)((int)puVar15 + -1) < puVar12) {\n                    uVar19 = local_760[-1];\n                  }\n                  else {\n                    uVar19 = 0;\n                  }\n                  local_760 = local_760 + -1;\n                  local_1d4[(int)local_758] =\n                       (uVar10 & (uint)local_75c) << ((byte)local_754 & 0x1f) |\n                       (uVar19 & local_778) >> ((byte)local_774 & 0x1f);\n                  local_758 = (uint *)((int)local_758 + -1);\n                  puVar15 = (uint *)((int)puVar15 + -1);\n                  puVar12 = local_1d8;\n                } while (local_758 != (uint *)0xffffffff);\n              }\n              if (puVar14 != (uint *)0x0) {\n                puVar12 = local_1d4;\n                for (; puVar14 != (uint *)0x0; puVar14 = (uint *)((int)puVar14 + -1)) {\n                  *puVar12 = 0;\n                  puVar12 = puVar12 + 1;\n                }\n              }\n              local_1d8 = local_764;\n              if ((bool)local_749) {\n                local_1d8 = (uint *)((int)local_764 + 1);\n              }\n            }\n            local_574[0] = 2;\n          }\n          local_3a8 = (uint *)0x1;\n          local_574[1] = 0;\n          local_578 = (uint *)0x1;\n          _memcpy_s(local_3a4,0x1cc,local_574,4);\n        }\n        local_778 = 10;\n        if ((int)local_770 < 0) {\n          local_75c = (uint *)(-local_770 % 10);\n          for (local_758 = (uint *)(-local_770 / 10); local_758 != (uint *)0x0;\n              local_758 = (uint *)((int)local_758 - (int)local_750)) {\n            local_750 = local_758;\n            if ((uint *)0x26 < local_758) {\n              local_750 = (uint *)0x26;\n            }\n            uVar10 = (uint)(byte)(&DAT_0042aa56)[(int)local_750 * 4];\n            bVar1 = (&DAT_0042aa57)[(int)local_750 * 4];\n            local_578 = (uint *)(uVar10 + bVar1);\n            _memset(local_574,0,uVar10 * 4);\n            FUN_00408c90(local_574 + uVar10,\n                         (uint *)(&UNK_0042a150 +\n                                 (uint)*(ushort *)(&UNK_0042aa54 + (int)local_750 * 4) * 4),\n                         (uint)bVar1 << 2);\n            uVar10 = local_1d4[0];\n            local_764 = local_578;\n            if (local_578 < (uint *)0x2) {\n              if (local_574[0] == 0) {\nLAB_0041b289:\n                local_1d8 = (uint *)0x0;\n                rVar7 = 0;\n                puVar14 = local_964;\n                goto LAB_0041b515;\n              }\n              if ((local_574[0] == 1) || (local_1d8 == (uint *)0x0)) goto LAB_0041b526;\n              uVar19 = 0;\n              local_76c = CONCAT44(local_1d8,(uint)local_76c);\n              puVar14 = (uint *)0x0;\n              do {\n                lVar22 = (ulonglong)local_574[0] * (ulonglong)local_1d4[(int)puVar14] +\n                         (ulonglong)uVar19;\n                local_1d4[(int)puVar14] = (uint)lVar22;\n                uVar19 = (uint)((ulonglong)lVar22 >> 0x20);\n                puVar14 = (uint *)((int)puVar14 + 1);\n              } while (puVar14 != local_1d8);\nLAB_0041b2e9:\n              if (uVar19 == 0) goto LAB_0041b526;\n              if (local_1d8 < (uint *)0x73) {\n                local_1d4[(int)local_1d8] = uVar19;\n                local_1d8 = (uint *)((int)local_1d8 + 1);\n                goto LAB_0041b526;\n              }\nLAB_0041b5c4:\n              local_1d8 = (uint *)0x0;\n              _memcpy_s(local_1d4,0x1cc,local_964,0);\n              bVar3 = false;\n            }\n            else {\n              if (local_1d8 < (uint *)0x2) {\n                local_1d8 = local_578;\n                _memcpy_s(local_1d4,0x1cc,local_574,(int)local_578 << 2);\n                if (uVar10 != 0) {\n                  if ((uVar10 != 1) && (local_1d8 != (uint *)0x0)) {\n                    uVar19 = 0;\n                    local_76c = CONCAT44(local_1d8,(uint)local_76c);\n                    puVar14 = (uint *)0x0;\n                    do {\n                      lVar22 = (ulonglong)uVar10 * (ulonglong)local_1d4[(int)puVar14] +\n                               (ulonglong)uVar19;\n                      local_1d4[(int)puVar14] = (uint)lVar22;\n                      uVar19 = (uint)((ulonglong)lVar22 >> 0x20);\n                      puVar14 = (uint *)((int)puVar14 + 1);\n                    } while (puVar14 != local_1d8);\n                    goto LAB_0041b2e9;\n                  }\n                  goto LAB_0041b526;\n                }\n                goto LAB_0041b289;\n              }\n              puVar14 = local_574;\n              if (local_578 < local_1d8) {\n                local_774 = local_1d4;\n                local_764 = local_1d8;\n                local_754 = local_578;\n              }\n              else {\n                puVar14 = local_1d4;\n                local_774 = local_574;\n                local_754 = local_1d8;\n              }\n              local_1d8 = (uint *)0x0;\n              puVar12 = (uint *)0x0;\n              local_748 = (uint *)0x0;\n              if (local_754 != (uint *)0x0) {\n                local_788 = (int)puVar14 - (int)local_744;\n                do {\n                  uVar10 = *(uint *)((int)local_744 + local_788 + (int)puVar12 * 4);\n                  local_76c = CONCAT44(uVar10,(uint)local_76c);\n                  if (uVar10 == 0) {\n                    if (puVar12 == local_1d8) {\n                      local_744[(int)puVar12] = 0;\n                      local_1d8 = (uint *)((int)puVar12 + 1);\n                      local_748 = local_1d8;\n                    }\n                  }\n                  else {\n                    uVar19 = 0;\n                    local_760 = (uint *)0x0;\n                    puVar14 = puVar12;\n                    if (local_764 != (uint *)0x0) {\n                      do {\n                        if (puVar14 == (uint *)0x73) break;\n                        if (puVar14 == local_1d8) {\n                          local_744[(int)puVar14] = 0;\n                          local_748 = (uint *)((int)local_760 + 1U + (int)puVar12);\n                        }\n                        lVar22 = (ulonglong)local_774[(int)local_760] * (ulonglong)uVar10 +\n                                 (ulonglong)uVar19;\n                        uVar8 = (uint)lVar22;\n                        puVar15 = local_744 + (int)puVar14;\n                        uVar19 = *puVar15;\n                        *puVar15 = *puVar15 + uVar8;\n                        uVar19 = (int)((ulonglong)lVar22 >> 0x20) + (uint)CARRY4(uVar19,uVar8);\n                        local_760 = (uint *)((int)local_760 + 1);\n                        puVar14 = (uint *)((int)puVar14 + 1);\n                        local_1d8 = local_748;\n                      } while (local_760 != local_764);\n                      do {\n                        if (uVar19 == 0) break;\n                        if (puVar14 == (uint *)0x73) goto LAB_0041b5c4;\n                        if (puVar14 == local_1d8) {\n                          local_744[(int)puVar14] = 0;\n                          local_748 = (uint *)((int)puVar14 + 1);\n                        }\n                        puVar15 = local_744 + (int)puVar14;\n                        uVar10 = *puVar15;\n                        *puVar15 = *puVar15 + uVar19;\n                        uVar19 = (uint)CARRY4(uVar10,uVar19);\n                        puVar14 = (uint *)((int)puVar14 + 1);\n                        local_1d8 = local_748;\n                      } while( true );\n                    }\n                    if (puVar14 == (uint *)0x73) goto LAB_0041b5c4;\n                  }\n                  puVar12 = (uint *)((int)puVar12 + 1);\n                } while (puVar12 != local_754);\n              }\n              rVar7 = (int)local_1d8 << 2;\n              puVar14 = local_744;\nLAB_0041b515:\n              _memcpy_s(local_1d4,0x1cc,puVar14,rVar7);\nLAB_0041b526:\n              bVar3 = true;\n            }\n            if (!bVar3) goto LAB_0041b612;\n          }\n          if (local_75c != (uint *)0x0) {\n            uVar10 = *(uint *)(&DAT_0042aaec + (int)local_75c * 2);\n            local_76c = CONCAT44(uVar10,(uint)local_76c);\n            if (uVar10 == 0) {\nLAB_0041b612:\n              local_1d8 = (uint *)0x0;\n              puVar14 = local_1d4;\n              goto LAB_0041b61f;\n            }\n            if ((uVar10 != 1) && (local_1d8 != (uint *)0x0)) {\n              uVar19 = 0;\n              puVar14 = (uint *)0x0;\n              do {\n                lVar22 = (ulonglong)uVar10 * (ulonglong)local_1d4[(int)puVar14] + (ulonglong)uVar19;\n                local_1d4[(int)puVar14] = (uint)lVar22;\n                uVar19 = (uint)((ulonglong)lVar22 >> 0x20);\n                puVar14 = (uint *)((int)puVar14 + 1);\n              } while (puVar14 != local_1d8);\n              if (uVar19 != 0) {\n                if ((uint *)0x72 < local_1d8) goto LAB_0041b612;\n                local_1d4[(int)local_1d8] = uVar19;\n                local_1d8 = (uint *)((int)local_1d8 + 1);\n              }\n            }\n          }\n        }\n        else {\n          local_774 = (uint *)(local_770 / 10);\n          local_76c = CONCAT44(local_770 % 10,(uint)local_76c);\n          uVar10 = local_770 % 10;\n          if (local_774 != (uint *)0x0) {\n            do {\n              local_760 = local_774;\n              if ((uint *)0x26 < local_774) {\n                local_760 = (uint *)0x26;\n              }\n              uVar10 = (uint)(byte)(&DAT_0042aa56)[(int)local_760 * 4];\n              bVar1 = (&DAT_0042aa57)[(int)local_760 * 4];\n              local_578 = (uint *)(uVar10 + bVar1);\n              _memset(local_574,0,uVar10 * 4);\n              FUN_00408c90(local_574 + uVar10,\n                           (uint *)(&UNK_0042a150 +\n                                   (uint)*(ushort *)(&UNK_0042aa54 + (int)local_760 * 4) * 4),\n                           (uint)bVar1 << 2);\n              uVar10 = local_3a4[0];\n              local_764 = local_578;\n              if (local_578 < (uint *)0x2) {\n                if (local_574[0] == 0) {\n                  rVar7 = 0;\n                  local_748 = (uint *)0x0;\n                  local_3a8 = (uint *)0x0;\nLAB_0041b0d2:\n                  puVar14 = local_744;\n                  goto LAB_0041b0d9;\n                }\n                if ((local_574[0] == 1) || (local_3a8 == (uint *)0x0)) goto LAB_0041b0ea;\n                uVar19 = 0;\n                puVar14 = (uint *)0x0;\n                do {\n                  lVar22 = (ulonglong)local_574[0] * (ulonglong)local_3a4[(int)puVar14] +\n                           (ulonglong)uVar19;\n                  local_3a4[(int)puVar14] = (uint)lVar22;\n                  uVar19 = (uint)((ulonglong)lVar22 >> 0x20);\n                  puVar14 = (uint *)((int)puVar14 + 1);\n                } while (puVar14 != local_3a8);\nLAB_0041af2a:\n                local_75c = local_3a8;\n                if (uVar19 == 0) goto LAB_0041b0ea;\n                if (local_3a8 < (uint *)0x73) {\n                  local_3a4[(int)local_3a8] = uVar19;\n                  local_3a8 = (uint *)((int)local_3a8 + 1);\n                  goto LAB_0041b0ea;\n                }\n                local_578 = (uint *)0x0;\n                puVar14 = local_574;\nLAB_0041b147:\n                local_3a8 = (uint *)0x0;\n                _memcpy_s(local_3a4,0x1cc,puVar14,0);\n                bVar3 = false;\n              }\n              else {\n                if ((uint *)0x1 < local_3a8) {\n                  puVar14 = local_574;\n                  if (local_578 < local_3a8) {\n                    local_754 = local_3a4;\n                    local_764 = local_3a8;\n                    local_758 = local_578;\n                  }\n                  else {\n                    puVar14 = local_3a4;\n                    local_754 = local_574;\n                    local_758 = local_3a8;\n                  }\n                  local_3a8 = (uint *)0x0;\n                  puVar12 = (uint *)0x0;\n                  local_748 = (uint *)0x0;\n                  if (local_758 != (uint *)0x0) {\n                    local_788 = (int)puVar14 - (int)local_744;\n                    do {\n                      local_75c = *(uint **)((int)local_744 + local_788 + (int)puVar12 * 4);\n                      if (local_75c == (uint *)0x0) {\n                        if (puVar12 == local_3a8) {\n                          local_744[(int)puVar12] = 0;\n                          local_3a8 = (uint *)((int)puVar12 + 1);\n                          local_748 = local_3a8;\n                        }\n                      }\n                      else {\n                        uVar10 = 0;\n                        local_750 = (uint *)0x0;\n                        puVar14 = puVar12;\n                        if (local_764 != (uint *)0x0) {\n                          do {\n                            if (puVar14 == (uint *)0x73) break;\n                            if (puVar14 == local_3a8) {\n                              local_744[(int)puVar14] = 0;\n                              local_748 = (uint *)((int)local_750 + 1U + (int)puVar12);\n                            }\n                            lVar22 = (ulonglong)local_754[(int)local_750] * ZEXT48(local_75c) +\n                                     (ulonglong)uVar10;\n                            uVar19 = (uint)lVar22;\n                            puVar15 = local_744 + (int)puVar14;\n                            uVar10 = *puVar15;\n                            *puVar15 = *puVar15 + uVar19;\n                            uVar10 = (int)((ulonglong)lVar22 >> 0x20) + (uint)CARRY4(uVar10,uVar19);\n                            local_750 = (uint *)((int)local_750 + 1);\n                            puVar14 = (uint *)((int)puVar14 + 1);\n                            local_3a8 = local_748;\n                          } while (local_750 != local_764);\n                          do {\n                            if (uVar10 == 0) break;\n                            if (puVar14 == (uint *)0x73) goto LAB_0041b132;\n                            if (puVar14 == local_3a8) {\n                              local_744[(int)puVar14] = 0;\n                              local_748 = (uint *)((int)puVar14 + 1);\n                            }\n                            puVar15 = local_744 + (int)puVar14;\n                            uVar19 = *puVar15;\n                            *puVar15 = *puVar15 + uVar10;\n                            uVar10 = (uint)CARRY4(uVar19,uVar10);\n                            puVar14 = (uint *)((int)puVar14 + 1);\n                            local_3a8 = local_748;\n                          } while( true );\n                        }\n                        if (puVar14 == (uint *)0x73) {\nLAB_0041b132:\n                          puVar14 = local_964;\n                          goto LAB_0041b147;\n                        }\n                      }\n                      puVar12 = (uint *)((int)puVar12 + 1);\n                    } while (puVar12 != local_758);\n                  }\n                  rVar7 = (int)local_3a8 << 2;\n                  goto LAB_0041b0d2;\n                }\n                local_3a8 = local_578;\n                _memcpy_s(local_3a4,0x1cc,local_574,(int)local_578 << 2);\n                if (uVar10 != 0) {\n                  if ((uVar10 != 1) && (local_3a8 != (uint *)0x0)) {\n                    uVar19 = 0;\n                    puVar14 = (uint *)0x0;\n                    do {\n                      lVar22 = (ulonglong)uVar10 * (ulonglong)local_3a4[(int)puVar14] +\n                               (ulonglong)uVar19;\n                      local_3a4[(int)puVar14] = (uint)lVar22;\n                      uVar19 = (uint)((ulonglong)lVar22 >> 0x20);\n                      puVar14 = (uint *)((int)puVar14 + 1);\n                    } while (puVar14 != local_3a8);\n                    goto LAB_0041af2a;\n                  }\n                  goto LAB_0041b0ea;\n                }\n                local_578 = (uint *)0x0;\n                local_3a8 = (uint *)0x0;\n                rVar7 = 0;\n                puVar14 = local_574;\nLAB_0041b0d9:\n                _memcpy_s(local_3a4,0x1cc,puVar14,rVar7);\nLAB_0041b0ea:\n                bVar3 = true;\n              }\n              if (!bVar3) goto LAB_0041b16c;\n              local_774 = (uint *)((int)local_774 - (int)local_760);\n            } while (local_774 != (uint *)0x0);\n            uVar10 = local_76c._4_4_;\n          }\n          if (uVar10 != 0) {\n            uVar10 = *(uint *)(&DAT_0042aaec + uVar10 * 2);\n            if (uVar10 == 0) {\nLAB_0041b16c:\n              local_3a8 = (uint *)0x0;\n              puVar14 = local_3a4;\nLAB_0041b61f:\n              _memcpy_s(puVar14,0x1cc,local_964,0);\n            }\n            else if (uVar10 != 1) {\n              local_76c = CONCAT44(local_3a8,(uint)local_76c);\n              if (local_3a8 != (uint *)0x0) {\n                uVar19 = 0;\n                puVar14 = (uint *)0x0;\n                do {\n                  lVar22 = (ulonglong)uVar10 * (ulonglong)local_3a4[(int)puVar14] +\n                           (ulonglong)uVar19;\n                  local_3a4[(int)puVar14] = (uint)lVar22;\n                  uVar19 = (uint)((ulonglong)lVar22 >> 0x20);\n                  puVar14 = (uint *)((int)puVar14 + 1);\n                } while (puVar14 != local_3a8);\n                if (uVar19 != 0) {\n                  if ((uint *)0x72 < local_3a8) goto LAB_0041b16c;\n                  local_3a4[(int)local_3a8] = uVar19;\n                  local_3a8 = (uint *)((int)local_3a8 + 1);\n                }\n              }\n            }\n          }\n        }\n        pcVar17 = local_780;\n        local_750 = (uint *)local_780;\n        if (local_1d8 != (uint *)0x0) {\n          uVar10 = 0;\n          puVar14 = (uint *)0x0;\n          do {\n            lVar22 = (ulonglong)local_1d4[(int)puVar14] * 10 + (ulonglong)uVar10;\n            local_1d4[(int)puVar14] = (uint)lVar22;\n            uVar10 = (uint)((ulonglong)lVar22 >> 0x20);\n            puVar14 = (uint *)((int)puVar14 + 1);\n          } while (puVar14 != local_1d8);\n          local_76c = CONCAT44(uVar10,(uint)local_76c);\n          if (uVar10 != 0) {\n            if (local_1d8 < (uint *)0x73) {\n              local_1d4[(int)local_1d8] = uVar10;\n              local_1d8 = (uint *)((int)local_1d8 + 1);\n            }\n            else {\n              local_1d8 = (uint *)0x0;\n              _memcpy_s(local_1d4,0x1cc,local_964,0);\n            }\n          }\n        }\n        _Var23 = __crt_strtox::divide((big_integer *)&local_1d8,(big_integer *)&local_3a8);\n        if ((int)_Var23 == 10) {\n          local_770 = local_770 + 1;\n          local_750 = (uint *)(pcVar17 + 1);\n          *pcVar17 = '1';\n          if (local_3a8 != (uint *)0x0) {\n            uVar10 = 0;\n            puVar14 = (uint *)0x0;\n            do {\n              lVar22 = (ulonglong)local_3a4[(int)puVar14] * 10 + (ulonglong)uVar10;\n              local_3a4[(int)puVar14] = (uint)lVar22;\n              uVar10 = (uint)((ulonglong)lVar22 >> 0x20);\n              puVar14 = (uint *)((int)puVar14 + 1);\n            } while (puVar14 != local_3a8);\n            if (uVar10 != 0) {\n              if (local_3a8 < (uint *)0x73) {\n                local_3a4[(int)local_3a8] = uVar10;\n                local_3a8 = (uint *)((int)local_3a8 + 1);\n              }\n              else {\n                local_3a8 = (uint *)0x0;\n                _memcpy_s(local_3a4,0x1cc,local_964,0);\n              }\n            }\n          }\nLAB_0041b783:\n          pcVar17 = pcVar17 + 1;\n          uVar10 = local_770;\n        }\n        else {\n          if ((int)_Var23 != 0) {\n            local_750 = (uint *)(pcVar17 + 1);\n            *pcVar17 = (char)_Var23 + '0';\n            goto LAB_0041b783;\n          }\n          uVar10 = local_770 - 1;\n        }\n        local_784[1] = uVar10;\n        if ((-1 < (int)uVar10) && (local_77c < 0x80000000)) {\n          local_77c = (char *)((int)local_77c + uVar10);\n        }\n        uVar10 = param_6 - 1;\n        if (local_77c <= param_6 - 1) {\n          uVar10 = (uint)local_77c;\n        }\n        local_77c = local_780 + uVar10;\n        if (pcVar17 != local_77c) {\n          do {\n            puVar14 = local_750;\n            if (local_1d8 == (uint *)0x0) break;\n            uVar10 = 0;\n            puVar12 = (uint *)0x0;\n            do {\n              lVar22 = (ulonglong)local_1d4[(int)puVar12] * 1000000000 + (ulonglong)uVar10;\n              local_1d4[(int)puVar12] = (uint)lVar22;\n              uVar10 = (uint)((ulonglong)lVar22 >> 0x20);\n              puVar12 = (uint *)((int)puVar12 + 1);\n            } while (puVar12 != local_1d8);\n            if (uVar10 != 0) {\n              if (local_1d8 < (uint *)0x73) {\n                local_1d4[(int)local_1d8] = uVar10;\n                local_1d8 = (uint *)((int)local_1d8 + 1);\n              }\n              else {\n                local_1d8 = (uint *)0x0;\n                _memcpy_s(local_1d4,0x1cc,local_964,0);\n              }\n            }\n            uVar21 = __crt_strtox::divide((big_integer *)&local_1d8,(big_integer *)&local_3a8);\n            uVar19 = 8;\n            uVar10 = (int)local_77c - (int)puVar14;\n            do {\n              uVar2 = uVar21 & 0xffffffff;\n              uVar21 = uVar2 / local_778;\n              if (uVar19 <= uVar10) {\n                *(char *)((int)puVar14 + uVar19) = (char)(uVar2 % (ulonglong)local_778) + '0';\n              }\n              uVar19 = uVar19 - 1;\n            } while (uVar19 != 0xffffffff);\n            if (9 < uVar10) {\n              uVar10 = 9;\n            }\n            pcVar17 = (char *)((int)puVar14 + uVar10);\n            local_750 = (uint *)pcVar17;\n          } while (pcVar17 != local_77c);\n        }\n        *pcVar17 = '\\0';\n        goto LAB_0041b8c6;\n      }\n      _Src = \"1#IND\";\n    }\n  }\n  eVar9 = _strcpy_s(pcVar17,param_6,_Src);\n  if (eVar9 != 0) {\n                    /* WARNING: Subroutine does not return */\n    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  }\nLAB_0041b8c6:\n  if (local_790 != '\\0') {\n    fesetenv((uint *)local_798);\n  }\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "__towlower_l",
      "entry": "0041b8fa",
      "c": "\n/* Library Function - Single Match\n    __towlower_l\n   \n   Library: Visual Studio 2015 Release */\n\nwint_t __cdecl __towlower_l(wint_t _C,_locale_t _Locale)\n\n{\n  int iVar1;\n  undefined2 in_stack_00000006;\n  int local_1c;\n  int local_18;\n  char local_10;\n  WCHAR local_8 [2];\n  \n  if (_C == 0xffff) {\n    return 0xffff;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,(__crt_locale_pointers *)_Locale);\n  if (*(wchar_t **)(local_18 + 0xa8) == (wchar_t *)0x0) {\n    if ((ushort)(_C - 0x41) < 0x1a) {\n      __C = (uint)(ushort)(_C + 0x20);\n    }\n  }\n  else {\n    if (0xff < _C) {\n      iVar1 = ___acrt_LCMapStringW(*(wchar_t **)(local_18 + 0xa8),0x100,(LPCWSTR)&_C,1,local_8,1);\n      if (iVar1 == 0) {\n        local_8[0] = (WCHAR)__C;\n      }\n      goto LAB_0041b9af;\n    }\n    iVar1 = _iswctype(_C,1);\n    if (iVar1 != 0) {\n      local_8[0] = (WCHAR)*(byte *)(*(int *)(local_18 + 0x94) + (__C & 0xffff));\n      goto LAB_0041b9af;\n    }\n  }\n  local_8[0] = (WCHAR)__C;\nLAB_0041b9af:\n  if (local_10 != '\\0') {\n    *(uint *)(local_1c + 0x350) = *(uint *)(local_1c + 0x350) & 0xfffffffd;\n  }\n  return local_8[0];\n}\n\n"
    },
    {
      "name": "FUN_0041b9fa",
      "entry": "0041b9fa",
      "c": "\nundefined4 * FUN_0041b9fa(void)\n\n{\n  return &DAT_0043b570;\n}\n\n"
    },
    {
      "name": "FUN_0041ba00",
      "entry": "0041ba00",
      "c": "\nundefined4 * FUN_0041ba00(void)\n\n{\n  return &DAT_0043b574;\n}\n\n"
    },
    {
      "name": "FUN_0041ba06",
      "entry": "0041ba06",
      "c": "\nundefined4 * FUN_0041ba06(void)\n\n{\n  return &DAT_0043b56c;\n}\n\n"
    },
    {
      "name": "FUN_0041ba0c",
      "entry": "0041ba0c",
      "c": "\nundefined4 FUN_0041ba0c(void)\n\n{\n  return DAT_0043b578;\n}\n\n"
    },
    {
      "name": "__get_daylight",
      "entry": "0041ba12",
      "c": "\n/* Library Function - Single Match\n    __get_daylight\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl __get_daylight(int *_Daylight)\n\n{\n  int *piVar1;\n  \n  if (_Daylight == (int *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0x16;\n  }\n  *_Daylight = DAT_0043b570;\n  return 0;\n}\n\n"
    },
    {
      "name": "__get_dstbias",
      "entry": "0041ba3e",
      "c": "\n/* Library Function - Single Match\n    __get_dstbias\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl __get_dstbias(long *_Daylight_savings_bias)\n\n{\n  int *piVar1;\n  \n  if (_Daylight_savings_bias == (long *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0x16;\n  }\n  *_Daylight_savings_bias = DAT_0043b574;\n  return 0;\n}\n\n"
    },
    {
      "name": "__get_timezone",
      "entry": "0041ba6a",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    __get_daylight\n    __get_timezone\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl __get_timezone(long *_Timezone)\n\n{\n  int *piVar1;\n  \n  if (_Timezone == (long *)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0x16;\n  }\n  *_Timezone = DAT_0043b56c;\n  return 0;\n}\n\n"
    },
    {
      "name": "_isindst_nolock",
      "entry": "0041ba96",
      "c": "\n/* Library Function - Single Match\n    int __cdecl _isindst_nolock(struct tm * const)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl _isindst_nolock(tm *param_1)\n\n{\n  errno_t eVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  uint uVar9;\n  int local_8;\n  \n  local_8 = 0;\n  eVar1 = __get_daylight(&local_8);\n  if (eVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  }\n  if (local_8 == 0) {\n    return 0;\n  }\n  iVar8 = param_1->tm_year;\n  if ((iVar8 != DAT_0042d918) || (iVar8 != DAT_0042d924)) {\n    if (DAT_0043b580 == 0) {\n      iVar6 = 3;\n      iVar4 = 2;\n      iVar5 = 1;\n      iVar7 = 0xb;\n      if (iVar8 < 0x6b) {\n        iVar6 = 4;\n        iVar7 = 10;\n        iVar4 = 1;\n        iVar5 = 5;\n      }\n      cvtdate(0,1,iVar8,iVar6,iVar4,0,0,2,0,0,0);\n      cvtdate(1,1,param_1->tm_year,iVar7,iVar5,0,0,2,0,0,0);\n    }\n    else {\n      if (DAT_0043b620 != 0) {\n        uVar9 = (uint)DAT_0043b626;\n        uVar2 = 0;\n        uVar3 = 0;\n      }\n      else {\n        uVar2 = (uint)DAT_0043b624;\n        uVar9 = 0;\n        uVar3 = (uint)DAT_0043b626;\n      }\n      cvtdate(0,(uint)(DAT_0043b620 == 0),iVar8,(uint)DAT_0043b622,uVar3,uVar2,uVar9,\n              (uint)DAT_0043b628,(uint)DAT_0043b62a,(uint)DAT_0043b62c,(uint)DAT_0043b62e);\n      if (DAT_0043b5cc != 0) {\n        uVar9 = (uint)DAT_0043b5d2;\n        uVar2 = 0;\n        uVar3 = 0;\n        iVar8 = param_1->tm_year;\n      }\n      else {\n        uVar2 = (uint)DAT_0043b5d0;\n        uVar9 = 0;\n        uVar3 = (uint)DAT_0043b5d2;\n        iVar8 = param_1->tm_year;\n      }\n      cvtdate(1,(uint)(DAT_0043b5cc == 0),iVar8,(uint)DAT_0043b5ce,uVar3,uVar2,uVar9,\n              (uint)DAT_0043b5d4,(uint)DAT_0043b5d6,(uint)DAT_0043b5d8,(uint)DAT_0043b5da);\n    }\n  }\n  iVar8 = param_1->tm_yday;\n  if (DAT_0042d91c < DAT_0042d928) {\n    if ((iVar8 < DAT_0042d91c) || (DAT_0042d928 < iVar8)) {\n      return 0;\n    }\n    if ((iVar8 <= DAT_0042d91c) || (DAT_0042d928 <= iVar8)) {\nLAB_0041bc44:\n      iVar6 = ((param_1->tm_hour * 0x3c + param_1->tm_min) * 0x3c + param_1->tm_sec) * 1000;\n      if (iVar8 != DAT_0042d91c) {\n        return (uint)(iVar6 < DAT_0042d92c);\n      }\n      return (uint)(DAT_0042d920 <= iVar6);\n    }\n  }\n  else if ((DAT_0042d928 <= iVar8) && (iVar8 <= DAT_0042d91c)) {\n    if ((DAT_0042d928 < iVar8) && (iVar8 < DAT_0042d91c)) {\n      return 0;\n    }\n    goto LAB_0041bc44;\n  }\n  return 1;\n}\n\n"
    },
    {
      "name": "cvtdate",
      "entry": "0041bc7d",
      "c": "\n/* Library Function - Single Match\n    void __cdecl cvtdate(enum `anonymous namespace'::transition_type,enum\n   A0xe529774e::date_type,int,int,int,int,int,int,int,int,int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\ncvtdate(transition_type param_1,date_type param_2,int param_3,int param_4,int param_5,int param_6,\n       int param_7,int param_8,int param_9,int param_10,int param_11)\n\n{\n  bool bVar1;\n  int iVar2;\n  errno_t eVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  long local_c;\n  undefined4 uStack_8;\n  \n  local_c = 0;\n  if (param_2 == 1) {\n    bVar1 = __crt_time_is_leap_year<int>(param_3);\n    iVar5 = param_4 * 4;\n    if (bVar1) {\n      iVar6 = *(int *)(&DAT_0042ab6c + iVar5);\n    }\n    else {\n      iVar6 = *(int *)(&DAT_0042ab38 + iVar5);\n    }\n    uStack_8._3_1_ = bVar1;\n    iVar2 = __crt_time_elapsed_leap_years<int>(param_3);\n    iVar4 = (iVar2 + iVar6 + 1 + param_3 * 0x16d + -0x63ca) % 7;\n    iVar2 = param_5 * 7 - iVar4;\n    if (iVar4 <= param_6) {\n      iVar2 = iVar2 + -7;\n    }\n    iVar6 = iVar6 + 1 + iVar2 + param_6;\n    if (uStack_8._3_1_ == '\\0') {\n      iVar5 = *(int *)(&DAT_0042ab3c + iVar5);\n    }\n    else {\n      iVar5 = *(int *)(&DAT_0042ab70 + iVar5);\n    }\n    if ((param_5 == 5) && (iVar5 < iVar6)) {\n      iVar6 = iVar6 + -7;\n    }\n  }\n  else {\n    bVar1 = __crt_time_is_leap_year<int>(param_3);\n    if (bVar1) {\n      iVar6 = *(int *)(&DAT_0042ab6c + param_4 * 4);\n    }\n    else {\n      iVar6 = *(int *)(&DAT_0042ab38 + param_4 * 4);\n    }\n    iVar6 = iVar6 + param_7;\n  }\n  iVar5 = ((param_8 * 0x3c + param_9) * 0x3c + param_10) * 1000 + param_11;\n  if (param_1 == 0) {\n    DAT_0042d918 = param_3;\n    DAT_0042d91c = iVar6;\n    DAT_0042d920 = iVar5;\n  }\n  else {\n    DAT_0042d928 = iVar6;\n    DAT_0042d92c = iVar5;\n    eVar3 = __get_dstbias(&local_c);\n    if (eVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    DAT_0042d92c = DAT_0042d92c + local_c * 1000;\n    DAT_0042d924 = param_3;\n    if (DAT_0042d92c < 0) {\n      DAT_0042d92c = DAT_0042d92c + 86400000;\n      DAT_0042d928 = DAT_0042d928 + -1;\n    }\n    else if (86399999 < DAT_0042d92c) {\n      DAT_0042d92c = DAT_0042d92c + -86400000;\n      DAT_0042d928 = DAT_0042d928 + 1;\n    }\n  }\n  return;\n}\n\n"
    },
    {
      "name": "tzset_from_environment_nolock",
      "entry": "0041bdcd",
      "c": "\n/* Library Function - Single Match\n    void __cdecl tzset_from_environment_nolock(char *)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl tzset_from_environment_nolock(char *param_1)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  undefined4 *puVar4;\n  errno_t eVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int iVar8;\n  long lVar9;\n  int *piVar10;\n  uint *puVar11;\n  byte *pbVar12;\n  char *pcVar13;\n  int iVar14;\n  bool bVar15;\n  uint local_10;\n  undefined4 *local_c;\n  long local_8;\n  \n  puVar4 = (undefined4 *)FUN_0041ba0c();\n  local_8 = 0;\n  local_10 = 0;\n  local_c = puVar4;\n  eVar5 = __get_timezone(&local_8);\n  if ((eVar5 == 0) && (eVar5 = __get_daylight((int *)&local_10), eVar5 == 0)) {\n    pbVar6 = (byte *)param_1;\n    pbVar12 = DAT_0043b57c;\n    if (DAT_0043b57c != (byte *)0x0) {\n      do {\n        bVar1 = *pbVar6;\n        bVar15 = bVar1 < *pbVar12;\n        if (bVar1 != *pbVar12) {\nLAB_0041be3e:\n          uVar7 = -(uint)bVar15 | 1;\n          goto LAB_0041be43;\n        }\n        if (bVar1 == 0) break;\n        bVar1 = pbVar6[1];\n        bVar15 = bVar1 < pbVar12[1];\n        if (bVar1 != pbVar12[1]) goto LAB_0041be3e;\n        pbVar6 = pbVar6 + 2;\n        pbVar12 = pbVar12 + 2;\n      } while (bVar1 != 0);\n      uVar7 = 0;\nLAB_0041be43:\n      puVar4 = local_c;\n      if (uVar7 == 0) {\n        return;\n      }\n    }\n    FID_conflict__free(DAT_0043b57c);\n    pcVar13 = param_1;\n    do {\n      cVar2 = *pcVar13;\n      pcVar13 = pcVar13 + 1;\n    } while (cVar2 != '\\0');\n    DAT_0043b57c = (byte *)__malloc_base((size_t)(pcVar13 + (1 - (int)(param_1 + 1))));\n    FID_conflict__free((void *)0x0);\n    if (DAT_0043b57c == (byte *)0x0) {\n      return;\n    }\n    pcVar13 = param_1;\n    do {\n      cVar2 = *pcVar13;\n      pcVar13 = pcVar13 + 1;\n    } while (cVar2 != '\\0');\n    eVar5 = _strcpy_s((char *)DAT_0043b57c,(rsize_t)(pcVar13 + (1 - (int)(param_1 + 1))),param_1);\n    if (eVar5 == 0) {\n      iVar14 = 3;\n      iVar8 = FUN_0041d6db((char *)*puVar4,0x40,param_1,3);\n      if (iVar8 == 0) {\n        do {\n          if (*param_1 == '\\0') break;\n          param_1 = param_1 + 1;\n          iVar14 = iVar14 + -1;\n        } while (iVar14 != 0);\n        cVar2 = *param_1;\n        if (cVar2 == '-') {\n          param_1 = param_1 + 1;\n        }\n        lVar9 = _atol(param_1);\n        local_8 = lVar9 * 0xe10;\n        for (; (cVar3 = *param_1, cVar3 == '+' || (('/' < cVar3 && (cVar3 < ':'))));\n            param_1 = param_1 + 1) {\n        }\n        if (*param_1 == ':') {\n          param_1 = param_1 + 1;\n          lVar9 = _atol(param_1);\n          local_8 = local_8 + lVar9 * 0x3c;\n          for (; ('/' < *param_1 && (*param_1 < ':')); param_1 = param_1 + 1) {\n          }\n          if (*param_1 == ':') {\n            param_1 = param_1 + 1;\n            lVar9 = _atol(param_1);\n            local_8 = local_8 + lVar9;\n            for (; ('/' < *param_1 && (*param_1 < ':')); param_1 = param_1 + 1) {\n            }\n          }\n        }\n        if (cVar2 == '-') {\n          local_8 = -local_8;\n        }\n        local_10 = (uint)(*param_1 != '\\0');\n        if (local_10 == 0) {\n          *(undefined1 *)local_c[1] = 0;\n        }\n        else {\n          iVar14 = FUN_0041d6db((char *)local_c[1],0x40,param_1,3);\n          if (iVar14 != 0) goto LAB_0041bf95;\n        }\n        lVar9 = local_8;\n        piVar10 = FUN_0041ba06();\n        uVar7 = local_10;\n        *piVar10 = lVar9;\n        puVar11 = FUN_0041b9fa();\n        *puVar11 = uVar7;\n        return;\n      }\n    }\n  }\nLAB_0041bf95:\n                    /* WARNING: Subroutine does not return */\n  __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n\n"
    },
    {
      "name": "tzset_from_system_nolock",
      "entry": "0041bfa2",
      "c": "\n/* Library Function - Single Match\n    void __cdecl tzset_from_system_nolock(void)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl tzset_from_system_nolock(void)\n\n{\n  long lVar1;\n  int *piVar2;\n  errno_t eVar3;\n  DWORD DVar4;\n  UINT CodePage;\n  int iVar5;\n  int local_14;\n  long local_10;\n  int local_c;\n  long local_8;\n  \n  piVar2 = (int *)FUN_0041ba0c();\n  local_8 = 0;\n  local_c = 0;\n  local_10 = 0;\n  eVar3 = __get_timezone(&local_8);\n  if (eVar3 == 0) {\n    eVar3 = __get_daylight(&local_c);\n    if (eVar3 == 0) {\n      eVar3 = __get_dstbias(&local_10);\n      if (eVar3 == 0) {\n        FID_conflict__free(DAT_0043b57c);\n        DAT_0043b57c = (void *)0x0;\n        DVar4 = GetTimeZoneInformation((LPTIME_ZONE_INFORMATION)&DAT_0043b588);\n        if (DVar4 != 0xffffffff) {\n          local_8 = DAT_0043b588 * 0x3c;\n          DAT_0043b580 = 1;\n          if (DAT_0043b5ce != 0) {\n            local_8 = local_8 + DAT_0043b5dc * 0x3c;\n          }\n          if ((DAT_0043b622 == 0) || (DAT_0043b630 == 0)) {\n            local_c = 0;\n            local_10 = 0;\n          }\n          else {\n            local_c = 1;\n            local_10 = (DAT_0043b630 - DAT_0043b5dc) * 0x3c;\n          }\n          CodePage = ____lc_codepage_func();\n          iVar5 = WideCharToMultiByte(CodePage,0,(LPCWSTR)&DAT_0043b58c,-1,(LPSTR)*piVar2,0x3f,\n                                      (LPCSTR)0x0,&local_14);\n          if ((iVar5 == 0) || (local_14 != 0)) {\n            *(undefined1 *)*piVar2 = 0;\n          }\n          else {\n            *(undefined1 *)(*piVar2 + 0x3f) = 0;\n          }\n          iVar5 = WideCharToMultiByte(CodePage,0,(LPCWSTR)&DAT_0043b5e0,-1,(LPSTR)piVar2[1],0x3f,\n                                      (LPCSTR)0x0,&local_14);\n          if ((iVar5 == 0) || (local_14 != 0)) {\n            *(undefined1 *)piVar2[1] = 0;\n          }\n          else {\n            *(undefined1 *)(piVar2[1] + 0x3f) = 0;\n          }\n        }\n        lVar1 = local_8;\n        piVar2 = FUN_0041ba06();\n        iVar5 = local_c;\n        *piVar2 = lVar1;\n        piVar2 = FUN_0041b9fa();\n        lVar1 = local_10;\n        *piVar2 = iVar5;\n        piVar2 = FUN_0041ba00();\n        *piVar2 = lVar1;\n        return;\n      }\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n\n"
    },
    {
      "name": "tzset_nolock",
      "entry": "0041c0fd",
      "c": "\n/* Library Function - Single Match\n    void __cdecl tzset_nolock(void)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl tzset_nolock(void)\n\n{\n  int iVar1;\n  char *_Memory;\n  uint local_110;\n  size_t local_10c;\n  char local_108 [256];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  DAT_0042d924 = 0xffffffff;\n  DAT_0042d918 = 0xffffffff;\n  DAT_0043b580 = 0;\n  iVar1 = FUN_00417a49(&local_10c,local_108,0x100,\"TZ\");\n  if (iVar1 == 0) {\n    _Memory = local_108;\n  }\n  else {\n    _Memory = (char *)0x0;\n    if (iVar1 == 0x22) {\n      _Memory = (char *)__malloc_base(local_10c);\n      if (_Memory == (char *)0x0) {\n        _Memory = (char *)0x0;\n      }\n      else {\n        iVar1 = FUN_00417a49(&local_110,_Memory,local_10c,\"TZ\");\n        if (iVar1 == 0) {\n          FID_conflict__free((void *)0x0);\n          goto LAB_0041c19e;\n        }\n      }\n      FID_conflict__free(_Memory);\n      _Memory = (char *)0x0;\n    }\n  }\nLAB_0041c19e:\n  if ((_Memory == (char *)0x0) || (*_Memory == '\\0')) {\n    tzset_from_system_nolock();\n  }\n  else {\n    tzset_from_environment_nolock(_Memory);\n  }\n  FID_conflict__free((void *)(-(uint)(_Memory != local_108) & (uint)_Memory));\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "___tzset",
      "entry": "0041c1dd",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    ___tzset\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___tzset(void)\n\n{\n  if (DAT_0043b634 == 0) {\n    ___acrt_lock(6);\n    if (DAT_0043b634 == 0) {\n      tzset_nolock();\n      LOCK();\n      DAT_0043b634 = DAT_0043b634 + 1;\n      UNLOCK();\n    }\n    FUN_0041c225();\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041c225",
      "entry": "0041c225",
      "c": "\nvoid FUN_0041c225(void)\n\n{\n  ___acrt_unlock(6);\n  return;\n}\n\n"
    },
    {
      "name": "__isindst",
      "entry": "0041c22e",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    __isindst\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __isindst(tm *_Time)\n\n{\n  int iVar1;\n  \n  ___acrt_lock(6);\n  iVar1 = _isindst_nolock(_Time);\n  FUN_0041c26f();\n  return iVar1;\n}\n\n"
    },
    {
      "name": "FUN_0041c26f",
      "entry": "0041c26f",
      "c": "\nvoid FUN_0041c26f(void)\n\n{\n  ___acrt_unlock(6);\n  return;\n}\n\n"
    },
    {
      "name": "__wcsnicmp",
      "entry": "0041c278",
      "c": "\n/* Library Function - Single Match\n    __wcsnicmp\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __wcsnicmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)\n\n{\n  wchar_t wVar1;\n  int *piVar2;\n  int iVar3;\n  wchar_t wVar4;\n  \n  if (DAT_0043b0e8 == 0) {\n    iVar3 = 0;\n    if (_MaxCount != 0) {\n      if ((_Str1 == (wchar_t *)0x0) || (_Str2 == (wchar_t *)0x0)) {\n        piVar2 = __errno();\n        *piVar2 = 0x16;\n        FUN_00412362();\n        iVar3 = 0x7fffffff;\n      }\n      else {\n        iVar3 = (int)_Str1 - (int)_Str2;\n        do {\n          wVar4 = *(wchar_t *)(iVar3 + (int)_Str2);\n          if ((0x40 < (ushort)wVar4) && ((ushort)wVar4 < 0x5b)) {\n            wVar4 = wVar4 + L' ';\n          }\n          wVar1 = *_Str2;\n          if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {\n            wVar1 = wVar1 + L' ';\n          }\n          _Str2 = _Str2 + 1;\n          _MaxCount = _MaxCount - 1;\n        } while (((_MaxCount != 0) && (wVar4 != L'\\0')) && (wVar4 == wVar1));\n        iVar3 = (uint)(ushort)wVar4 - (uint)(ushort)wVar1;\n      }\n    }\n  }\n  else {\n    iVar3 = __wcsnicmp_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "__wcsnicmp_l",
      "entry": "0041c330",
      "c": "\n/* Library Function - Single Match\n    __wcsnicmp_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __wcsnicmp_l(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale)\n\n{\n  wchar_t wVar1;\n  wchar_t wVar2;\n  int *piVar3;\n  int iVar4;\n  int local_18;\n  localeinfo_struct local_14;\n  char local_c;\n  \n  iVar4 = 0;\n  if (_MaxCount != 0) {\n    if ((_Str1 == (wchar_t *)0x0) || (_Str2 == (wchar_t *)0x0)) {\n      piVar3 = __errno();\n      *piVar3 = 0x16;\n      FUN_00412362();\n      iVar4 = 0x7fffffff;\n    }\n    else {\n      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18,(__crt_locale_pointers *)_Locale);\n      if ((local_14.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n        iVar4 = (int)_Str1 - (int)_Str2;\n        do {\n          wVar1 = *(wchar_t *)(iVar4 + (int)_Str2);\n          if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {\n            wVar1 = wVar1 + L' ';\n          }\n          wVar2 = *_Str2;\n          if ((0x40 < (ushort)wVar2) && ((ushort)wVar2 < 0x5b)) {\n            wVar2 = wVar2 + L' ';\n          }\n          _Str2 = _Str2 + 1;\n          _MaxCount = _MaxCount - 1;\n        } while (((_MaxCount != 0) && (wVar1 != L'\\0')) && (wVar1 == wVar2));\n      }\n      else {\n        do {\n          wVar1 = __towlower_l(*_Str1,&local_14);\n          wVar2 = __towlower_l(*_Str2,&local_14);\n          _MaxCount = _MaxCount - 1;\n          _Str1 = _Str1 + 1;\n          _Str2 = _Str2 + 1;\n          if ((_MaxCount == 0) || (wVar1 == L'\\0')) break;\n        } while (wVar1 == wVar2);\n      }\n      iVar4 = (uint)(ushort)wVar1 - (uint)(ushort)wVar2;\n      if (local_c != '\\0') {\n        *(uint *)(local_18 + 0x350) = *(uint *)(local_18 + 0x350) & 0xfffffffd;\n      }\n    }\n  }\n  return iVar4;\n}\n\n"
    },
    {
      "name": "__strnicmp",
      "entry": "0041c431",
      "c": "\n/* Library Function - Single Match\n    __strnicmp\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if (DAT_0043b0e8 == 0) {\n    if ((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) {\n      piVar1 = __errno();\n      *piVar1 = 0x16;\n      FUN_00412362();\n      iVar2 = 0x7fffffff;\n    }\n    else {\n      if (_MaxCount < 0x80000000) {\n        iVar2 = ___ascii_strnicmp(_Str1,_Str2,_MaxCount);\n        return iVar2;\n      }\n      piVar1 = __errno();\n      *piVar1 = 0x16;\n      FUN_00412362();\n      iVar2 = 0x7fffffff;\n    }\n  }\n  else {\n    iVar2 = __strnicmp_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "__strnicmp_l",
      "entry": "0041c49d",
      "c": "\n/* Library Function - Single Match\n    __strnicmp_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __strnicmp_l(char *_Str1,char *_Str2,size_t _MaxCount,_locale_t _Locale)\n\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int local_14;\n  localeinfo_struct local_10;\n  char local_8;\n  \n  if (_MaxCount == 0) {\n    iVar3 = 0;\n  }\n  else {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);\n    iVar3 = 0x7fffffff;\n    if (((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) || (0x7fffffff < _MaxCount)) {\n      piVar1 = __errno();\n      *piVar1 = 0x16;\n      FUN_00412362();\n    }\n    else if ((local_10.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n      iVar3 = ___ascii_strnicmp(_Str1,_Str2,_MaxCount);\n    }\n    else {\n      iVar4 = (int)_Str1 - (int)_Str2;\n      do {\n        iVar3 = __tolower_l((uint)((byte *)_Str2)[iVar4],&local_10);\n        iVar2 = __tolower_l((uint)(byte)*_Str2,&local_10);\n        _Str2 = (char *)((byte *)_Str2 + 1);\n        _MaxCount = _MaxCount - 1;\n        if ((_MaxCount == 0) || (iVar3 == 0)) break;\n      } while (iVar3 == iVar2);\n      iVar3 = iVar3 - iVar2;\n    }\n    if (local_8 != '\\0') {\n      *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n    }\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "common_sopen_dispatch<wchar_t>",
      "entry": "0041c554",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    int __cdecl common_sopen_dispatch<wchar_t>(wchar_t const * const,int,int,int,int * const,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\ncommon_sopen_dispatch<wchar_t>\n          (wchar_t *param_1,int param_2,int param_3,int param_4,int *param_5,int param_6)\n\n{\n  int *piVar1;\n  int iVar2;\n  int local_24;\n  errno_t local_20;\n  undefined4 uStack_c;\n  undefined *local_8;\n  \n  local_8 = &DAT_0042c1b0;\n  uStack_c = 0x41c560;\n  if (((param_5 == (int *)0x0) || (*param_5 = -1, param_1 == (wchar_t *)0x0)) ||\n     ((param_6 != 0 && ((param_4 & 0xfffffe7fU) != 0)))) {\n    piVar1 = __errno();\n    iVar2 = 0x16;\n    *piVar1 = 0x16;\n    FUN_00412362();\n  }\n  else {\n    local_24 = 0;\n    local_20 = 0;\n    local_8 = (undefined *)0x0;\n    iVar2 = __wsopen_nolock(&local_24,param_5,param_1,param_2,param_3,param_4,param_6);\n    local_8 = (undefined *)0xfffffffe;\n    local_20 = iVar2;\n    FUN_0041c5f4();\n    if (iVar2 != 0) {\n      *param_5 = -1;\n    }\n  }\n  return iVar2;\n}\n\n"
    },
    {
      "name": "FUN_0041c5f4",
      "entry": "0041c5f4",
      "c": "\nvoid FUN_0041c5f4(void)\n\n{\n  byte *pbVar1;\n  int unaff_EBP;\n  uint *unaff_ESI;\n  int unaff_EDI;\n  \n  if (*(int *)(unaff_EBP + -0x20) != 0) {\n    if (unaff_EDI != 0) {\n      pbVar1 = (byte *)((&DAT_0043b110)[(int)*unaff_ESI >> 6] + 0x28 + (*unaff_ESI & 0x3f) * 0x30);\n      *pbVar1 = *pbVar1 & 0xfe;\n    }\n    ___acrt_lowio_unlock_fh(*unaff_ESI);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "configure_text_mode",
      "entry": "0041c620",
      "c": "\n/* Library Function - Single Match\n    int __cdecl configure_text_mode(int,struct `anonymous namespace'::file_options,int,enum\n   __crt_lowio_text_mode &)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl configure_text_mode(uint param_1,byte param_2,uint param_3,uint param_4)\n\n{\n  bool bVar1;\n  errno_t eVar2;\n  uint uVar3;\n  int iVar4;\n  int *piVar5;\n  int iVar6;\n  uint in_ECX;\n  uint uVar7;\n  int iVar8;\n  int unaff_ESI;\n  longlong lVar9;\n  uint in_stack_00000020;\n  char *in_stack_00000024;\n  uint local_8;\n  \n  iVar8 = 0;\n  *in_stack_00000024 = '\\0';\n  if ((*(byte *)((&DAT_0043b110)[(int)param_1 >> 6] + 0x28 + (param_1 & 0x3f) * 0x30) & 0x80) == 0)\n  {\n    return 0;\n  }\n  local_8 = in_ECX;\n  if ((in_stack_00000020 & 0x74000) == 0) {\n    local_8 = 0;\n    eVar2 = __get_fmode((int *)&local_8);\n    if (eVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    if ((local_8 & 0x74000) == 0) {\n      in_stack_00000020 = in_stack_00000020 | 0x4000;\n    }\n    else {\n      in_stack_00000020 = in_stack_00000020 | local_8 & 0x74000;\n    }\n  }\n  uVar3 = in_stack_00000020 & 0x74000;\n  if (uVar3 == 0x4000) {\n    *in_stack_00000024 = '\\0';\n  }\n  else if ((uVar3 == 0x10000) || (uVar3 == 0x14000)) {\n    if ((in_stack_00000020 & 0x301) == 0x301) goto LAB_0041c6d2;\n  }\n  else if ((uVar3 == 0x20000) || (uVar3 == 0x24000)) {\nLAB_0041c6d2:\n    *in_stack_00000024 = '\\x02';\n  }\n  else if ((uVar3 == 0x40000) || (uVar3 == 0x44000)) {\n    *in_stack_00000024 = '\\x01';\n  }\n  if ((in_stack_00000020 & 0x70000) == 0) {\n    return 0;\n  }\n  if ((param_2 & 0x40) != 0) {\n    return 0;\n  }\n  uVar3 = param_3 & 0xc0000000;\n  uVar7 = 0;\n  bVar1 = false;\n  if (uVar3 == 0x40000000) {\nLAB_0041c707:\n    if (param_4 == 0) {\n      return 0;\n    }\n    if (param_4 < 3) {\nLAB_0041c75a:\n      bVar1 = true;\nLAB_0041c75d:\n      if (uVar7 != 0) goto LAB_0041c765;\n      goto LAB_0041c800;\n    }\n    if (4 < param_4) {\n      if (param_4 != 5) {\n        return 0;\n      }\n      goto LAB_0041c75a;\n    }\n    lVar9 = __lseeki64_nolock(param_1,0x200000000,unaff_ESI);\n    if (lVar9 != 0) {\n      lVar9 = __lseeki64_nolock(param_1,0,unaff_ESI);\n      if (lVar9 == -1) goto LAB_0041c7bd;\n      uVar7 = param_3 >> 0x1f;\n      goto LAB_0041c75d;\n    }\n  }\n  else {\n    if (uVar3 != 0x80000000) {\n      if (uVar3 != 0xc0000000) {\n        return 0;\n      }\n      goto LAB_0041c707;\n    }\nLAB_0041c765:\n    local_8 = 0;\n    iVar4 = __read_nolock(param_1,&local_8,3);\n    if (0 < iVar4) {\n      bVar1 = (bool)(bVar1 & !bVar1);\n    }\n    if (iVar4 == -1) goto LAB_0041c7bd;\n    if (iVar4 == 2) {\nLAB_0041c7a6:\n      if ((local_8 & 0xffff) == 0xfffe) {\n        piVar5 = __errno();\n        *piVar5 = 0x16;\n        goto LAB_0041c7bd;\n      }\n      if ((local_8 & 0xffff) == 0xfeff) {\n        lVar9 = __lseeki64_nolock(param_1,0,unaff_ESI);\n        if (lVar9 == -1) goto LAB_0041c7bd;\n        *in_stack_00000024 = '\\x02';\n        goto LAB_0041c800;\n      }\n    }\n    else if (iVar4 == 3) {\n      if (local_8 == 0xbfbbef) {\n        *in_stack_00000024 = '\\x01';\n        goto LAB_0041c800;\n      }\n      goto LAB_0041c7a6;\n    }\n    lVar9 = __lseeki64_nolock(param_1,0,unaff_ESI);\n    if (lVar9 == -1) goto LAB_0041c7bd;\nLAB_0041c800:\n    if (!bVar1) {\n      return 0;\n    }\n  }\n  iVar4 = 0;\n  local_8 = 0;\n  if (*in_stack_00000024 == '\\x01') {\n    local_8 = 0xbfbbef;\n    iVar4 = 3;\nLAB_0041c830:\n    if (iVar4 == 0) {\n      return 0;\n    }\n  }\n  else {\n    if (*in_stack_00000024 != '\\x02') goto LAB_0041c830;\n    local_8 = 0xfeff;\n    iVar4 = 2;\n  }\n  while (iVar6 = __write(param_1,(void *)((int)&local_8 + iVar8),iVar4 - iVar8), iVar6 != -1) {\n    iVar8 = iVar8 + iVar6;\n    if (iVar4 <= iVar8) {\n      return 0;\n    }\n  }\nLAB_0041c7bd:\n  piVar5 = __errno();\n  return *piVar5;\n}\n\n"
    },
    {
      "name": "create_file",
      "entry": "0041c86d",
      "c": "\n/* Library Function - Single Match\n    void * __cdecl create_file(wchar_t const * const,struct _SECURITY_ATTRIBUTES * const,struct\n   `anonymous namespace'::file_options)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid * __cdecl\ncreate_file(LPCWSTR param_1,LPSECURITY_ATTRIBUTES param_2,undefined4 param_3,DWORD param_4,\n           DWORD param_5,DWORD param_6,uint param_7,uint param_8)\n\n{\n  HANDLE pvVar1;\n  \n  pvVar1 = CreateFileW(param_1,param_4,param_6,param_2,param_5,param_7 | param_8,(HANDLE)0x0);\n  return pvVar1;\n}\n\n"
    },
    {
      "name": "decode_open_create_flags",
      "entry": "0041c892",
      "c": "\n/* Library Function - Single Match\n    unsigned long __cdecl decode_open_create_flags(int)\n   \n   Library: Visual Studio 2015 Release */\n\nulong __cdecl decode_open_create_flags(int param_1)\n\n{\n  uint uVar1;\n  int *piVar2;\n  \n  uVar1 = param_1 & 0x700;\n  if (uVar1 < 0x401) {\n    if ((uVar1 == 0x400) || (uVar1 == 0)) {\n      return 3;\n    }\n    if (uVar1 == 0x100) {\n      return 4;\n    }\n    if (uVar1 != 0x200) {\n      if (uVar1 == 0x300) {\n        return 2;\n      }\nLAB_0041c8e4:\n      piVar2 = __errno();\n      *piVar2 = 0x16;\n      FUN_00412362();\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (uVar1 == 0x500) {\n      return 1;\n    }\n    if (uVar1 != 0x600) {\n      if (uVar1 == 0x700) {\n        return 1;\n      }\n      goto LAB_0041c8e4;\n    }\n  }\n  return 5;\n}\n\n"
    },
    {
      "name": "decode_options",
      "entry": "0041c902",
      "c": "\n/* Library Function - Single Match\n    struct `anonymous namespace'::file_options __cdecl decode_options(int,int,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl decode_options(int param_1,int param_2,int param_3)\n\n{\n  uint uVar1;\n  int *piVar2;\n  int iVar3;\n  ulong uVar4;\n  errno_t eVar5;\n  byte in_stack_00000010;\n  int local_8;\n  \n  uVar1 = param_2 & 3;\n  *(undefined1 *)param_1 = 0;\n  if (uVar1 == 0) {\n    iVar3 = -0x80000000;\n  }\n  else if (uVar1 == 1) {\n    iVar3 = (-(uint)((param_2 & 0x70000U) != 0 && (param_2 & 8U) != 0) & 0x80000000) + 0x40000000;\n  }\n  else if (uVar1 == 2) {\n    iVar3 = -0x40000000;\n  }\n  else {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    iVar3 = -1;\n  }\n  *(int *)(param_1 + 4) = iVar3;\n  uVar4 = decode_open_create_flags(param_2);\n  *(ulong *)(param_1 + 8) = uVar4;\n  if (param_3 == 0x10) {\n    uVar1 = 0;\n  }\n  else if (param_3 == 0x20) {\n    uVar1 = 1;\n  }\n  else if (param_3 == 0x30) {\n    uVar1 = 2;\n  }\n  else if (param_3 == 0x40) {\n    uVar1 = 3;\n  }\n  else if (param_3 == 0x80) {\n    uVar1 = (uint)(*(int *)(param_1 + 4) == -0x80000000);\n  }\n  else {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    uVar1 = 0xffffffff;\n  }\n  *(undefined4 *)(param_1 + 0x14) = 0;\n  *(uint *)(param_1 + 0xc) = uVar1;\n  *(undefined4 *)(param_1 + 0x10) = 0x80;\n  if ((char)param_2 < '\\0') {\n    *(byte *)param_1 = *(byte *)param_1 | 0x10;\n  }\n  if ((param_2 & 0x8000U) == 0) {\n    if ((param_2 & 0x74000U) == 0) {\n      eVar5 = __get_fmode(&local_8);\n      if (eVar5 != 0) {\n                    /* WARNING: Subroutine does not return */\n        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n      }\n      if (local_8 == 0x8000) goto LAB_0041c9ff;\n    }\n    *(byte *)param_1 = *(byte *)param_1 | 0x80;\n  }\nLAB_0041c9ff:\n  if (((param_2 & 0x100U) != 0) && (-1 < (char)(~(byte)DAT_0043b650 & in_stack_00000010))) {\n    *(undefined4 *)(param_1 + 0x10) = 1;\n  }\n  if ((param_2 & 0x40U) != 0) {\n    *(uint *)(param_1 + 0x14) = *(uint *)(param_1 + 0x14) | 0x4000000;\n    *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 0x10000;\n    *(uint *)(param_1 + 0xc) = *(uint *)(param_1 + 0xc) | 4;\n  }\n  if ((param_2 & 0x1000U) != 0) {\n    *(uint *)(param_1 + 0x10) = *(uint *)(param_1 + 0x10) | 0x100;\n  }\n  if ((param_2 & 0x2000U) != 0) {\n    *(uint *)(param_1 + 0x14) = *(uint *)(param_1 + 0x14) | 0x2000000;\n  }\n  if ((param_2 & 0x20U) == 0) {\n    if ((param_2 & 0x10U) != 0) {\n      *(uint *)(param_1 + 0x14) = *(uint *)(param_1 + 0x14) | 0x10000000;\n    }\n  }\n  else {\n    *(uint *)(param_1 + 0x14) = *(uint *)(param_1 + 0x14) | 0x8000000;\n  }\n  return param_1;\n}\n\n"
    },
    {
      "name": "truncate_ctrl_z_if_present",
      "entry": "0041ca7e",
      "c": "\n/* Library Function - Single Match\n    int __cdecl truncate_ctrl_z_if_present(int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl truncate_ctrl_z_if_present(int param_1)\n\n{\n  byte bVar1;\n  ulong *puVar2;\n  int iVar3;\n  int *piVar4;\n  int unaff_EDI;\n  longlong lVar5;\n  uint local_8;\n  \n  bVar1 = *(byte *)((&DAT_0043b110)[param_1 >> 6] + 0x28 + (param_1 & 0x3fU) * 0x30);\n  if (((bVar1 & 0x48) != 0) || (-1 < (char)bVar1)) {\n    return 0;\n  }\n  lVar5 = __lseeki64_nolock(param_1,0x2ffffffff,unaff_EDI);\n  if (lVar5 == -1) {\n    puVar2 = ___doserrno();\n    if (*puVar2 == 0x83) {\n      return 0;\n    }\n  }\n  else {\n    local_8 = local_8 & 0xffff0000;\n    iVar3 = __read_nolock(param_1,&local_8,1);\n    if ((((iVar3 != 0) || ((short)local_8 != 0x1a)) ||\n        (iVar3 = __chsize_nolock(param_1,CONCAT44(unaff_EDI,(int)((ulonglong)lVar5 >> 0x20))),\n        iVar3 != -1)) && (lVar5 = __lseeki64_nolock(param_1,0,unaff_EDI), lVar5 != -1)) {\n      return 0;\n    }\n  }\n  piVar4 = __errno();\n  return *piVar4;\n}\n\n"
    },
    {
      "name": "__wsopen_nolock",
      "entry": "0041cb2e",
      "c": "\n/* Library Function - Single Match\n    __wsopen_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl\n__wsopen_nolock(int *UnlockFlag,int *_FileHandle,wchar_t *_Filename,int _OpenFlag,int _ShareFlag,\n               int _PermissionFlag,int _SecureFlag)\n\n{\n  uint uVar1;\n  undefined4 *puVar2;\n  ulong *puVar3;\n  int *piVar4;\n  void *pvVar5;\n  DWORD DVar6;\n  int iVar7;\n  int iVar8;\n  byte *pbVar9;\n  wchar_t **ppwVar10;\n  wchar_t *apwStack_74 [4];\n  undefined1 local_48 [24];\n  byte local_30 [4];\n  uint local_2c;\n  int local_24;\n  undefined4 local_18;\n  undefined4 local_14;\n  uint local_10;\n  void *local_c;\n  undefined1 local_6;\n  byte local_5;\n  \n  apwStack_74[3] =\n       L\"\uc483\u8d10\ud47d\\xf08b\u066a\\xf359\u83a5\uffce\u7539\u75e0\\xe819\u58a6\\xffff\u2083\u8b00\u0c45\u3089\uace8\uff58\u8bff\\xe900\u02d7\";\n  puVar2 = (undefined4 *)decode_options((int)local_48,_OpenFlag,_ShareFlag);\n  pbVar9 = local_30;\n  for (iVar7 = 6; iVar7 != 0; iVar7 = iVar7 + -1) {\n    *(undefined4 *)pbVar9 = *puVar2;\n    puVar2 = puVar2 + 1;\n    pbVar9 = pbVar9 + 4;\n  }\n  if (local_24 == -1) {\n    puVar3 = ___doserrno();\n    *puVar3 = 0;\n    *_FileHandle = -1;\n    goto LAB_0041cb6d;\n  }\n  iVar7 = __alloc_osfhnd();\n  *_FileHandle = iVar7;\n  if (iVar7 == -1) {\n    puVar3 = ___doserrno();\n    *puVar3 = 0;\n    *_FileHandle = -1;\n    piVar4 = __errno();\n    *piVar4 = 0x18;\n    goto LAB_0041cb6d;\n  }\n  local_14 = 0;\n  local_18 = 0xc;\n  *UnlockFlag = 1;\n  local_10 = ~((uint)_OpenFlag >> 7) & 1;\n  apwStack_74[1] = (wchar_t *)&local_18;\n  apwStack_74[0] = _Filename;\n  pbVar9 = local_30;\n  ppwVar10 = apwStack_74 + 2;\n  for (iVar7 = 6; iVar7 != 0; iVar7 = iVar7 + -1) {\n    *ppwVar10 = (wchar_t *)*(undefined4 *)pbVar9;\n    pbVar9 = pbVar9 + 4;\n    ppwVar10 = ppwVar10 + 1;\n  }\n  pvVar5 = create_file();\n  local_c = pvVar5;\n  if (pvVar5 == (void *)0xffffffff) {\n    if (((local_2c & 0xc0000000) == 0xc0000000) && ((_OpenFlag & 1U) != 0)) {\n      apwStack_74[1] = (wchar_t *)&local_18;\n      local_2c = local_2c & 0x7fffffff;\n      apwStack_74[0] = _Filename;\n      pbVar9 = local_30;\n      ppwVar10 = apwStack_74 + 2;\n      for (iVar7 = 6; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *ppwVar10 = (wchar_t *)*(undefined4 *)pbVar9;\n        pbVar9 = pbVar9 + 4;\n        ppwVar10 = ppwVar10 + 1;\n      }\n      pvVar5 = create_file();\n      local_c = pvVar5;\n      if (pvVar5 != (void *)0xffffffff) goto LAB_0041cc54;\n    }\n    pbVar9 = (byte *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x28 + (*_FileHandle & 0x3fU) * 0x30);\n    *pbVar9 = *pbVar9 & 0xfe;\n    DVar6 = GetLastError();\n    ___acrt_errno_map_os_error(DVar6);\n  }\n  else {\nLAB_0041cc54:\n    local_c = pvVar5;\n    DVar6 = GetFileType(pvVar5);\n    if (DVar6 != 0) {\n      if (DVar6 == 2) {\n        local_30[0] = local_30[0] | 0x40;\n      }\n      else if (DVar6 == 3) {\n        local_30[0] = local_30[0] | 8;\n      }\n      local_5 = local_30[0];\n      ___acrt_lowio_set_os_handle(*_FileHandle,pvVar5);\n      local_5 = local_5 | 1;\n      local_30[0] = local_5;\n      *(byte *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x28 + (*_FileHandle & 0x3fU) * 0x30) = local_5\n      ;\n      *(undefined1 *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x29 + (*_FileHandle & 0x3fU) * 0x30) = 0\n      ;\n      if (((_OpenFlag & 2U) == 0) || (iVar7 = truncate_ctrl_z_if_present(*_FileHandle), iVar7 == 0))\n      {\n        local_6 = 0;\n        iVar7 = *_FileHandle;\n        pbVar9 = local_30;\n        ppwVar10 = apwStack_74;\n        for (iVar8 = 6; iVar8 != 0; iVar8 = iVar8 + -1) {\n          *ppwVar10 = (wchar_t *)*(undefined4 *)pbVar9;\n          pbVar9 = pbVar9 + 4;\n          ppwVar10 = ppwVar10 + 1;\n        }\n        iVar7 = configure_text_mode(iVar7);\n        uVar1 = local_2c;\n        if (iVar7 == 0) {\n          *(undefined1 *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x29 + (*_FileHandle & 0x3fU) * 0x30)\n               = local_6;\n          iVar7 = (*_FileHandle & 0x3fU) * 0x30;\n          pbVar9 = (byte *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x2d + iVar7);\n          *pbVar9 = *pbVar9 ^ ((byte)((uint)_OpenFlag >> 0x10) ^\n                              *(byte *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x2d + iVar7)) & 1;\n          if (((local_5 & 0x48) == 0) && ((_OpenFlag & 8U) != 0)) {\n            pbVar9 = (byte *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x28 +\n                             (*_FileHandle & 0x3fU) * 0x30);\n            *pbVar9 = *pbVar9 | 0x20;\n          }\n          if (((local_2c & 0xc0000000) == 0xc0000000) && ((_OpenFlag & 1U) != 0)) {\n            CloseHandle(local_c);\n            apwStack_74[1] = (wchar_t *)&local_18;\n            local_2c = uVar1 & 0x7fffffff;\n            apwStack_74[0] = _Filename;\n            pbVar9 = local_30;\n            ppwVar10 = apwStack_74 + 2;\n            for (iVar7 = 6; iVar7 != 0; iVar7 = iVar7 + -1) {\n              *ppwVar10 = (wchar_t *)*(undefined4 *)pbVar9;\n              pbVar9 = pbVar9 + 4;\n              ppwVar10 = ppwVar10 + 1;\n            }\n            pvVar5 = create_file();\n            if (pvVar5 == (void *)0xffffffff) {\n              DVar6 = GetLastError();\n              ___acrt_errno_map_os_error(DVar6);\n              pbVar9 = (byte *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x28 +\n                               (*_FileHandle & 0x3fU) * 0x30);\n              *pbVar9 = *pbVar9 & 0xfe;\n              __free_osfhnd(*_FileHandle);\n              goto LAB_0041cb6d;\n            }\n            *(void **)((&DAT_0043b110)[*_FileHandle >> 6] + 0x18 + (*_FileHandle & 0x3fU) * 0x30) =\n                 pvVar5;\n          }\n          return 0;\n        }\n      }\n      __close_nolock(*_FileHandle);\n      return iVar7;\n    }\n    DVar6 = GetLastError();\n    ___acrt_errno_map_os_error(DVar6);\n    pbVar9 = (byte *)((&DAT_0043b110)[*_FileHandle >> 6] + 0x28 + (*_FileHandle & 0x3fU) * 0x30);\n    *pbVar9 = *pbVar9 & 0xfe;\n    CloseHandle(pvVar5);\n    if (DVar6 == 0) {\n      piVar4 = __errno();\n      *piVar4 = 0xd;\n    }\n  }\nLAB_0041cb6d:\n  piVar4 = __errno();\n  return *piVar4;\n}\n\n"
    },
    {
      "name": "FID_conflict:__sopen_s",
      "entry": "0041ce57",
      "c": "\n/* Library Function - Multiple Matches With Different Base Names\n    __sopen_s\n    __wsopen_s\n   \n   Library: Visual Studio 2015 Release */\n\nerrno_t __cdecl\nFID_conflict___sopen_s\n          (int *_FileHandle,char *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionMode)\n\n{\n  int iVar1;\n  \n  iVar1 = common_sopen_dispatch<wchar_t>\n                    ((wchar_t *)_Filename,_OpenFlag,_ShareFlag,_PermissionMode,_FileHandle,1);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__wcsnicoll",
      "entry": "0041ce77",
      "c": "\n/* Library Function - Single Match\n    __wcsnicoll\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __wcsnicoll(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)\n\n{\n  wchar_t wVar1;\n  int *piVar2;\n  int iVar3;\n  wchar_t wVar4;\n  \n  if (DAT_0043b0e8 == 0) {\n    if ((_Str1 == (wchar_t *)0x0) || (_Str2 == (wchar_t *)0x0)) {\n      piVar2 = __errno();\n      *piVar2 = 0x16;\n      FUN_00412362();\n      iVar3 = 0x7fffffff;\n    }\n    else if (_MaxCount < 0x80000000) {\n      iVar3 = (int)_Str1 - (int)_Str2;\n      do {\n        wVar4 = *(wchar_t *)(iVar3 + (int)_Str2);\n        if ((0x40 < (ushort)wVar4) && ((ushort)wVar4 < 0x5b)) {\n          wVar4 = wVar4 + L' ';\n        }\n        wVar1 = *_Str2;\n        if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {\n          wVar1 = wVar1 + L' ';\n        }\n        _Str2 = _Str2 + 1;\n        _MaxCount = _MaxCount - 1;\n      } while (((_MaxCount != 0) && (wVar4 != L'\\0')) && (wVar4 == wVar1));\n      iVar3 = (uint)(ushort)wVar4 - (uint)(ushort)wVar1;\n    }\n    else {\n      piVar2 = __errno();\n      *piVar2 = 0x16;\n      FUN_00412362();\n      iVar3 = 0x7fffffff;\n    }\n  }\n  else {\n    iVar3 = __wcsnicoll_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "__wcsnicoll_l",
      "entry": "0041cf47",
      "c": "\n/* Library Function - Single Match\n    __wcsnicoll_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __wcsnicoll_l(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale)\n\n{\n  int iVar1;\n  int *piVar2;\n  int iVar3;\n  wchar_t wVar4;\n  wchar_t wVar5;\n  int local_14;\n  int local_10;\n  char local_8;\n  \n  if (_MaxCount == 0) {\n    iVar1 = 0;\n  }\n  else if (_Str1 == (wchar_t *)0x0) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    iVar1 = 0x7fffffff;\n  }\n  else if (_Str2 == (wchar_t *)0x0) {\n    piVar2 = __errno();\n    *piVar2 = 0x16;\n    FUN_00412362();\n    iVar1 = 0x7fffffff;\n  }\n  else {\n    iVar1 = 0x7fffffff;\n    if (_MaxCount < 0x80000000) {\n      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);\n      if (*(wchar_t **)(local_10 + 0xa4) == (wchar_t *)0x0) {\n        iVar1 = (int)_Str1 - (int)_Str2;\n        do {\n          wVar4 = *(wchar_t *)(iVar1 + (int)_Str2);\n          if ((0x40 < (ushort)wVar4) && ((ushort)wVar4 < 0x5b)) {\n            wVar4 = wVar4 + L' ';\n          }\n          wVar5 = *_Str2;\n          if ((0x40 < (ushort)wVar5) && ((ushort)wVar5 < 0x5b)) {\n            wVar5 = wVar5 + L' ';\n          }\n          _Str2 = _Str2 + 1;\n          _MaxCount = _MaxCount - 1;\n        } while (((_MaxCount != 0) && (wVar4 != L'\\0')) && (wVar4 == wVar5));\n        iVar1 = (uint)(ushort)wVar4 - (uint)(ushort)wVar5;\n      }\n      else {\n        iVar3 = ___acrt_CompareStringW\n                          (*(wchar_t **)(local_10 + 0xa4),0x1001,_Str1,_MaxCount,_Str2,_MaxCount);\n        if (iVar3 == 0) {\n          piVar2 = __errno();\n          *piVar2 = 0x16;\n        }\n        else {\n          iVar1 = iVar3 + -2;\n        }\n      }\n      if (local_8 != '\\0') {\n        *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n      }\n    }\n    else {\n      piVar2 = __errno();\n      *piVar2 = 0x16;\n      FUN_00412362();\n    }\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__strnicoll",
      "entry": "0041d074",
      "c": "\n/* Library Function - Single Match\n    __strnicoll\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __strnicoll(char *_Str1,char *_Str2,size_t _MaxCount)\n\n{\n  int iVar1;\n  \n  if (DAT_0043b0e8 == 0) {\n    iVar1 = __strnicmp(_Str1,_Str2,_MaxCount);\n    return iVar1;\n  }\n  iVar1 = __strnicoll_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);\n  return iVar1;\n}\n\n"
    },
    {
      "name": "__strnicoll_l",
      "entry": "0041d09d",
      "c": "\n/* Library Function - Single Match\n    __strnicoll_l\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __strnicoll_l(char *_Str1,char *_Str2,size_t _MaxCount,_locale_t _Locale)\n\n{\n  int *piVar1;\n  int iVar2;\n  int iVar3;\n  int local_14;\n  localeinfo_struct local_10;\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,(__crt_locale_pointers *)_Locale);\n  if (_MaxCount == 0) {\n    iVar3 = 0;\n  }\n  else if ((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    iVar3 = 0x7fffffff;\n  }\n  else {\n    iVar3 = 0x7fffffff;\n    if (_MaxCount < 0x80000000) {\n      if ((local_10.locinfo)->locale_name[1] == (wchar_t *)0x0) {\n        iVar3 = __strnicmp_l(_Str1,_Str2,_MaxCount,&local_10);\n      }\n      else {\n        iVar2 = ___acrt_CompareStringA\n                          ((__crt_locale_pointers *)&local_10,(local_10.locinfo)->locale_name[1],\n                           0x1001,_Str1,_MaxCount,_Str2,_MaxCount,\n                           (int)(local_10.locinfo)->lc_category[0].locale);\n        if (iVar2 == 0) {\n          piVar1 = __errno();\n          *piVar1 = 0x16;\n        }\n        else {\n          iVar3 = iVar2 + -2;\n        }\n      }\n    }\n    else {\n      piVar1 = __errno();\n      *piVar1 = 0x16;\n      FUN_00412362();\n    }\n  }\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return iVar3;\n}\n\n"
    },
    {
      "name": "FUN_0041d167",
      "entry": "0041d167",
      "c": "\nvoid FUN_0041d167(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  int iVar3;\n  \n  iVar3 = 3;\n  puVar2 = &DAT_0043b638;\n  iVar1 = iVar3;\n  do {\n    FID_conflict__free((void *)*puVar2);\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n    iVar1 = iVar1 + -1;\n  } while (iVar1 != 0);\n  puVar2 = &DAT_0043b644;\n  do {\n    FID_conflict__free((void *)*puVar2);\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n    iVar3 = iVar3 + -1;\n  } while (iVar3 != 0);\n  return;\n}\n\n"
    },
    {
      "name": "shortsort",
      "entry": "0041d1b0",
      "c": "\n/* Library Function - Single Match\n    void __cdecl shortsort(char *,char *,unsigned int,int (__cdecl*)(void const *,void const *))\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\nshortsort(char *param_1,char *param_2,uint param_3,_func_int_void_ptr_void_ptr *param_4)\n\n{\n  char *pcVar1;\n  char cVar2;\n  uint uVar3;\n  int iVar4;\n  char *pcVar5;\n  uint uVar6;\n  char *pcVar7;\n  void *in_stack_ffffffdc;\n  void *pvVar8;\n  \n  uVar3 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_1 < param_2) {\n    do {\n      pcVar7 = param_1;\n      for (pcVar5 = param_1 + param_3; pcVar5 <= param_2; pcVar5 = pcVar5 + param_3) {\n        pvVar8 = (void *)0x41d1eb;\n        (*(code *)PTR_guard_check_icall_0042118c)(pcVar5,pcVar7);\n        iVar4 = (*param_4)(in_stack_ffffffdc,pvVar8);\n        if (0 < iVar4) {\n          pcVar7 = pcVar5;\n        }\n      }\n      if ((pcVar7 != param_2) && (pcVar5 = param_2, uVar6 = param_3, param_3 != 0)) {\n        do {\n          pcVar1 = pcVar5 + 1;\n          cVar2 = pcVar1[(int)(pcVar7 + (-1 - (int)param_2))];\n          pcVar1[(int)(pcVar7 + (-1 - (int)param_2))] = *pcVar5;\n          *pcVar5 = cVar2;\n          uVar6 = uVar6 - 1;\n          pcVar5 = pcVar1;\n        } while (uVar6 != 0);\n      }\n      param_2 = param_2 + -param_3;\n    } while (param_1 < param_2);\n  }\n  __security_check_cookie(uVar3 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "swap",
      "entry": "0041d250",
      "c": "\n/* Library Function - Single Match\n    void __cdecl swap(char *,char *,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl swap(char *param_1,char *param_2,uint param_3)\n\n{\n  char *pcVar1;\n  char cVar2;\n  char *pcVar3;\n  \n  if ((param_1 != param_2) && (pcVar3 = param_2, param_3 != 0)) {\n    do {\n      pcVar1 = pcVar3 + 1;\n      cVar2 = pcVar1[(int)(param_1 + (-1 - (int)param_2))];\n      pcVar1[(int)(param_1 + (-1 - (int)param_2))] = *pcVar3;\n      *pcVar3 = cVar2;\n      param_3 = param_3 - 1;\n      pcVar3 = pcVar1;\n    } while (param_3 != 0);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "_qsort",
      "entry": "0041d290",
      "c": "\n/* Library Function - Single Match\n    _qsort\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n_qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,_PtFuncCompare *_PtFuncCompare)\n\n{\n  uint uVar1;\n  char cVar2;\n  int *piVar3;\n  int iVar4;\n  char *pcVar5;\n  char *pcVar6;\n  char *pcVar7;\n  size_t sVar8;\n  char *in_stack_fffffec4;\n  void *pvVar9;\n  char *pcVar10;\n  char *local_118;\n  char *local_114;\n  char *local_110;\n  int local_10c;\n  char *local_108;\n  undefined4 auStack_f8 [30];\n  undefined4 auStack_80 [30];\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  local_108 = (char *)_Base;\n  if ((((_Base == (void *)0x0) && (_NumOfElements != 0)) || (_SizeOfElements == 0)) ||\n     (_PtFuncCompare == (_PtFuncCompare *)0x0)) {\n    piVar3 = __errno();\n    *piVar3 = 0x16;\n    FUN_00412362();\n    __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n    return;\n  }\n  local_10c = 0;\n  if (_NumOfElements < 2) {\nLAB_0041d61a:\n    __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n    return;\n  }\n  pcVar5 = (char *)((_NumOfElements - 1) * _SizeOfElements + (int)_Base);\nLAB_0041d315:\n  while (uVar1 = (uint)((int)pcVar5 - (int)local_108) / _SizeOfElements + 1, 8 < uVar1) {\n    pcVar7 = local_108 + (uVar1 >> 1) * _SizeOfElements;\n    pcVar6 = local_108;\n    pcVar10 = pcVar7;\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    pvVar9 = (void *)0x41d354;\n    iVar4 = (*_PtFuncCompare)(pcVar6,pcVar10);\n    if (0 < iVar4) {\n      swap(local_108,pcVar7,_SizeOfElements);\n    }\n    pcVar6 = local_108;\n    pcVar10 = pcVar5;\n    (*(code *)PTR_guard_check_icall_0042118c)();\n    iVar4 = (*_PtFuncCompare)(pcVar6,pcVar10);\n    if (0 < iVar4) {\n      swap(local_108,pcVar5,_SizeOfElements);\n    }\n    (*(code *)PTR_guard_check_icall_0042118c)(pcVar7,pcVar5);\n    iVar4 = (*_PtFuncCompare)(in_stack_fffffec4,pvVar9);\n    local_110 = local_108;\n    local_118 = pcVar5;\n    local_114 = pcVar7;\n    if (0 < iVar4) {\n      in_stack_fffffec4 = (char *)0x41d3c2;\n      swap(pcVar7,pcVar5,_SizeOfElements);\n    }\nLAB_0041d3e0:\n    if (local_110 < pcVar7) {\n      do {\n        local_110 = local_110 + _SizeOfElements;\n        if (pcVar7 <= local_110) goto LAB_0041d421;\n        pvVar9 = (void *)0x41d3fe;\n        (*(code *)PTR_guard_check_icall_0042118c)(local_110,pcVar7);\n        iVar4 = (*_PtFuncCompare)(in_stack_fffffec4,pvVar9);\n      } while (iVar4 < 1);\n      if (pcVar7 <= local_110) goto LAB_0041d421;\n    }\n    else {\nLAB_0041d421:\n      do {\n        local_110 = local_110 + _SizeOfElements;\n        if (pcVar5 < local_110) break;\n        pvVar9 = (void *)0x41d431;\n        (*(code *)PTR_guard_check_icall_0042118c)(local_110,pcVar7);\n        iVar4 = (*_PtFuncCompare)(in_stack_fffffec4,pvVar9);\n      } while (iVar4 < 1);\n    }\n    do {\n      local_118 = local_118 + -_SizeOfElements;\n      if (local_118 <= pcVar7) break;\n      pvVar9 = (void *)0x41d476;\n      (*(code *)PTR_guard_check_icall_0042118c)(local_118,pcVar7);\n      iVar4 = (*_PtFuncCompare)(in_stack_fffffec4,pvVar9);\n    } while (0 < iVar4);\n    if (local_110 <= local_118) {\n      pcVar6 = local_118;\n      sVar8 = _SizeOfElements;\n      if (local_110 != local_118) {\n        do {\n          pcVar7 = pcVar6 + 1;\n          cVar2 = pcVar7[(int)(local_110 + (-1 - (int)local_118))];\n          pcVar7[(int)(local_110 + (-1 - (int)local_118))] = *pcVar6;\n          *pcVar6 = cVar2;\n          sVar8 = sVar8 - 1;\n          pcVar6 = pcVar7;\n          pcVar7 = local_114;\n        } while (sVar8 != 0);\n      }\n      if (pcVar7 == local_118) {\n        local_114 = local_110;\n        pcVar7 = local_110;\n      }\n      goto LAB_0041d3e0;\n    }\n    local_118 = local_118 + _SizeOfElements;\n    if (pcVar7 < local_118) {\n      do {\n        local_118 = local_118 + -_SizeOfElements;\n        if (local_118 <= pcVar7) goto LAB_0041d531;\n        pvVar9 = (void *)0x41d514;\n        (*(code *)PTR_guard_check_icall_0042118c)(local_118,pcVar7);\n        iVar4 = (*_PtFuncCompare)(in_stack_fffffec4,pvVar9);\n      } while (iVar4 == 0);\n      if (local_118 <= pcVar7) goto LAB_0041d531;\n    }\n    else {\nLAB_0041d531:\n      do {\n        local_118 = local_118 + -_SizeOfElements;\n        if (local_118 <= local_108) break;\n        pvVar9 = (void *)0x41d545;\n        (*(code *)PTR_guard_check_icall_0042118c)(local_118,pcVar7);\n        iVar4 = (*_PtFuncCompare)(in_stack_fffffec4,pvVar9);\n      } while (iVar4 == 0);\n    }\n    if ((int)local_118 - (int)local_108 < (int)pcVar5 - (int)local_110) goto LAB_0041d5ab;\n    if (local_108 < local_118) {\n      auStack_f8[local_10c] = local_108;\n      auStack_80[local_10c] = local_118;\n      local_10c = local_10c + 1;\n    }\n    local_108 = local_110;\n    if (pcVar5 <= local_110) goto LAB_0041d5f2;\n  }\n  shortsort(local_108,pcVar5,_SizeOfElements,(_func_int_void_ptr_void_ptr *)_PtFuncCompare);\n  in_stack_fffffec4 = local_108;\n  goto LAB_0041d5f2;\nLAB_0041d5ab:\n  if (local_110 < pcVar5) {\n    auStack_f8[local_10c] = local_110;\n    auStack_80[local_10c] = pcVar5;\n    local_10c = local_10c + 1;\n  }\n  pcVar5 = local_118;\n  if (local_118 <= local_108) {\nLAB_0041d5f2:\n    local_10c = local_10c + -1;\n    if (-1 < local_10c) {\n      local_108 = (char *)auStack_f8[local_10c];\n      pcVar5 = (char *)auStack_80[local_10c];\n      goto LAB_0041d315;\n    }\n    goto LAB_0041d61a;\n  }\n  goto LAB_0041d315;\n}\n\n"
    },
    {
      "name": "common_tcsncpy_s<char>",
      "entry": "0041d62a",
      "c": "\n/* Library Function - Single Match\n    int __cdecl common_tcsncpy_s<char>(char * const,unsigned int,char const * const,unsigned int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl common_tcsncpy_s<char>(char *param_1,uint param_2,char *param_3,uint param_4)\n\n{\n  char cVar1;\n  int *piVar2;\n  uint uVar3;\n  uint uVar4;\n  char *pcVar5;\n  int iVar6;\n  \n  if (param_4 == 0) {\n    if (param_1 == (char *)0x0) {\n      if (param_2 == 0) {\n        return 0;\n      }\n    }\n    else {\nLAB_0041d64c:\n      if (param_2 != 0) {\n        if (param_4 == 0) {\n          *param_1 = '\\0';\n          return 0;\n        }\n        if (param_3 != (char *)0x0) {\n          uVar3 = param_4;\n          uVar4 = param_2;\n          pcVar5 = param_1;\n          if (param_4 == 0xffffffff) {\n            do {\n              cVar1 = pcVar5[(int)param_3 - (int)param_1];\n              *pcVar5 = cVar1;\n              pcVar5 = pcVar5 + 1;\n              if (cVar1 == '\\0') break;\n              uVar4 = uVar4 - 1;\n            } while (uVar4 != 0);\n          }\n          else {\n            do {\n              cVar1 = pcVar5[(int)param_3 - (int)param_1];\n              *pcVar5 = cVar1;\n              pcVar5 = pcVar5 + 1;\n              if ((cVar1 == '\\0') || (uVar4 = uVar4 - 1, uVar4 == 0)) break;\n              uVar3 = uVar3 - 1;\n            } while (uVar3 != 0);\n            if (uVar3 == 0) {\n              *pcVar5 = '\\0';\n            }\n          }\n          if (uVar4 != 0) {\n            return 0;\n          }\n          if (param_4 == 0xffffffff) {\n            param_1[param_2 - 1] = '\\0';\n            return 0x50;\n          }\n          *param_1 = '\\0';\n          piVar2 = __errno();\n          iVar6 = 0x22;\n          goto LAB_0041d66c;\n        }\n        *param_1 = '\\0';\n      }\n    }\n  }\n  else if (param_1 != (char *)0x0) goto LAB_0041d64c;\n  piVar2 = __errno();\n  iVar6 = 0x16;\nLAB_0041d66c:\n  *piVar2 = iVar6;\n  FUN_00412362();\n  return iVar6;\n}\n\n"
    },
    {
      "name": "FUN_0041d6db",
      "entry": "0041d6db",
      "c": "\nvoid __cdecl FUN_0041d6db(char *param_1,uint param_2,char *param_3,uint param_4)\n\n{\n  common_tcsncpy_s<char>(param_1,param_2,param_3,param_4);\n  return;\n}\n\n"
    },
    {
      "name": "_strpbrk",
      "entry": "0041d6f0",
      "c": "\n/* Library Function - Single Match\n    _strpbrk\n   \n   Library: Visual Studio */\n\nchar * __cdecl _strpbrk(char *_Str,char *_Control)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte abStack_28 [32];\n  \n  abStack_28[0x1c] = 0;\n  abStack_28[0x1d] = 0;\n  abStack_28[0x1e] = 0;\n  abStack_28[0x1f] = 0;\n  abStack_28[0x18] = 0;\n  abStack_28[0x19] = 0;\n  abStack_28[0x1a] = 0;\n  abStack_28[0x1b] = 0;\n  abStack_28[0x14] = 0;\n  abStack_28[0x15] = 0;\n  abStack_28[0x16] = 0;\n  abStack_28[0x17] = 0;\n  abStack_28[0x10] = 0;\n  abStack_28[0x11] = 0;\n  abStack_28[0x12] = 0;\n  abStack_28[0x13] = 0;\n  abStack_28[0xc] = 0;\n  abStack_28[0xd] = 0;\n  abStack_28[0xe] = 0;\n  abStack_28[0xf] = 0;\n  abStack_28[8] = 0;\n  abStack_28[9] = 0;\n  abStack_28[10] = 0;\n  abStack_28[0xb] = 0;\n  abStack_28[4] = 0;\n  abStack_28[5] = 0;\n  abStack_28[6] = 0;\n  abStack_28[7] = 0;\n  abStack_28[0] = 0;\n  abStack_28[1] = 0;\n  abStack_28[2] = 0;\n  abStack_28[3] = 0;\n  while( true ) {\n    bVar1 = *_Control;\n    if (bVar1 == 0) break;\n    _Control = (char *)((byte *)_Control + 1);\n    abStack_28[(int)(uint)bVar1 >> 3] = abStack_28[(int)(uint)bVar1 >> 3] | '\\x01' << (bVar1 & 7);\n  }\n  do {\n    pbVar2 = (byte *)_Str;\n    bVar1 = *pbVar2;\n    if (bVar1 == 0) {\n      return (char *)(uint)bVar1;\n    }\n    _Str = (char *)(pbVar2 + 1);\n  } while ((abStack_28[(int)(uint)bVar1 >> 3] >> (bVar1 & 7) & 1) == 0);\n  return (char *)pbVar2;\n}\n\n"
    },
    {
      "name": "FUN_0041d73f",
      "entry": "0041d73f",
      "c": "\nSIZE_T __cdecl FUN_0041d73f(LPCVOID param_1)\n\n{\n  int *piVar1;\n  SIZE_T SVar2;\n  \n  if (param_1 == (LPCVOID)0x0) {\n    piVar1 = __errno();\n    *piVar1 = 0x16;\n    FUN_00412362();\n    return 0xffffffff;\n  }\n  SVar2 = HeapSize(DAT_0043b564,0,param_1);\n  return SVar2;\n}\n\n"
    },
    {
      "name": "__realloc_base",
      "entry": "0041d772",
      "c": "\n/* Library Function - Single Match\n    __realloc_base\n   \n   Library: Visual Studio 2015 Release */\n\nLPVOID __cdecl __realloc_base(void *param_1,uint param_2)\n\n{\n  LPVOID pvVar1;\n  int *piVar2;\n  int iVar3;\n  \n  if (param_1 == (void *)0x0) {\n    pvVar1 = __malloc_base(param_2);\n  }\n  else {\n    if (param_2 == 0) {\n      FID_conflict__free(param_1);\n    }\n    else {\n      if (param_2 < 0xffffffe1) {\n        do {\n          pvVar1 = HeapReAlloc(DAT_0043b564,0,param_1,param_2);\n          if (pvVar1 != (LPVOID)0x0) {\n            return pvVar1;\n          }\n          iVar3 = FUN_00410fdd();\n        } while ((iVar3 != 0) && (iVar3 = __callnewh(param_2), iVar3 != 0));\n      }\n      piVar2 = __errno();\n      *piVar2 = 0xc;\n    }\n    pvVar1 = (LPVOID)0x0;\n  }\n  return pvVar1;\n}\n\n"
    },
    {
      "name": "___set_fpsr_sse2",
      "entry": "0041d7db",
      "c": "\n/* WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4 */\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n/* Library Function - Single Match\n    ___set_fpsr_sse2\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___set_fpsr_sse2(uint param_1)\n\n{\n  if (0 < DAT_0043adbc) {\n    if (((param_1 & 0x40) == 0) || (DAT_0042d930 == 0)) {\n      MXCSR = param_1 & 0xffffffbf;\n    }\n    else {\n      MXCSR = param_1;\n    }\n  }\n  return;\n}\n\n"
    },
    {
      "name": "__clrfp",
      "entry": "0041d851",
      "c": "\n/* Library Function - Single Match\n    __clrfp\n   \n   Library: Visual Studio 2015 Release */\n\nint __clrfp(void)\n\n{\n  short in_FPUStatusWord;\n  \n  return (int)in_FPUStatusWord;\n}\n\n"
    },
    {
      "name": "__ctrlfp",
      "entry": "0041d864",
      "c": "\n/* Library Function - Single Match\n    __ctrlfp\n   \n   Library: Visual Studio 2015 Release */\n\nint __ctrlfp(void)\n\n{\n  short in_FPUControlWord;\n  \n  return (int)in_FPUControlWord;\n}\n\n"
    },
    {
      "name": "FUN_0041d890",
      "entry": "0041d890",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0041d890(void)\n\n{\n  return;\n}\n\n"
    },
    {
      "name": "__statfp",
      "entry": "0041d8eb",
      "c": "\n/* Library Function - Single Match\n    __statfp\n   \n   Library: Visual Studio 2015 Release */\n\nint __statfp(void)\n\n{\n  short in_FPUStatusWord;\n  \n  return (int)in_FPUStatusWord;\n}\n\n"
    },
    {
      "name": "___dcrt_lowio_initialize_console_output",
      "entry": "0041d8fd",
      "c": "\n/* Library Function - Single Match\n    ___dcrt_lowio_initialize_console_output\n   \n   Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release */\n\nvoid ___dcrt_lowio_initialize_console_output(void)\n\n{\n  DAT_0042d934 = CreateFileW(L\"CONOUT$\",0x40000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);\n  return;\n}\n\n"
    },
    {
      "name": "___strncnt",
      "entry": "0041d933",
      "c": "\n/* Library Function - Single Match\n    ___strncnt\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl ___strncnt(char *param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  \n  iVar2 = 0;\n  cVar1 = *param_1;\n  while ((cVar1 != '\\0' && (iVar2 != param_2))) {\n    iVar2 = iVar2 + 1;\n    cVar1 = param_1[iVar2];\n  }\n  return;\n}\n\n"
    },
    {
      "name": "fegetenv",
      "entry": "0041d94f",
      "c": "\n/* Library Function - Single Match\n    _fegetenv\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl fegetenv(uint *param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = __getfpcontrolword();\n  *param_1 = uVar1;\n  uVar1 = __getfpstatusword();\n  param_1[1] = uVar1;\n  return 0;\n}\n\n"
    },
    {
      "name": "fesetenv",
      "entry": "0041d96c",
      "c": "\n/* Library Function - Single Match\n    _fesetenv\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl fesetenv(uint *param_1)\n\n{\n  undefined4 uVar1;\n  uint local_c;\n  uint local_8;\n  \n  local_c = 0;\n  local_8 = 0;\n  __setfpcontrolword(*param_1);\n  __setfpstatusword(param_1[1]);\n  fegetenv(&local_c);\n  if ((*param_1 == local_c) && (param_1[1] == local_8)) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = 1;\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "feholdexcept",
      "entry": "0041d9b5",
      "c": "\n/* Library Function - Single Match\n    _feholdexcept\n   \n   Library: Visual Studio 2015 Release */\n\nundefined4 __cdecl feholdexcept(uint *param_1)\n\n{\n  int iVar1;\n  uint local_c;\n  uint local_8;\n  \n  local_c = 0;\n  local_8 = 0;\n  iVar1 = fegetenv(&local_c);\n  if (iVar1 == 0) {\n    param_1[1] = local_8;\n    *param_1 = local_c;\n    local_c = local_c | 0x1f;\n    iVar1 = fesetenv(&local_c);\n    if (iVar1 == 0) {\n      __clearfp();\n      return 0;\n    }\n  }\n  return 1;\n}\n\n"
    },
    {
      "name": "FUN_0041da50",
      "entry": "0041da50",
      "c": "\nvoid FUN_0041da50(void)\n\n{\n  ushort in_FPUControlWord;\n  float10 in_ST0;\n  double dVar1;\n  \n  if ((DAT_0043b67c != 0) && ((MXCSR & 0x7f80) == 0x1f80 && (in_FPUControlWord & 0x7f) == 0x7f)) {\n    FUN_0041e6b0();\n    return;\n  }\n  dVar1 = (double)in_ST0;\n  FUN_0041edc8(SUB84(dVar1,0),(uint)((ulonglong)dVar1 >> 0x20));\n  FUN_0041daa8(SUB84(dVar1,0),(uint)((ulonglong)dVar1 >> 0x20));\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041daa8",
      "entry": "0041daa8",
      "c": "\nuint __cdecl FUN_0041daa8(int param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint in_EAX;\n  uint uVar2;\n  uint extraout_EAX;\n  bool in_ZF;\n  ushort in_FPUControlWord;\n  undefined4 unaff_retaddr;\n  \n  if (in_ZF) {\n    if (((in_EAX & 0xfffff) != 0) || (param_1 != 0)) {\n      uVar2 = FUN_0041ed6c();\n      goto LAB_0041db41;\n    }\n    uVar2 = in_EAX & 0x80000000;\n    uVar1 = uVar2;\n  }\n  else {\n    uVar1 = param_2;\n    if ((param_2 & 0x7ff00000) == 0) {\n      if (((param_2 & 0xfffff) == 0) && (param_1 == 0)) {\n        uVar2 = 2;\n        goto LAB_0041db41;\n      }\n      uVar2 = param_2 & 0x80000000;\n    }\n    else {\n      uVar2 = param_2 & 0x80000000;\n    }\n  }\n  if (uVar2 == 0) {\n    if (DAT_0043b654 != 0) {\n      return uVar1;\n    }\n    uVar2 = __math_exit(\"log10\",0x1b,unaff_retaddr,param_1,param_2);\n    return uVar2;\n  }\n  uVar2 = 1;\nLAB_0041db41:\n  if (DAT_0043b654 != 0) {\n    return uVar2;\n  }\n  __startOneArgErrorHandling(\"log10\",0x1b,in_FPUControlWord,unaff_retaddr,param_1,param_2);\n  return extraout_EAX;\n}\n\n"
    },
    {
      "name": "FUN_0041db60",
      "entry": "0041db60",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nfloat10 __cdecl FUN_0041db60(double param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  ushort in_FPUControlWord;\n  float10 fVar4;\n  double dVar5;\n  longlong lVar6;\n  \n  if ((DAT_0043b67c == 0) || ((MXCSR & 0x7f80) != 0x1f80 || (in_FPUControlWord & 0x7f) != 0x7f)) {\n    uVar2 = __ctrlfp();\n    if ((param_1._6_2_ & 0x7ff0) == 0x7ff0) {\n      iVar3 = __sptype(SUB84(param_1,0),(uint)((ulonglong)param_1 >> 0x20));\n      if (iVar3 - 1U < 3) {\n        __ctrlfp();\n        return (float10)param_1;\n      }\n      dVar5 = _DAT_0042ae40 + param_1;\n      uVar1 = 8;\n    }\n    else {\n      fVar4 = FUN_0041f494(param_1);\n      dVar5 = (double)fVar4;\n      if (((float10)param_1 == fVar4) || ((uVar2 & 0x20) != 0)) {\n        __ctrlfp();\n        return (float10)dVar5;\n      }\n      dVar5 = (double)fVar4;\n      uVar1 = 0x10;\n    }\n    fVar4 = (float10)__except1(uVar1,0xc,param_1,dVar5,uVar2);\n    return fVar4;\n  }\n  uVar2 = (uint)((ulonglong)param_1 >> 0x20);\n  uVar1 = uVar2 >> 0x14;\n  lVar6 = CONCAT44(_UNK_0042abf4,_DAT_0042abf0 - (uVar2 >> 0x14 & _DAT_0042ac10));\n  if ((uVar1 & 0x800) == 0) {\n    dVar5 = (double)(((ulonglong)param_1 >> lVar6) << lVar6);\n    if (uVar1 < 0x3ff) {\n      return (float10)(double)(-(ulonglong)(_DAT_0042ac00 < param_1) & _DAT_0042abe0);\n    }\n    if (uVar1 < 0x433) {\n      return (float10)(dVar5 + (double)(-(ulonglong)(dVar5 < param_1) & _DAT_0042abe0));\n    }\n  }\n  else {\n    if (uVar1 < 0xbff) {\n      return (float10)_DAT_0042ac20;\n    }\n    if (uVar1 < 0xc33) {\n      return (float10)(double)(((ulonglong)param_1 >> lVar6) << lVar6);\n    }\n  }\n  if (NAN(param_1)) {\n    ___libm_error_support(&param_1,&param_1,&param_1,0x3ec);\n  }\n  return (float10)param_1;\n}\n\n"
    },
    {
      "name": "___acrt_LCMapStringW",
      "entry": "0041dc7d",
      "c": "\n/* Library Function - Single Match\n    ___acrt_LCMapStringW\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___acrt_LCMapStringW\n          (wchar_t *param_1,DWORD param_2,LPCWSTR param_3,uint param_4,LPWSTR param_5,int param_6)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar2 = param_4;\n  if (0 < (int)param_4) {\n    uVar1 = FUN_00409bff(param_3,param_4);\n    uVar2 = uVar1 + 1;\n    if ((int)param_4 <= (int)uVar1) {\n      uVar2 = uVar1;\n    }\n  }\n  ___acrt_LCMapStringEx_36(param_1,param_2,param_3,uVar2,param_5,param_6,0,0,0);\n  return;\n}\n\n"
    },
    {
      "name": "___ascii_strnicmp",
      "entry": "0041dcc0",
      "c": "\n/* Library Function - Single Match\n    ___ascii_strnicmp\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)\n\n{\n  char cVar1;\n  byte bVar2;\n  ushort uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  if (_MaxCount != 0) {\n    do {\n      bVar2 = *_Str1;\n      cVar1 = *_Str2;\n      uVar3 = CONCAT11(bVar2,cVar1);\n      if (bVar2 == 0) break;\n      uVar3 = CONCAT11(bVar2,cVar1);\n      uVar4 = (uint)uVar3;\n      if (cVar1 == '\\0') break;\n      _Str1 = (char *)((byte *)_Str1 + 1);\n      _Str2 = _Str2 + 1;\n      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {\n        uVar4 = (uint)CONCAT11(bVar2 + 0x20,cVar1);\n      }\n      uVar3 = (ushort)uVar4;\n      bVar2 = (byte)uVar4;\n      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {\n        uVar3 = (ushort)CONCAT31((int3)(uVar4 >> 8),bVar2 + 0x20);\n      }\n      bVar2 = (byte)(uVar3 >> 8);\n      bVar5 = bVar2 < (byte)uVar3;\n      if (bVar2 != (byte)uVar3) goto LAB_0041dd11;\n      _MaxCount = _MaxCount - 1;\n    } while (_MaxCount != 0);\n    _MaxCount = 0;\n    bVar2 = (byte)(uVar3 >> 8);\n    bVar5 = bVar2 < (byte)uVar3;\n    if (bVar2 != (byte)uVar3) {\nLAB_0041dd11:\n      _MaxCount = 0xffffffff;\n      if (!bVar5) {\n        _MaxCount = 1;\n      }\n    }\n  }\n  return _MaxCount;\n}\n\n"
    },
    {
      "name": "__chsize_nolock",
      "entry": "0041dd21",
      "c": "\n/* Library Function - Single Match\n    __chsize_nolock\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl __chsize_nolock(int _FileHandle,longlong _Size)\n\n{\n  int iVar1;\n  int *piVar2;\n  LPVOID _Buf;\n  int iVar3;\n  ulong *puVar4;\n  HANDLE hFile;\n  BOOL BVar5;\n  DWORD DVar6;\n  int unaff_EBX;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int unaff_EDI;\n  ulonglong uVar10;\n  longlong lVar11;\n  uint in_stack_00000008;\n  int local_8;\n  \n  uVar10 = __lseeki64_nolock(_FileHandle,0x100000000,unaff_EDI);\n  if (uVar10 == 0xffffffffffffffff) {\nLAB_0041dd4c:\n    piVar2 = __errno();\n    return *piVar2;\n  }\n  lVar11 = __lseeki64_nolock(_FileHandle,0x200000000,unaff_EDI);\n  iVar3 = (int)((ulonglong)lVar11 >> 0x20);\n  if (lVar11 == -1) goto LAB_0041dd4c;\n  uVar7 = in_stack_00000008 - (uint)lVar11;\n  uVar8 = (uint)(in_stack_00000008 < (uint)lVar11);\n  iVar1 = (int)_Size - iVar3;\n  local_8 = iVar1 - uVar8;\n  if ((local_8 < 0) ||\n     ((local_8 == 0 || (SBORROW4((int)_Size,iVar3) != SBORROW4(iVar1,uVar8)) != local_8 < 0 &&\n      (uVar7 == 0)))) {\n    if ((local_8 < 1) && (local_8 < 0)) {\n      lVar11 = __lseeki64_nolock(_FileHandle,_Size & 0xffffffff,unaff_EBX);\n      if (lVar11 == -1) goto LAB_0041de2a;\n      hFile = (HANDLE)__get_osfhandle(_FileHandle);\n      BVar5 = SetEndOfFile(hFile);\n      if (BVar5 == 0) {\n        piVar2 = __errno();\n        *piVar2 = 0xd;\n        puVar4 = ___doserrno();\n        DVar6 = GetLastError();\n        *puVar4 = DVar6;\n        goto LAB_0041de2a;\n      }\n    }\n  }\n  else {\n    _Buf = __calloc_base(0x1000,1);\n    if (_Buf == (LPVOID)0x0) {\n      piVar2 = __errno();\n      *piVar2 = 0xc;\nLAB_0041de48:\n      piVar2 = __errno();\n      iVar3 = *piVar2;\n      FID_conflict__free(_Buf);\n      return iVar3;\n    }\n    iVar3 = __setmode_nolock(_FileHandle,0x8000);\n    do {\n      uVar8 = uVar7;\n      if (local_8 < 0) goto LAB_0041ddda;\n      uVar9 = uVar7;\n      if ((local_8 < 1) && (uVar7 < 0x1000)) goto LAB_0041ddda;\n      do {\n        uVar7 = 0x1000;\n        uVar8 = uVar9;\nLAB_0041ddda:\n        uVar7 = __write_nolock(_FileHandle,_Buf,uVar7);\n        if (uVar7 == 0xffffffff) {\n          puVar4 = ___doserrno();\n          if (*puVar4 == 5) {\n            piVar2 = __errno();\n            *piVar2 = 0xd;\n          }\n          goto LAB_0041de48;\n        }\n        uVar9 = uVar8 - uVar7;\n        local_8 = (local_8 - ((int)uVar7 >> 0x1f)) - (uint)(uVar8 < uVar7);\n      } while (0 < local_8);\n    } while ((-1 < local_8) && (uVar7 = uVar9, uVar9 != 0));\n    __setmode_nolock(_FileHandle,iVar3);\n    FID_conflict__free(_Buf);\n  }\n  lVar11 = __lseeki64_nolock(_FileHandle,uVar10 >> 0x20,unaff_EBX);\n  if (lVar11 != -1) {\n    return 0;\n  }\nLAB_0041de2a:\n  piVar2 = __errno();\n  return *piVar2;\n}\n\n"
    },
    {
      "name": "___acrt_CompareStringW",
      "entry": "0041deb2",
      "c": "\n/* Library Function - Single Match\n    ___acrt_CompareStringW\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\n___acrt_CompareStringW\n          (wchar_t *param_1,ulong param_2,wchar_t *param_3,uint param_4,wchar_t *param_5,\n          uint param_6)\n\n{\n  int iVar1;\n  \n  if (0 < (int)param_4) {\n    param_4 = FUN_00409bff(param_3,param_4);\n  }\n  if (0 < (int)param_6) {\n    param_6 = FUN_00409bff(param_5,param_6);\n  }\n  if ((param_4 == 0) || (param_6 == 0)) {\n    if (param_4 == param_6) {\n      iVar1 = 2;\n    }\n    else {\n      iVar1 = (uint)(-1 < (int)(param_4 - param_6)) * 2 + 1;\n    }\n  }\n  else {\n    iVar1 = ___acrt_CompareStringEx_36\n                      (param_1,param_2,param_3,param_4,param_5,param_6,(_nlsversioninfo *)0x0,\n                       (void *)0x0,0);\n  }\n  return iVar1;\n}\n\n"
    },
    {
      "name": "InternalCompareStringA",
      "entry": "0041df1a",
      "c": "\n/* WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    int __cdecl InternalCompareStringA(struct __crt_locale_pointers *,wchar_t const *,unsigned\n   long,char const *,int,char const *,int,int)\n   \n   Library: Visual Studio 2015 Release */\n\nint __cdecl\nInternalCompareStringA\n          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,\n          char *param_6,int param_7,int param_8)\n\n{\n  uint uVar1;\n  BOOL BVar2;\n  wchar_t *pwVar3;\n  int iVar4;\n  LPWSTR pWVar5;\n  int iVar6;\n  int iVar7;\n  BYTE *pBVar8;\n  LPWSTR lpWideCharStr;\n  wchar_t *local_20;\n  _cpinfo local_1c;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (param_5 < 1) {\n    if (param_5 < -1) goto LAB_0041e1ae;\n  }\n  else {\n    param_5 = ___strncnt(param_4,param_5);\n  }\n  if (param_7 < 1) {\n    if (param_7 < -1) goto LAB_0041e1ae;\n  }\n  else {\n    param_7 = ___strncnt(param_6,param_7);\n  }\n  if (param_8 == 0) {\n    param_8 = *(int *)(*(int *)param_1 + 8);\n  }\n  if ((param_5 == 0) || (param_7 == 0)) {\n    if ((param_5 == param_7) ||\n       (((1 < param_7 || (1 < param_5)) || (BVar2 = GetCPInfo(param_8,&local_1c), BVar2 == 0))))\n    goto LAB_0041e1ae;\n    if (0 < param_5) {\n      if (1 < local_1c.MaxCharSize) {\n        pBVar8 = local_1c.LeadByte;\n        while (((local_1c.LeadByte[0] != 0 && (pBVar8[1] != 0)) &&\n               (((byte)*param_4 < *pBVar8 || (pBVar8[1] < (byte)*param_4))))) {\n          pBVar8 = pBVar8 + 2;\n          local_1c.LeadByte[0] = *pBVar8;\n        }\n      }\n      goto LAB_0041e1ae;\n    }\n    if (0 < param_7) {\n      if (1 < local_1c.MaxCharSize) {\n        pBVar8 = local_1c.LeadByte;\n        while (((local_1c.LeadByte[0] != 0 && (pBVar8[1] != 0)) &&\n               (((byte)*param_6 < *pBVar8 || (pBVar8[1] < (byte)*param_6))))) {\n          pBVar8 = pBVar8 + 2;\n          local_1c.LeadByte[0] = *pBVar8;\n        }\n      }\n      goto LAB_0041e1ae;\n    }\n  }\n  iVar7 = MultiByteToWideChar(param_8,9,param_4,param_5,(LPWSTR)0x0,0);\n  if (iVar7 == 0) goto LAB_0041e1ae;\n  uVar1 = iVar7 * 2;\n  if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) {\n    local_20 = (wchar_t *)0x0;\nLAB_0041e0c6:\n    if (((local_20 != (wchar_t *)0x0) &&\n        (iVar4 = MultiByteToWideChar(param_8,1,param_4,param_5,local_20,iVar7), iVar4 != 0)) &&\n       (iVar4 = MultiByteToWideChar(param_8,9,param_6,param_7,(LPWSTR)0x0,0), iVar4 != 0)) {\n      uVar1 = iVar4 * 2;\n      if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) {\n        lpWideCharStr = (LPWSTR)0x0;\nLAB_0041e15e:\n        if ((lpWideCharStr != (LPWSTR)0x0) &&\n           (iVar6 = MultiByteToWideChar(param_8,1,param_6,param_7,lpWideCharStr,iVar4), iVar6 != 0))\n        {\n          ___acrt_CompareStringEx_36\n                    (param_2,param_3,local_20,iVar7,lpWideCharStr,iVar4,(_nlsversioninfo *)0x0,\n                     (void *)0x0,0);\n        }\n      }\n      else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) {\n        pWVar5 = (LPWSTR)&stack0xffffffc4;\n        lpWideCharStr = (LPWSTR)&stack0xffffffc4;\n        if (&stack0x00000000 != (undefined1 *)0x3c) {\nLAB_0041e157:\n          lpWideCharStr = pWVar5 + 4;\n          goto LAB_0041e15e;\n        }\n      }\n      else {\n        pWVar5 = (LPWSTR)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8);\n        lpWideCharStr = pWVar5;\n        if (pWVar5 != (LPWSTR)0x0) {\n          pWVar5[0] = L'\\xdddd';\n          pWVar5[1] = L'\\0';\n          goto LAB_0041e157;\n        }\n      }\n      __freea_crt((int)lpWideCharStr);\n    }\n  }\n  else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) {\n    pwVar3 = (wchar_t *)&stack0xffffffc4;\n    local_20 = (wchar_t *)&stack0xffffffc4;\n    if (&stack0x00000000 != (undefined1 *)0x3c) {\nLAB_0041e0b9:\n      local_20 = pwVar3 + 4;\n      goto LAB_0041e0c6;\n    }\n  }\n  else {\n    pwVar3 = (wchar_t *)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8);\n    local_20 = pwVar3;\n    if (pwVar3 != (wchar_t *)0x0) {\n      pwVar3[0] = L'\\xdddd';\n      pwVar3[1] = L'\\0';\n      goto LAB_0041e0b9;\n    }\n  }\n  __freea_crt((int)local_20);\nLAB_0041e1ae:\n  iVar7 = __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return iVar7;\n}\n\n"
    },
    {
      "name": "___acrt_CompareStringA",
      "entry": "0041e1c2",
      "c": "\n/* Library Function - Single Match\n    ___acrt_CompareStringA\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___acrt_CompareStringA\n          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,\n          char *param_6,int param_7,int param_8)\n\n{\n  int local_14;\n  __crt_locale_pointers local_10 [8];\n  char local_8;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,param_1);\n  InternalCompareStringA(local_10,param_2,param_3,param_4,param_5,param_6,param_7,param_8);\n  if (local_8 != '\\0') {\n    *(uint *)(local_14 + 0x350) = *(uint *)(local_14 + 0x350) & 0xfffffffd;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "___get_abstract_control_sse2",
      "entry": "0041e20a",
      "c": "\n/* Library Function - Single Match\n    ___get_abstract_control_sse2\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___get_abstract_control_sse2(uint param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  if ((param_1 & 0x7e80) != 0) {\n    if ((char)param_1 < '\\0') {\n      uVar1 = 0x10;\n    }\n    if ((param_1 & 0x200) != 0) {\n      uVar1 = uVar1 | 8;\n    }\n    if ((param_1 & 0x400) != 0) {\n      uVar1 = uVar1 | 4;\n    }\n    if ((param_1 & 0x800) != 0) {\n      uVar1 = uVar1 | 2;\n    }\n    if ((param_1 & 0x1000) != 0) {\n      uVar1 = uVar1 | 1;\n    }\n    if ((param_1 & 0x6000) == 0x6000) {\n      uVar1 = uVar1 | 0x300;\n    }\n    else if ((param_1 & 0x4000) == 0) {\n      if ((param_1 & 0x2000) != 0) {\n        uVar1 = uVar1 | 0x200;\n      }\n    }\n    else {\n      uVar1 = uVar1 | 0x100;\n    }\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "___get_abstract_control_x87",
      "entry": "0041e287",
      "c": "\n/* Library Function - Single Match\n    ___get_abstract_control_x87\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___get_abstract_control_x87(uint param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  if ((param_1 & 0xc3d) != 0) {\n    if ((param_1 & 1) != 0) {\n      uVar1 = 0x10;\n    }\n    if ((param_1 & 4) != 0) {\n      uVar1 = uVar1 | 8;\n    }\n    if ((param_1 & 8) != 0) {\n      uVar1 = uVar1 | 4;\n    }\n    if ((param_1 & 0x10) != 0) {\n      uVar1 = uVar1 | 2;\n    }\n    if ((param_1 & 0x20) != 0) {\n      uVar1 = uVar1 | 1;\n    }\n    if ((param_1 & 0xc00) == 0xc00) {\n      uVar1 = uVar1 | 0x300;\n    }\n    else if ((param_1 & 0x800) == 0) {\n      if ((param_1 & 0x400) != 0) {\n        uVar1 = uVar1 | 0x200;\n      }\n    }\n    else {\n      uVar1 = uVar1 | 0x100;\n    }\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "___get_machine_control",
      "entry": "0041e2fa",
      "c": "\n/* Library Function - Single Match\n    ___get_machine_control\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___get_machine_control(uint param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  if ((param_1 & 799) != 0) {\n    uVar1 = (uint)((param_1 & 0x10) != 0);\n    if ((param_1 & 8) != 0) {\n      uVar1 = uVar1 | 4;\n    }\n    if ((param_1 & 4) != 0) {\n      uVar1 = uVar1 | 8;\n    }\n    if ((param_1 & 2) != 0) {\n      uVar1 = uVar1 | 0x10;\n    }\n    if ((param_1 & 1) != 0) {\n      uVar1 = uVar1 | 0x20;\n    }\n    if ((param_1 & 0x300) == 0x300) {\n      uVar1 = uVar1 | 0xc00;\n    }\n    else if ((param_1 & 0x200) == 0) {\n      if ((param_1 & 0x100) != 0) {\n        uVar1 = uVar1 | 0x800;\n      }\n    }\n    else {\n      uVar1 = uVar1 | 0x400;\n    }\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "___get_machine_control_sse2",
      "entry": "0041e36b",
      "c": "\n/* Library Function - Single Match\n    ___get_machine_control_sse2\n   \n   Library: Visual Studio 2015 Release */\n\nuint __cdecl ___get_machine_control_sse2(uint param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  if ((param_1 & 799) != 0) {\n    if ((param_1 & 0x10) != 0) {\n      uVar1 = 0x80;\n    }\n    if ((param_1 & 8) != 0) {\n      uVar1 = uVar1 | 0x200;\n    }\n    if ((param_1 & 4) != 0) {\n      uVar1 = uVar1 | 0x400;\n    }\n    if ((param_1 & 2) != 0) {\n      uVar1 = uVar1 | 0x800;\n    }\n    if ((param_1 & 1) != 0) {\n      uVar1 = uVar1 | 0x1000;\n    }\n    if ((param_1 & 0x300) == 0x300) {\n      uVar1 = uVar1 | 0x6000;\n    }\n    else if ((param_1 & 0x200) == 0) {\n      if ((param_1 & 0x100) != 0) {\n        uVar1 = uVar1 | 0x4000;\n      }\n    }\n    else {\n      uVar1 = uVar1 | 0x2000;\n    }\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "___get_machine_status_sse2",
      "entry": "0041e3eb",
      "c": "\n/* Library Function - Single Match\n    ___get_machine_status_sse2\n   \n   Library: Visual Studio 2015 Release */\n\nbyte __cdecl ___get_machine_status_sse2(uint param_1)\n\n{\n  byte bVar1;\n  \n  bVar1 = 0;\n  if ((param_1 & 0x1f) != 0) {\n    bVar1 = (param_1 & 0x10000010) == 0x10000010;\n    if ((param_1 & 0x8000008) == 0x8000008) {\n      bVar1 = bVar1 | 4;\n    }\n    if ((param_1 & 0x4000004) == 0x4000004) {\n      bVar1 = bVar1 | 8;\n    }\n    if ((param_1 & 0x2000002) == 0x2000002) {\n      bVar1 = bVar1 | 0x10;\n    }\n    if ((param_1 & 0x1000001) == 0x1000001) {\n      bVar1 = bVar1 | 0x20;\n    }\n  }\n  return bVar1;\n}\n\n"
    },
    {
      "name": "___get_machine_status_x87",
      "entry": "0041e44c",
      "c": "\n/* Library Function - Single Match\n    ___get_machine_status_x87\n   \n   Library: Visual Studio 2015 Release */\n\nbyte __cdecl ___get_machine_status_x87(uint param_1)\n\n{\n  byte bVar1;\n  \n  bVar1 = 0;\n  if ((param_1 & 0x1f) != 0) {\n    bVar1 = (param_1 & 0x100010) == 0x100010;\n    if ((param_1 & 0x80008) == 0x80008) {\n      bVar1 = bVar1 | 4;\n    }\n    if ((param_1 & 0x40004) == 0x40004) {\n      bVar1 = bVar1 | 8;\n    }\n    if ((param_1 & 0x20002) == 0x20002) {\n      bVar1 = bVar1 | 0x10;\n    }\n    if ((param_1 & 0x10001) == 0x10001) {\n      bVar1 = bVar1 | 0x20;\n    }\n  }\n  return bVar1;\n}\n\n"
    },
    {
      "name": "__getfpcontrolword",
      "entry": "0041e4ad",
      "c": "\n/* Library Function - Single Match\n    __getfpcontrolword\n   \n   Library: Visual Studio 2015 Release */\n\nuint __getfpcontrolword(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ushort in_FPUControlWord;\n  undefined4 local_c;\n  \n  local_c = 0;\n  if (0 < DAT_0043adbc) {\n    local_c = MXCSR;\n  }\n  uVar1 = ___get_abstract_control_x87((uint)in_FPUControlWord);\n  uVar2 = ___get_abstract_control_sse2(local_c);\n  return (uVar2 | uVar1) & 799;\n}\n\n"
    },
    {
      "name": "__getfpstatusword",
      "entry": "0041e4f0",
      "c": "\n/* Library Function - Single Match\n    __getfpstatusword\n   \n   Library: Visual Studio 2015 Release */\n\nuint __getfpstatusword(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  ushort in_FPUStatusWord;\n  undefined4 local_c;\n  \n  uVar2 = 0;\n  local_c = 0;\n  if (0 < DAT_0043adbc) {\n    local_c = MXCSR;\n  }\n  uVar1 = 0;\n  if ((in_FPUStatusWord & 0x3d) != 0) {\n    if ((in_FPUStatusWord & 1) != 0) {\n      uVar1 = 0x100010;\n    }\n    if ((in_FPUStatusWord & 4) != 0) {\n      uVar1 = uVar1 | 0x80008;\n    }\n    if ((in_FPUStatusWord & 8) != 0) {\n      uVar1 = uVar1 | 0x40004;\n    }\n    if ((in_FPUStatusWord & 0x10) != 0) {\n      uVar1 = uVar1 | 0x20002;\n    }\n    if ((in_FPUStatusWord & 0x20) != 0) {\n      uVar1 = uVar1 | 0x10001;\n    }\n  }\n  if ((local_c & 0x3d) != 0) {\n    if ((local_c & 1) != 0) {\n      uVar2 = 0x10000010;\n    }\n    if ((local_c & 4) != 0) {\n      uVar2 = uVar2 | 0x8000008;\n    }\n    if ((local_c & 8) != 0) {\n      uVar2 = uVar2 | 0x4000004;\n    }\n    if ((local_c & 0x10) != 0) {\n      uVar2 = uVar2 | 0x2000002;\n    }\n    if ((local_c & 0x20) != 0) {\n      uVar2 = uVar2 | 0x1000001;\n    }\n  }\n  return uVar1 | uVar2;\n}\n\n"
    },
    {
      "name": "__setfpcontrolword",
      "entry": "0041e598",
      "c": "\n/* Library Function - Single Match\n    __setfpcontrolword\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __setfpcontrolword(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  ___get_machine_control(799);\n  ___get_machine_control(param_1);\n  uVar1 = MXCSR;\n  if (0 < DAT_0043adbc) {\n    uVar2 = ___get_machine_control_sse2(799);\n    MXCSR = ___get_machine_control_sse2(param_1);\n    MXCSR = ~uVar2 & uVar1 | MXCSR;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "__setfpstatusword",
      "entry": "0041e618",
      "c": "\n/* Library Function - Single Match\n    __setfpstatusword\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __setfpstatusword(uint param_1)\n\n{\n  uint uVar1;\n  byte bVar2;\n  byte bVar3;\n  undefined3 extraout_var;\n  undefined3 extraout_var_00;\n  \n  ___get_machine_status_x87(0x1f1f001f);\n  ___get_machine_status_x87(param_1);\n  uVar1 = MXCSR;\n  if (0 < DAT_0043adbc) {\n    bVar2 = ___get_machine_status_sse2(0x1f1f001f);\n    bVar3 = ___get_machine_status_sse2(param_1);\n    MXCSR = ~CONCAT31(extraout_var,bVar2) & uVar1 | CONCAT31(extraout_var_00,bVar3);\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041e6b0",
      "entry": "0041e6b0",
      "c": "\nvoid FUN_0041e6b0(void)\n\n{\n  float10 in_ST0;\n  \n  FUN_0041e6ce((double)in_ST0);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041e6ce",
      "entry": "0041e6ce",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nfloat10 __cdecl FUN_0041e6ce(double param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  double dVar6;\n  double dVar7;\n  undefined1 in_XMM0 [16];\n  double dVar8;\n  double dVar9;\n  double dVar10;\n  double local_c;\n  \n  iVar4 = 0;\n  while( true ) {\n    uVar2 = (uint)(ushort)(in_XMM0._6_2_ >> 4);\n    dVar6 = (double)(in_XMM0._0_8_ & (ulonglong)_DAT_0042ac30 | (ulonglong)DAT_0042aca0);\n    dVar7 = (double)(in_XMM0._0_8_ & _UNK_0042ac38 | _UNK_0042aca8);\n    uVar1 = SUB82(_DAT_0042ac50 + dVar6,0) & 0x7f0;\n    dVar10 = (double)(_UNK_0042ac68 & (ulonglong)dVar7);\n    dVar9 = (double)(_DAT_0042ac60 & (ulonglong)dVar6) * *(double *)(&DAT_0042b260 + uVar1) -\n            _DAT_0042ac40;\n    dVar6 = (dVar6 - (double)(_DAT_0042ac60 & (ulonglong)dVar6)) *\n            *(double *)(&DAT_0042b260 + uVar1);\n    dVar8 = (dVar7 - dVar10) * *(double *)(&UNK_0042b268 + uVar1);\n    dVar7 = dVar6 + dVar9;\n    in_XMM0._8_8_ = dVar8 + (dVar10 * *(double *)(&UNK_0042b268 + uVar1) - _UNK_0042ac48);\n    uVar3 = uVar2 - 1;\n    if (uVar3 < 0x7fe) {\n      iVar4 = (uVar2 - 0x3ff) + iVar4;\n      dVar10 = (double)iVar4;\n      iVar5 = 0;\n      if (uVar1 + iVar4 * 0x400 == 0) {\n        iVar5 = 0x10;\n      }\n      return (float10)(((_UNK_0042acf8 * in_XMM0._8_8_ + _UNK_0042ad08) * in_XMM0._8_8_ +\n                       _UNK_0042ad18) * in_XMM0._8_8_ * in_XMM0._8_8_ +\n                       ((_DAT_0042acf0 * dVar7 + _DAT_0042ad00) * dVar7 + _DAT_0042ad10) *\n                       dVar7 * dVar7 * dVar7 * dVar7 * dVar7 + _DAT_0042ad20 * dVar7 +\n                       *(double *)(&UNK_0042ae58 + uVar1) + dVar10 * _UNK_0042ac78 +\n                       (double)((ulonglong)dVar8 & *(ulonglong *)(&UNK_0042ac88 + iVar5)) +\n                      *(double *)(&DAT_0042ae50 + uVar1) + dVar9 + dVar10 * _DAT_0042ac70 +\n                      (double)((ulonglong)dVar6 & *(ulonglong *)(&DAT_0042ac80 + iVar5)));\n    }\n    local_c = (double)-(ulonglong)(_DAT_0042acb0 == param_1);\n    if (SUB82(local_c,0) != 0) break;\n    if (uVar3 != 0xffffffff) {\n      if (uVar3 < 0x7ff) {\n        if (DAT_0042aca0 ==\n            (double)((ulonglong)param_1 & (ulonglong)_DAT_0042ac30 | (ulonglong)DAT_0042aca0)) {\n          return (float10)_DAT_0042acd8;\n        }\n        iVar4 = 0x3e9;\n        local_c = _DAT_0042ac30;\n      }\n      else if (((uVar2 & 0x7ff) < 0x7ff) ||\n              (SUB84(param_1,0) == 0 && ((ulonglong)param_1 & 0xfffff00000000) == 0)) {\n        local_c = -NAN;\n        iVar4 = 9;\n      }\n      else {\n        iVar4 = 0x3e9;\n      }\n      goto LAB_0041e8da;\n    }\n    in_XMM0._0_8_ = param_1 * DAT_0042acc0;\n    iVar4 = -0x34;\n  }\n  iVar4 = 8;\n  local_c = DAT_0042acd0;\nLAB_0041e8da:\n  ___libm_error_support(&param_1,&param_1,&local_c,iVar4);\n  return (float10)local_c;\n}\n\n"
    },
    {
      "name": "FUN_0041ed6c",
      "entry": "0041ed6c",
      "c": "\nundefined4 FUN_0041ed6c(void)\n\n{\n  uint in_EAX;\n  \n  if ((in_EAX & 0x80000) != 0) {\n    return 0;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_0041edc8",
      "entry": "0041edc8",
      "c": "\nuint __cdecl FUN_0041edc8(undefined4 param_1,uint param_2)\n\n{\n  if ((param_2 & 0x7ff00000) != 0x7ff00000) {\n    return param_2 & 0x7ff00000;\n  }\n  return param_2;\n}\n\n"
    },
    {
      "name": "__math_exit",
      "entry": "0041edeb",
      "c": "\n/* Library Function - Single Match\n    __math_exit\n   \n   Library: Visual Studio */\n\nvoid __fastcall\n__math_exit(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5)\n\n{\n  ushort in_FPUStatusWord;\n  ushort unaff_retaddr;\n  \n  if (((unaff_retaddr != 0x27f) && ((unaff_retaddr & 0x20) != 0)) &&\n     ((in_FPUStatusWord & 0x20) != 0)) {\n    __startOneArgErrorHandling(param_1,param_2,unaff_retaddr,param_3,param_4,param_5);\n    return;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041eed0",
      "entry": "0041eed0",
      "c": "\nfloat10 __fastcall\nFUN_0041eed0(undefined4 param_1,int param_2,undefined2 param_3,undefined4 param_4,undefined4 param_5\n            ,undefined4 param_6,undefined4 param_7,undefined4 param_8)\n\n{\n  float10 in_ST0;\n  int local_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  undefined4 uStack_18;\n  undefined4 local_14;\n  undefined4 local_10;\n  double dStack_c;\n  \n  local_14 = param_7;\n  local_10 = param_8;\n  dStack_c = (double)in_ST0;\n  uStack_1c = param_5;\n  uStack_18 = param_6;\n  uStack_20 = param_1;\n  __87except(param_2,&local_24,&param_3);\n  return (float10)dStack_c;\n}\n\n"
    },
    {
      "name": "__startOneArgErrorHandling",
      "entry": "0041eee7",
      "c": "\n/* Library Function - Single Match\n    __startOneArgErrorHandling\n   \n   Library: Visual Studio 2015 Release */\n\nfloat10 __fastcall\n__startOneArgErrorHandling\n          (undefined4 param_1,int param_2,ushort param_3,undefined4 param_4,undefined4 param_5,\n          undefined4 param_6)\n\n{\n  float10 in_ST0;\n  int local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  undefined4 local_18;\n  double local_c;\n  \n  local_c = (double)in_ST0;\n  local_1c = param_5;\n  local_18 = param_6;\n  local_20 = param_1;\n  __87except(param_2,&local_24,&param_3);\n  return (float10)local_c;\n}\n\n"
    },
    {
      "name": "___libm_error_support",
      "entry": "0041ef23",
      "c": "\n/* Library Function - Single Match\n    ___libm_error_support\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n___libm_error_support(undefined8 *param_1,undefined8 *param_2,undefined8 *param_3,int param_4)\n\n{\n  undefined8 uVar1;\n  code *pcVar2;\n  int iVar3;\n  int *piVar4;\n  undefined4 local_28;\n  char *local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  undefined8 local_10;\n  uint local_8;\n  \n  local_8 = DAT_0042d008 ^ (uint)&stack0xfffffffc;\n  if (DAT_0043b658 == 0) {\n    pcVar2 = ___acrt_invoke_user_matherr;\n  }\n  else {\n    pcVar2 = (code *)DecodePointer(DAT_0043b678);\n  }\n  if (0x1a < param_4) {\n    if (param_4 != 0x1b) {\n      if (param_4 == 0x1c) {\n        local_24 = \"pow\";\n      }\n      else if (param_4 == 0x31) {\n        local_24 = \"sqrt\";\n      }\n      else if (param_4 == 0x3a) {\n        local_24 = \"acos\";\n      }\n      else {\n        if (param_4 != 0x3d) {\n          if ((param_4 != 1000) && (param_4 != 0x3e9)) goto LAB_0041f12b;\n          uVar1 = *param_1;\n          goto LAB_0041f078;\n        }\n        local_24 = \"asin\";\n      }\n      goto LAB_0041ef97;\n    }\n    local_28 = 2;\nLAB_0041f0e9:\n    local_24 = \"pow\";\n    goto LAB_0041f0f0;\n  }\n  if (param_4 == 0x1a) {\n    uVar1 = 0x3ff0000000000000;\nLAB_0041f078:\n    *param_3 = uVar1;\n    goto LAB_0041f12b;\n  }\n  if (param_4 < 0xf) {\n    if (param_4 == 0xe) {\n      local_28 = 3;\n      local_24 = \"exp\";\n    }\n    else {\n      if (param_4 != 2) {\n        if (param_4 == 3) {\n          local_24 = \"log\";\n        }\n        else {\n          if (param_4 == 8) {\n            local_28 = 2;\n            local_24 = \"log10\";\n            goto LAB_0041f0f0;\n          }\n          if (param_4 != 9) goto LAB_0041f12b;\n          local_24 = \"log10\";\n        }\nLAB_0041ef97:\n        local_28 = 1;\n        local_20 = *param_1;\n        local_18 = *param_2;\n        local_10 = *param_3;\n        (*(code *)PTR_guard_check_icall_0042118c)(&local_28);\n        iVar3 = (*pcVar2)();\n        if (iVar3 == 0) {\n          piVar4 = __errno();\n          *piVar4 = 0x21;\n        }\n        goto LAB_0041f126;\n      }\n      local_28 = 2;\n      local_24 = \"log\";\n    }\nLAB_0041f0f0:\n    local_20 = *param_1;\n    local_18 = *param_2;\n    local_10 = *param_3;\n    (*(code *)PTR_guard_check_icall_0042118c)(&local_28);\n    iVar3 = (*pcVar2)();\n    if (iVar3 == 0) {\n      piVar4 = __errno();\n      *piVar4 = 0x22;\n    }\n  }\n  else {\n    if (param_4 == 0xf) {\n      local_24 = \"exp\";\n    }\n    else {\n      if (param_4 == 0x18) {\n        local_28 = 3;\n        goto LAB_0041f0e9;\n      }\n      if (param_4 != 0x19) goto LAB_0041f12b;\n      local_24 = \"pow\";\n    }\n    local_28 = 4;\n    local_20 = *param_1;\n    local_18 = *param_2;\n    local_10 = *param_3;\n    (*(code *)PTR_guard_check_icall_0042118c)(&local_28);\n    (*pcVar2)();\n  }\nLAB_0041f126:\n  *param_3 = local_10;\nLAB_0041f12b:\n  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041f1f4",
      "entry": "0041f1f4",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 __cdecl FUN_0041f1f4(double param_1)\n\n{\n  uint uVar1;\n  float10 fVar2;\n  float10 fVar3;\n  \n  uVar1 = __fpclass(param_1);\n  if ((uVar1 & 0x90) == 0) {\n    fVar2 = FUN_0041f494(param_1);\n    if ((float10)param_1 == fVar2) {\n      fVar2 = (float10)param_1 * (float10)_DAT_0042b670;\n      fVar3 = FUN_0041f494((double)fVar2);\n      if ((float10)(double)fVar2 == fVar3) {\n        return 2;\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_0041f25e",
      "entry": "0041f25e",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 __cdecl FUN_0041f25e(int param_1,int param_2,int param_3,int param_4,undefined8 *param_5)\n\n{\n  double dVar1;\n  double dVar2;\n  int iVar3;\n  \n  dVar1 = ABS((double)CONCAT44(param_2,param_1));\n  dVar2 = _DAT_0042b800;\n  if (param_4 == 0x7ff00000) {\n    if (param_3 == 0) {\n      if ((dVar1 <= 1.0) && (dVar2 = 1.0, dVar1 < 1.0)) {\n        dVar2 = 0.0;\n      }\n      goto LAB_0041f383;\n    }\n  }\n  else if ((param_4 == -0x100000) && (param_3 == 0)) {\n    if (dVar1 <= 1.0) {\n      dVar2 = 1.0;\n      if (dVar1 < 1.0) {\n        dVar2 = _DAT_0042b800;\n      }\n    }\n    else {\n      dVar2 = 0.0;\n    }\n    goto LAB_0041f383;\n  }\n  if (param_2 == 0x7ff00000) {\n    if (param_1 != 0) {\n      return 0;\n    }\n    if (((double)CONCAT44(param_4,param_3) <= 0.0) &&\n       (dVar2 = 0.0, 0.0 <= (double)CONCAT44(param_4,param_3))) {\n      dVar2 = 1.0;\n    }\n  }\n  else {\n    if (param_2 != -0x100000) {\n      return 0;\n    }\n    if (param_1 != 0) {\n      return 0;\n    }\n    iVar3 = FUN_0041f1f4((double)CONCAT44(param_4,param_3));\n    if ((double)CONCAT44(param_4,param_3) <= 0.0) {\n      if (0.0 <= (double)CONCAT44(param_4,param_3)) {\n        dVar2 = 1.0;\n      }\n      else {\n        dVar2 = 0.0;\n        if (iVar3 == 1) {\n          dVar2 = _DAT_0042b810;\n        }\n      }\n    }\n    else {\n      dVar2 = _DAT_0042b800;\n      if (iVar3 == 1) {\n        dVar2 = -_DAT_0042b800;\n      }\n    }\n  }\nLAB_0041f383:\n  *param_5 = dVar2;\n  return 0;\n}\n\n"
    },
    {
      "name": "__87except",
      "entry": "0041f389",
      "c": "\n/* Library Function - Single Match\n    __87except\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __87except(int param_1,int *param_2,ushort *param_3)\n\n{\n  bool bVar1;\n  undefined3 extraout_var;\n  int iVar2;\n  uint uVar3;\n  uint local_94;\n  uint local_90 [12];\n  undefined8 local_60;\n  uint local_50;\n  uint local_14;\n  \n  local_14 = DAT_0042d008 ^ (uint)&stack0xfffffff0;\n  local_94 = (uint)*param_3;\n  iVar2 = *param_2;\n  if (iVar2 == 1) {\nLAB_0041f3f1:\n    uVar3 = 8;\n  }\n  else if (iVar2 == 2) {\n    uVar3 = 4;\n  }\n  else if (iVar2 == 3) {\n    uVar3 = 0x11;\n  }\n  else if (iVar2 == 4) {\n    uVar3 = 0x12;\n  }\n  else {\n    if (iVar2 == 5) goto LAB_0041f3f1;\n    if (iVar2 != 8) goto LAB_0041f453;\n    uVar3 = 0x10;\n  }\n  bVar1 = __handle_exc(uVar3,(double *)(param_2 + 6),local_94);\n  if (CONCAT31(extraout_var,bVar1) == 0) {\n    if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {\n      local_60 = *(undefined8 *)(param_2 + 4);\n      local_50 = local_50 & 0xffffffe3 | 3;\n    }\n    else {\n      local_50 = local_50 & 0xfffffffe;\n    }\n    __raise_exc(local_90,&local_94,uVar3,param_1,(uint *)(param_2 + 2),(uint *)(param_2 + 6));\n  }\nLAB_0041f453:\n  __ctrlfp();\n  if (((*param_2 == 8) || (bVar1 = ___acrt_has_user_matherr(), !bVar1)) ||\n     (iVar2 = ___acrt_invoke_user_matherr(param_2), iVar2 == 0)) {\n    __set_errno_from_matherr(*param_2);\n  }\n  __security_check_cookie(local_14 ^ (uint)&stack0xfffffff0);\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041f494",
      "entry": "0041f494",
      "c": "\nfloat10 __cdecl FUN_0041f494(double param_1)\n\n{\n  return (float10)ROUND(param_1);\n}\n\n"
    },
    {
      "name": "__errcode",
      "entry": "0041f4aa",
      "c": "\n/* Library Function - Single Match\n    __errcode\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl __errcode(uint param_1)\n\n{\n  undefined4 uStack_8;\n  \n  if ((param_1 & 0x20) == 0) {\n    if ((param_1 & 8) != 0) {\n      return 1;\n    }\n    if ((param_1 & 4) == 0) {\n      if ((param_1 & 1) == 0) {\n        return (param_1 & 2) * 2;\n      }\n      uStack_8 = 3;\n    }\n    else {\n      uStack_8 = 2;\n    }\n  }\n  else {\n    uStack_8 = 5;\n  }\n  return uStack_8;\n}\n\n"
    },
    {
      "name": "__except1",
      "entry": "0041f4de",
      "c": "\n/* Library Function - Single Match\n    __except1\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __except1(uint param_1,int param_2,undefined8 param_3,double param_4,uint param_5)\n\n{\n  bool bVar1;\n  undefined3 extraout_var;\n  int iVar2;\n  uint local_90 [16];\n  uint local_50;\n  uint local_14;\n  \n  local_14 = DAT_0042d008 ^ (uint)&stack0xfffffff0;\n  bVar1 = __handle_exc(param_1,&param_4,param_5);\n  if (CONCAT31(extraout_var,bVar1) == 0) {\n    local_50 = local_50 & 0xfffffffe;\n    __raise_exc_ex(local_90,&param_5,param_1,param_2,(uint *)&param_3,(uint *)&param_4,0);\n  }\n  iVar2 = __errcode(param_1);\n  bVar1 = ___acrt_has_user_matherr();\n  if ((bVar1) && (iVar2 != 0)) {\n    __umatherr(iVar2,param_2,(int)param_3,(int)((ulonglong)param_3 >> 0x20),0,0,SUB84(param_4,0),\n               (int)((ulonglong)param_4 >> 0x20));\n  }\n  else {\n    __set_errno_from_matherr(iVar2);\n    __ctrlfp();\n  }\n  __security_check_cookie(local_14 ^ (uint)&stack0xfffffff0);\n  return;\n}\n\n"
    },
    {
      "name": "__handle_exc",
      "entry": "0041f5ac",
      "c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __handle_exc\n   \n   Library: Visual Studio 2015 Release */\n\nbool __cdecl __handle_exc(uint param_1,double *param_2,uint param_3)\n\n{\n  double dVar1;\n  double dVar2;\n  double dVar3;\n  int iVar4;\n  uint uVar5;\n  bool bVar6;\n  float10 fVar7;\n  float10 fVar8;\n  uint local_14;\n  byte bStack_10;\n  undefined1 uStack_f;\n  ushort uStack_e;\n  int local_8;\n  \n  uVar5 = param_1 & 0x1f;\n  if (((param_1 & 8) != 0) && ((param_3 & 1) != 0)) {\n    FUN_0041d890();\n    uVar5 = param_1 & 0x17;\n    goto LAB_0041f769;\n  }\n  if ((param_1 & param_3 & 4) != 0) {\n    FUN_0041d890();\n    uVar5 = param_1 & 0x1b;\n    goto LAB_0041f769;\n  }\n  if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {\n    if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {\n      bVar6 = (param_1 & 0x10) != 0;\n      if (*param_2 == 0.0) {\n        bVar6 = true;\n      }\n      else {\n        fVar7 = (float10)FUN_0041fb71(SUB84(*param_2,0),(uint)((ulonglong)*param_2 >> 0x20),&local_8\n                                     );\n        local_8 = local_8 + -0x600;\n        dVar2 = (double)fVar7;\n        local_14 = SUB84(dVar2,0);\n        bStack_10 = (byte)((ulonglong)dVar2 >> 0x20);\n        uStack_f = (undefined1)((ulonglong)dVar2 >> 0x28);\n        uStack_e = (ushort)((ulonglong)dVar2 >> 0x30);\n        if (local_8 < -0x432) {\n          fVar8 = (float10)0 * fVar7;\n          bVar6 = true;\n        }\n        else {\n          uStack_e = uStack_e & 0xf | 0x10;\n          if (local_8 < -0x3fd) {\n            iVar4 = -0x3fd - local_8;\n            do {\n              if (((local_14 & 1) != 0) && (!bVar6)) {\n                bVar6 = true;\n              }\n              local_14 = local_14 >> 1;\n              if ((bStack_10 & 1) != 0) {\n                local_14 = local_14 | 0x80000000;\n              }\n              uVar5 = CONCAT22(uStack_e,CONCAT11(uStack_f,bStack_10)) >> 1;\n              bStack_10 = (byte)uVar5;\n              uStack_f = (undefined1)(uVar5 >> 8);\n              uStack_e = uStack_e >> 1;\n              iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n          }\n          fVar8 = (float10)(double)CONCAT26(uStack_e,CONCAT15(uStack_f,CONCAT14(bStack_10,local_14))\n                                           );\n          if (fVar7 < (float10)0) {\n            fVar8 = -fVar8;\n          }\n        }\n        *param_2 = (double)fVar8;\n      }\n      if (bVar6) {\n        FUN_0041d890();\n      }\n      uVar5 = param_1 & 0x1d;\n    }\n    goto LAB_0041f769;\n  }\n  FUN_0041d890();\n  uVar5 = param_3 & 0xc00;\n  dVar2 = _DAT_0042b800;\n  dVar3 = _DAT_0042b800;\n  if (uVar5 == 0) {\n    dVar1 = *param_2;\njoined_r0x0041f64d:\n    if (dVar1 <= 0.0) {\n      dVar2 = -dVar3;\n    }\n    *param_2 = dVar2;\n  }\n  else {\n    if (uVar5 == 0x400) {\n      dVar1 = *param_2;\n      dVar2 = _DAT_0042b808;\n      goto joined_r0x0041f64d;\n    }\n    dVar3 = _DAT_0042b808;\n    if (uVar5 == 0x800) {\n      dVar1 = *param_2;\n      goto joined_r0x0041f64d;\n    }\n    if (uVar5 == 0xc00) {\n      dVar1 = *param_2;\n      dVar2 = _DAT_0042b808;\n      goto joined_r0x0041f64d;\n    }\n  }\n  uVar5 = param_1 & 0x1e;\nLAB_0041f769:\n  if (((param_1 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {\n    FUN_0041d890();\n    uVar5 = uVar5 & 0xffffffef;\n  }\n  return uVar5 == 0;\n}\n\n"
    },
    {
      "name": "__raise_exc",
      "entry": "0041f78c",
      "c": "\n/* Library Function - Single Match\n    __raise_exc\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__raise_exc(uint *param_1,uint *param_2,uint param_3,int param_4,uint *param_5,uint *param_6)\n\n{\n  __raise_exc_ex(param_1,param_2,param_3,param_4,param_5,param_6,0);\n  return;\n}\n\n"
    },
    {
      "name": "__raise_exc_ex",
      "entry": "0041f7af",
      "c": "\n/* Library Function - Single Match\n    __raise_exc_ex\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl\n__raise_exc_ex(uint *param_1,uint *param_2,uint param_3,int param_4,uint *param_5,uint *param_6,\n              int param_7)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  uint uVar3;\n  DWORD dwExceptionCode;\n  \n  puVar1 = param_2;\n  param_1[1] = 0;\n  dwExceptionCode = 0xc000000d;\n  param_1[2] = 0;\n  param_1[3] = 0;\n  if ((param_3 & 0x10) != 0) {\n    dwExceptionCode = 0xc000008f;\n    param_1[1] = param_1[1] | 1;\n  }\n  if ((param_3 & 2) != 0) {\n    dwExceptionCode = 0xc0000093;\n    param_1[1] = param_1[1] | 2;\n  }\n  if ((param_3 & 1) != 0) {\n    dwExceptionCode = 0xc0000091;\n    param_1[1] = param_1[1] | 4;\n  }\n  if ((param_3 & 4) != 0) {\n    dwExceptionCode = 0xc000008e;\n    param_1[1] = param_1[1] | 8;\n  }\n  if ((param_3 & 8) != 0) {\n    dwExceptionCode = 0xc0000090;\n    param_1[1] = param_1[1] | 0x10;\n  }\n  param_1[2] = param_1[2] ^ (~(*param_2 << 4) ^ param_1[2]) & 0x10;\n  param_1[2] = param_1[2] ^ (~(*param_2 * 2) ^ param_1[2]) & 8;\n  param_1[2] = param_1[2] ^ (~(*param_2 >> 1) ^ param_1[2]) & 4;\n  param_1[2] = param_1[2] ^ (~(*param_2 >> 3) ^ param_1[2]) & 2;\n  param_1[2] = param_1[2] ^ (~(*param_2 >> 5) ^ param_1[2]) & 1;\n  uVar3 = __statfp();\n  puVar2 = param_6;\n  if ((uVar3 & 1) != 0) {\n    param_1[3] = param_1[3] | 0x10;\n  }\n  if ((uVar3 & 4) != 0) {\n    param_1[3] = param_1[3] | 8;\n  }\n  if ((uVar3 & 8) != 0) {\n    param_1[3] = param_1[3] | 4;\n  }\n  if ((uVar3 & 0x10) != 0) {\n    param_1[3] = param_1[3] | 2;\n  }\n  if ((uVar3 & 0x20) != 0) {\n    param_1[3] = param_1[3] | 1;\n  }\n  uVar3 = *puVar1 & 0xc00;\n  if (uVar3 == 0) {\n    *param_1 = *param_1 & 0xfffffffc;\n  }\n  else {\n    if (uVar3 == 0x400) {\n      uVar3 = *param_1 & 0xfffffffd | 1;\n    }\n    else {\n      if (uVar3 != 0x800) {\n        if (uVar3 == 0xc00) {\n          *param_1 = *param_1 | 3;\n        }\n        goto LAB_0041f911;\n      }\n      uVar3 = *param_1 & 0xfffffffe | 2;\n    }\n    *param_1 = uVar3;\n  }\nLAB_0041f911:\n  uVar3 = *puVar1 & 0x300;\n  if (uVar3 == 0) {\n    uVar3 = *param_1 & 0xffffffeb | 8;\nLAB_0041f947:\n    *param_1 = uVar3;\n  }\n  else {\n    if (uVar3 == 0x200) {\n      uVar3 = *param_1 & 0xffffffe7 | 4;\n      goto LAB_0041f947;\n    }\n    if (uVar3 == 0x300) {\n      *param_1 = *param_1 & 0xffffffe3;\n    }\n  }\n  *param_1 = *param_1 ^ (param_4 << 5 ^ *param_1) & 0x1ffe0;\n  param_1[8] = param_1[8] | 1;\n  if (param_7 == 0) {\n    param_1[8] = param_1[8] & 0xffffffe3 | 2;\n    *(undefined8 *)(param_1 + 4) = *(undefined8 *)param_5;\n    param_1[0x18] = param_1[0x18] | 1;\n    param_1[0x18] = param_1[0x18] & 0xffffffe3 | 2;\n    *(undefined8 *)(param_1 + 0x14) = *(undefined8 *)param_6;\n  }\n  else {\n    param_1[8] = param_1[8] & 0xffffffe1;\n    param_1[4] = *param_5;\n    param_1[0x18] = param_1[0x18] | 1;\n    param_1[0x18] = param_1[0x18] & 0xffffffe1;\n    param_1[0x14] = *param_6;\n  }\n  __clrfp();\n  RaiseException(dwExceptionCode,0,1,(ULONG_PTR *)&param_1);\n  if ((param_1[2] & 0x10) != 0) {\n    *puVar1 = *puVar1 & 0xfffffffe;\n  }\n  if ((param_1[2] & 8) != 0) {\n    *puVar1 = *puVar1 & 0xfffffffb;\n  }\n  if ((param_1[2] & 4) != 0) {\n    *puVar1 = *puVar1 & 0xfffffff7;\n  }\n  if ((param_1[2] & 2) != 0) {\n    *puVar1 = *puVar1 & 0xffffffef;\n  }\n  if ((param_1[2] & 1) != 0) {\n    *puVar1 = *puVar1 & 0xffffffdf;\n  }\n  uVar3 = *param_1 & 3;\n  if (uVar3 == 0) {\n    *puVar1 = *puVar1 & 0xfffff3ff;\n  }\n  else {\n    if (uVar3 == 1) {\n      uVar3 = *puVar1 & 0xfffff7ff | 0x400;\n    }\n    else {\n      if (uVar3 != 2) {\n        if (uVar3 == 3) {\n          *puVar1 = *puVar1 | 0xc00;\n        }\n        goto LAB_0041fa58;\n      }\n      uVar3 = *puVar1 & 0xfffffbff | 0x800;\n    }\n    *puVar1 = uVar3;\n  }\nLAB_0041fa58:\n  uVar3 = *param_1 >> 2 & 7;\n  if (uVar3 == 0) {\n    uVar3 = *puVar1 & 0xfffff3ff | 0x300;\n  }\n  else {\n    if (uVar3 != 1) {\n      if (uVar3 == 2) {\n        *puVar1 = *puVar1 & 0xfffff3ff;\n      }\n      goto LAB_0041fa89;\n    }\n    uVar3 = *puVar1 & 0xfffff3ff | 0x200;\n  }\n  *puVar1 = uVar3;\nLAB_0041fa89:\n  if (param_7 == 0) {\n    *(undefined8 *)puVar2 = *(undefined8 *)(param_1 + 0x14);\n  }\n  else {\n    *puVar2 = param_1[0x14];\n  }\n  return;\n}\n\n"
    },
    {
      "name": "__set_errno_from_matherr",
      "entry": "0041faa0",
      "c": "\n/* Library Function - Single Match\n    __set_errno_from_matherr\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __set_errno_from_matherr(int param_1)\n\n{\n  int *piVar1;\n  \n  if (param_1 == 1) {\n    piVar1 = __errno();\n    *piVar1 = 0x21;\n  }\n  else if (param_1 - 2U < 2) {\n    piVar1 = __errno();\n    *piVar1 = 0x22;\n    return;\n  }\n  return;\n}\n\n"
    },
    {
      "name": "__umatherr",
      "entry": "0041facf",
      "c": "\n/* Library Function - Single Match\n    __umatherr\n   \n   Library: Visual Studio 2015 Release */\n\nfloat10 __cdecl\n__umatherr(int param_1,int param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,\n          undefined4 param_6,undefined4 param_7,undefined4 param_8)\n\n{\n  double dVar1;\n  int iVar2;\n  int local_24;\n  int local_20;\n  undefined4 local_1c;\n  undefined4 local_18;\n  undefined4 local_14;\n  undefined4 local_10;\n  undefined4 local_c;\n  undefined4 uStack_8;\n  \n  local_20 = 0;\n  iVar2 = 0;\n  do {\n    if ((&DAT_0042b708)[iVar2 * 2] == param_2) {\n      local_20 = *(int *)(&UNK_0042b70c + iVar2 * 8);\n      break;\n    }\n    iVar2 = iVar2 + 1;\n  } while (iVar2 < 0x1d);\n  if (local_20 == 0) {\n    __ctrlfp();\n    __set_errno_from_matherr(param_1);\n    dVar1 = (double)CONCAT44(param_8,param_7);\n  }\n  else {\n    local_1c = param_3;\n    local_18 = param_4;\n    local_14 = param_5;\n    local_10 = param_6;\n    local_c = param_7;\n    local_24 = param_1;\n    uStack_8 = param_8;\n    __ctrlfp();\n    iVar2 = ___acrt_invoke_user_matherr(&local_24);\n    if (iVar2 == 0) {\n      __set_errno_from_matherr(param_1);\n    }\n    dVar1 = (double)CONCAT44(uStack_8,local_c);\n  }\n  return (float10)dVar1;\n}\n\n"
    },
    {
      "name": "FUN_0041fb71",
      "entry": "0041fb71",
      "c": "\nvoid __cdecl FUN_0041fb71(int param_1,uint param_2,int *param_3)\n\n{\n  uint uVar1;\n  double dVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  \n  dVar2 = (double)CONCAT17(param_2._3_1_,\n                           CONCAT16(param_2._2_1_,CONCAT24((undefined2)param_2,param_1)));\n  if (dVar2 == 0.0) {\n    iVar5 = 0;\n  }\n  else if (((param_2 & 0x7ff00000) == 0) && (((param_2 & 0xfffff) != 0 || (param_1 != 0)))) {\n    iVar5 = -0x3fd;\n    uVar3 = param_2;\n    if ((param_2 & 0x100000) == 0) {\n      do {\n        uVar1 = uVar3 * 2;\n        param_2._0_2_ = (undefined2)uVar1;\n        uVar3 = uVar1;\n        if (param_1 < 0) {\n          uVar3 = uVar1 | 1;\n          param_2._0_2_ = (undefined2)uVar3;\n        }\n        param_1 = param_1 * 2;\n        iVar5 = iVar5 + -1;\n      } while ((uVar1 & 0x100000) == 0);\n      param_2 = CONCAT22((short)(uVar1 >> 0x10),(undefined2)param_2);\n    }\n    uVar4 = (ushort)(param_2 >> 0x10) & 0xffef;\n    param_2._2_1_ = (undefined1)uVar4;\n    param_2._3_1_ = (byte)(uVar4 >> 8);\n    if (dVar2 < 0.0) {\n      param_2._3_1_ = param_2._3_1_ | 0x80;\n    }\n    __set_exp(CONCAT17(param_2._3_1_,CONCAT16(param_2._2_1_,CONCAT24((undefined2)param_2,param_1))),\n              0);\n  }\n  else {\n    __set_exp(dVar2,0);\n    iVar5 = (param_2 >> 0x14 & 0x7ff) - 0x3fe;\n  }\n  *param_3 = iVar5;\n  return;\n}\n\n"
    },
    {
      "name": "__set_exp",
      "entry": "0041fc45",
      "c": "\n/* Library Function - Single Match\n    __set_exp\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release */\n\nfloat10 __cdecl __set_exp(undefined8 param_1,short param_2)\n\n{\n  undefined8 local_c;\n  \n  local_c = (double)CONCAT26((param_2 + 0x3fe) * 0x10 | param_1._6_2_ & 0x800f,(int6)param_1);\n  return (float10)local_c;\n}\n\n"
    },
    {
      "name": "__sptype",
      "entry": "0041fc74",
      "c": "\n/* Library Function - Single Match\n    __sptype\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined4 __cdecl __sptype(int param_1,uint param_2)\n\n{\n  undefined4 uStack_8;\n  \n  if (param_2 == 0x7ff00000) {\n    if (param_1 == 0) {\n      return 1;\n    }\n  }\n  else if ((param_2 == 0xfff00000) && (param_1 == 0)) {\n    return 2;\n  }\n  if ((param_2._2_2_ & 0x7ff8) == 0x7ff8) {\n    uStack_8 = 3;\n  }\n  else {\n    if (((param_2._2_2_ & 0x7ff8) != 0x7ff0) || (((param_2 & 0x7ffff) == 0 && (param_1 == 0)))) {\n      return 0;\n    }\n    uStack_8 = 4;\n  }\n  return uStack_8;\n}\n\n"
    },
    {
      "name": "__fpclass",
      "entry": "0041fcd2",
      "c": "\n/* Library Function - Single Match\n    __fpclass\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl __fpclass(double _X)\n\n{\n  int iVar1;\n  \n  if ((_X._6_2_ & 0x7ff0) == 0x7ff0) {\n    iVar1 = __sptype(_X._0_4_,(uint)((ulonglong)_X >> 0x20));\n    if (iVar1 == 1) {\n      return 0x200;\n    }\n    if (iVar1 == 2) {\n      iVar1 = 4;\n    }\n    else {\n      if (iVar1 != 3) {\n        return 1;\n      }\n      iVar1 = 2;\n    }\n    return iVar1;\n  }\n  if ((((ulonglong)_X & 0x7ff0000000000000) == 0) &&\n     ((((ulonglong)_X & 0xfffff00000000) != 0 || (_X._0_4_ != 0)))) {\n    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff90) + 0x80;\n  }\n  if (_X == 0.0) {\n    return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffffe0) + 0x40;\n  }\n  return (-(uint)(((ulonglong)_X & 0x8000000000000000) != 0) & 0xffffff08) + 0x100;\n}\n\n"
    },
    {
      "name": "IsProcessorFeaturePresent",
      "entry": "0041fd76",
      "c": "\nBOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)\n\n{\n  BOOL BVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x0041fd76. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  BVar1 = IsProcessorFeaturePresent(ProcessorFeature);\n  return BVar1;\n}\n\n"
    },
    {
      "name": "RtlUnwind",
      "entry": "0041fd7c",
      "c": "\nvoid RtlUnwind(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,PVOID ReturnValue)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x0041fd7c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);\n  return;\n}\n\n"
    },
    {
      "name": "__FindPESection",
      "entry": "0041fd90",
      "c": "\n/* Library Function - Single Match\n    __FindPESection\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nPIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)\n\n{\n  int iVar1;\n  PIMAGE_SECTION_HEADER p_Var2;\n  uint uVar3;\n  \n  uVar3 = 0;\n  iVar1 = *(int *)(pImageBase + 0x3c);\n  p_Var2 = (PIMAGE_SECTION_HEADER)\n           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);\n  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {\n    do {\n      if ((p_Var2->VirtualAddress <= rva) &&\n         (rva < (p_Var2->Misc).PhysicalAddress + p_Var2->VirtualAddress)) {\n        return p_Var2;\n      }\n      uVar3 = uVar3 + 1;\n      p_Var2 = p_Var2 + 1;\n    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));\n  }\n  return (PIMAGE_SECTION_HEADER)0x0;\n}\n\n"
    },
    {
      "name": "__IsNonwritableInCurrentImage",
      "entry": "0041fde0",
      "c": "\n/* Library Function - Single Match\n    __IsNonwritableInCurrentImage\n   \n   Library: Visual Studio 2015 Release */\n\nBOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)\n\n{\n  BOOL BVar1;\n  PIMAGE_SECTION_HEADER p_Var2;\n  void *local_14;\n  code *pcStack_10;\n  uint local_c;\n  undefined4 local_8;\n  \n  pcStack_10 = __except_handler4;\n  local_14 = ExceptionList;\n  local_c = DAT_0042d008 ^ 0x42c1f0;\n  ExceptionList = &local_14;\n  local_8 = 0;\n  BVar1 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_00400000);\n  if (BVar1 != 0) {\n    p_Var2 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_00400000,(DWORD_PTR)(pTarget + -0x400000));\n    if (p_Var2 != (PIMAGE_SECTION_HEADER)0x0) {\n      ExceptionList = local_14;\n      return ~(p_Var2->Characteristics >> 0x1f) & 1;\n    }\n  }\n  ExceptionList = local_14;\n  return 0;\n}\n\n"
    },
    {
      "name": "__ValidateImageBase",
      "entry": "0041fea0",
      "c": "\n/* Library Function - Single Match\n    __ValidateImageBase\n   \n   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release */\n\nBOOL __cdecl __ValidateImageBase(PBYTE pImageBase)\n\n{\n  uint uVar1;\n  \n  if (*(short *)pImageBase != 0x5a4d) {\n    return 0;\n  }\n  uVar1 = 0;\n  if (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550) {\n    uVar1 = (uint)((short)*(int *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b)\n    ;\n  }\n  return uVar1;\n}\n\n"
    },
    {
      "name": "__aulldvrm",
      "entry": "0041fee0",
      "c": "\n/* Library Function - Single Match\n    __aulldvrm\n   \n   Library: Visual Studio 2015 Release */\n\nundefined8 __aulldvrm(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  \n  uVar3 = param_1;\n  uVar8 = param_4;\n  uVar6 = param_2;\n  uVar9 = param_3;\n  if (param_4 == 0) {\n    uVar3 = param_2 / param_3;\n    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /\n                 (ulonglong)param_3);\n  }\n  else {\n    do {\n      uVar5 = uVar8 >> 1;\n      uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;\n      uVar7 = uVar6 >> 1;\n      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;\n      uVar8 = uVar5;\n      uVar6 = uVar7;\n    } while (uVar5 != 0);\n    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;\n    iVar4 = (int)uVar1;\n    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);\n    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);\n    uVar8 = uVar3 + iVar4 * param_4;\n    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||\n       ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {\n      iVar4 = iVar4 + -1;\n    }\n    uVar3 = 0;\n  }\n  return CONCAT44(uVar3,iVar4);\n}\n\n"
    },
    {
      "name": "__SEH_prolog4_GS",
      "entry": "0041ff80",
      "c": "\n/* WARNING: This is an inlined function */\n/* WARNING: Unable to track spacebase fully for stack */\n/* WARNING: Variable defined which should be unmapped: param_2 */\n/* Library Function - Single Match\n    __SEH_prolog4_GS\n   \n   Library: Visual Studio 2015 Release */\n\nvoid __cdecl __SEH_prolog4_GS(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 unaff_EBX;\n  undefined4 unaff_ESI;\n  undefined4 unaff_EDI;\n  undefined4 unaff_retaddr;\n  uint auStack_1c [5];\n  undefined1 local_8 [8];\n  \n  iVar1 = -param_2;\n  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;\n  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;\n  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;\n  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_0042d008 ^ (uint)&param_2;\n  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;\n  ExceptionList = local_8;\n  return;\n}\n\n"
    },
    {
      "name": "FUN_0041ffc9",
      "entry": "0041ffc9",
      "c": "\n/* WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3 */\n\nvoid FUN_0041ffc9(void)\n\n{\n  uint unaff_EBP;\n  \n  __security_check_cookie(*(uint *)(unaff_EBP - 0x1c) ^ unaff_EBP);\n  return;\n}\n\n"
    },
    {
      "name": "__allmul",
      "entry": "0041ffe0",
      "c": "\n/* Library Function - Single Match\n    __allmul\n   \n   Library: Visual Studio 2015 Release */\n\nlonglong __allmul(uint param_1,int param_2,uint param_3,int param_4)\n\n{\n  if (param_4 == 0 && param_2 == 0) {\n    return (ulonglong)param_1 * (ulonglong)param_3;\n  }\n  return CONCAT44((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +\n                  param_2 * param_3 + param_1 * param_4,\n                  (int)((ulonglong)param_1 * (ulonglong)param_3));\n}\n\n"
    },
    {
      "name": "__alldvrm",
      "entry": "00420020",
      "c": "\n/* Library Function - Single Match\n    __alldvrm\n   \n   Library: Visual Studio 2015 Release */\n\nundefined8 __alldvrm(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  bool bVar10;\n  char cVar11;\n  uint uVar9;\n  \n  cVar11 = (int)param_2 < 0;\n  if ((bool)cVar11) {\n    bVar10 = param_1 != 0;\n    param_1 = -param_1;\n    param_2 = -(uint)bVar10 - param_2;\n  }\n  if ((int)param_4 < 0) {\n    cVar11 = cVar11 + '\\x01';\n    bVar10 = param_3 != 0;\n    param_3 = -param_3;\n    param_4 = -(uint)bVar10 - param_4;\n  }\n  uVar3 = param_1;\n  uVar5 = param_3;\n  uVar6 = param_2;\n  uVar9 = param_4;\n  if (param_4 == 0) {\n    uVar3 = param_2 / param_3;\n    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /\n                 (ulonglong)param_3);\n  }\n  else {\n    do {\n      uVar8 = uVar9 >> 1;\n      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;\n      uVar7 = uVar6 >> 1;\n      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;\n      uVar6 = uVar7;\n      uVar9 = uVar8;\n    } while (uVar8 != 0);\n    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;\n    iVar4 = (int)uVar1;\n    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);\n    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);\n    uVar5 = uVar3 + iVar4 * param_4;\n    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||\n       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {\n      iVar4 = iVar4 + -1;\n    }\n    uVar3 = 0;\n  }\n  if (cVar11 == '\\x01') {\n    bVar10 = iVar4 != 0;\n    iVar4 = -iVar4;\n    uVar3 = -(uint)bVar10 - uVar3;\n  }\n  return CONCAT44(uVar3,iVar4);\n}\n\n"
    },
    {
      "name": "__aullshr",
      "entry": "00420100",
      "c": "\n/* Library Function - Single Match\n    __aullshr\n   \n   Library: Visual Studio 2015 Release */\n\nulonglong __fastcall __aullshr(byte param_1,uint param_2)\n\n{\n  uint in_EAX;\n  \n  if (0x3f < param_1) {\n    return 0;\n  }\n  if (param_1 < 0x20) {\n    return CONCAT44(param_2 >> (param_1 & 0x1f),\n                    in_EAX >> (param_1 & 0x1f) | param_2 << 0x20 - (param_1 & 0x1f));\n  }\n  return (ulonglong)(param_2 >> (param_1 & 0x1f));\n}\n\n"
    },
    {
      "name": "__alloca_probe_16",
      "entry": "00420120",
      "c": "\n/* WARNING: This is an inlined function */\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    __alloca_probe_16\n   \n   Library: Visual Studio 2015 Release */\n\nuint __alloca_probe_16(void)\n\n{\n  uint in_EAX;\n  uint uVar1;\n  \n  uVar1 = 4 - in_EAX & 0xf;\n  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);\n}\n\n"
    },
    {
      "name": "__alloca_probe_8",
      "entry": "00420136",
      "c": "\n/* WARNING: This is an inlined function */\n/* WARNING: Function: __alloca_probe replaced with injection: alloca_probe */\n\nuint __alloca_probe_8(void)\n\n{\n  uint in_EAX;\n  uint uVar1;\n  \n  uVar1 = 4 - in_EAX & 7;\n  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);\n}\n\n"
    },
    {
      "name": "__allshl",
      "entry": "00420150",
      "c": "\n/* Library Function - Single Match\n    __allshl\n   \n   Library: Visual Studio 2015 Release */\n\nlonglong __fastcall __allshl(byte param_1,int param_2)\n\n{\n  uint in_EAX;\n  \n  if (0x3f < param_1) {\n    return 0;\n  }\n  if (param_1 < 0x20) {\n    return CONCAT44(param_2 << (param_1 & 0x1f) | in_EAX >> 0x20 - (param_1 & 0x1f),\n                    in_EAX << (param_1 & 0x1f));\n  }\n  return (ulonglong)(in_EAX << (param_1 & 0x1f)) << 0x20;\n}\n\n"
    },
    {
      "name": "FUN_00420170",
      "entry": "00420170",
      "c": "\nulonglong __fastcall FUN_00420170(undefined4 param_1,undefined4 param_2)\n\n{\n  ulonglong uVar1;\n  uint uVar2;\n  float fVar3;\n  float10 in_ST0;\n  uint local_20;\n  float fStack_1c;\n  \n  if (DAT_0043adbc == 0) {\n    uVar1 = (ulonglong)ROUND(in_ST0);\n    local_20 = (uint)uVar1;\n    fStack_1c = (float)(uVar1 >> 0x20);\n    fVar3 = (float)in_ST0;\n    if ((local_20 != 0) || (fVar3 = fStack_1c, (uVar1 & 0x7fffffff00000000) != 0)) {\n      if ((int)fVar3 < 0) {\n        uVar1 = uVar1 + (0x80000000 < (uint)-(float)(in_ST0 - (float10)(longlong)uVar1));\n      }\n      else {\n        uVar2 = (uint)(0x80000000 < (uint)(float)(in_ST0 - (float10)(longlong)uVar1));\n        uVar1 = CONCAT44((int)fStack_1c - (uint)(local_20 < uVar2),local_20 - uVar2);\n      }\n    }\n    return uVar1;\n  }\n  return CONCAT44(param_2,(int)in_ST0);\n}\n\n"
    },
    {
      "name": "FUN_00420225",
      "entry": "00420225",
      "c": "\nundefined1 (*) [16] __cdecl FUN_00420225(undefined1 (*param_1) [16],ushort param_2)\n\n{\n  undefined1 *puVar1;\n  undefined1 (*pauVar2) [16];\n  int iVar3;\n  undefined1 (*pauVar4) [16];\n  bool bVar5;\n  bool bVar6;\n  \n  pauVar4 = (undefined1 (*) [16])0x0;\n  pauVar2 = param_1;\n  if (DAT_0043adbc < 2) {\n    do {\n      puVar1 = *pauVar2;\n      pauVar4 = (undefined1 (*) [16])(*pauVar2 + 2);\n      pauVar2 = pauVar4;\n    } while (*(short *)puVar1 != 0);\n    do {\n      pauVar4 = (undefined1 (*) [16])(pauVar4[-1] + 0xe);\n      if (pauVar4 == param_1) break;\n    } while (*(ushort *)*pauVar4 != param_2);\n    if (*(ushort *)*pauVar4 != param_2) {\n      pauVar4 = (undefined1 (*) [16])0x0;\n    }\n  }\n  else {\n    for (; ((uint)(*param_1 + 1) & 0xe) != 0; param_1 = (undefined1 (*) [16])(*param_1 + 2)) {\n      if (*(ushort *)*param_1 == param_2) {\n        pauVar4 = param_1;\n      }\n      if (*(ushort *)*param_1 == 0) {\n        return pauVar4;\n      }\n    }\n    bVar5 = param_2 != 0;\n    bVar6 = param_2 == 0;\n    if (bVar6) {\n      while (iVar3 = pcmpistri(ZEXT416(0xffff0001),*param_1,0x15), !bVar6) {\n        param_1 = param_1 + 1;\n        bVar6 = param_1 == (undefined1 (*) [16])0x0;\n      }\n      pauVar4 = (undefined1 (*) [16])(*param_1 + iVar3 * 2);\n    }\n    else {\n      while( true ) {\n        iVar3 = pcmpistri(ZEXT216(param_2),*param_1,0x41);\n        if (bVar5) {\n          pauVar4 = (undefined1 (*) [16])(*param_1 + iVar3 * 2);\n        }\n        if (bVar6) break;\n        bVar5 = (undefined1 (*) [16])0xffffffef < param_1;\n        param_1 = param_1 + 1;\n        bVar6 = param_1 == (undefined1 (*) [16])0x0;\n      }\n    }\n  }\n  return pauVar4;\n}\n\n"
    },
    {
      "name": "FUN_004202c6",
      "entry": "004202c6",
      "c": "\nushort * __cdecl FUN_004202c6(ushort *param_1,ushort param_2)\n\n{\n  int iVar1;\n  undefined1 auVar2 [16];\n  undefined1 auVar3 [16];\n  undefined1 auVar4 [16];\n  ushort uVar5;\n  ushort uVar6;\n  int iStack_34;\n  \n  if (0 < DAT_0043adbc) {\n    auVar2 = pshuflw(ZEXT216(param_2),ZEXT216(param_2),0);\n    do {\n      if (((uint)param_1 & 0xfff) < 0xff1) {\n        auVar4._0_2_ = -(ushort)(*param_1 == 0);\n        auVar4._2_2_ = -(ushort)(param_1[1] == 0);\n        auVar4._4_2_ = -(ushort)(param_1[2] == 0);\n        auVar4._6_2_ = -(ushort)(param_1[3] == 0);\n        auVar4._8_2_ = -(ushort)(param_1[4] == 0);\n        auVar4._10_2_ = -(ushort)(param_1[5] == 0);\n        auVar4._12_2_ = -(ushort)(param_1[6] == 0);\n        auVar4._14_2_ = -(ushort)(param_1[7] == 0);\n        uVar5 = auVar2._0_2_;\n        auVar3._0_2_ = -(ushort)(*param_1 == uVar5);\n        uVar6 = auVar2._2_2_;\n        auVar3._2_2_ = -(ushort)(param_1[1] == uVar6);\n        auVar3._4_2_ = -(ushort)(param_1[2] == uVar5);\n        auVar3._6_2_ = -(ushort)(param_1[3] == uVar6);\n        auVar3._8_2_ = -(ushort)(param_1[4] == uVar5);\n        auVar3._10_2_ = -(ushort)(param_1[5] == uVar6);\n        auVar3._12_2_ = -(ushort)(param_1[6] == uVar5);\n        auVar3._14_2_ = -(ushort)(param_1[7] == uVar6);\n        auVar4 = auVar4 | auVar3;\n        uVar5 = (ushort)(SUB161(auVar4 >> 7,0) & 1) | (ushort)(SUB161(auVar4 >> 0xf,0) & 1) << 1 |\n                (ushort)(SUB161(auVar4 >> 0x17,0) & 1) << 2 |\n                (ushort)(SUB161(auVar4 >> 0x1f,0) & 1) << 3 |\n                (ushort)(SUB161(auVar4 >> 0x27,0) & 1) << 4 |\n                (ushort)(SUB161(auVar4 >> 0x2f,0) & 1) << 5 |\n                (ushort)(SUB161(auVar4 >> 0x37,0) & 1) << 6 |\n                (ushort)(SUB161(auVar4 >> 0x3f,0) & 1) << 7 |\n                (ushort)(SUB161(auVar4 >> 0x47,0) & 1) << 8 |\n                (ushort)(SUB161(auVar4 >> 0x4f,0) & 1) << 9 |\n                (ushort)(SUB161(auVar4 >> 0x57,0) & 1) << 10 |\n                (ushort)(SUB161(auVar4 >> 0x5f,0) & 1) << 0xb |\n                (ushort)(SUB161(auVar4 >> 0x67,0) & 1) << 0xc |\n                (ushort)(SUB161(auVar4 >> 0x6f,0) & 1) << 0xd |\n                (ushort)(SUB161(auVar4 >> 0x77,0) & 1) << 0xe |\n                (ushort)(byte)(auVar4[0xf] >> 7) << 0xf;\n        if (uVar5 != 0) goto LAB_0042035d;\n        iStack_34 = 0x10;\n      }\n      else {\n        if (*param_1 == param_2) {\n          return param_1;\n        }\n        if (*param_1 == 0) {\n          return (ushort *)0x0;\n        }\n        iStack_34 = 2;\n      }\n      param_1 = (ushort *)((int)param_1 + iStack_34);\n    } while( true );\n  }\n  for (; (*param_1 != 0 && (*param_1 != param_2)); param_1 = param_1 + 1) {\n  }\nLAB_0042033c:\n  return (ushort *)((*param_1 != param_2) - 1 & (uint)param_1);\nLAB_0042035d:\n  iVar1 = 0;\n  if (uVar5 != 0) {\n    for (; (uVar5 >> iVar1 & 1) == 0; iVar1 = iVar1 + 1) {\n    }\n  }\n  param_1 = (ushort *)((int)param_1 + iVar1);\n  goto LAB_0042033c;\n}\n\n"
    },
    {
      "name": "FUN_00420380",
      "entry": "00420380",
      "c": "\nulonglong __cdecl FUN_00420380(uint *param_1,uint *param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined4 uVar18;\n  undefined4 uVar19;\n  undefined4 uVar20;\n  undefined4 uVar21;\n  undefined4 uVar22;\n  undefined4 uVar23;\n  undefined4 uVar24;\n  undefined4 uVar25;\n  undefined4 uVar26;\n  undefined4 uVar27;\n  undefined4 uVar28;\n  undefined4 uVar29;\n  undefined4 uVar30;\n  undefined4 uVar31;\n  undefined4 uVar32;\n  undefined4 uVar33;\n  uint uVar34;\n  uint uVar35;\n  uint uVar36;\n  uint uVar37;\n  uint uVar38;\n  uint uVar39;\n  uint uVar40;\n  uint uVar41;\n  uint uVar42;\n  uint uVar43;\n  uint uVar44;\n  uint uVar45;\n  uint uVar46;\n  uint uVar47;\n  uint *puVar48;\n  undefined4 *puVar49;\n  undefined4 *puVar50;\n  uint *puVar51;\n  undefined4 *puVar52;\n  undefined4 *puVar53;\n  uint uVar54;\n  ulonglong uVar55;\n  \n  if ((param_2 < param_1) && (param_1 < (uint *)(param_3 + (int)param_2))) {\n    puVar49 = (undefined4 *)(param_3 + (int)param_2);\n    puVar52 = (undefined4 *)(param_3 + (int)param_1);\n    uVar46 = param_3;\n    uVar47 = param_3;\n    if (0x1f < param_3) {\n      if ((DAT_0042d020 >> 1 & 1) == 0) {\n        if (((uint)puVar52 & 3) != 0) {\n          uVar47 = (uint)puVar52 & 3;\n          param_3 = param_3 - uVar47;\n          do {\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            puVar49 = (undefined4 *)((int)puVar49 + -1);\n            puVar52 = (undefined4 *)((int)puVar52 - 1);\n            uVar47 = uVar47 - 1;\n          } while (uVar47 != 0);\n        }\n        uVar46 = param_3;\n        if (0x1f < param_3) {\n          uVar46 = param_3 >> 2;\n          while( true ) {\n            if (uVar46 == 0) break;\n            uVar46 = uVar46 - 1;\n            puVar52[-1] = puVar49[-1];\n            puVar49 = puVar49 + -1;\n            puVar52 = puVar52 + -1;\n          }\n          switch(param_3 & 3) {\n          case 0:\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          case 1:\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          case 2:\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            *(undefined1 *)((int)puVar52 - 2) = *(undefined1 *)((int)puVar49 + -2);\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          case 3:\n            *(undefined1 *)((int)puVar52 - 1) = *(undefined1 *)((int)puVar49 + -1);\n            *(undefined1 *)((int)puVar52 - 2) = *(undefined1 *)((int)puVar49 + -2);\n            *(undefined1 *)((int)puVar52 - 3) = *(undefined1 *)((int)puVar49 + -3);\n            return CONCAT44(param_3,param_1) & 0x3ffffffff;\n          }\n        }\n      }\n      else {\n        while (puVar50 = puVar49, puVar53 = puVar52, ((uint)puVar52 & 0xf) != 0) {\n          puVar49 = (undefined4 *)((int)puVar49 + -1);\n          puVar52 = (undefined4 *)((int)puVar52 + -1);\n          *(undefined1 *)puVar52 = *(undefined1 *)puVar49;\n          uVar46 = uVar46 - 1;\n        }\n        do {\n          puVar49 = puVar50;\n          puVar52 = puVar53;\n          if (uVar46 < 0x80) break;\n          puVar49 = puVar50 + -0x20;\n          puVar52 = puVar53 + -0x20;\n          uVar3 = puVar50[-0x1f];\n          uVar4 = puVar50[-0x1e];\n          uVar5 = puVar50[-0x1d];\n          uVar6 = puVar50[-0x1c];\n          uVar7 = puVar50[-0x1b];\n          uVar8 = puVar50[-0x1a];\n          uVar9 = puVar50[-0x19];\n          uVar10 = puVar50[-0x18];\n          uVar11 = puVar50[-0x17];\n          uVar12 = puVar50[-0x16];\n          uVar13 = puVar50[-0x15];\n          uVar14 = puVar50[-0x14];\n          uVar15 = puVar50[-0x13];\n          uVar16 = puVar50[-0x12];\n          uVar17 = puVar50[-0x11];\n          uVar18 = puVar50[-0x10];\n          uVar19 = puVar50[-0xf];\n          uVar20 = puVar50[-0xe];\n          uVar21 = puVar50[-0xd];\n          uVar22 = puVar50[-0xc];\n          uVar23 = puVar50[-0xb];\n          uVar24 = puVar50[-10];\n          uVar25 = puVar50[-9];\n          uVar26 = puVar50[-8];\n          uVar27 = puVar50[-7];\n          uVar28 = puVar50[-6];\n          uVar29 = puVar50[-5];\n          uVar30 = puVar50[-4];\n          uVar31 = puVar50[-3];\n          uVar32 = puVar50[-2];\n          uVar33 = puVar50[-1];\n          *puVar52 = *puVar49;\n          puVar53[-0x1f] = uVar3;\n          puVar53[-0x1e] = uVar4;\n          puVar53[-0x1d] = uVar5;\n          puVar53[-0x1c] = uVar6;\n          puVar53[-0x1b] = uVar7;\n          puVar53[-0x1a] = uVar8;\n          puVar53[-0x19] = uVar9;\n          puVar53[-0x18] = uVar10;\n          puVar53[-0x17] = uVar11;\n          puVar53[-0x16] = uVar12;\n          puVar53[-0x15] = uVar13;\n          puVar53[-0x14] = uVar14;\n          puVar53[-0x13] = uVar15;\n          puVar53[-0x12] = uVar16;\n          puVar53[-0x11] = uVar17;\n          puVar53[-0x10] = uVar18;\n          puVar53[-0xf] = uVar19;\n          puVar53[-0xe] = uVar20;\n          puVar53[-0xd] = uVar21;\n          puVar53[-0xc] = uVar22;\n          puVar53[-0xb] = uVar23;\n          puVar53[-10] = uVar24;\n          puVar53[-9] = uVar25;\n          puVar53[-8] = uVar26;\n          puVar53[-7] = uVar27;\n          puVar53[-6] = uVar28;\n          puVar53[-5] = uVar29;\n          puVar53[-4] = uVar30;\n          puVar53[-3] = uVar31;\n          puVar53[-2] = uVar32;\n          puVar53[-1] = uVar33;\n          uVar46 = uVar46 - 0x80;\n          puVar50 = puVar49;\n          puVar53 = puVar52;\n        } while ((uVar46 & 0xffffff80) != 0);\n        puVar50 = puVar49;\n        puVar53 = puVar52;\n        if (0x1f < uVar46) {\n          do {\n            puVar49 = puVar50 + -8;\n            puVar52 = puVar53 + -8;\n            uVar3 = puVar50[-7];\n            uVar4 = puVar50[-6];\n            uVar5 = puVar50[-5];\n            uVar6 = puVar50[-4];\n            uVar7 = puVar50[-3];\n            uVar8 = puVar50[-2];\n            uVar9 = puVar50[-1];\n            *puVar52 = *puVar49;\n            puVar53[-7] = uVar3;\n            puVar53[-6] = uVar4;\n            puVar53[-5] = uVar5;\n            puVar53[-4] = uVar6;\n            puVar53[-3] = uVar7;\n            puVar53[-2] = uVar8;\n            puVar53[-1] = uVar9;\n            uVar46 = uVar46 - 0x20;\n            puVar50 = puVar49;\n            puVar53 = puVar52;\n          } while ((uVar46 & 0xffffffe0) != 0);\n        }\n      }\n    }\n    for (; (uVar46 & 0xfffffffc) != 0; uVar46 = uVar46 - 4) {\n      puVar52 = puVar52 + -1;\n      puVar49 = puVar49 + -1;\n      *puVar52 = *puVar49;\n    }\n    for (; uVar46 != 0; uVar46 = uVar46 - 1) {\n      puVar52 = (undefined4 *)((int)puVar52 - 1);\n      puVar49 = (undefined4 *)((int)puVar49 + -1);\n      *(undefined1 *)puVar52 = *(undefined1 *)puVar49;\n    }\n    return CONCAT44(uVar47,param_1);\n  }\n  uVar46 = param_3;\n  puVar51 = param_1;\n  if (0x1f < param_3) {\n    if (param_3 < 0x80) {\n      if ((DAT_0042d020 >> 1 & 1) != 0) {\nLAB_0042084d:\n        if (uVar46 == 0) goto LAB_004208b0;\n        for (param_3 = uVar46 >> 5; param_3 != 0; param_3 = param_3 - 1) {\n          uVar47 = param_2[1];\n          uVar54 = param_2[2];\n          uVar2 = param_2[3];\n          uVar34 = param_2[4];\n          uVar35 = param_2[5];\n          uVar36 = param_2[6];\n          uVar37 = param_2[7];\n          *puVar51 = *param_2;\n          puVar51[1] = uVar47;\n          puVar51[2] = uVar54;\n          puVar51[3] = uVar2;\n          puVar51[4] = uVar34;\n          puVar51[5] = uVar35;\n          puVar51[6] = uVar36;\n          puVar51[7] = uVar37;\n          param_2 = param_2 + 8;\n          puVar51 = puVar51 + 8;\n        }\n        goto LAB_0042087b;\n      }\nLAB_004205a7:\n      uVar46 = (uint)param_1 & 3;\n      while (uVar46 != 0) {\n        *(char *)puVar51 = (char)*param_2;\n        param_3 = param_3 - 1;\n        param_2 = (uint *)((int)param_2 + 1);\n        puVar51 = (uint *)((int)puVar51 + 1);\n        uVar46 = (uint)puVar51 & 3;\n      }\n    }\n    else {\n      if ((DAT_0043adc0 >> 1 & 1) != 0) {\n        for (; uVar46 != 0; uVar46 = uVar46 - 1) {\n          *(char *)puVar51 = (char)*param_2;\n          param_2 = (uint *)((int)param_2 + 1);\n          puVar51 = (uint *)((int)puVar51 + 1);\n        }\n        return CONCAT44(param_3,param_1);\n      }\n      if (((((uint)param_1 ^ (uint)param_2) & 0xf) == 0) && ((DAT_0042d020 >> 1 & 1) != 0)) {\n        if (((uint)param_2 & 0xf) != 0) {\n          uVar47 = 0x10 - ((uint)param_2 & 0xf);\n          param_3 = param_3 - uVar47;\n          for (uVar46 = uVar47 & 3; uVar46 != 0; uVar46 = uVar46 - 1) {\n            *(char *)puVar51 = (char)*param_2;\n            param_2 = (uint *)((int)param_2 + 1);\n            puVar51 = (uint *)((int)puVar51 + 1);\n          }\n          for (uVar47 = uVar47 >> 2; uVar47 != 0; uVar47 = uVar47 - 1) {\n            *puVar51 = *param_2;\n            param_2 = param_2 + 1;\n            puVar51 = puVar51 + 1;\n          }\n        }\n        uVar46 = param_3 & 0x7f;\n        for (param_3 = param_3 >> 7; param_3 != 0; param_3 = param_3 - 1) {\n          uVar47 = param_2[1];\n          uVar54 = param_2[2];\n          uVar2 = param_2[3];\n          uVar34 = param_2[4];\n          uVar35 = param_2[5];\n          uVar36 = param_2[6];\n          uVar37 = param_2[7];\n          uVar38 = param_2[8];\n          uVar39 = param_2[9];\n          uVar40 = param_2[10];\n          uVar41 = param_2[0xb];\n          uVar42 = param_2[0xc];\n          uVar43 = param_2[0xd];\n          uVar44 = param_2[0xe];\n          uVar45 = param_2[0xf];\n          *puVar51 = *param_2;\n          puVar51[1] = uVar47;\n          puVar51[2] = uVar54;\n          puVar51[3] = uVar2;\n          puVar51[4] = uVar34;\n          puVar51[5] = uVar35;\n          puVar51[6] = uVar36;\n          puVar51[7] = uVar37;\n          puVar51[8] = uVar38;\n          puVar51[9] = uVar39;\n          puVar51[10] = uVar40;\n          puVar51[0xb] = uVar41;\n          puVar51[0xc] = uVar42;\n          puVar51[0xd] = uVar43;\n          puVar51[0xe] = uVar44;\n          puVar51[0xf] = uVar45;\n          uVar47 = param_2[0x11];\n          uVar54 = param_2[0x12];\n          uVar2 = param_2[0x13];\n          uVar34 = param_2[0x14];\n          uVar35 = param_2[0x15];\n          uVar36 = param_2[0x16];\n          uVar37 = param_2[0x17];\n          uVar38 = param_2[0x18];\n          uVar39 = param_2[0x19];\n          uVar40 = param_2[0x1a];\n          uVar41 = param_2[0x1b];\n          uVar42 = param_2[0x1c];\n          uVar43 = param_2[0x1d];\n          uVar44 = param_2[0x1e];\n          uVar45 = param_2[0x1f];\n          puVar51[0x10] = param_2[0x10];\n          puVar51[0x11] = uVar47;\n          puVar51[0x12] = uVar54;\n          puVar51[0x13] = uVar2;\n          puVar51[0x14] = uVar34;\n          puVar51[0x15] = uVar35;\n          puVar51[0x16] = uVar36;\n          puVar51[0x17] = uVar37;\n          puVar51[0x18] = uVar38;\n          puVar51[0x19] = uVar39;\n          puVar51[0x1a] = uVar40;\n          puVar51[0x1b] = uVar41;\n          puVar51[0x1c] = uVar42;\n          puVar51[0x1d] = uVar43;\n          puVar51[0x1e] = uVar44;\n          puVar51[0x1f] = uVar45;\n          param_2 = param_2 + 0x20;\n          puVar51 = puVar51 + 0x20;\n        }\n        goto LAB_0042084d;\n      }\n      if (((DAT_0043adc0 & 1) == 0) || (((uint)param_1 & 3) != 0)) goto LAB_004205a7;\n      if (((uint)param_2 & 3) == 0) {\n        if (((uint)param_1 >> 2 & 1) != 0) {\n          uVar46 = *param_2;\n          param_3 = param_3 - 4;\n          param_2 = param_2 + 1;\n          *param_1 = uVar46;\n          param_1 = param_1 + 1;\n        }\n        if (((uint)param_1 >> 3 & 1) != 0) {\n          uVar1 = *(undefined8 *)param_2;\n          param_3 = param_3 - 8;\n          param_2 = param_2 + 2;\n          *(undefined8 *)param_1 = uVar1;\n          param_1 = param_1 + 2;\n        }\n        if (((uint)param_2 & 7) == 0) {\n          puVar51 = param_2 + -2;\n          uVar46 = *param_2;\n          uVar47 = param_2[1];\n          do {\n            puVar48 = puVar51;\n            uVar34 = puVar48[8];\n            uVar35 = puVar48[9];\n            param_3 = param_3 - 0x30;\n            uVar36 = puVar48[6];\n            uVar37 = puVar48[7];\n            uVar38 = puVar48[8];\n            uVar39 = puVar48[9];\n            uVar54 = puVar48[0xe];\n            uVar2 = puVar48[0xf];\n            uVar40 = puVar48[10];\n            uVar41 = puVar48[0xb];\n            uVar42 = puVar48[0xc];\n            uVar43 = puVar48[0xd];\n            param_1[2] = uVar46;\n            param_1[3] = uVar47;\n            param_1[4] = uVar34;\n            param_1[5] = uVar35;\n            param_1[6] = uVar36;\n            param_1[7] = uVar37;\n            param_1[8] = uVar38;\n            param_1[9] = uVar39;\n            param_1[10] = uVar40;\n            param_1[0xb] = uVar41;\n            param_1[0xc] = uVar42;\n            param_1[0xd] = uVar43;\n            param_1 = param_1 + 0xc;\n            puVar51 = puVar48 + 0xc;\n            uVar46 = uVar54;\n            uVar47 = uVar2;\n          } while (0x2f < (int)param_3);\n          puVar48 = puVar48 + 0xe;\n        }\n        else if (((uint)param_2 >> 3 & 1) == 0) {\n          puVar51 = param_2 + -1;\n          uVar46 = *param_2;\n          uVar47 = param_2[1];\n          uVar54 = param_2[2];\n          do {\n            puVar48 = puVar51;\n            uVar36 = puVar48[8];\n            param_3 = param_3 - 0x30;\n            uVar37 = puVar48[5];\n            uVar38 = puVar48[6];\n            uVar39 = puVar48[7];\n            uVar40 = puVar48[8];\n            uVar2 = puVar48[0xd];\n            uVar34 = puVar48[0xe];\n            uVar35 = puVar48[0xf];\n            uVar41 = puVar48[9];\n            uVar42 = puVar48[10];\n            uVar43 = puVar48[0xb];\n            uVar44 = puVar48[0xc];\n            param_1[1] = uVar46;\n            param_1[2] = uVar47;\n            param_1[3] = uVar54;\n            param_1[4] = uVar36;\n            param_1[5] = uVar37;\n            param_1[6] = uVar38;\n            param_1[7] = uVar39;\n            param_1[8] = uVar40;\n            param_1[9] = uVar41;\n            param_1[10] = uVar42;\n            param_1[0xb] = uVar43;\n            param_1[0xc] = uVar44;\n            param_1 = param_1 + 0xc;\n            puVar51 = puVar48 + 0xc;\n            uVar46 = uVar2;\n            uVar47 = uVar34;\n            uVar54 = uVar35;\n          } while (0x2f < (int)param_3);\n          puVar48 = puVar48 + 0xd;\n        }\n        else {\n          puVar51 = param_2 + -3;\n          uVar46 = *param_2;\n          do {\n            puVar48 = puVar51;\n            uVar54 = puVar48[8];\n            uVar2 = puVar48[9];\n            uVar34 = puVar48[10];\n            param_3 = param_3 - 0x30;\n            uVar35 = puVar48[7];\n            uVar36 = puVar48[8];\n            uVar37 = puVar48[9];\n            uVar38 = puVar48[10];\n            uVar47 = puVar48[0xf];\n            uVar39 = puVar48[0xb];\n            uVar40 = puVar48[0xc];\n            uVar41 = puVar48[0xd];\n            uVar42 = puVar48[0xe];\n            param_1[3] = uVar46;\n            param_1[4] = uVar54;\n            param_1[5] = uVar2;\n            param_1[6] = uVar34;\n            param_1[7] = uVar35;\n            param_1[8] = uVar36;\n            param_1[9] = uVar37;\n            param_1[10] = uVar38;\n            param_1[0xb] = uVar39;\n            param_1[0xc] = uVar40;\n            param_1[0xd] = uVar41;\n            param_1[0xe] = uVar42;\n            param_1 = param_1 + 0xc;\n            puVar51 = puVar48 + 0xc;\n            uVar46 = uVar47;\n          } while (0x2f < (int)param_3);\n          puVar48 = puVar48 + 0xf;\n        }\n        for (; 0xf < (int)param_3; param_3 = param_3 - 0x10) {\n          uVar46 = *puVar48;\n          uVar47 = puVar48[1];\n          uVar54 = puVar48[2];\n          uVar2 = puVar48[3];\n          puVar48 = puVar48 + 4;\n          *param_1 = uVar46;\n          param_1[1] = uVar47;\n          param_1[2] = uVar54;\n          param_1[3] = uVar2;\n          param_1 = param_1 + 4;\n        }\n        if ((param_3 >> 2 & 1) != 0) {\n          uVar46 = *puVar48;\n          param_3 = param_3 - 4;\n          puVar48 = puVar48 + 1;\n          *param_1 = uVar46;\n          param_1 = param_1 + 1;\n        }\n        if ((param_3 >> 3 & 1) != 0) {\n          param_3 = param_3 - 8;\n          *(undefined8 *)param_1 = *(undefined8 *)puVar48;\n        }\n                    /* WARNING: Could not recover jumptable at 0x004205a5. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        uVar55 = (*(code *)(&switchD_004205d5::switchdataD_004205e4)[param_3])();\n        return uVar55;\n      }\n    }\n    uVar46 = param_3;\n    if (0x1f < param_3) {\n      for (uVar46 = param_3 >> 2; uVar46 != 0; uVar46 = uVar46 - 1) {\n        *puVar51 = *param_2;\n        param_2 = param_2 + 1;\n        puVar51 = puVar51 + 1;\n      }\n      switch(param_3 & 3) {\n      case 0:\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      case 1:\n        *(char *)puVar51 = (char)*param_2;\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      case 2:\n        *(char *)puVar51 = (char)*param_2;\n        *(undefined1 *)((int)puVar51 + 1) = *(undefined1 *)((int)param_2 + 1);\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      case 3:\n        *(char *)puVar51 = (char)*param_2;\n        *(undefined1 *)((int)puVar51 + 1) = *(undefined1 *)((int)param_2 + 1);\n        *(undefined1 *)((int)puVar51 + 2) = *(undefined1 *)((int)param_2 + 2);\n        return CONCAT44(param_3,param_1) & 0x3ffffffff;\n      }\n    }\n  }\nLAB_0042087b:\n  if ((uVar46 & 0x1f) != 0) {\n    for (uVar47 = (uVar46 & 0x1f) >> 2; uVar47 != 0; uVar47 = uVar47 - 1) {\n      param_3 = *param_2;\n      *puVar51 = param_3;\n      puVar51 = puVar51 + 1;\n      param_2 = param_2 + 1;\n    }\n    for (uVar46 = uVar46 & 3; uVar46 != 0; uVar46 = uVar46 - 1) {\n      *(char *)puVar51 = (char)*param_2;\n      param_2 = (uint *)((int)param_2 + 1);\n      puVar51 = (uint *)((int)puVar51 + 1);\n    }\n  }\nLAB_004208b0:\n  return CONCAT44(param_3,param_1);\n}\n\n"
    }
  ]
}